(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_abcjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-abcjs */ "./node_modules/react-abcjs/es/index.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__);
/* module decorator */ module = __webpack_require__.hmd(module);





var _jsxFileName = "C:\\Users\\Sherwin\\Desktop\\TheGitStuff\\Sonatina-Alpha\\pages\\index.js";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }





var Index = /*#__PURE__*/function (_Component) {
  (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__.default)(Index, _Component);

  var _super = _createSuper(Index);

  function Index() {
    (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, Index);

    return _super.apply(this, arguments);
  }

  (0,C_Users_Sherwin_Desktop_TheGitStuff_Sonatina_Alpha_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(Index, [{
    key: "componentDidMount",
    value: function componentDidMount() {//var reactAbcjs = require("react-abcjs")
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxDEV)("div", {
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxDEV)("div", {
          children: " This is my website "
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 12,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxDEV)("div", {
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__.jsxDEV)(react_abcjs__WEBPACK_IMPORTED_MODULE_6__.default, {
            abcNotation: 'X:1\nT:Example\nM:4/4\nC:Trad.\nK:G\n|:Gccc dedB|dedB dedB|c2ec B2dB|c2A2 A2BA|',
            parserParams: {},
            engraverParams: {
              responsive: 'resize'
            },
            renderParams: {
              viewportHorizontal: true
            }
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 14,
            columnNumber: 17
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 13,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 10
      }, this);
    }
  }]);

  return Index;
}(react__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ __webpack_exports__["default"] = (Index);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/abcjs/index.js":
/*!*************************************!*\
  !*** ./node_modules/abcjs/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var version = __webpack_require__(/*! ./version */ "./node_modules/abcjs/version.js");
var animation = __webpack_require__(/*! ./src/api/abc_animation */ "./node_modules/abcjs/src/api/abc_animation.js");
var tuneBook = __webpack_require__(/*! ./src/api/abc_tunebook */ "./node_modules/abcjs/src/api/abc_tunebook.js");

var abcjs = {};

abcjs.signature = "abcjs-basic v" + version;

Object.keys(animation).forEach(function (key) {
	abcjs[key] = animation[key];
});

Object.keys(tuneBook).forEach(function (key) {
	abcjs[key] = tuneBook[key];
});

abcjs.renderAbc = __webpack_require__(/*! ./src/api/abc_tunebook_svg */ "./node_modules/abcjs/src/api/abc_tunebook_svg.js");
abcjs.TimingCallbacks = __webpack_require__(/*! ./src/api/abc_timing_callbacks */ "./node_modules/abcjs/src/api/abc_timing_callbacks.js");

var glyphs = __webpack_require__(/*! ./src/write/abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
abcjs.setGlyph = glyphs.setSymbol;

var CreateSynth = __webpack_require__(/*! ./src/synth/create-synth */ "./node_modules/abcjs/src/synth/create-synth.js");
var instrumentIndexToName = __webpack_require__(/*! ./src/synth/instrument-index-to-name */ "./node_modules/abcjs/src/synth/instrument-index-to-name.js");
var pitchToNoteName = __webpack_require__(/*! ./src/synth/pitch-to-note-name */ "./node_modules/abcjs/src/synth/pitch-to-note-name.js");
var SynthSequence = __webpack_require__(/*! ./src/synth/synth-sequence */ "./node_modules/abcjs/src/synth/synth-sequence.js");
var CreateSynthControl = __webpack_require__(/*! ./src/synth/create-synth-control */ "./node_modules/abcjs/src/synth/create-synth-control.js");
var registerAudioContext = __webpack_require__(/*! ./src/synth/register-audio-context */ "./node_modules/abcjs/src/synth/register-audio-context.js");
var activeAudioContext = __webpack_require__(/*! ./src/synth/active-audio-context */ "./node_modules/abcjs/src/synth/active-audio-context.js");
var supportsAudio = __webpack_require__(/*! ./src/synth/supports-audio */ "./node_modules/abcjs/src/synth/supports-audio.js");
var playEvent = __webpack_require__(/*! ./src/synth/play-event */ "./node_modules/abcjs/src/synth/play-event.js");
var SynthController = __webpack_require__(/*! ./src/synth/synth-controller */ "./node_modules/abcjs/src/synth/synth-controller.js");

abcjs.synth = {
	CreateSynth: CreateSynth,
	instrumentIndexToName: instrumentIndexToName,
	pitchToNoteName: pitchToNoteName,
	SynthController: SynthController,
	SynthSequence: SynthSequence,
	CreateSynthControl: CreateSynthControl,
	registerAudioContext: registerAudioContext,
	activeAudioContext: activeAudioContext,
	supportsAudio: supportsAudio,
	playEvent: playEvent
};

var editor = __webpack_require__(/*! ./src/edit/abc_editor */ "./node_modules/abcjs/src/edit/abc_editor.js");
abcjs['Editor'] = editor;

module.exports = abcjs;


/***/ }),

/***/ "./node_modules/abcjs/src/api/abc_animation.js":
/*!*****************************************************!*\
  !*** ./node_modules/abcjs/src/api/abc_animation.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_animation.js: handles animating the music in real time.
//    Copyright (C) 2014-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var spacing = __webpack_require__(/*! ../write/abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");
var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var TimingCallbacks = __webpack_require__(/*! ./abc_timing_callbacks */ "./node_modules/abcjs/src/api/abc_timing_callbacks.js");

var animation = {};

(function() {
	"use strict";

	var timer;
	var cursor;
	animation.startAnimation = function(paper, tune, options) {
		//options.bpm
		//options.showCursor
		//options.hideCurrentMeasure
		//options.hideFinishedMeasures
		if (timer) {
			timer.stop();
			timer = undefined;
		}

		if (options.showCursor) {
			cursor = paper.querySelector('.abcjs-cursor');
			if (!cursor) {
				cursor = document.createElement('DIV');
				cursor.className = 'abcjs-cursor cursor';
				cursor.style.position = 'absolute';

				paper.appendChild(cursor);
				paper.style.position = 'relative';
			}
		}

		function hideMeasures(elements) {
			for (var i = 0; i < elements.length; i++) {
				var element = elements[i];
				if (!element.classList.contains('abcjs-bar'))
					element.style.display = "none";
			}
		}

		var lastMeasure;
		function disappearMeasuresAfter(selector) {
			if (lastMeasure) {
				var elements = paper.querySelectorAll(lastMeasure);
				hideMeasures(elements);
			}
			lastMeasure = selector;
		}

		function disappearMeasuresBefore(selector) {
			var elements = paper.querySelectorAll(selector);
			hideMeasures(elements);
		}

		function measureCallback(selector) {
			if (options.hideCurrentMeasure) {
				disappearMeasuresBefore(selector);
			} else if (options.hideFinishedMeasures) {
				disappearMeasuresAfter(selector);
			}
		}

		function getLineAndMeasure(element) {
			return '.abcjs-l' + element.line + '.abcjs-m' + element.measureNumber;
		}

		function setCursor(range) {
			if (range) {
				if (range.measureStart) {
					var selector = getLineAndMeasure(range);
					if (selector)
						measureCallback(selector);
				}
				if (cursor) {
					cursor.style.left = range.left + "px";
					cursor.style.top = range.top + "px";
					cursor.style.width = range.width + "px";
					cursor.style.height = range.height + "px";
				}
			} else {
				timer.stop();
				timer = undefined;
			}
		}

		timer = new TimingCallbacks(tune, {
			qpm: options.bpm,
			eventCallback: setCursor
		});
		timer.start();
	};

	animation.pauseAnimation = function(pause) {
		if (timer) {
			if (pause)
				timer.pause();
			else
				timer.start();
		}
	};

	animation.stopAnimation = function() {
		if (timer) {
			timer.stop();
			timer = undefined;
		}
	};

})();

module.exports = animation;


/***/ }),

/***/ "./node_modules/abcjs/src/api/abc_timing_callbacks.js":
/*!************************************************************!*\
  !*** ./node_modules/abcjs/src/api/abc_timing_callbacks.js ***!
  \************************************************************/
/***/ (function(module) {


var TimingCallbacks = function(target, params) {
	var self = this;
	if (!params) params = {};
	self.qpm = params.qpm ? parseInt(params.qpm, 10) : null;
	if (!self.qpm) {
		var tempo = target.metaText ? target.metaText.tempo : null;
		self.qpm = target.getBpm(tempo);
	}
	self.extraMeasuresAtBeginning = params.extraMeasuresAtBeginning ? parseInt(params.extraMeasuresAtBeginning, 10) : 0;
	self.beatCallback = params.beatCallback; // This is called for each beat.
	self.eventCallback = params.eventCallback;   // This is called for each note or rest encountered.
	self.lineEndCallback = params.lineEndCallback;   // This is called when the end of a line is approaching.
	self.lineEndAnticipation = params.lineEndAnticipation ? parseInt(params.lineEndAnticipation, 10) : 0;   // How many milliseconds before the end should the call happen.
	self.beatSubdivisions = params.beatSubdivisions ? parseInt(params.beatSubdivisions, 10) : 1; // how many callbacks per beat is desired.

	self.replaceTarget = function(newTarget) {
		newTarget.setTiming(self.qpm, self.extraMeasuresAtBeginning);
		if (newTarget.noteTimings.length === 0)
			newTarget.setTiming(0,0);
		if (self.lineEndCallback) {
			self.lineEndTimings = getLineEndTimings(newTarget.noteTimings, self.lineEndAnticipation);
		}
		self.noteTimings = newTarget.noteTimings;
	};

	self.replaceTarget(target);
	if (self.noteTimings.length === 0)
		return;

	// noteTimings contains an array of events sorted by time. Events that happen at the same time are in the same element of the array.
	self.noteTimings = target.noteTimings;
	self.millisecondsPerBeat = 1000 / (self.qpm / 60) / self.beatSubdivisions;
	self.lastMoment = self.noteTimings[self.noteTimings.length-1].milliseconds;
	self.totalBeats = Math.round(self.lastMoment / self.millisecondsPerBeat);

	self.startTime = null;
	self.currentBeat = 0;
	self.currentEvent = 0;
	self.isPaused = false;
	self.isRunning = false;
	self.pausedTime = null;
	self.justUnpaused = false;

	self.newSeekPercent = 0;
	self.justSeeked = false;

	function setCurrentLocation(timestamp) {
		// First find the relative amount to move: that is, the difference between the current percentage and the passed in percent.
		var currentPercent = (timestamp - self.startTime) / self.lastMoment;
		var percentDifference = currentPercent - self.newSeekPercent;
		var timeDifference = self.lastMoment * percentDifference;
		self.startTime = self.startTime + timeDifference;

		var currentTime = timestamp - self.startTime;
		currentTime += 50; // Add a little slop because this function isn't called exactly.

		var oldBeat = self.currentBeat;
		self.currentBeat = Math.floor(currentTime / self.millisecondsPerBeat);
		if (self.beatCallback && oldBeat !== self.currentBeat) // If the movement caused the beat to change, then immediately report it to the client.
			self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);

		self.currentEvent = 0;
		while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < currentTime) {
			self.currentEvent++;
		}
		if (self.eventCallback && self.currentEvent > 0 && self.noteTimings[self.currentEvent - 1].type === 'event')
			self.eventCallback(self.noteTimings[self.currentEvent - 1]);

		// console.log("currentPercent="+currentPercent+
		// 	" newSeekPercent="+self.newSeekPercent+
		// 	" percentDifference="+percentDifference+
		// 	" timeDifference=",timeDifference+
		// 	" currentBeat="+self.currentBeat+
		// 	" currentEvent="+self.currentEvent);
	}

	self.doTiming = function (timestamp) {
		if (!self.startTime) {
			self.startTime = timestamp;
		} else if (self.justUnpaused) {
			// Add the amount we paused to the start time to get the right place.
			var timePaused = (timestamp - self.pausedTime);
			self.startTime += timePaused;
		}
		self.justUnpaused = false;

		if (self.justSeeked) {
			setCurrentLocation(timestamp);
			self.justSeeked = false;
		}
		if (self.isPaused) {
			self.pausedTime = timestamp;
		} else if (self.isRunning) {
			var currentTime = timestamp - self.startTime;
			currentTime += 50; // Add a little slop because this function isn't called exactly.
			while (self.noteTimings.length > self.currentEvent && self.noteTimings[self.currentEvent].milliseconds < currentTime) {
				if (self.eventCallback && self.noteTimings[self.currentEvent].type === 'event')
					self.eventCallback(self.noteTimings[self.currentEvent]);
				self.currentEvent++;
			}
			if (currentTime < self.lastMoment) {
				requestAnimationFrame(self.doTiming);
				if (self.currentBeat * self.millisecondsPerBeat < currentTime) {
					if (self.beatCallback)
						self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);
					self.currentBeat++;
				}
			} else if (self.currentBeat <= self.totalBeats) {
				// Because of timing issues (for instance, if the browser tab isn't active), the beat callbacks might not have happened when they are supposed to. To keep the client programs from having to deal with that, this will keep calling the loop until all of them have been sent.
				if (self.beatCallback) {
					self.beatCallback(self.currentBeat / self.beatSubdivisions, self.totalBeats / self.beatSubdivisions, self.lastMoment);
					self.currentBeat++;
					requestAnimationFrame(self.doTiming);
				}
			}

			if (self.lineEndCallback && self.lineEndTimings.length && self.lineEndTimings[0].milliseconds <= currentTime) {
				self.lineEndCallback(self.lineEndTimings[0]);
				self.lineEndTimings.shift();
			}

			if (currentTime >= self.lastMoment && self.eventCallback)
				self.eventCallback(null);
		}
	};

	self.start = function() {
		self.isRunning = true;
		if (self.isPaused) {
			self.isPaused = false;
			self.justUnpaused = true;
		}
		requestAnimationFrame(self.doTiming);
	};
	self.pause = function() {
		self.isPaused = true;
		self.isRunning = false;
	};
	self.reset = function() {
		self.currentBeat = 0;
		self.currentEvent = 0;
		self.startTime = null;
		self.pausedTime = null;
		if (self.lineEndCallback) {
			self.lineEndTimings = getLineEndTimings(self.noteTimings, self.lineEndAnticipation);
		}
	};
	self.stop = function() {
		self.pause();
		self.reset();
	};
	self.setProgress = function(percent) {
		// this is passed a value between 0 and 1.
		// the effect of this function is to move startTime so that the callbacks happen correctly for the new seek.
		if (percent < 0) percent = 0;
		if (percent > 1) percent = 1;

		self.newSeekPercent = percent;
		self.justSeeked = true;
		requestAnimationFrame(self.doTiming);
	};
};

function getLineEndTimings(timings, anticipation) {
	// Returns an array of milliseconds to call the lineEndCallback.
	// This figures out the timing of the beginning of each line and subtracts the anticipation from it.
	var callbackTimes = [];
	var lastTop = null;
	for (var i = 0; i < timings.length; i++) {
		var timing = timings[i];
		if (timing.top !== lastTop) {
			callbackTimes.push({ milliseconds: timing.milliseconds - anticipation, top: timing.top, bottom: timing.top+timing.height });
			lastTop = timing.top;
		}
	}
	return callbackTimes;
}

module.exports = TimingCallbacks;



/***/ }),

/***/ "./node_modules/abcjs/src/api/abc_tunebook.js":
/*!****************************************************!*\
  !*** ./node_modules/abcjs/src/api/abc_tunebook.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_tunebook.js: splits a string representing ABC Music Notation into individual tunes.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global document */
/*global window, ABCJS, console */

var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var Parse = __webpack_require__(/*! ../parse/abc_parse */ "./node_modules/abcjs/src/parse/abc_parse.js");

var tunebook = {};

(function() {
	"use strict";

	tunebook.numberOfTunes = function(abc) {
		var tunes = abc.split("\nX:");
		var num = tunes.length;
		if (num === 0) num = 1;
		return num;
	};

	var TuneBook = tunebook.TuneBook = function(book) {
		var This = this;
		var directives = "";
		book = parseCommon.strip(book);
		var tunes = book.split("\nX:");
		for (var i = 1; i < tunes.length; i++)	// Put back the X: that we lost when splitting the tunes.
			tunes[i] = "X:" + tunes[i];
		// Keep track of the character position each tune starts with.
		var pos = 0;
		This.tunes = [];
		parseCommon.each(tunes, function(tune) {
			This.tunes.push({ abc: tune, startPos: pos});
			pos += tune.length + 1; // We also lost a newline when splitting, so count that.
		});
		if (This.tunes.length > 1 && !parseCommon.startsWith(This.tunes[0].abc, 'X:')) {	// If there is only one tune, the X: might be missing, otherwise assume the top of the file is "intertune"
			// There could be file-wide directives in this, if so, we need to insert it into each tune. We can probably get away with
			// just looking for file-wide directives here (before the first tune) and inserting them at the bottom of each tune, since
			// the tune is parsed all at once. The directives will be seen before the engraver begins processing.
			var dir = This.tunes.shift();
			var arrDir = dir.abc.split('\n');
			parseCommon.each(arrDir, function(line) {
				if (parseCommon.startsWith(line, '%%'))
					directives += line + '\n';
			});
		}
		This.header = directives;

		// Now, the tune ends at a blank line, so truncate it if needed. There may be "intertune" stuff.
		parseCommon.each(This.tunes, function(tune) {
			var end = tune.abc.indexOf('\n\n');
			if (end > 0)
				tune.abc = tune.abc.substring(0, end);
			tune.pure = tune.abc;
			tune.abc = directives + tune.abc;

			// for the user's convenience, parse and store the title separately. The title is between the first T: and the next \n
			var title = tune.pure.split("T:");
			if (title.length > 1) {
				title = title[1].split("\n");
				tune.title = title[0].replace(/^\s+|\s+$/g, '');
			} else
				tune.title = "";

			// for the user's convenience, parse and store the id separately. The id is between the first X: and the next \n
			var id = tune.pure.substring(2, tune.pure.indexOf("\n"));
			tune.id = id.replace(/^\s+|\s+$/g, '');
		});
	};

	TuneBook.prototype.getTuneById = function(id) {
		for (var i = 0; i < this.tunes.length; i++) {
			if (this.tunes[i].id === ''+id)
				return this.tunes[i];
		}
		return null;
	};

	TuneBook.prototype.getTuneByTitle = function(title) {
		for (var i = 0; i < this.tunes.length; i++) {
			if (this.tunes[i].title === title)
				return this.tunes[i];
		}
		return null;
	};

	tunebook.parseOnly = function(abc, params) {
		var tunes = [];
		var numTunes = tunebook.numberOfTunes(abc);

		// this just needs to be passed in because this tells the engine how many tunes to process.
		var output = [];
		for (var i = 0; i < numTunes; i++) {
			output.push(1);
		}
		function callback() {
			// Don't need to do anything with the parsed tunes.
		}
		return tunebook.renderEngine(callback, output, abc, params);
	};

	tunebook.renderEngine = function (callback, output, abc, params) {
		var ret = [];
		var isArray = function(testObject) {
			return testObject && !(testObject.propertyIsEnumerable('length')) && typeof testObject === 'object' && typeof testObject.length === 'number';
		};

		// check and normalize input parameters
		if (output === undefined || abc === undefined)
			return;
		if (!isArray(output))
			output = [ output ];
		if (params === undefined)
			params = {};
		var currentTune = params.startingTune ? parseInt(params.startingTune, 10) : 0;

		// parse the abc string
		var book = new TuneBook(abc);
		var abcParser = new Parse();

		// output each tune, if it exists. Otherwise clear the div.
		for (var i = 0; i < output.length; i++) {
			var div = output[i];
			if (div === "*") {
				// This is for "headless" rendering: doing the work but not showing the svg.
			} else if (typeof(div) === "string")
				div = document.getElementById(div);
			if (div) {
				if (currentTune >= 0 && currentTune < book.tunes.length) {
					abcParser.parse(book.tunes[currentTune].abc, params, book.tunes[currentTune].startPos - book.header.length);
					var tune = abcParser.getTune();
					var override = callback(div, tune, i, book.tunes[currentTune].abc);
					ret.push(override ? override : tune);
				} else {
					if (div.hasOwnProperty('innerHTML'))
						div.innerHTML = "";
				}
			}
			currentTune++;
		}
		return ret;
	};

	function flattenTune(tuneObj) {
		// This removes the line breaks and removes the non-music lines.
		var staves = [];
		for (var j = 0; j < tuneObj.lines.length; j++) {
			var line = tuneObj.lines[j];
			if (line.staff) {
				for (var k = 0; k < line.staff.length; k++) {
					var staff = line.staff[k];
					if (!staves[k])
						staves[k] = staff;
					else {
						for (var i = 0; i < staff.voices.length; i++) {
							if (staves[k].voices[i])
								staves[k].voices[i] = staves[k].voices[i].concat(staff.voices[i]);
							// TODO-PER: If staves[k].voices[i] doesn't exist, that means a voice appeared in the middle of the tune. That isn't handled yet.
						}
					}
				}
			}
		}
		return staves;
	}

	function measuresParser(staff, tune) {
		var voices = [];
		var lastChord = null;
		var measureStartChord = null;
		var fragStart = null;
		var hasNotes = false;

		for (var i = 0; i < staff.voices.length; i++) {
			var voice = staff.voices[i];
			voices.push([]);
			for (var j = 0; j < voice.length; j++) {
				var elem = voice[j];
				if (fragStart === null && elem.startChar >= 0) {
					fragStart = elem.startChar;
					if (elem.chord === undefined)
						measureStartChord = lastChord;
					else
						measureStartChord = null;
				}
				if (elem.chord)
					lastChord = elem;
				if (elem.el_type === 'bar') {
					if (hasNotes) {
						var frag = tune.abc.substring(fragStart, elem.endChar);
						var measure = {abc: frag};
						lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
						if (lastChord)
							measure.lastChord = lastChord;
						if (elem.startEnding)
							measure.startEnding = elem.startEnding;
						if (elem.endEnding)
							measure.endEnding = elem.endEnding;
						voices[i].push(measure);
						fragStart = null;
						hasNotes = false;
					}
				} else if (elem.el_type === 'note') {
					hasNotes = true;
				}
			}
		}
		return voices;
	}

	tunebook.extractMeasures = function(abc) {
		var tunes = [];
		var book = new TuneBook(abc);
		for (var i = 0; i < book.tunes.length; i++) {
			var tune = book.tunes[i];
			var arr = tune.abc.split("K:");
			var arr2 = arr[1].split("\n");
			var header = arr[0] + "K:" + arr2[0] + "\n";
			var lastChord = null;
			var measureStartChord = null;
			var fragStart = null;
			var measures = [];
			var hasNotes = false;
			var tuneObj = tunebook.parseOnly(tune.abc)[0];
			var hasPickup = tuneObj.getPickupLength() > 0;
			// var staves = flattenTune(tuneObj);
			// for (var s = 0; s < staves.length; s++) {
			// 	var voices = measuresParser(staves[s], tune);
			// 	if (s === 0)
			// 		measures = voices;
			// 	else {
			// 		for (var ss = 0; ss < voices.length; ss++) {
			// 			var voice = voices[ss];
			// 			if (measures.length <= ss)
			// 				measures.push([]);
			// 			var measureVoice = measures[ss];
			// 			for (var sss = 0; sss < voice.length; sss++) {
			// 				if (measureVoice.length > sss)
			// 					measureVoice[sss].abc += "\n" + voice[sss].abc;
			// 				else
			// 					measures.push(voice[sss]);
			// 			}
			// 		}
			// 	}
			// 	console.log(voices);
			// }
			// measures = measures[0];

			for (var j = 0; j < tuneObj.lines.length; j++) {
				var line = tuneObj.lines[j];
				if (line.staff) {
					for (var k = 0; k < 1 /*line.staff.length*/; k++) {
						var staff = line.staff[k];
						for (var kk = 0; kk < 1 /*staff.voices.length*/; kk++) {
							var voice = staff.voices[kk];
							for (var kkk = 0; kkk < voice.length; kkk++) {
								var elem = voice[kkk];
								if (fragStart === null && elem.startChar >= 0) {
									fragStart = elem.startChar;
									if (elem.chord === undefined)
										measureStartChord = lastChord;
									else
										measureStartChord = null;
								}
								if (elem.chord)
									lastChord = elem;
								if (elem.el_type === 'bar') {
									if (hasNotes) {
										var frag = tune.abc.substring(fragStart, elem.endChar);
										var measure = {abc: frag};
										lastChord = measureStartChord && measureStartChord.chord && measureStartChord.chord.length > 0 ? measureStartChord.chord[0].name : null;
										if (lastChord)
											measure.lastChord = lastChord;
										if (elem.startEnding)
											measure.startEnding = elem.startEnding;
										if (elem.endEnding)
											measure.endEnding = elem.endEnding;
										measures.push(measure);
										fragStart = null;
										hasNotes = false;
									}
								} else if (elem.el_type === 'note') {
									hasNotes = true;
								}
							}
						}
					}
				}
			}
			tunes.push({
				header: header,
				measures: measures,
				hasPickup: hasPickup
			});
		}
		return tunes;
	};
})();

module.exports = tunebook;


/***/ }),

/***/ "./node_modules/abcjs/src/api/abc_tunebook_svg.js":
/*!********************************************************!*\
  !*** ./node_modules/abcjs/src/api/abc_tunebook_svg.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var tunebook = __webpack_require__(/*! ./abc_tunebook */ "./node_modules/abcjs/src/api/abc_tunebook.js");
var Tune = __webpack_require__(/*! ../data/abc_tune */ "./node_modules/abcjs/src/data/abc_tune.js");

var EngraverController = __webpack_require__(/*! ../write/abc_engraver_controller */ "./node_modules/abcjs/src/write/abc_engraver_controller.js");
var Parse = __webpack_require__(/*! ../parse/abc_parse */ "./node_modules/abcjs/src/parse/abc_parse.js");
var wrap = __webpack_require__(/*! ../parse/wrap_lines */ "./node_modules/abcjs/src/parse/wrap_lines.js");

var resizeDivs = {};
function resizeOuter() {
    var width = window.innerWidth;
    for (var id in resizeDivs) {
        if (resizeDivs.hasOwnProperty(id)) {
            var outer = resizeDivs[id];
            var ofs = outer.offsetLeft;
            width -= ofs * 2;
            outer.style.width = width + "px";
        }
    }
}

window.addEventListener("resize", resizeOuter);
window.addEventListener("orientationChange", resizeOuter);

function renderOne(div, tune, params, tuneNumber) {
    if (params.viewportHorizontal) {
        // Create an inner div that holds the music, so that the passed in div will be the viewport.
        div.innerHTML = '<div class="abcjs-inner"></div>';
        if (params.scrollHorizontal) {
            div.style.overflowX = "auto";
            div.style.overflowY = "hidden";
        } else
            div.style.overflow = "hidden";
        resizeDivs[div.id] = div; // We use a hash on the element's id so that multiple calls won't keep adding to the list.
        div = div.children[0]; // The music should be rendered in the inner div.
    }
    else if (params.viewportVertical) {
        // Create an inner div that holds the music, so that the passed in div will be the viewport.
        div.innerHTML = '<div class="abcjs-inner scroll-amount"></div>';
        div.style.overflowX = "hidden";
        div.style.overflowY = "auto";
        div = div.children[0]; // The music should be rendered in the inner div.
    }
    else
	    div.innerHTML = "";
    var engraver_controller = new EngraverController(div, params);
    engraver_controller.engraveABC(tune, tuneNumber);
    tune.engraver = engraver_controller;
    if (params.viewportVertical || params.viewportHorizontal) {
        // If we added a wrapper around the div, then we need to size the wrapper, too.
        var parent = div.parentNode;
        parent.style.width = div.style.width;
    }
}

function renderEachLineSeparately(div, tune, params, tuneNumber) {
    function initializeTuneLine(tune) {
        var obj = new Tune();
        obj.formatting = tune.formatting;
        obj.media = tune.media;
        obj.version = tune.version;
        obj.metaText = {};
        obj.lines = [];
        return obj;
    }

    // Before rendering, chop up the returned tune into an array where each element is a line.
    // The first element of the array gets the title and other items that go on top, the last element
    // of the array gets the extra text that goes on bottom. Each element gets any non-music info that comes before it.
    var tunes = [];
    var tuneLine;
    for (var i = 0; i < tune.lines.length; i++) {
        var line = tune.lines[i];
        if (!tuneLine)
            tuneLine = initializeTuneLine(tune);

        if (i === 0) {
            // These items go on top of the music
            tuneLine.metaText.tempo = tune.metaText.tempo;
            tuneLine.metaText.title = tune.metaText.title;
            tuneLine.metaText.header = tune.metaText.header;
            tuneLine.metaText.rhythm = tune.metaText.rhythm;
            tuneLine.metaText.origin = tune.metaText.origin;
            tuneLine.metaText.composer = tune.metaText.composer;
            tuneLine.metaText.author = tune.metaText.author;
            tuneLine.metaText.partOrder = tune.metaText.partOrder;
        }

        // push the lines until we get to a music line
        tuneLine.lines.push(line);
        if (line.staff) {
            tunes.push(tuneLine);
            tuneLine = undefined;
        }
    }
    // Add any extra stuff to the last line.
    if (tuneLine) {
        var lastLine = tunes[tunes.length-1];
        for (var j = 0; j < tuneLine.lines.length; j++)
            lastLine.lines.push(tuneLine.lines[j]);
    }

    // These items go below the music
    tuneLine = tunes[tunes.length-1];
    tuneLine.metaText.unalignedWords = tune.metaText.unalignedWords;
    tuneLine.metaText.book = tune.metaText.book;
    tuneLine.metaText.source = tune.metaText.source;
    tuneLine.metaText.discography = tune.metaText.discography;
    tuneLine.metaText.notes = tune.metaText.notes;
    tuneLine.metaText.transcription = tune.metaText.transcription;
    tuneLine.metaText.history = tune.metaText.history;
    tuneLine.metaText['abc-copyright'] = tune.metaText['abc-copyright'];
    tuneLine.metaText['abc-creator'] = tune.metaText['abc-creator'];
    tuneLine.metaText['abc-edited-by'] = tune.metaText['abc-edited-by'];
    tuneLine.metaText.footer = tune.metaText.footer;

    // Now create sub-divs and render each line. Need to copy the params to change the padding for the interior slices.
    var ep = {};
    for (var key in params) {
        if (params.hasOwnProperty(key)) {
            ep[key] = params[key];
        }
    }
    var origPaddingTop = ep.paddingtop;
    var origPaddingBottom = ep.paddingbottom;
    div.innerHTML = "";
    for (var k = 0; k < tunes.length; k++) {
        var lineEl = document.createElement("div");
        div.appendChild(lineEl);

        if (k === 0) {
	        ep.paddingtop = origPaddingTop;
	        ep.paddingbottom = -20;
        } else if (k === tunes.length-1) {
	        ep.paddingtop = 10;
	        ep.paddingbottom = origPaddingBottom;
        } else {
	        ep.paddingtop = 10;
	        ep.paddingbottom = -20;
        }
        renderOne(lineEl, tunes[k], ep, tuneNumber);
        if (k === 0)
            tune.engraver = tunes[k].engraver;
        else {
            if (!tune.engraver.staffgroups)
                tune.engraver.staffgroups = tunes[k].engraver.staffgroups;
            else if (tunes[k].engraver.staffgroups.length > 0)
                tune.engraver.staffgroups.push(tunes[k].engraver.staffgroups[0]);
        }
    }
}

// A quick way to render a tune from javascript when interactivity is not required.
// This is used when a javascript routine has some abc text that it wants to render
// in a div or collection of divs. One tune or many can be rendered.
//
// parameters:
//      output: an array of divs that the individual tunes are rendered to.
//          If the number of tunes exceeds the number of divs in the array, then
//          only the first tunes are rendered. If the number of divs exceeds the number
//          of tunes, then the unused divs are cleared. The divs can be passed as either
//          elements or strings of ids. If ids are passed, then the div MUST exist already.
//          (if a single element is passed, then it is an implied array of length one.)
//          (if a null is passed for an element, or the element doesn't exist, then that tune is skipped.)
//      abc: text representing a tune or an entire tune book in ABC notation.
//      renderParams: hash of:
//          startingTune: an index, starting at zero, representing which tune to start rendering at.
//              (If this element is not present, then rendering starts at zero.)
//          width: 800 by default. The width in pixels of the output paper
var renderAbc = function(output, abc, parserParams, engraverParams, renderParams) {
    // Note: all parameters have been condensed into the first ones. It doesn't hurt anything to allow the old format, so just copy them here.
    var params = {};
    var key;
    if (parserParams) {
        for (key in parserParams) {
            if (parserParams.hasOwnProperty(key)) {
                params[key] = parserParams[key];
            }
        }
    }
    if (engraverParams) {
        for (key in engraverParams) {
            if (engraverParams.hasOwnProperty(key)) {
	            // There is a conflict with the name of the parameter "listener". If it is in the second parameter, then it is for click.
	            if (key === "listener") {
	            	if (engraverParams[key].highlight)
		                params.clickListener = engraverParams[key].highlight;
	            } else
                    params[key] = engraverParams[key];
            }
        }
    }
    if (renderParams) {
        for (key in renderParams) {
            if (renderParams.hasOwnProperty(key)) {
                params[key] = renderParams[key];
            }
        }
    }

    function callback(div, tune, tuneNumber, abcString) {
        var removeDiv = false;
        if (div === "*") {
            removeDiv = true;
            div = document.createElement("div");
            div.setAttribute("style", "display:none;");
            document.body.appendChild(div);
        }
    	if (params.afterParsing)
    		params.afterParsing(tune, tuneNumber, abcString);
        if (!removeDiv && params.wrap && params.staffwidth) {
	        tune = doLineWrapping(div, tune, tuneNumber, abcString, params);
	        return tune;
        }
        else if (removeDiv || !params.oneSvgPerLine || tune.lines.length < 2)
            renderOne(div, tune, params, tuneNumber);
        else
            renderEachLineSeparately(div, tune, params, tuneNumber);
        if (removeDiv)
            div.parentNode.removeChild(div);
        return null;
    }

    return tunebook.renderEngine(callback, output, abc, params);
};

function doLineWrapping(div, tune, tuneNumber, abcString, params) {
	var engraver_controller = new EngraverController(div, params);
	var widths = engraver_controller.getMeasureWidths(tune);

	var ret = wrap.calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller);
    if (!params.oneSvgPerLine || ret.tune.lines.length < 2)
        renderOne(div, ret.tune, ret.revisedParams, tuneNumber);
    else
        renderEachLineSeparately(div, ret.tune, ret.revisedParams, tuneNumber);
	ret.tune.explanation = ret.explanation;
	return ret.tune;
}

module.exports = renderAbc;


/***/ }),

/***/ "./node_modules/abcjs/src/data/abc_tune.js":
/*!*************************************************!*\
  !*** ./node_modules/abcjs/src/data/abc_tune.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_tune.js: a computer usable internal structure representing one tune.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var parseKeyVoice = __webpack_require__(/*! ../parse/abc_parse_key_voice */ "./node_modules/abcjs/src/parse/abc_parse_key_voice.js");
var spacing = __webpack_require__(/*! ../write/abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

/**
 * This is the data for a single ABC tune. It is created and populated by the window.ABCJS.parse.Parse class.
 * Also known as the ABCJS Abstract Syntax Tree
 * @alternateClassName ABCJS.Tune
 */
var Tune = function() {
	// The structure consists of a hash with the following two items:
	// metaText: a hash of {key, value}, where key is one of: title, author, rhythm, source, transcription, unalignedWords, etc...
	// tempo: { noteLength: number (e.g. .125), bpm: number }
	// lines: an array of elements, or one of the following:
	//
	// STAFF: array of elements
	// SUBTITLE: string
	//
	// TODO: actually, the start and end char should modify each part of the note type
	// The elements all have a type field and a start and end char
	// field. The rest of the fields depend on the type and are listed below:
	// REST: duration=1,2,4,8; chord: string
	// NOTE: accidental=none,dbl_flat,flat,natural,sharp,dbl_sharp
	//		pitch: "C" is 0. The numbers refer to the pitch letter.
	//		duration: .5 (sixteenth), .75 (dotted sixteenth), 1 (eighth), 1.5 (dotted eighth)
	//			2 (quarter), 3 (dotted quarter), 4 (half), 6 (dotted half) 8 (whole)
	//		chord: { name:chord, position: one of 'default', 'above', 'below' }
	//		end_beam = true or undefined if this is the last note in a beam.
	//		lyric: array of { syllable: xxx, divider: one of " -_" }
	//		startTie = true|undefined
	//		endTie = true|undefined
	//		startTriplet = num <- that is the number to print
	//		endTriplet = true|undefined (the last note of the triplet)
	// TODO: actually, decoration should be an array.
	//		decoration: upbow, downbow, accent
	// BAR: type=bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat
	//	number: 1 or 2: if it is the start of a first or second ending
	// CLEF: type=treble,bass
	// KEY-SIG:
	//		accidentals[]: { acc:sharp|dblsharp|natural|flat|dblflat,  note:a|b|c|d|e|f|g }
	// METER: type: common_time,cut_time,specified
	//		if specified, { num: 99, den: 99 }

	this.getBeatLength = function() {
		for (var i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff) {
				for (var j = 0; j < this.lines[i].staff.length; j++) {
					if (this.lines[i].staff[j].meter) {
						var meter = this.lines[i].staff[j].meter;
						if (meter.type === "specified") {
							if (meter.value.length > 0) {
								var num = parseInt(meter.value[0].num, 10);
								var den = parseInt(meter.value[0].den, 10);
								if (num === 3 && den === 8) return 3/8;
								if (num === 6 && den === 8) return 3/8;
								if (num === 6 && den === 4) return 3/4;
								if (num === 9 && den === 8) return 3/8;
								if (num === 12 && den === 8) return 3/8;
								return 1/den;
							}
							else
								return 1/4; // No meter was specified, so use this default
						} else if (meter.type === 'cut_time') {
							return 1/2;
						} else {
							return 1/4; // TODO-PER: this works for common time, but not for the ancient meters.
						}
					}
				}
			}
		}
		return 1/4; // No meter was specified, so use this default
	};

	this.getPickupLength = function() {
		var pickupLength = 0;
		var barLength = this.getBarLength();
		for (var i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff) {
				for (var j = 0; j < this.lines[i].staff.length; j++) {
					for (var v = 0; v < this.lines[i].staff[j].voices.length; v++) {
						var voice = this.lines[i].staff[j].voices[v];
						var hasNote = false;
						var tripletMultiplier = 1;
						for (var el = 0; el < voice.length; el++) {
							var isSpacer = voice[el].rest && voice[el].rest.type === "spacer";
							if (voice[el].startTriplet)
								tripletMultiplier = voice[el].tripletMultiplier;
							if (voice[el].duration && !isSpacer)
								pickupLength += voice[el].duration * tripletMultiplier;
							if (voice[el].endTriplet)
								tripletMultiplier = 1;
							if (pickupLength >= barLength)
								pickupLength -= barLength;
							if (voice[el].el_type === 'bar')
								return pickupLength;
						}
					}
				}
			}
		}
		return pickupLength;
	};

	this.getBarLength = function() {
		var meter = this.getMeterFraction();
		return meter.num / meter.den;
	};

	this.millisecondsPerMeasure = function(bpmOverride) {
		var bpm;
		if (bpmOverride) {
			bpm = bpmOverride;
		} else {
			var tempo = this.metaText ? this.metaText.tempo : null;
			bpm = this.getBpm(tempo);
		}
		if (bpm <= 0)
			bpm = 1; // I don't think this can happen, but we don't want a possibility of dividing by zero.

		var beatsPerMeasure = this.getBeatsPerMeasure();

		var minutesPerMeasure = beatsPerMeasure / bpm;
		return minutesPerMeasure * 60000;
	};

	this.getBeatsPerMeasure = function() {
		var beatsPerMeasure;
		var meter = this.getMeterFraction();
		if (meter.den === 8) {
			beatsPerMeasure = meter.num / 3;
		} else {
			beatsPerMeasure = meter.num;
		}
		if (beatsPerMeasure <= 0) // This probably won't happen in any normal case - but it is possible that the meter could be set to something nonsensical.
			beatsPerMeasure = 1;
		return beatsPerMeasure;
	};

	this.reset = function () {
		this.version = "1.0.1";
		this.media = "screen";
		this.metaText = {};
		this.formatting = {};
		this.lines = [];
		this.staffNum = 0;
		this.voiceNum = 0;
		this.lineNum = 0;
	};

	this.resolveOverlays = function() {
		var madeChanges = false;
		for (var i = 0; i < this.lines.length; i++) {
			var line = this.lines[i];
			if (line.staff) {
				for (var j = 0; j < line.staff.length; j++) {
					var staff = line.staff[j];
					var overlayVoice = [];
					for (var k = 0; k < staff.voices.length; k++) {
						var voice = staff.voices[k];
						overlayVoice.push({ hasOverlay: false, voice: [], snip: []});
						var durationThisBar = 0;
						var inOverlay = false;
						var snipStart = -1;
						for (var kk = 0; kk < voice.length; kk++) {
							var event = voice[kk];
							if (event.el_type === "overlay" && !inOverlay) {
								madeChanges = true;
								inOverlay = true;
								snipStart = kk;
								overlayVoice[k].hasOverlay = true;
							} else if (event.el_type === "bar") {
								if (inOverlay) {
									// delete the overlay events from this array without messing up this loop.
									inOverlay = false;
									overlayVoice[k].snip.push({ start: snipStart, len: kk - snipStart});
									overlayVoice[k].voice.push(event); // Also end the overlay with the barline.
								} else {
									// This keeps the voices lined up: if the overlay isn't in the first measure then we need a bunch of invisible rests.
									if (durationThisBar > 0)
										overlayVoice[k].voice.push({ el_type: "note", duration: durationThisBar, rest: {type: "invisible"}, startChar: event.startChar, endChar: event.endChar });
									overlayVoice[k].voice.push(event);
								}
								durationThisBar = 0;
							} else if (event.el_type === "note") {
								if (inOverlay) {
									overlayVoice[k].voice.push(event);
								} else {
									durationThisBar += event.duration;
								}
							} else if (event.el_type === "scale" || event.el_type === "stem" || event.el_type === "overlay" || event.el_type === "style" || event.el_type === "transpose") {
								// These types of events are duplicated on the overlay layer.
								overlayVoice[k].voice.push(event);
							}
						}
						if (overlayVoice[k].hasOverlay && overlayVoice[k].snip.length === 0) {
							// there was no closing bar, so we didn't set the snip amount.
							overlayVoice[k].snip.push({ start: snipStart, len: voice.length - snipStart});
						}
					}
					for (k = 0; k < overlayVoice.length; k++) {
						var ov = overlayVoice[k];
						if (ov.hasOverlay) {
							staff.voices.push(ov.voice);
							for (var kkk = ov.snip.length-1; kkk >= 0; kkk--) {
								var snip = ov.snip[kkk];
								staff.voices[k].splice(snip.start, snip.len);
							}
							// remove ending marks from the overlay voice so they are not repeated
							for (kkk = 0; kkk < staff.voices[staff.voices.length-1].length; kkk++) {
								staff.voices[staff.voices.length-1][kkk] = parseCommon.clone(staff.voices[staff.voices.length-1][kkk]);
								var el = staff.voices[staff.voices.length-1][kkk];
								if (el.el_type === 'bar' && el.startEnding) {
									delete el.startEnding;
								}
								if (el.el_type === 'bar' && el.endEnding)
									delete el.endEnding;
							}
						}
					}
				}
			}
		}
		return madeChanges;
	};

	function fixTitles(lines) {
		// We might have name and subname defined. We now know what line everything is on, so we can determine which to use.
		var firstMusicLine = true;
		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];
			if (line.staff) {
				for (var j = 0; j < line.staff.length; j++) {
					var staff = line.staff[j];
					if (staff.title) {
						var hasATitle = false;
						for (var k = 0; k < staff.title.length; k++) {
							if (staff.title[k]) {
							staff.title[k] = (firstMusicLine) ? staff.title[k].name : staff.title[k].subname;
							if (staff.title[k])
								hasATitle = true;
							else
									staff.title[k] = '';
							} else
								staff.title[k] = '';
						}
						if (!hasATitle)
							delete staff.title;
					}
				}
				firstMusicLine = false;
			}
		}
	}

	this.cleanUp = function(defWidth, defLength, barsperstaff, staffnonote, currSlur) {
		this.closeLine();	// Close the last line.

		// If the tempo was created with a string like "Allegro", then the duration of a beat needs to be set at the last moment, when it is most likely known.
		if (this.metaText.tempo && this.metaText.tempo.bpm && !this.metaText.tempo.duration)
			this.metaText.tempo.duration = [ this.getBeatLength() ];

		// Remove any blank lines
		var anyDeleted = false;
		var i, s, v;
		for (i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff !== undefined) {
				var hasAny = false;
				for (s = 0; s < this.lines[i].staff.length; s++) {
					if (this.lines[i].staff[s] === undefined) {
						anyDeleted = true;
						this.lines[i].staff[s] = null;
						//this.lines[i].staff[s] = { voices: []};	// TODO-PER: There was a part missing in the abc music. How should we recover?
					} else {
						for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {
							if (this.lines[i].staff[s].voices[v] === undefined)
								this.lines[i].staff[s].voices[v] = [];	// TODO-PER: There was a part missing in the abc music. How should we recover?
							else
								if (this.containsNotes(this.lines[i].staff[s].voices[v])) hasAny = true;
						}
					}
				}
				if (!hasAny) {
					this.lines[i] = null;
					anyDeleted = true;
				}
			}
		}
		if (anyDeleted) {
			this.lines = parseCommon.compact(this.lines);
			parseCommon.each(this.lines, function(line) {
				if (line.staff)
					line.staff = parseCommon.compact(line.staff);
			});
		}

		// if we exceeded the number of bars allowed on a line, then force a new line
		if (barsperstaff) {
			while (wrapMusicLines(this.lines, barsperstaff)) {
				// This will keep wrapping until the end of the piece.
			}
		}

		// If we were passed staffnonote, then we want to get rid of all staffs that contain only rests.
		if (staffnonote) {
			anyDeleted = false;
			for (i = 0; i < this.lines.length; i++) {
				if (this.lines[i].staff !== undefined) {
					for (s = 0; s < this.lines[i].staff.length; s++) {
						var keepThis = false;
						for (v = 0; v < this.lines[i].staff[s].voices.length; v++) {
							if (this.containsNotesStrict(this.lines[i].staff[s].voices[v])) {
								keepThis = true;
							}
						}
						if (!keepThis) {
							anyDeleted = true;
							this.lines[i].staff[s] = null;
						}
					}
				}
			}
			if (anyDeleted) {
				parseCommon.each(this.lines, function(line) {
					if (line.staff)
						line.staff = parseCommon.compact(line.staff);
				});
			}
		}

		fixTitles(this.lines);

		// Remove the temporary working variables
		for (i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff) {
				for (s = 0; s < this.lines[i].staff.length; s++)
						delete this.lines[i].staff[s].workingClef;
			}
		}

		// If there are overlays, create new voices for them.
		while (this.resolveOverlays()) {
			// keep resolving overlays as long as any are found.
		}

		function cleanUpSlursInLine(line) {
			var x;
//			var lyr = null;	// TODO-PER: debugging.

			var addEndSlur = function(obj, num, chordPos) {
				if (currSlur[chordPos] === undefined) {
					// There isn't an exact match for note position, but we'll take any other open slur.
					for (x = 0; x < currSlur.length; x++) {
						if (currSlur[x] !== undefined) {
							chordPos = x;
							break;
						}
					}
					if (currSlur[chordPos] === undefined) {
						var offNum = chordPos*100+1;
						parseCommon.each(obj.endSlur, function(x) { if (offNum === x) --offNum; });
						currSlur[chordPos] = [offNum];
					}
				}
				var slurNum;
				for (var i = 0; i < num; i++) {
					slurNum = currSlur[chordPos].pop();
					obj.endSlur.push(slurNum);
//					lyr.syllable += '<' + slurNum;	// TODO-PER: debugging
				}
				if (currSlur[chordPos].length === 0)
					delete currSlur[chordPos];
				return slurNum;
			};

			var addStartSlur = function(obj, num, chordPos, usedNums) {
				obj.startSlur = [];
				if (currSlur[chordPos] === undefined) {
					currSlur[chordPos] = [];
				}
				var nextNum = chordPos*100+1;
				for (var i = 0; i < num; i++) {
					if (usedNums) {
						parseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });
						parseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });
						parseCommon.each(usedNums, function(x) { if (nextNum === x) ++nextNum; });
					}
					parseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });
					parseCommon.each(currSlur[chordPos], function(x) { if (nextNum === x) ++nextNum; });

					currSlur[chordPos].push(nextNum);
					obj.startSlur.push({ label: nextNum });
//					lyr.syllable += ' ' + nextNum + '>';	// TODO-PER:debugging
					nextNum++;
				}
			};

			for (var i = 0; i < line.length; i++) {
				var el = line[i];
//				if (el.lyric === undefined)	// TODO-PER: debugging
//					el.lyric = [{ divider: '-' }];	// TODO-PER: debugging
//				lyr = el.lyric[0];	// TODO-PER: debugging
//				lyr.syllable = '';	// TODO-PER: debugging
				if (el.el_type === 'note') {
					if (el.gracenotes) {
						for (var g = 0; g < el.gracenotes.length; g++) {
							if (el.gracenotes[g].endSlur) {
								var gg = el.gracenotes[g].endSlur;
								el.gracenotes[g].endSlur = [];
								for (var ggg = 0; ggg < gg; ggg++)
									addEndSlur(el.gracenotes[g], 1, 20);
							}
							if (el.gracenotes[g].startSlur) {
								x = el.gracenotes[g].startSlur;
								addStartSlur(el.gracenotes[g], x, 20);
							}
						}
					}
					if (el.endSlur) {
						x = el.endSlur;
						el.endSlur = [];
						addEndSlur(el, x, 0);
					}
					if (el.startSlur) {
						x = el.startSlur;
						addStartSlur(el, x, 0);
					}
					if (el.pitches) {
						var usedNums = [];
						for (var p = 0; p < el.pitches.length; p++) {
							if (el.pitches[p].endSlur) {
								var k = el.pitches[p].endSlur;
								el.pitches[p].endSlur = [];
								for (var j = 0; j < k; j++) {
									var slurNum = addEndSlur(el.pitches[p], 1, p+1);
									usedNums.push(slurNum);
								}
							}
						}
						for (p = 0; p < el.pitches.length; p++) {
							if (el.pitches[p].startSlur) {
								x = el.pitches[p].startSlur;
								addStartSlur(el.pitches[p], x, p+1, usedNums);
							}
						}
						// Correct for the weird gracenote case where ({g}a) should match.
						// The end slur was already assigned to the note, and needs to be moved to the first note of the graces.
						if (el.gracenotes && el.pitches[0].endSlur && el.pitches[0].endSlur[0] === 100 && el.pitches[0].startSlur) {
							if (el.gracenotes[0].endSlur)
								el.gracenotes[0].endSlur.push(el.pitches[0].startSlur[0].label);
							else
								el.gracenotes[0].endSlur = [el.pitches[0].startSlur[0].label];
							if (el.pitches[0].endSlur.length === 1)
								delete el.pitches[0].endSlur;
							else if (el.pitches[0].endSlur[0] === 100)
								el.pitches[0].endSlur.shift();
							else if (el.pitches[0].endSlur[el.pitches[0].endSlur.length-1] === 100)
								el.pitches[0].endSlur.pop();
							if (currSlur[1].length === 1)
								delete currSlur[1];
							else
								currSlur[1].pop();
						}
					}
				}
			}
		}

		// TODO-PER: This could be done faster as we go instead of as the last step.
		function fixClefPlacement(el) {
			parseKeyVoice.fixClef(el);
			//if (el.el_type === 'clef') {
//				var min = -2;
//				var max = 5;
//				switch(el.type) {
//					case 'treble+8':
//					case 'treble-8':
//						break;
//					case 'bass':
//					case 'bass+8':
//					case 'bass-8':
//						el.verticalPos = 20 + el.verticalPos; min += 6; max += 6;
//						break;
//					case 'tenor':
//					case 'tenor+8':
//					case 'tenor-8':
//						el.verticalPos = - el.verticalPos; min = -40; max = 40;
////						el.verticalPos+=2; min += 6; max += 6;
//						break;
//					case 'alto':
//					case 'alto+8':
//					case 'alto-8':
//						el.verticalPos = - el.verticalPos; min = -40; max = 40;
////						el.verticalPos-=2; min += 4; max += 4;
//						break;
//				}
//				if (el.verticalPos < min) {
//					while (el.verticalPos < min)
//						el.verticalPos += 7;
//				} else if (el.verticalPos > max) {
//					while (el.verticalPos > max)
//						el.verticalPos -= 7;
//				}
			//}
		}

		function wrapMusicLines(lines, barsperstaff) {
			for (i = 0; i < lines.length; i++) {
				if (lines[i].staff !== undefined) {
					for (s = 0; s < lines[i].staff.length; s++) {
						var permanentItems = [];
						for (v = 0; v < lines[i].staff[s].voices.length; v++) {
							var voice = lines[i].staff[s].voices[v];
							var barNumThisLine = 0;
							for (var n = 0; n < voice.length; n++) {
								if (voice[n].el_type === 'bar') {
									barNumThisLine++;
									if (barNumThisLine >= barsperstaff) {
										// push everything else to the next line, if there is anything else,
										// and there is a next line. If there isn't a next line, create one.
										if (n < voice.length - 1) {
											var nextLine = getNextMusicLine(lines, i);
											if (!nextLine) {
												var cp = JSON.parse(JSON.stringify(lines[i]));
												lines.push(parseCommon.clone(cp));
												nextLine = lines[lines.length - 1];
												for (var ss = 0; ss < nextLine.staff.length; ss++) {
													for (var vv = 0; vv < nextLine.staff[ss].voices.length; vv++)
														nextLine.staff[ss].voices[vv] = [];
												}
											}
											var startElement = n + 1;
											var section = lines[i].staff[s].voices[v].slice(startElement);
											lines[i].staff[s].voices[v] = lines[i].staff[s].voices[v].slice(0, startElement);
											nextLine.staff[s].voices[v] = permanentItems.concat(section.concat(nextLine.staff[s].voices[v]));
											return true;
										}
									}
								} else if (!voice[n].duration) {
									permanentItems.push(voice[n]);
								}
							}
						}
					}
				}
			}
			return false;
		}

		function getNextMusicLine(lines, currentLine) {
			currentLine++;
			while (lines.length > currentLine) {
				if (lines[currentLine].staff)
					return lines[currentLine];
				currentLine++;
			}
			return null;
		}

		for (this.lineNum = 0; this.lineNum < this.lines.length; this.lineNum++) {
			var staff = this.lines[this.lineNum].staff;
			if (staff) {
				for (this.staffNum = 0; this.staffNum < staff.length; this.staffNum++) {
					if (staff[this.staffNum].clef)
						fixClefPlacement(staff[this.staffNum].clef);
					for (this.voiceNum = 0; this.voiceNum < staff[this.staffNum].voices.length; this.voiceNum++) {
						var voice = staff[this.staffNum].voices[this.voiceNum];
						cleanUpSlursInLine(voice);
						for (var j = 0; j < voice.length; j++) {
							if (voice[j].el_type === 'clef')
								fixClefPlacement(voice[j]);
						}
						if (voice.length > 0 && voice[voice.length-1].barNumber) {
							// Don't hang a bar number on the last bar line: it should go on the next line.
							var nextLine = getNextMusicLine(this.lines, this.lineNum);
							if (nextLine)
								nextLine.staff[0].barNumber = voice[voice.length-1].barNumber;
							delete voice[voice.length-1].barNumber;
						}
					}
				}
			}
		}

		if (!this.formatting.pagewidth)
			this.formatting.pagewidth = defWidth;
		if (!this.formatting.pageheight)
			this.formatting.pageheight = defLength;

		// Remove temporary variables that the outside doesn't need to know about
		delete this.staffNum;
		delete this.voiceNum;
		delete this.lineNum;
		delete this.potentialStartBeam;
		delete this.potentialEndBeam;
		delete this.vskipPending;

		return currSlur;
	};

	this.reset();

	this.getLastNote = function() {
		if (this.lines[this.lineNum] && this.lines[this.lineNum].staff && this.lines[this.lineNum].staff[this.staffNum] &&
			this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]) {
			for (var i = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length-1; i >= 0; i--) {
				var el = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][i];
				if (el.el_type === 'note') {
					return el;
				}
			}
		}
		return null;
	};

	this.addTieToLastNote = function() {
		// TODO-PER: if this is a chord, which note?
		var el = this.getLastNote();
		if (el && el.pitches && el.pitches.length > 0) {
			el.pitches[0].startTie = {};
			return true;
		}
		return false;
	};

	this.getDuration = function(el) {
		if (el.duration) return el.duration;
		//if (el.pitches && el.pitches.length > 0) return el.pitches[0].duration;
		return 0;
	};

	this.closeLine = function() {
		if (this.potentialStartBeam && this.potentialEndBeam) {
			this.potentialStartBeam.startBeam = true;
			this.potentialEndBeam.endBeam = true;
		}
		delete this.potentialStartBeam;
		delete this.potentialEndBeam;
	};

	this.appendElement = function(type, startChar, endChar, hashParams)
	{
		var This = this;
		var pushNote = function(hp) {
			var currStaff = This.lines[This.lineNum].staff[This.staffNum];
			if (!currStaff) {
				// TODO-PER: This prevents a crash, but it drops the element. Need to figure out how to start a new line, or delay adding this.
				return;
			}
			if (hp.pitches !== undefined) {
				var mid = currStaff.workingClef.verticalPos;
				parseCommon.each(hp.pitches, function(p) { p.verticalPos = p.pitch - mid; });
			}
			if (hp.gracenotes !== undefined) {
				var mid2 = currStaff.workingClef.verticalPos;
				parseCommon.each(hp.gracenotes, function(p) { p.verticalPos = p.pitch - mid2; });
			}
			currStaff.voices[This.voiceNum].push(hp);
		};
		hashParams.el_type = type;
		if (startChar !== null)
			hashParams.startChar = startChar;
		if (endChar !== null)
			hashParams.endChar = endChar;
		var endBeamHere = function() {
			This.potentialStartBeam.startBeam = true;
			hashParams.endBeam = true;
			delete This.potentialStartBeam;
			delete This.potentialEndBeam;
		};
		var endBeamLast = function() {
			if (This.potentialStartBeam !== undefined && This.potentialEndBeam !== undefined) {	// Do we have a set of notes to beam?
				This.potentialStartBeam.startBeam = true;
				This.potentialEndBeam.endBeam = true;
			}
			delete This.potentialStartBeam;
			delete This.potentialEndBeam;
		};
		if (type === 'note') { // && (hashParams.rest !== undefined || hashParams.end_beam === undefined)) {
			// Now, add the startBeam and endBeam where it is needed.
			// end_beam is already set on the places where there is a forced end_beam. We'll remove that here after using that info.
			// this.potentialStartBeam either points to null or the start beam.
			// this.potentialEndBeam either points to null or the start beam.
			// If we have a beam break (note is longer than a quarter, or an end_beam is on this element), then set the beam if we have one.
			// reset the variables for the next notes.
			var dur = This.getDuration(hashParams);
			if (dur >= 0.25) {	// The beam ends on the note before this.
				endBeamLast();
			} else if (hashParams.force_end_beam_last && This.potentialStartBeam !== undefined) {
				endBeamLast();
			} else if (hashParams.end_beam && This.potentialStartBeam !== undefined) {	// the beam is forced to end on this note, probably because of a space in the ABC
				if (hashParams.rest === undefined)
					endBeamHere();
				else
					endBeamLast();
			} else if (hashParams.rest === undefined) {	// this a short note and we aren't about to end the beam
				if (This.potentialStartBeam === undefined) {	// We aren't collecting notes for a beam, so start here.
					if (!hashParams.end_beam) {
						This.potentialStartBeam = hashParams;
						delete This.potentialEndBeam;
					}
				} else {
					This.potentialEndBeam = hashParams;	// Continue the beaming, look for the end next note.
				}
			}

			//  end_beam goes on rests and notes which precede rests _except_ when a rest (or set of adjacent rests) has normal notes on both sides (no spaces)
//			if (hashParams.rest !== undefined)
//			{
//				hashParams.end_beam = true;
//				var el2 = this.getLastNote();
//				if (el2) el2.end_beam = true;
//				// TODO-PER: implement exception mentioned in the comment.
//			}
		} else {	// It's not a note, so there definitely isn't beaming after it.
			endBeamLast();
		}
		delete hashParams.end_beam;	// We don't want this temporary variable hanging around.
		delete hashParams.force_end_beam_last;	// We don't want this temporary variable hanging around.
		pushNote(hashParams);
	};

	this.appendStartingElement = function(type, startChar, endChar, hashParams2)
	{
		// If we're in the middle of beaming, then end the beam.
		this.closeLine();

		// We only ever want implied naturals the first time.
		var impliedNaturals;
		if (type === 'key') {
			impliedNaturals = hashParams2.impliedNaturals;
			delete hashParams2.impliedNaturals;
			delete hashParams2.explicitAccidentals;
		}

		// Clone the object because it will be sticking around for the next line and we don't want the extra fields in it.
		var hashParams = parseCommon.clone(hashParams2);

		if (this.lines[this.lineNum].staff) { // be sure that we are on a music type line before doing the following.
			// If this is the first item in this staff, then we might have to initialize the staff, first.
			if (this.lines[this.lineNum].staff.length <= this.staffNum) {
				this.lines[this.lineNum].staff[this.staffNum] = {};
				this.lines[this.lineNum].staff[this.staffNum].clef = parseCommon.clone(this.lines[this.lineNum].staff[0].clef);
				this.lines[this.lineNum].staff[this.staffNum].key = parseCommon.clone(this.lines[this.lineNum].staff[0].key);
				if (this.lines[this.lineNum].staff[0].meter)
					this.lines[this.lineNum].staff[this.staffNum].meter = parseCommon.clone(this.lines[this.lineNum].staff[0].meter);
				this.lines[this.lineNum].staff[this.staffNum].workingClef = parseCommon.clone(this.lines[this.lineNum].staff[0].workingClef);
				this.lines[this.lineNum].staff[this.staffNum].voices = [[]];
			}
			// If this is a clef type, then we replace the working clef on the line. This is kept separate from
			// the clef in case there is an inline clef field. We need to know what the current position for
			// the note is.
			if (type === 'clef') {
				this.lines[this.lineNum].staff[this.staffNum].workingClef = hashParams;
			}

			// These elements should not be added twice, so if the element exists on this line without a note or bar before it, just replace the staff version.
			var voice = this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];
			for (var i = 0; i < voice.length; i++) {
				if (voice[i].el_type === 'note' || voice[i].el_type === 'bar') {
					hashParams.el_type = type;
					hashParams.startChar = startChar;
					hashParams.endChar = endChar;
					if (impliedNaturals)
						hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
					voice.push(hashParams);
					return;
				}
				if (voice[i].el_type === type) {
					hashParams.el_type = type;
					hashParams.startChar = startChar;
					hashParams.endChar = endChar;
					if (impliedNaturals)
						hashParams.accidentals = impliedNaturals.concat(hashParams.accidentals);
					voice[i] = hashParams;
					return;
				}
			}
			// We didn't see either that type or a note, so replace the element to the staff.
			this.lines[this.lineNum].staff[this.staffNum][type] = hashParams2;
		}
	};

	this.getNumLines = function() {
		return this.lines.length;
	};

	this.pushLine = function(hash) {
		if (this.vskipPending) {
			hash.vskip = this.vskipPending;
			delete this.vskipPending;
		}
		this.lines.push(hash);
	};

	this.addSubtitle = function(str) {
		this.pushLine({subtitle: str});
	};

	this.addSpacing = function(num) {
		this.vskipPending = num;
	};

	this.addNewPage = function(num) {
		this.pushLine({newpage: num});
	};

	this.addSeparator = function(spaceAbove, spaceBelow, lineLength) {
		this.pushLine({separator: {spaceAbove: spaceAbove, spaceBelow: spaceBelow, lineLength: lineLength}});
	};

	this.addText = function(str) {
		this.pushLine({text: str});
	};

	this.addCentered = function(str) {
		this.pushLine({text: [{text: str, center: true }]});
	};

	this.containsNotes = function(voice) {
		for (var i = 0; i < voice.length; i++) {
			if (voice[i].el_type === 'note' || voice[i].el_type === 'bar')
				return true;
		}
		return false;
	};

	this.containsNotesStrict = function(voice) {
		for (var i = 0; i < voice.length; i++) {
			if (voice[i].el_type === 'note' && voice[i].rest === undefined)
				return true;
		}
		return false;
	};

//	anyVoiceContainsNotes: function(line) {
//		for (var i = 0; i < line.staff.voices.length; i++) {
//			if (this.containsNotes(line.staff.voices[i]))
//				return true;
//		}
//		return false;
//	},
	this.changeVoiceScale = function(scale) {
		var This = this;
		This.appendElement('scale', null, null, { size: scale} );
	};

	this.startNewLine = function(params) {
		// If the pointed to line doesn't exist, just create that. If the line does exist, but doesn't have any music on it, just use it.
		// If it does exist and has music, then increment the line number. If the new element doesn't exist, create it.
		var This = this;
		this.closeLine();	// Close the previous line.
		var createVoice = function(params) {
			var thisStaff = This.lines[This.lineNum].staff[This.staffNum];
			thisStaff.voices[This.voiceNum] = [];
			if (!thisStaff.title)
				thisStaff.title = [];
			thisStaff.title[This.voiceNum] = { name: params.name, subname: params.subname };
			if (params.style)
				This.appendElement('style', null, null, {head: params.style});
			if (params.stem)
				This.appendElement('stem', null, null, {direction: params.stem});
			else if (This.voiceNum > 0) {
				if (thisStaff.voices[0]!== undefined) {
					var found = false;
					for (var i = 0; i < thisStaff.voices[0].length; i++) {
						if (thisStaff.voices[0].el_type === 'stem')
							found = true;
					}
					if (!found) {
						var stem = { el_type: 'stem', direction: 'up' };
						thisStaff.voices[0].splice(0,0,stem);
					}
				}
				This.appendElement('stem', null, null, {direction: 'down'});
			}
			if (params.scale)
				This.appendElement('scale', null, null, { size: params.scale} );
		};
		var createStaff = function(params) {
			if (params.key && params.key.impliedNaturals) {
				params.key.accidentals = params.key.accidentals.concat(params.key.impliedNaturals);
				delete params.key.impliedNaturals;
			}

			This.lines[This.lineNum].staff[This.staffNum] = {voices: [ ], clef: params.clef, key: params.key, workingClef: params.clef };
			if (params.stafflines !== undefined) {
				This.lines[This.lineNum].staff[This.staffNum].clef.stafflines = params.stafflines;
				This.lines[This.lineNum].staff[This.staffNum].workingClef.stafflines = params.stafflines;
			}
			if (params.staffscale) {
				This.lines[This.lineNum].staff[This.staffNum].staffscale = params.staffscale;
			}
			if (params.tripletfont) This.lines[This.lineNum].staff[This.staffNum].tripletfont = params.tripletfont;
			if (params.vocalfont) This.lines[This.lineNum].staff[This.staffNum].vocalfont = params.vocalfont;
			if (params.bracket) This.lines[This.lineNum].staff[This.staffNum].bracket = params.bracket;
			if (params.brace) This.lines[This.lineNum].staff[This.staffNum].brace = params.brace;
			if (params.connectBarLines) This.lines[This.lineNum].staff[This.staffNum].connectBarLines = params.connectBarLines;
			if (params.barNumber) This.lines[This.lineNum].staff[This.staffNum].barNumber = params.barNumber;
			createVoice(params);
			// Some stuff just happens for the first voice
			if (params.part)
				This.appendElement('part', params.part.startChar, params.part.endChar, {title: params.part.title});
			if (params.meter !== undefined) This.lines[This.lineNum].staff[This.staffNum].meter = params.meter;
		};
		var createLine = function(params) {
			This.lines[This.lineNum] = {staff: []};
			createStaff(params);
		};
		if (this.lines[this.lineNum] === undefined) createLine(params);
		else if (this.lines[this.lineNum].staff === undefined) {
			this.lineNum++;
			this.startNewLine(params);
		} else if (this.lines[this.lineNum].staff[this.staffNum] === undefined) createStaff(params);
		else if (this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] === undefined) createVoice(params);
		else if (!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])) return;
		else {
			this.lineNum++;
			this.startNewLine(params);
		}
	};

	this.setBarNumberImmediate = function(barNumber) {
		// If this is called right at the beginning of a line, then correct the measure number that is already written.
		// If this is called at the beginning of a measure, then correct the measure number that was just created.
		// If this is called in the middle of a measure, then subtract one from it, because it will be incremented before applied.
		var currentVoice = this.getCurrentVoice();
		if (currentVoice && currentVoice.length > 0) {
			var lastElement = currentVoice[currentVoice.length-1];
			if (lastElement.el_type === 'bar') {
				if (lastElement.barNumber !== undefined) // the measure number might not be written for this bar, don't override that.
					lastElement.barNumber = barNumber;
			} else
				return barNumber-1;
		}
		return barNumber;
	};

	this.hasBeginMusic = function() {
		// return true if there exists at least one line that contains "staff"
		for (var i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff)
				return true;
		}
		return false;
	};

	this.isFirstLine = function(index) {
		for (var i = index-1; i >= 0; i--) {
			if (this.lines[i].staff !== undefined) return false;
		}
		return true;
	};

	this.getMeter = function() {
		for (var i = 0; i < this.lines.length; i++) {
			var line = this.lines[i];
			if (line.staff) {
				for (var j = 0; j < line.staff.length; j++) {
					var meter = line.staff[j].meter;
					if (meter) {
						return meter;
					}
				}
			}
		}
		return { type: "common_time" };
	};

	this.getMeterFraction = function() {
		var meter = this.getMeter();
		var num = 4;
		var den = 4;
		if (meter) {
			if (meter.type === 'specified') {
				num = parseInt(meter.value[0].num, 10);
				den = parseInt(meter.value[0].den,10);
			} else if (meter.type === 'cut_time') {
				num = 2;
				den = 2;
			} else if (meter.type === 'common_time') {
				num = 4;
				den = 4;
			}
		}
		this.meter = { num: num, den: den };
		return this.meter; // TODO-PER: is this saved value used anywhere? A get function shouldn't change state.
	};

	this.getKeySignature = function() {
		for (var i = 0; i < this.lines.length; i++) {
			var line = this.lines[i];
			if (line.staff) {
				for (var j = 0; j < line.staff.length; j++) {
					if (line.staff[j].key)
						return line.staff[j].key;
				}
			}
		}
		return {  };
	};

	this.getCurrentVoice = function() {
		if (this.lines[this.lineNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum] !== undefined && this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum] !== undefined)
			return this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];
		else return null;
	};

	this.setCurrentVoice = function(staffNum, voiceNum) {
		this.staffNum = staffNum;
		this.voiceNum = voiceNum;
		for (var i = 0; i < this.lines.length; i++) {
			if (this.lines[i].staff) {
				if (this.lines[i].staff[staffNum] === undefined || this.lines[i].staff[staffNum].voices[voiceNum] === undefined ||
					!this.containsNotes(this.lines[i].staff[staffNum].voices[voiceNum] )) {
					this.lineNum =  i;
					return;
				}
			}
		}
		this.lineNum =  i;
	};

	this.addMetaText = function(key, value) {
		if (this.metaText[key] === undefined)
			this.metaText[key] = value;
		else
			this.metaText[key] += "\n" + value;
	};

	this.addMetaTextArray = function(key, value) {
		if (this.metaText[key] === undefined)
			this.metaText[key] = [value];
		else
			this.metaText[key].push(value);
	};
	this.addMetaTextObj = function(key, value) {
		this.metaText[key] = value;
	};

	function addVerticalInfo(timingEvents) {
		// Add vertical info to the bar events: put the next event's top, and the event after the next measure's top.
		var lastBarTop;
		var lastBarBottom;
		var lastEventTop;
		var lastEventBottom;
		for (var e = timingEvents.length - 1; e >= 0; e--) {
			var ev = timingEvents[e];
			if (ev.type === 'bar') {
				ev.top = lastEventTop;
				ev.nextTop = lastBarTop;
				lastBarTop = lastEventTop;

				ev.bottom = lastEventBottom;
				ev.nextBottom = lastBarBottom;
				lastBarBottom = lastEventBottom;
			} else if (ev.type === 'event') {
				lastEventTop = ev.top;
				lastEventBottom = ev.top + ev.height;
			}
		}
	}

	function makeSortedArray(hash) {
		var arr = [];
		for (var k in hash) {
			if (hash.hasOwnProperty(k))
				arr.push(hash[k]);
		}
		arr = arr.sort(function (a, b) {
			var diff = a.milliseconds - b.milliseconds;
			// if the events have the same time, make sure a bar comes before a note
			if (diff !== 0) {
				return diff;
			}
			else {
				return a.type === "bar" ? -1 : 1;
			}
		});
		return arr;
	}

	this.addElementToEvents = function(eventHash, element, voiceTimeMilliseconds, top, height, line, measureNumber, timeDivider, isTiedState, nextIsBar) {
		if (element.hint)
			return { isTiedState: undefined, duration: 0 };
		var realDuration = element.durationClass ? element.durationClass : element.duration;
		if (element.abcelem.rest && element.abcelem.rest.type === "spacer")
			realDuration = 0;
		if (realDuration > 0) {
			var es = [];
			// If there is an invisible rest, then there are not elements, so don't push a null one.
			for (var i = 0; i < element.elemset.length; i++) {
				if (element.elemset[i] !== null)
					es.push(element.elemset[i]);
			}
			var isTiedToNext = element.startTie;
			if (isTiedState !== undefined) {
				eventHash["event" + isTiedState].elements.push(es); // Add the tied note to the first note that it is tied to
				if (nextIsBar) {
					if (!eventHash["event" + voiceTimeMilliseconds]) {
						eventHash["event" + voiceTimeMilliseconds] = {
							type: "event",
							milliseconds: voiceTimeMilliseconds,
							line: line,
							measureNumber: measureNumber,
							top: top,
							height: height,
							left: null,
							width: 0,
							elements: [],
							startChar: null,
							endChar: null,
							startCharArray: [],
							endCharArray: []
						};
					}
					eventHash["event" + voiceTimeMilliseconds].measureStart = true;
					nextIsBar = false;
				}
				if (!isTiedToNext)
					isTiedState = undefined;
			} else {
				// the last note wasn't tied.
				if (!eventHash["event" + voiceTimeMilliseconds]) {
					eventHash["event" + voiceTimeMilliseconds] = {
						type: "event",
						milliseconds: voiceTimeMilliseconds,
						line: line,
						measureNumber: measureNumber,
						top: top,
						height: height,
						left: element.x,
						width: element.w,
						elements: [es],
						startChar: element.abcelem.startChar,
						endChar: element.abcelem.endChar,
						startCharArray: [element.abcelem.startChar],
						endCharArray: [element.abcelem.endChar],
						midiPitches: element.abcelem.midiPitches ? parseCommon.cloneArray(element.abcelem.midiPitches) : []
					};
					if (element.abcelem.midiGraceNotePitches)
						eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = parseCommon.cloneArray(element.abcelem.midiGraceNotePitches);
				} else {
					// If there is more than one voice then two notes can fall at the same time. Usually they would be lined up in the same place, but if it is a whole rest, then it is placed funny. In any case, the left most element wins.
					if (eventHash["event" + voiceTimeMilliseconds].left)
						eventHash["event" + voiceTimeMilliseconds].left = Math.min(eventHash["event" + voiceTimeMilliseconds].left, element.x);
					else
						eventHash["event" + voiceTimeMilliseconds].left = element.x;
					eventHash["event" + voiceTimeMilliseconds].elements.push(es);
					eventHash["event" + voiceTimeMilliseconds].startCharArray.push(element.abcelem.startChar);
					eventHash["event" + voiceTimeMilliseconds].endCharArray.push(element.abcelem.endChar);
					if (eventHash["event" + voiceTimeMilliseconds].startChar === null)
						eventHash["event" + voiceTimeMilliseconds].startChar =element.abcelem.startChar;
					if (eventHash["event" + voiceTimeMilliseconds].endChar === null)
						eventHash["event" + voiceTimeMilliseconds].endChar =element.abcelem.endChar;
					if (element.abcelem.midiPitches && element.abcelem.midiPitches.length) {
						if (!eventHash["event" + voiceTimeMilliseconds].midiPitches)
							eventHash["event" + voiceTimeMilliseconds].midiPitches = [];
						for (var i = 0; i < element.abcelem.midiPitches.length; i++)
							eventHash["event" + voiceTimeMilliseconds].midiPitches.push(element.abcelem.midiPitches[i]);
					}
					if (element.abcelem.midiGraceNotePitches && element.abcelem.midiGraceNotePitches.length) {
						if (!eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches)
							eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches = [];
						for (var j = 0; j < element.abcelem.midiGraceNotePitches.length; j++)
							eventHash["event" + voiceTimeMilliseconds].midiGraceNotePitches.push(element.abcelem.midiGraceNotePitches[j]);
					}
				}
				if (nextIsBar) {
					eventHash["event" + voiceTimeMilliseconds].measureStart = true;
					nextIsBar = false;
				}
				if (isTiedToNext)
					isTiedState = voiceTimeMilliseconds;
			}
		}
		return { isTiedState: isTiedState, duration: realDuration / timeDivider, nextIsBar: nextIsBar || element.type === 'bar' };
	};

	this.makeVoicesArray = function() {
		// First make a new array that is arranged by voice so that the repeats that span different lines are handled correctly.
		var voicesArr = [];
		for (var line = 0; line < this.engraver.staffgroups.length; line++) {
			var group = this.engraver.staffgroups[line];
			var firstStaff = group.staffs[0];
			var middleC = firstStaff.absoluteY;
			var top = middleC - firstStaff.top * spacing.STEP;
			var lastStaff = group.staffs[group.staffs.length - 1];
			middleC = lastStaff.absoluteY;
			var bottom = middleC - lastStaff.bottom * spacing.STEP;
			var height = bottom - top;

			var voices = group.voices;
			for (var v = 0; v < voices.length; v++) {
				var measureNumber = 0;
				var noteFound = false;
				if (!voicesArr[v])
					voicesArr[v] = [];
				var elements = voices[v].children;
				for (var elem = 0; elem < elements.length; elem++) {
					voicesArr[v].push({top: top, height: height, line: line, measureNumber: measureNumber, elem: elements[elem]});
					if (elements[elem].type === 'bar' && noteFound) // Count the measures by counting the bar lines, but skip a bar line that appears at the left of the music, before any notes.
						measureNumber++;
					if (elements[elem].type === 'note' || elements[elem].type === 'rest')
						noteFound = true;
				}
			}
		}
		return voicesArr;
	};

	this.setupEvents = function(startingDelay, timeDivider, bpm) {
		var timingEvents = [];

		var eventHash = {};
		// The time is the number of seconds from the beginning of the piece.
		// The units we are scanning are in notation units (i.e. 0.25 is a quarter note)
		var time = startingDelay;
		var isTiedState;
		var nextIsBar = true;
		var voices = this.makeVoicesArray();
		for (var v = 0; v < voices.length; v++) {
			var voiceTime = time;
			var voiceTimeMilliseconds = Math.round(voiceTime * 1000);
			var startingRepeatElem = 0;
			var endingRepeatElem = -1;
			var elements = voices[v];
			for (var elem = 0; elem < elements.length; elem++) {
				var element = elements[elem].elem;
				if (element.abcelem.el_type === "tempo") {
					var bpm = this.getBpm(element.abcelem);
					var beatLength = this.getBeatLength();
					var beatsPerSecond = bpm / 60;
					timeDivider = beatLength * beatsPerSecond;
				}
				var ret = this.addElementToEvents(eventHash, element, voiceTimeMilliseconds, elements[elem].top, elements[elem].height, elements[elem].line, elements[elem].measureNumber, timeDivider, isTiedState, nextIsBar);
				isTiedState = ret.isTiedState;
				nextIsBar = ret.nextIsBar;
				voiceTime += ret.duration;
				voiceTimeMilliseconds = Math.round(voiceTime * 1000);
				if (element.type === 'bar') {
					var barType = element.abcelem.type;
					var endRepeat = (barType === "bar_right_repeat" || barType === "bar_dbl_repeat");
					var startEnding = (element.abcelem.startEnding === '1');
					var startRepeat = (barType === "bar_left_repeat" || barType === "bar_dbl_repeat" || barType === "bar_right_repeat");
					if (endRepeat) {
						if (endingRepeatElem === -1)
							endingRepeatElem = elem;
						for (var el2 = startingRepeatElem; el2 < endingRepeatElem; el2++) {
							var element2 = elements[el2].elem;
							ret = this.addElementToEvents(eventHash, element2, voiceTimeMilliseconds, elements[el2].top, elements[el2].height, elements[el2].line, elements[el2].measureNumber, timeDivider, isTiedState, nextIsBar);
							isTiedState = ret.isTiedState;
							nextIsBar = ret.nextIsBar;
							voiceTime += ret.duration;
							voiceTimeMilliseconds = Math.round(voiceTime * 1000);
						}
						nextIsBar = true;
						endingRepeatElem = -1;
					}
					if (startEnding)
						endingRepeatElem = elem;
					if (startRepeat)
						startingRepeatElem = elem;
				}
			}
		}
		// now we have all the events, but if there are multiple voices then there may be events out of order or duplicated, so normalize it.
		timingEvents = makeSortedArray(eventHash);
		addVerticalInfo(timingEvents);
		timingEvents.push({ type: "end", milliseconds: voiceTimeMilliseconds });
		this.addUsefulCallbackInfo(timingEvents, bpm);
		return timingEvents;
	};

	this.addUsefulCallbackInfo = function(timingEvents, bpm) {
		var millisecondsPerMeasure = this.millisecondsPerMeasure(bpm);
		for (var i = 0; i < timingEvents.length; i++) {
			var ev = timingEvents[i];
			ev.millisecondsPerMeasure = millisecondsPerMeasure;
		}
	};

	function getVertical(group) {
		var voices = group.voices;
		var firstStaff = group.staffs[0];
		var middleC = firstStaff.absoluteY;
		var top = middleC - firstStaff.top*spacing.STEP;
		var lastStaff = group.staffs[group.staffs.length-1];
		middleC = lastStaff.absoluteY;
		var bottom = middleC - lastStaff.bottom*spacing.STEP;
		var height = bottom - top;
		return { top: top, height: height };
	}

	this.getBpm = function(tempo) {
		var bpm;
		if (tempo) {
			bpm = tempo.bpm;
			var beatLength = this.getBeatLength();
			var statedBeatLength = tempo.duration && tempo.duration.length > 0 ? tempo.duration[0] : beatLength;
			bpm = bpm * statedBeatLength / beatLength;
		}
		if (!bpm) {
			bpm = 180;
			// Compensate for compound meter, where the beat isn't a beat.
			var meter = this.getMeterFraction();
			if (meter && meter.den === 8) {
				bpm = 120;
			}
		}
		return bpm;
	};

	this.setTiming = function (bpm, measuresOfDelay) {
		if (!bpm) {
			var tempo = this.metaText ? this.metaText.tempo : null;
			bpm = this.getBpm(tempo);
		}

		var beatLength = this.getBeatLength();
		var beatsPerSecond = bpm / 60;

		var measureLength = this.getBarLength();

		var startingDelay = measureLength / beatLength * measuresOfDelay / beatsPerSecond;
		if (startingDelay)
			startingDelay -= this.getPickupLength() / beatLength / beatsPerSecond;
		var timeDivider = beatLength * beatsPerSecond;

		this.noteTimings = this.setupEvents(startingDelay, timeDivider, bpm);
	};
};

module.exports = Tune;


/***/ }),

/***/ "./node_modules/abcjs/src/edit/abc_editor.js":
/*!***************************************************!*\
  !*** ./node_modules/abcjs/src/edit/abc_editor.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// abc_editor.js
// window.ABCJS.Editor is the interface class for the area that contains the ABC text. It is responsible for
// holding the text of the tune and calling the parser and the rendering engines.
//
// EditArea is an example of using a textarea as the control that is shown to the user. As long as
// the same interface is used, window.ABCJS.Editor can use a different type of object.
//
// EditArea:
// - constructor(textareaid)
//		This contains the id of a textarea control that will be used.
// - addSelectionListener(listener)
//		A callback class that contains the entry point fireSelectionChanged()
// - addChangeListener(listener)
//		A callback class that contains the entry point fireChanged()
// - getSelection()
//		returns the object { start: , end: } with the current selection in characters
// - setSelection(start, end)
//		start and end are the character positions that should be selected.
// - getString()
//		returns the ABC text that is currently displayed.
// - setString(str)
//		sets the ABC text that is currently displayed, and resets the initialText variable
// - getElem()
//		returns the textarea element
// - string initialText
//		Contains the starting text. This can be compared against the current text to see if anything changed.
//

/*global document, window, clearTimeout, setTimeout */

var TuneBook = __webpack_require__(/*! ../api/abc_tunebook */ "./node_modules/abcjs/src/api/abc_tunebook.js").TuneBook;
var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var Parse = __webpack_require__(/*! ../parse/abc_parse */ "./node_modules/abcjs/src/parse/abc_parse.js");
var TextPrinter = __webpack_require__(/*! ../transform/abc2abc_write */ "./node_modules/abcjs/src/transform/abc2abc_write.js");
var EngraverController = __webpack_require__(/*! ../write/abc_engraver_controller */ "./node_modules/abcjs/src/write/abc_engraver_controller.js");
var SynthController = __webpack_require__(/*! ../synth/synth-controller */ "./node_modules/abcjs/src/synth/synth-controller.js");
var supportsAudio = __webpack_require__(/*! ../synth/supports-audio */ "./node_modules/abcjs/src/synth/supports-audio.js");

// Polyfill for CustomEvent for old IE versions
if ( typeof window.CustomEvent !== "function" ) {
	var CustomEvent = function(event, params) {
		params = params || {bubbles: false, cancelable: false, detail: undefined};
		var evt = document.createEvent('CustomEvent');
		evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
		return evt;
	};
	CustomEvent.prototype = window.Event.prototype;
	window.CustomEvent = CustomEvent;
}

var EditArea = function(textareaid) {
  this.textarea = document.getElementById(textareaid);
  this.initialText = this.textarea.value;
  this.isDragging = false;
}

EditArea.prototype.addSelectionListener = function(listener) {
  this.textarea.onmousemove = function(ev) {
	  if (this.isDragging)
	    listener.fireSelectionChanged();
  };
};

EditArea.prototype.addChangeListener = function(listener) {
  this.changelistener = listener;
  this.textarea.onkeyup = function() {
    listener.fireChanged();
  };
  this.textarea.onmousedown = function() {
	this.isDragging = true;
    listener.fireSelectionChanged();
  };
  this.textarea.onmouseup = function() {
	this.isDragging = false;
    listener.fireChanged();
  };
  this.textarea.onchange = function() {
    listener.fireChanged();
  };
};

//TODO won't work under IE?
EditArea.prototype.getSelection = function() {
  return {start: this.textarea.selectionStart, end: this.textarea.selectionEnd};
};

EditArea.prototype.setSelection = function(start, end) {
	if(this.textarea.setSelectionRange)
	   this.textarea.setSelectionRange(start, end);
	else if(this.textarea.createTextRange) {
		// For IE8
	   var e = this.textarea.createTextRange();
	   e.collapse(true);
	   e.moveEnd('character', end);
	   e.moveStart('character', start);
	   e.select();
	}
  this.textarea.focus();
};

EditArea.prototype.getString = function() {
  return this.textarea.value;
};

EditArea.prototype.setString = function(str) {
  this.textarea.value = str;
  this.initialText = this.getString();
  if (this.changelistener) {
    this.changelistener.fireChanged();
  }
};

EditArea.prototype.getElem = function() {
  return this.textarea;
};

//
// window.ABCJS.Editor:
//
// constructor(editarea, params)
//		if editarea is a string, then it is an HTML id of a textarea control.
//		Otherwise, it should be an instantiation of an object that expresses the EditArea interface.
//
//		params is a hash of:
//		canvas_id: or paper_id: HTML id to draw in. If not present, then the drawing happens just below the editor.
//		generate_midi: if present, then midi is generated.
//		midi_id: if present, the HTML id to place the midi control. Otherwise it is placed in the same div as the paper.
//		midi_download_id: if present, the HTML id to place the midi download link. Otherwise it is placed in the same div as the paper.
//		generate_warnings: if present, then parser warnings are displayed on the page.
//		warnings_id: if present, the HTML id to place the warnings. Otherwise they are placed in the same div as the paper.
//		onchange: if present, the callback function to call whenever there has been a change.
//		gui: if present, the paper can send changes back to the editor (presumably because the user changed something directly.)
//		parser_options: options to send to the parser engine.
//		midi_options: options to send to the midi engine.
//		render_options: options to send to the render engine.
//		indicate_changed: the dirty flag is set if this is true.
//
// - setReadOnly(bool)
//		adds or removes the class abc_textarea_readonly, and adds or removes the attribute readonly=yes
// - setDirtyStyle(bool)
//		adds or removes the class abc_textarea_dirty
// - renderTune(abc, parserparams, div)
//		Immediately renders the tune. (Useful for creating the SVG output behind the scenes, if div is hidden)
//		string abc: the ABC text
//		parserparams: params to send to the parser
//		div: the HTML id to render to.
// - modelChanged()
//		Called when the model has been changed to trigger re-rendering
// - parseABC()
//		Called internally by fireChanged()
//		returns true if there has been a change since last call.
// - updateSelection()
//		Called when the user has changed the selection. This calls the engraver_controller to show the selection.
// - fireSelectionChanged()
//		Called by the textarea object when the user has changed the selection.
// - paramChanged(engraverparams)
//		Called to signal that the engraver params have changed, so re-rendering should occur.
// - fireChanged()
//		Called by the textarea object when the user has changed something.
// - setNotDirty()
//		Called by the client app to reset the dirty flag
// - isDirty()
//		Returns true or false, whether the textarea contains the same text that it started with.
// - highlight(abcelem)
//		Called by the engraver_controller to highlight an area.
// - pause(bool)
//		Stops the automatic rendering when the user is typing.
//

var Editor = function(editarea, params) {
	// Copy all the options that will be passed through
	this.abcjsParams = {};
	var key;
	if (params.abcjsParams) {
		for (key in params.abcjsParams) {
			if (params.abcjsParams.hasOwnProperty(key)) {
				this.abcjsParams[key] = params.abcjsParams[key];
			}
		}
	}
	if (params.midi_options) {
		for (key in params.midi_options) {
			if (params.midi_options.hasOwnProperty(key)) {
				this.abcjsParams[key] = params.midi_options[key];
			}
		}
	}
	if (params.parser_options) {
		for (key in params.parser_options) {
			if (params.parser_options.hasOwnProperty(key)) {
				this.abcjsParams[key] = params.parser_options[key];
			}
		}
	}
	if (params.render_options) {
		for (key in params.render_options) {
			if (params.render_options.hasOwnProperty(key)) {
				this.abcjsParams[key] = params.render_options[key];
			}
		}
	}

	if (params.indicate_changed)
		this.indicate_changed = true;
  if (typeof editarea === "string") {
    this.editarea = new EditArea(editarea);
  } else {
    this.editarea = editarea;
  }
  this.editarea.addSelectionListener(this);
  this.editarea.addChangeListener(this);

  if (params.canvas_id) {
    this.div = document.getElementById(params.canvas_id);
  } else if (params.paper_id) {
    this.div = document.getElementById(params.paper_id);
  } else {
    this.div = document.createElement("DIV");
    this.editarea.getElem().parentNode.insertBefore(this.div, this.editarea.getElem());
  }

  if (params.selectionChangeCallback) {
  	this.selectionChangeCallback = params.selectionChangeCallback;
  }

  if (params.synth) {
  	if (supportsAudio()) {
	    this.synth = {
		    el: params.synth.el,
		    cursorControl: params.synth.cursorControl,
		    options: params.synth.options
	    }
    }
  }
	// If the user wants midi, then store the elements that it will be written to. The element could either be passed in as an id,
	// an element, or nothing. If nothing is passed in, then just put the midi on top of the generated music.
	if (params.generate_midi) {
	  	this.generate_midi = params.generate_midi;
		if (this.abcjsParams.generateDownload) {
			if (typeof params.midi_download_id === 'string')
				this.downloadMidi = document.getElementById(params.midi_download_id);
			else if (params.midi_download_id) // assume, if the var is not a string it is an element. If not, it will crash soon enough.
				this.downloadMidi = params.midi_download_id;
		}
		if (this.abcjsParams.generateInline !== false) { // The default for this is true, so undefined is also true.
			if (typeof params.midi_id === 'string')
				this.inlineMidi = document.getElementById(params.midi_id);
			else if (params.midi_id) // assume, if the var is not a string it is an element. If not, it will crash soon enough.
				this.inlineMidi = params.midi_id;
		}
	}

  if (params.generate_warnings || params.warnings_id) {
    if (params.warnings_id) {
      this.warningsdiv = document.getElementById(params.warnings_id);
    } else {
      this.warningsdiv = this.div;
    }
  }

  this.onchangeCallback = params.onchange;

  if (params.gui) {
    this.target = document.getElementById(editarea);
    this.abcjsParams.editable = true;
  }
  this.oldt = "";
  this.bReentry = false;
  this.parseABC();
  this.modelChanged();

  this.addClassName = function(element, className) {
    var hasClassName = function(element, className) {
      var elementClassName = element.className;
      return (elementClassName.length > 0 && (elementClassName === className ||
        new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
    };

    if (!hasClassName(element, className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  };

  this.removeClassName = function(element, className) {
    element.className = parseCommon.strip(element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' '));
    return element;
  };

  this.setReadOnly = function(readOnly) {
	  var readonlyClass = 'abc_textarea_readonly';
	  var el = this.editarea.getElem();
    if (readOnly) {
      el.setAttribute('readonly', 'yes');
	  this.addClassName(el, readonlyClass);
	} else {
      el.removeAttribute('readonly');
	  this.removeClassName(el, readonlyClass);
    }
  };
};

Editor.prototype.renderTune = function(abc, params, div) {
  var tunebook = new TuneBook(abc);
  var abcParser = Parse();
  abcParser.parse(tunebook.tunes[0].abc, params, tunebook.tunes[0].startPos - tunebook.header.length); //TODO handle multiple tunes
  var tune = abcParser.getTune();
  var engraver_controller = new EngraverController(div, this.abcjsParams);
  engraver_controller.engraveABC(tune);
};

Editor.prototype.redrawMidi = function() {
	if (this.generate_midi && !this.midiPause) {
		var event = new window.CustomEvent("generateMidi", {
			detail: {
				tunes: this.tunes,
				abcjsParams: this.abcjsParams,
				downloadMidiEl: this.downloadMidi,
				inlineMidiEl: this.inlineMidi,
				engravingEl: this.div
			}
		});
		window.dispatchEvent(event);
	}
	if (this.synth) {
		if (!this.synth.synthControl) {
			this.synth.synthControl = new SynthController();
			this.synth.synthControl.load(this.synth.el, this.synth.cursorControl, this.synth.options);
		}
		this.synth.synthControl.setTune(this.tunes[0], false);
	}
};

Editor.prototype.modelChanged = function() {
  if (this.tunes === undefined) {
    if (this.downloadMidi !== undefined)
		this.downloadMidi.innerHTML = "";
    if (this.inlineMidi !== undefined)
		this.inlineMidi.innerHTML = "";
    this.div.innerHTML = "";
	return;
  }

  if (this.bReentry)
    return; // TODO is this likely? maybe, if we rewrite abc immediately w/ abc2abc
  this.bReentry = true;
  this.timerId = null;
  this.div.innerHTML = "";
  this.engraver_controller = new EngraverController(this.div, this.abcjsParams);
  this.engraver_controller.engraveABC(this.tunes);
	this.tunes[0].engraver = this.engraver_controller;	// TODO-PER: We actually want an output object for each tune, not the entire controller. When refactoring, don't save data in the controller.
	this.redrawMidi();

  if (this.warningsdiv) {
    this.warningsdiv.innerHTML = (this.warnings) ? this.warnings.join("<br />") : "No errors";
  }
  if (this.target) {
    var textprinter = new TextPrinter(this.target, true);
    textprinter.printABC(this.tunes[0]); //TODO handle multiple tunes
  }
  this.engraver_controller.addSelectListener(this.highlight.bind(this));
  this.updateSelection();
  this.bReentry = false;
};

// Call this to reparse in response to the printing parameters changing
Editor.prototype.paramChanged = function(engraverParams) {
	if (engraverParams) {
		for (var key in engraverParams) {
			if (engraverParams.hasOwnProperty(key)) {
				this.abcjsParams[key] = engraverParams[key];
			}
		}
	}
	this.oldt = "";
	this.fireChanged();
};

// return true if the model has changed
Editor.prototype.parseABC = function() {
  var t = this.editarea.getString();
  if (t===this.oldt) {
    this.updateSelection();
    return false;
  }

  this.oldt = t;
  if (t === "") {
	this.tunes = undefined;
	this.warnings = "";
	return true;
  }
  var tunebook = new TuneBook(t);

  this.tunes = [];
  this.startPos = [];
  this.warnings = [];
  for (var i=0; i<tunebook.tunes.length; i++) {
    var abcParser = new Parse();
    abcParser.parse(tunebook.tunes[i].abc, this.abcjsParams, tunebook.tunes[i].startPos - tunebook.header.length);
    this.tunes[i] = abcParser.getTune();
	  this.startPos[i] = tunebook.tunes[i].startPos;
    var warnings = abcParser.getWarnings() || [];
    for (var j=0; j<warnings.length; j++) {
      this.warnings.push(warnings[j]);
    }
  }
  return true;
};

Editor.prototype.updateSelection = function() {
  var selection = this.editarea.getSelection();
  try {
    this.engraver_controller.rangeHighlight(selection.start, selection.end);
  } catch (e) {} // maybe printer isn't defined yet?
	if (this.selectionChangeCallback)
		this.selectionChangeCallback(selection.start, selection.end);
};

Editor.prototype.fireSelectionChanged = function() {
  this.updateSelection();
};

Editor.prototype.setDirtyStyle = function(isDirty) {
	if (this.indicate_changed === undefined)
		return;
  var addClassName = function(element, className) {
    var hasClassName = function(element, className) {
      var elementClassName = element.className;
      return (elementClassName.length > 0 && (elementClassName === className ||
        new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
    };

    if (!hasClassName(element, className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  };

  var removeClassName = function(element, className) {
    element.className = parseCommon.strip(element.className.replace(
      new RegExp("(^|\\s+)" + className + "(\\s+|$)"), ' '));
    return element;
  };

	var readonlyClass = 'abc_textarea_dirty';
	var el = this.editarea.getElem();
	if (isDirty) {
		addClassName(el, readonlyClass);
	} else {
		removeClassName(el, readonlyClass);
    }
};

// call when abc text is changed and needs re-parsing
Editor.prototype.fireChanged = function() {
  if (this.bIsPaused)
    return;
  if (this.parseABC()) {
    var self = this;
    if (this.timerId)	// If the user is still typing, cancel the update
      clearTimeout(this.timerId);
    this.timerId = setTimeout(function () {
      self.modelChanged();
    }, 300);	// Is this a good compromise between responsiveness and not redrawing too much?
	  var isDirty = this.isDirty();
	  if (this.wasDirty !== isDirty) {
		  this.wasDirty = isDirty;
		  this.setDirtyStyle(isDirty);
	  }
	  if (this.onchangeCallback)
		  this.onchangeCallback(this);
	  }
};

Editor.prototype.setNotDirty = function() {
	this.editarea.initialText = this.editarea.getString();
	this.wasDirty = false;
	this.setDirtyStyle(false);
};

Editor.prototype.isDirty = function() {
	if (this.indicate_changed === undefined)
		return false;
	return this.editarea.initialText !== this.editarea.getString();
};

Editor.prototype.highlight = function(abcelem, tuneNumber, classes) {
	// TODO-PER: The marker appears to get off by one for each tune parsed. I'm not sure why, but adding the tuneNumber in corrects it for the time being.
//	var offset = (tuneNumber !== undefined) ? this.startPos[tuneNumber] + tuneNumber : 0;

  this.editarea.setSelection(abcelem.startChar, abcelem.endChar);
	if (this.selectionChangeCallback)
		this.selectionChangeCallback(abcelem.startChar, abcelem.endChar);
};

Editor.prototype.pause = function(shouldPause) {
	this.bIsPaused = shouldPause;
	if (!shouldPause)
		this.fireChanged();
};

Editor.prototype.millisecondsPerMeasure = function() {
	return this.synth.synthControl.visualObj.millisecondsPerMeasure();
};

Editor.prototype.pauseMidi = function(shouldPause) {
	this.midiPause = shouldPause;
	if (!shouldPause)
		this.redrawMidi();
};

module.exports = Editor;


/***/ }),

/***/ "./node_modules/abcjs/src/midi/abc_midi_flattener.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/midi/abc_midi_flattener.js ***!
  \***********************************************************/
/***/ (function(module) {

//    abc_midi_flattener.js: Turn a linear series of events into a series of MIDI commands.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// We input a set of voices, but the notes are still complex. This pass changes the logical definitions
// of the grace notes, decorations, ties, triplets, rests, transpositions, keys, and accidentals into actual note durations.
// It also extracts guitar chords to a separate voice and resolves their rhythm.

var flatten;

(function() {
	"use strict";

	var barAccidentals;
	var accidentals;
	var transpose;
	var bagpipes;
	var multiplier;
	var tracks;
	var startingTempo;
	var startingMeter;
	var tempoChangeFactor = 1;
	var instrument;
	var currentInstrument;
	// var channel;
	var currentTrack;
	var pitchesTied;
	var lastNoteDurationPosition;
	var currentTrackCounter;

	var meter = { num: 4, den: 4 };
	var chordTrack;
	var chordTrackFinished;
	var chordChannel;
	var chordInstrument = 0;
	var drumInstrument = 128;
	var currentChords;
	var lastChord;
	var barBeat;
	var gChordTacet = false;
	var doBeatAccents = true;
	var stressBeat1 = 105;
	var stressBeatDown = 95;
	var stressBeatUp = 85;
	var beatFraction = 0.25;
	var nextVolume;
	var nextVolumeDelta;

	var drumTrack;
	var drumTrackFinished;
	var drumDefinition = {};

	var normalBreakBetweenNotes = 1.0/128;	// a 128th note of silence between notes for articulation.

	flatten = function(voices, options) {
		if (!options) options = {};
		barAccidentals = [];
		accidentals = [0,0,0,0,0,0,0];
		bagpipes = false;
		multiplier = 1;
		tracks = [];
		startingTempo = undefined;
		startingMeter = undefined;
		tempoChangeFactor = 1;
		instrument = undefined;
		currentInstrument = undefined;
		// channel = undefined;
		currentTrack = undefined;
		currentTrackCounter = undefined;
		pitchesTied = {};

		// For resolving chords.
		meter = { num: 4, den: 4 };
		chordTrack = [];
		chordChannel = voices.length; // first free channel for chords
		chordTrackFinished = false;
		currentChords = [];
		lastChord = undefined;
		barBeat = 0;
		gChordTacet = options.chordsOff ? true : false;

		doBeatAccents = true;
		stressBeat1 = 105;
		stressBeatDown = 95;
		stressBeatUp = 85;
		beatFraction = 0.25;
		nextVolume = undefined;
		nextVolumeDelta = undefined;

		// For the drum/metronome track.
		drumTrack = [];
		drumTrackFinished = false;
		drumDefinition = {};

		zeroOutMilliseconds(voices);

		for (var i = 0; i < voices.length; i++) {
			transpose = 0;
			lastNoteDurationPosition = -1;
			var voice = voices[i];
			currentTrack = [{ cmd: 'program', channel: i, instrument: instrument }];
			currentTrackCounter = 0;
			pitchesTied = {};
			for (var j = 0; j < voice.length; j++) {
				var element = voice[j];
				switch (element.el_type) {
					case "note":
						writeNote(element, options.voicesOff);
						break;
					case "key":
						accidentals = setKeySignature(element);
						break;
					case "meter":
						if (!startingMeter)
							startingMeter = element;
						meter = element;
						beatFraction = getBeatFraction(meter);
						break;
					case "tempo":
						if (!startingTempo)
							startingTempo = element.qpm;
						else
							tempoChangeFactor = element.qpm ? startingTempo / element.qpm : 1;
						break;
					case "transpose":
						transpose = element.transpose;
						break;
					case "bar":
						if (chordTrack.length > 0 && i === 0) {
							resolveChords();
							currentChords = [];
						}
						barBeat = 0;
						barAccidentals = [];
						if (i === 0) // Only write the drum part on the first voice so that it is not duplicated.
							writeDrum(voices.length+1);
						break;
					case "bagpipes":
						bagpipes = true;
						break;
					case "instrument":
						if (instrument === undefined)
							instrument = element.program;
						currentInstrument = element.program;
						if (currentTrack.length > 0 && currentTrack[currentTrack.length-1].cmd === 'program')
							currentTrack[currentTrack.length-1].instrument = element.program;
						else {
							var ii;
							for (ii = currentTrack.length-1; ii >= 0 && currentTrack[ii].cmd !== 'program'; ii--)
								;
							if (ii < 0 || currentTrack[ii].instrument !== element.program)
								currentTrack.push({cmd: 'program', channel: i, instrument: element.program});
						}
						break;
					case "channel":
					// 	if (channel === undefined)
					// 		channel = element.channel;
					// 	currentTrack[0].channel = element.channel;
						break;
					case "drum":
						drumDefinition = normalizeDrumDefinition(element.params);
						break;
					case "gchord":
						if (!options.chordsOff)
							gChordTacet = element.tacet;
						break;
					case "beat":
						stressBeat1 = element.beats[0];
						stressBeatDown = element.beats[1];
						stressBeatUp = element.beats[2];
						// TODO-PER: also use the last parameter - which changes which beats are strong.
						break;
					case "vol":
						nextVolume = element.volume;
						break;
					case "volinc":
						nextVolumeDelta = element.volume;
						break;
					case "beataccents":
						doBeatAccents = element.value;
						break;
					default:
						// This should never happen
						console.log("MIDI creation. Unknown el_type: " + element.el_type + "\n");// jshint ignore:line
						break;
				}
			}
			if (currentTrack[0].instrument === undefined)
				currentTrack[0].instrument = instrument ? instrument : 0;
			tracks.push(currentTrack);
			if (chordTrack.length > 0) // Don't do chords on more than one track, so turn off chord detection after we create it.
				chordTrackFinished = true;
			if (drumTrack.length > 0) // Don't do drums on more than one track, so turn off drum after we create it.
				drumTrackFinished = true;
		}
		if (chordTrack.length > 0)
			tracks.push(chordTrack);
		if (drumTrack.length > 0)
			tracks.push(drumTrack);
		// Adjust the tempo according to the meter. The rules are this:
		// 1) If the denominator is 2 or 4, then always make a beat be the denominator.
		//
		// 2) If the denominator is 8 or 16, then:
		// a) If the numerator is divisible by 3, the beat is 3*denominator.
		// b) Otherwise the beat is the denominator.
		//
		// 3) If the denominator is anything else, then don't worry about it because it doesn't make sense. Don't modify it and hope for the best.
		//
		// Right now, the startingTempo is calculated for a quarter note, so modify it if necessary.
		// var num = startingMeter ? parseInt(startingMeter.num, 10) : meter.num;
		// var den = startingMeter ? parseInt(startingMeter.den, 10) : meter.den;
		// if (den === 2)
		// 	startingTempo *= 2;
		// else if (den === 8) {
		// 	if (parseInt(num, 10) % 3 === 0)
		// 		startingTempo *= 3/2;
		// 	else
		// 		startingTempo /= 2;
		// } else if (den === 16) {
		// 	if (num % 3 === 0)
		// 		startingTempo *= 3/4;
		// 	else
		// 		startingTempo /= 4;
		// }

		return { tempo: startingTempo, instrument: instrument, tracks: tracks, totalDuration: totalDuration(tracks) };
	};

	function zeroOutMilliseconds(voices) {
		for (var i = 0; i < voices.length; i++) {
			var voice = voices[i];
			for (var j = 0; j < voice.length; j++) {
				var element = voice[j];
				delete element.currentTrackMilliseconds;
			}
		}
	}

	function totalDuration(tracks) {
		var total = 0;
		for (var i = 0; i < tracks.length; i++) {
			var track = tracks[i];
			var trackTotal = 0;
			for (var j = 0; j < track.length; j++) {
				var event = track[j];
				if (event.duration)
					trackTotal += event.duration;
			}
			total = Math.max(total, trackTotal);
		}
		return total;
	}

	function getBeatFraction(meter) {
		switch (meter.den) {
			case 2: return 0.5;
			case 4: return 0.25;
			case 8: return 0.375;
			case 16: return 0.125;
		}
		return 0.25;
	}
	//
	// The algorithm for chords is:
	// - The chords are done in a separate track.
	// - If there are notes before the first chord, then put that much silence to start the track.
	// - The pattern of chord expression depends on the meter, and how many chords are in a measure.
	// - There is a possibility that a measure will have an incorrect number of beats, if that is the case, then
	// start the pattern anew on the next measure number.
	// - If a chord root is not A-G, then ignore it as if the chord wasn't there at all.
	// - If a chord modification isn't in our supported list, change it to a major triad.
	//
	// - If there is only one chord in a measure:
	//		- If 2/4, play root chord
	//		- If cut time, play root(1) chord(3)
	//		- If 3/4, play root chord chord
	//		- If 4/4 or common time, play root chord fifth chord
	//		- If 6/8, play root(1) chord(3) fifth(4) chord(6)
	//		- For any other meter, play the full chord on each beat. (TODO-PER: expand this as more support is added.)
	//
	//	- If there is a chord specified that is not on a beat, move it earlier to the previous beat, unless there is already a chord on that beat.
	//	- Otherwise, move it later, unless there is already a chord on that beat.
	// 	- Otherwise, ignore it. (TODO-PER: expand this as more support is added.)
	//
	// - If there is a chord on the second beat, play a chord for the first beat instead of a bass note.
	// - Likewise, if there is a chord on the fourth beat of 4/4, play a chord on the third beat instead of a bass note.
	//
	var breakSynonyms = [ 'break', '(break)', 'no chord', 'n.c.', 'tacet'];

	function findChord(elem) {
		if (gChordTacet)
			return 'break';

		// TODO-PER: Just using the first chord if there are more than one.
		if (chordTrackFinished || !elem.chord || elem.chord.length === 0)
			return null;

		// Return the first annotation that is a regular chord: that is, it is in the default place or is a recognized "tacet" phrase.
		for (var i = 0; i < elem.chord.length; i++) {
			var ch = elem.chord[i];
			if (ch.position === 'default')
				return ch.name;
			if (breakSynonyms.indexOf(ch.name.toLowerCase()) >= 0)
				return 'break';
		}
		return null;
	}

	function timeFromStart() {
		var distance = 0;
		for (var ct = 0; ct < currentTrack.length; ct++) {
			if (currentTrack[ct].cmd === 'move')
				distance += currentTrack[ct].duration;
		}
		return distance;
	}

	function writeNote(elem, voiceOff) {
		//
		// Create a series of note events to append to the current track.
		// The output event is one of: { pitchStart: pitch_in_abc_units, volume: from_1_to_64 }
		// { pitchStop: pitch_in_abc_units }
		// { moveTime: duration_in_abc_units }
		// If there are guitar chords, then they are put in a separate track, but they have the same format.
		//

		var volume;
		if (nextVolume) {
			volume = nextVolume;
			nextVolume = undefined;
		} else if (!doBeatAccents) {
			volume = stressBeatDown;
		} else {
			if (barBeat === 0)
				volume = stressBeat1;
			else if (barBeat % beatFraction < 0.001) // A little slop because of JavaScript floating point math.
				volume = stressBeatDown;
			else
				volume = stressBeatUp;
		}
		if (nextVolumeDelta) {
			volume += nextVolumeDelta;
			nextVolumeDelta = undefined;
		}
		if (volume < 0)
			volume = 0;
		if (volume > 127)
			volume = 127;
		var velocity = voiceOff ? 0 : volume;
		var chord = findChord(elem);
		if (chord) {
			var c = interpretChord(chord);
			// If this isn't a recognized chord, just completely ignore it.
			if (c) {
				// If we ever have a chord in this voice, then we add the chord track.
				// However, if there are chords on more than one voice, then just use the first voice.
				if (chordTrack.length === 0) {
					chordTrack.push({cmd: 'program', channel: chordChannel, instrument: chordInstrument});
					// need to figure out how far in time the chord started: if there are pickup notes before the chords start, we need pauses.
					var distance = timeFromStart();
					if (distance > 0)
						chordTrack.push({cmd: 'move', duration: distance*tempoChangeFactor });
				}

				lastChord = c;
				currentChords.push({chord: lastChord, beat: barBeat});
			}
		}

		if (elem.startTriplet) {
			multiplier = elem.tripletMultiplier;
		}

		var duration = (elem.durationClass ? elem.durationClass : elem.duration) *multiplier;
		barBeat += duration;

		// if there are grace notes, then also play them.
		// I'm not sure there is an exact rule for the length of the notes. My rule, unless I find
		// a better one is: the grace notes cannot take more than 1/2 of the main note's value.
		// A grace note (of 1/8 note duration) takes 1/8 of the main note's value.
		var graces;
		if (elem.gracenotes) {
			// There are two cases: if this is bagpipe, the grace notes are played on the beat with the current note.
			// Normally, the grace notes would be played before the beat. (If this is the first note in the track, however, then it is played on the current beat.)
			// The reason for the exception on the first note is that it would otherwise move the whole track in time and would affect all the other tracks.
			var stealFromCurrent = (bagpipes || lastNoteDurationPosition < 0 || currentTrack.length === 0);
			var stealFromDuration = stealFromCurrent ? duration : currentTrack[lastNoteDurationPosition].duration;
			graces = processGraceNotes(elem.gracenotes, stealFromDuration);
			if (!bagpipes) {
				duration = writeGraceNotes(graces, stealFromCurrent, duration, null, velocity);
			}
		}

		// The currentTrackCounter is the number of whole notes from the beginning of the piece.
		// The beat fraction is the note that gets a beat (.25 is a quarter note)
		// The tempo is in minutes and we want to get to milliseconds.
		if (!elem.currentTrackMilliseconds)
			elem.currentTrackMilliseconds = [];
		elem.currentTrackMilliseconds.push(currentTrackCounter / beatFraction / startingTempo * 60*1000);
		if (elem.pitches) {
			if (graces && bagpipes) {
				// If it is bagpipes, then the graces are played with the note. If the grace has the same pitch as the note, then we just skip it.
				duration = writeGraceNotes(graces, true, duration, null, velocity);
			}
			var pitches = [];
			elem.midiPitches = [];
			for (var i=0; i<elem.pitches.length; i++) {
				var note = elem.pitches[i];
				var actualPitch = adjustPitch(note);
				pitches.push({ pitch: actualPitch, startTie: note.startTie });
				elem.midiPitches.push({ pitch: actualPitch+60, durationInMeasures: duration*tempoChangeFactor, volume: volume, instrument: currentInstrument }); // TODO-PER: why is the internal numbering system offset by 60 from midi? It should probably be the same as midi.

				if (!pitchesTied[''+actualPitch])	// If this is the second note of a tie, we don't start it again.
					currentTrack.push({ cmd: 'start', pitch: actualPitch, volume: velocity });
				else {
					// but we do add the duration to what we call back.
					for (var last = currentTrack.length-1; last >= 0; last--) {
						if (currentTrack[last].cmd === 'start' && currentTrack[last].pitch === actualPitch && currentTrack[last].elem) {
							var pitchArray = currentTrack[last].elem.midiPitches;
							for (var last2 = 0; last2 < pitchArray.length; last2++) {
								if (pitchArray[last2].pitch-60 === actualPitch) { // TODO-PER: the 60 is to compensate for the midi pitch numbers again.
									pitchArray[last2].durationInMeasures += duration * tempoChangeFactor;
								}
							}
							break;
						}
					}
				}

				if (note.startTie) {
					pitchesTied['' + actualPitch] = true;
					currentTrack[currentTrack.length-1].elem = elem;
				} else if (note.endTie)
					pitchesTied[''+actualPitch] = false;
			}
			if (elem.gracenotes) {
				for (var j = 0; j < elem.gracenotes.length; j++) {
					elem.midiGraceNotePitches = [];
					var grace = elem.gracenotes[j];
					elem.midiGraceNotePitches.push({ pitch: adjustPitch(grace)+60, durationInMeasures: 0, volume: volume, instrument: currentInstrument});
				}
			}
			var thisBreakBetweenNotes = normalBreakBetweenNotes;
			var soundDuration = duration-normalBreakBetweenNotes;
			if (soundDuration < 0) {
				soundDuration = 0;
				thisBreakBetweenNotes = 0;
			}
			currentTrack.push({ cmd: 'move', duration: soundDuration*tempoChangeFactor });
			lastNoteDurationPosition = currentTrack.length-1;
			currentTrackCounter += soundDuration*tempoChangeFactor;

			for (var ii = 0; ii < pitches.length; ii++) {
				if (!pitchesTied[''+pitches[ii].pitch])
					currentTrack.push({ cmd: 'stop', pitch: pitches[ii].pitch });
			}
			currentTrack.push({ cmd: 'move', duration: thisBreakBetweenNotes*tempoChangeFactor });
			currentTrackCounter += thisBreakBetweenNotes*tempoChangeFactor;
		} else if (elem.rest) {
			currentTrack.push({ cmd: 'move', duration: duration*tempoChangeFactor });
			currentTrackCounter += duration*tempoChangeFactor;
		}

		if (elem.endTriplet) {
			multiplier=1;
		}
	}

	var scale = [0,2,4,5,7,9,11];
	function adjustPitch(note) {
		if (note.midipitch)
			return note.midipitch - 60;
		var pitch = note.pitch;
		if (note.accidental) {
			switch(note.accidental) { // change that pitch (not other octaves) for the rest of the bar
				case "sharp":
					barAccidentals[pitch]=1; break;
				case "flat":
					barAccidentals[pitch]=-1; break;
				case "natural":
					barAccidentals[pitch]=0; break;
				case "dblsharp":
					barAccidentals[pitch]=2; break;
				case "dblflat":
					barAccidentals[pitch]=-2; break;
			}
		}

		var actualPitch = extractOctave(pitch) *12 + scale[extractNote(pitch)];

		if ( barAccidentals[pitch]!==undefined) {
			actualPitch +=  barAccidentals[pitch];
		} else { // use normal accidentals
			actualPitch +=  accidentals[extractNote(pitch)];
		}
		actualPitch += transpose;
		return actualPitch;
	}

	function setKeySignature(elem) {
		var accidentals = [0,0,0,0,0,0,0];
		if (!elem.accidentals) return accidentals;
		for (var i = 0; i < elem.accidentals.length; i++) {
			var acc = elem.accidentals[i];
			var d = (acc.acc === "sharp") ? 1 : (acc.acc === "natural") ?0 : -1;

			var lowercase = acc.note.toLowerCase();
			var note = extractNote(lowercase.charCodeAt(0)-'c'.charCodeAt(0));
			accidentals[note]+=d;
		}
		return accidentals;
	}

	var graceDivider = 8; // This is the fraction of a note that the grace represents. That is, if this is 2, then a grace note of 1/16 would be a 1/32.
	function processGraceNotes(graces, companionDuration) {
		var graceDuration = 0;
		var ret = [];
		var grace;
		for (var g = 0; g < graces.length; g++) {
			grace = graces[g];
			graceDuration += grace.duration;
		}
		graceDuration = graceDuration / graceDivider;
		var multiplier = (graceDuration * 2 > companionDuration) ? companionDuration/(graceDuration * 2) : 1;

		for (g = 0; g < graces.length; g++) {
			grace = graces[g];
			var pitch = grace.midipitch ? grace.midipitch - 60 : grace.pitch;
			ret.push({ pitch: pitch, duration: grace.duration/graceDivider*multiplier });
		}
		return ret;
	}

	function writeGraceNotes(graces, stealFromCurrent, duration, skipNote, velocity) {
		for (var g = 0; g < graces.length; g++) {
			var gp = graces[g];
			if (gp !== skipNote)
				currentTrack.push({cmd: 'start', pitch: gp.pitch, volume: velocity});
			currentTrack.push({cmd: 'move', duration: graces[g].duration*tempoChangeFactor });
			if (gp !== skipNote)
				currentTrack.push({cmd: 'stop', pitch: gp.pitch});
			if (!stealFromCurrent)
				currentTrack[lastNoteDurationPosition].duration -= graces[g].duration;
			duration -= graces[g].duration;
		}
		return duration;
	}

	function extractOctave(pitch) {
		return Math.floor(pitch/7);
	}

	function extractNote(pitch) {
		pitch = pitch%7;
		if (pitch<0) pitch+=7;
		return pitch;
	}

	var basses = {
		'A': -27, 'B': -25, 'C': -24, 'D': -22, 'E': -20, 'F': -19, 'G': -17
	};
	function interpretChord(name) {
		// chords have the format:
		// [root][acc][modifier][/][bass][acc]
		// (The chord might be surrounded by parens. Just ignore them.)
		// root must be present and must be from A-G.
		// acc is optional and can be # or b
		// The modifier can be a wide variety of things, like "maj7". As they are discovered, more are supported here.
		// If there is a slash, then there is a bass note, which can be from A-G, with an optional acc.
		// If the root is unrecognized, then "undefined" is returned and there is no chord.
		// If the modifier is unrecognized, a major triad is returned.
		// If the bass notes is unrecognized, it is ignored.
		if (name.length === 0)
			return undefined;
		if (name === 'break')
			return { chick: []};
		var root = name.substring(0,1);
		if (root === '(') {
			name = name.substring(1,name.length-2);
			if (name.length === 0)
				return undefined;
			root = name.substring(0,1);
		}
		var bass = basses[root];
		if (!bass)	// If the bass note isn't listed, then this was an unknown root. Only A-G are accepted.
			return undefined;
		bass  += transpose;
		var bass2 = bass - 5;	// The alternating bass is a 4th below
		var chick;
		if (name.length === 1)
			chick = chordNotes(bass, '');
		var remaining = name.substring(1);
		var acc = remaining.substring(0,1);
		if (acc === 'b' || acc === '') {
			bass--;
			bass2--;
			remaining = remaining.substring(1);
		} else if (acc === '#' || acc === '') {
			bass++;
			bass2++;
			remaining = remaining.substring(1);
		}
		var arr = remaining.split('/');
		chick = chordNotes(bass, arr[0]);
		if (arr.length === 2) {
			var explicitBass = basses[arr[1].substring(0,1)];
			if (explicitBass) {
				var bassAcc = arr[1].substring(1);
				var bassShift = {'#': 1, '': 1, 'b': -1, '': -1}[bassAcc] || 0;
				bass = basses[arr[1].substring(0,1)] + bassShift + transpose;
				bass2 = bass;
			}
		}
		return { boom: bass, boom2: bass2, chick: chick };
	}

	var chordIntervals = {
		// diminished (all flat 5 chords)
		'dim': [ 0, 3, 6 ],
		'': [ 0, 3, 6 ],
		'': [ 0, 3, 6 ],

		'dim7': [ 0, 3, 6, 9 ],
		'7': [ 0, 3, 6, 9 ],
		'7': [ 0, 3, 6, 9 ],

		'7': [ 0, 3, 6, 10 ],
		'm7(b5)': [ 0, 3, 6, 10 ],
		'm7b5': [ 0, 3, 6, 10 ],
		'-7(b5)': [ 0, 3, 6, 10 ],
		'-7b5': [ 0, 3, 6, 10 ],

		'7b5': [ 0, 4, 6, 10 ],
		'7(b5)': [ 0, 4, 6, 10 ],
		'75': [ 0, 4, 6, 10 ],

		'7(b9,b5)': [ 0, 4, 6, 10, 13 ],
		'7b9,b5': [ 0, 4, 6, 10, 13 ],
		'7(#9,b5)': [ 0, 4, 6, 10, 15 ],
		'7#9b5': [ 0, 4, 6, 10, 15 ],
		'maj7(b5)': [ 0, 3, 6, 11 ],
		'maj7b5': [ 0, 3, 6, 11 ],
		'13(b5)': [ 0, 4, 6, 10, 14, 18 ],
		'13b5': [ 0, 4, 6, 10, 14, 18 ],

		// minor (all normal 5, minor 3 chords)
		'm': [ 0, 3, 7 ],
		'-': [ 0, 3, 7 ],
		'm6': [ 0, 3, 7, 9 ],
		'-6': [ 0, 3, 7, 9 ],
		'm7': [ 0, 3, 7, 10 ],
		'-7': [ 0, 3, 7, 10 ],

		'-(b6)': [ 0, 3, 7, 8 ],
		'-b6': [ 0, 3, 7, 8 ],
		'-6/9': [ 0, 3, 7, 9, 14 ],
		'-7(b9)': [ 0, 3, 7, 10, 13 ],
		'-7b9': [ 0, 3, 7, 10, 13 ],
		'-maj7': [ 0, 3, 7, 11 ],
		'-9+7': [ 0, 3, 7, 11, 13 ],
		'-11': [  0, 3, 7, 11, 14, 16 ],

		// major (all normal 5, major 3 chords)
		'M': [ 0, 4, 7 ],
		'6': [ 0, 4, 7, 9 ],
		'6/9': [ 0, 4, 7, 9, 14 ],

		'7': [ 0, 4, 7, 10 ],
		'9': [ 0, 4, 7, 10, 14 ],
		'11': [ 0, 4, 7, 10, 14, 16 ],
		'13': [ 0, 4, 7, 10, 14, 18 ],
		'7b9': [ 0, 4, 7, 10, 13 ],
		'79': [ 0, 4, 7, 10, 13 ],
		'7(b9)': [ 0, 4, 7, 10, 13 ],
		'7(#9)': [ 0, 4, 7, 10, 15 ],
		'7#9': [ 0, 4, 7, 10, 15 ],
		'(13)': [ 0, 4, 7, 10, 14, 18 ],
		'7(9,13)': [ 0, 4, 7, 10, 14, 18 ],
		'7(#9,b13)': [ 0, 4, 7, 10, 15, 17 ],
		'7(#11)': [ 0, 4, 7, 10, 14, 17 ],
		'7#11': [ 0, 4, 7, 10, 14, 17 ],
		'7(b13)': [ 0, 4, 7, 10, 17 ],
		'7b13': [ 0, 4, 7, 10, 17 ],
		'9(#11)': [ 0, 4, 7, 10, 14, 17 ],
		'9#11': [ 0, 4, 7, 10, 14, 17 ],
		'13(#11)': [ 0, 4, 7, 10, 15, 18 ],
		'13#11': [ 0, 4, 7, 10, 15, 18 ],

		'maj7': [ 0, 4, 7, 11 ],
		'7': [ 0, 4, 7, 11 ],
		'7': [ 0, 4, 7, 11 ],
		'maj9': [ 0, 4, 7, 11, 14 ],
		'maj7(9)': [ 0, 4, 7, 11, 14 ],
		'maj7(11)': [ 0, 4, 7, 11, 16 ],
		'maj7(#11)': [ 0, 4, 7, 11, 17 ],
		'maj7(13)': [ 0, 4, 7, 11, 18 ],
		'maj7(9,13)': [ 0, 4, 7, 11, 14, 18 ],

		'7sus4': [ 0, 5, 7, 10 ],
		'm7sus4': [ 0, 5, 7, 10 ],
		'sus4': [ 0, 5, 7 ],
		'sus2': [ 0, 2, 7 ],
		'7sus2': [ 0, 2, 7, 10 ],
		'9sus4': [ 0, 5, 7, 14 ],
		'13sus4': [ 0, 5, 7, 18 ],

		// augmented (all sharp 5 chords)
		'aug7': [ 0, 4, 8, 10 ],
		'+7': [ 0, 4, 8, 10 ],
		'+': [ 0, 4, 8 ],
		'7#5': [ 0, 4, 8, 10 ],
		'75': [ 0, 4, 8, 10 ],
		'7+5': [ 0, 4, 8, 10 ],
		'9#5': [ 0, 4, 8, 10, 14 ],
		'95': [ 0, 4, 8, 10, 14 ],
		'9+5': [ 0, 4, 8, 10, 14 ],
		'-7(#5)': [ 0, 3, 8, 10 ],
		'-7#5': [ 0, 3, 8, 10 ],
		'7(#5)': [ 0, 4, 8, 10 ],
		'7(b9,#5)': [ 0, 4, 8, 10, 13 ],
		'7b9#5': [ 0, 4, 8, 10, 13 ],
		'maj7(#5)': [ 0, 4, 8, 11 ],
		'maj7#5': [ 0, 4, 8, 11 ],
		'maj7(#5,#11)': [ 0, 4, 8, 11, 14 ],
		'maj7#5#11': [ 0, 4, 8, 11, 14 ],
		'9(#5)': [ 0, 4, 8, 10, 14 ],
		'13(#5)': [ 0, 4, 8, 10, 14, 18 ],
		'13#5': [ 0, 4, 8, 10, 14, 18 ]
};
	function chordNotes(bass, modifier) {
		var intervals = chordIntervals[modifier];
		if (!intervals)
			intervals = chordIntervals.M;
		bass += 12;	// the chord is an octave above the bass note.
		var notes = [ ];
		for (var i = 0; i < intervals.length; i++) {
			notes.push(bass + intervals[i]);
		}
		return notes;
	}

	function writeBoom(boom, beatLength) {
		// undefined means there is a stop time.
		if (boom !== undefined)
			chordTrack.push({cmd: 'start', pitch: boom, volume: 64});
		chordTrack.push({ cmd: 'move', duration: (beatLength/2)*tempoChangeFactor });
		if (boom !== undefined)
			chordTrack.push({ cmd: 'stop', pitch: boom });
		chordTrack.push({ cmd: 'move', duration: (beatLength/2)*tempoChangeFactor });
	}

	function writeChick(chick, beatLength) {
		for (var c = 0; c < chick.length; c++)
			chordTrack.push({cmd: 'start', pitch: chick[c], volume: 48});
		chordTrack.push({ cmd: 'move', duration: (beatLength/2)*tempoChangeFactor });
		for (c = 0; c < chick.length; c++)
			chordTrack.push({ cmd: 'stop', pitch: chick[c] });
		chordTrack.push({ cmd: 'move', duration: (beatLength/2)*tempoChangeFactor });
	}

	var rhythmPatterns = { "2/2": [ 'boom', 'chick' ],
		"2/4": [ 'boom', 'chick' ],
		"3/4": [ 'boom', 'chick', 'chick' ],
		"4/4": [ 'boom', 'chick', 'boom2', 'chick' ],
		"5/4": [ 'boom', 'chick', 'chick', 'boom2', 'chick' ],
		"6/8": [ 'boom', '', 'chick', 'boom2', '', 'chick' ],
		"9/8": [ 'boom', '', 'chick', 'boom2', '', 'chick', 'boom2', '', 'chick' ],
		"12/8": [ 'boom', '', 'chick', 'boom2', '', 'chick', 'boom2', '', 'chick', 'boom2', '', 'chick' ],
	};

	function resolveChords() {
		var num = meter.num;
		var den = meter.den;
		var beatLength = 1/den;
		var pattern = rhythmPatterns[num+'/'+den];
		var thisMeasureLength = parseInt(num,10)/parseInt(den,10);
		// See if this is a full measure: unfortunately, with triplets, there isn't an exact match, what with the floating point, so we just see if it is "close".
		var portionOfAMeasure = Math.abs(thisMeasureLength - barBeat);
		if (!pattern || portionOfAMeasure > 0.0078125) { // If it is an unsupported meter, or this isn't a full bar, just chick on each beat.
			pattern = [];
			var beatsPresent = barBeat / beatLength;
			for (var p = 0; p < beatsPresent; p++)
				pattern.push("chick");
		}

		if (currentChords.length === 0) { // there wasn't a new chord this measure, so use the last chord declared.
			currentChords.push({ beat: 0, chord: lastChord});
		}
		if (currentChords[0].beat !== 0 && lastChord) { // this is the case where there is a chord declared in the measure, but not on its first beat.
			currentChords.unshift({ beat: 0, chord: lastChord});
		}
		if (currentChords.length === 1) {
			for (var m = 0; m < pattern.length; m++) {
				switch (pattern[m]) {
					case 'boom':
						writeBoom(currentChords[0].chord.boom, beatLength);
						break;
					case 'boom2':
						writeBoom(currentChords[0].chord.boom2, beatLength);
						break;
					case 'chick':
						writeChick(currentChords[0].chord.chick, beatLength);
						break;
					case '':
						chordTrack.push({ cmd: 'move', duration: beatLength*tempoChangeFactor });
						break;
				}
			}
			return;
		}

		// If we are here it is because more than one chord was declared in the measure, so we have to sort out what chord goes where.

		// First, normalize the chords on beats.
		var beats = {};
		for (var i = 0; i < currentChords.length; i++) {
			var cc = currentChords[i];
			var beat = Math.floor(cc.beat / beatLength);	// now all the beats are integers, there may be
			beats[''+beat] = cc;
		}

		// - If there is a chord on the second beat, play a chord for the first beat instead of a bass note.
		// - Likewise, if there is a chord on the fourth beat of 4/4, play a chord on the third beat instead of a bass note.
		for (var m2 = 0; m2 < pattern.length; m2++) {
			var thisChord;
			if (beats[''+m2])
				thisChord = beats[''+m2];
			switch (pattern[m2]) {
				case 'boom':
					if (beats[''+(m2+1)]) // If there is not a chord change on the next beat, play a bass note.
						writeChick(thisChord.chord.chick, beatLength);
					else
						writeBoom(thisChord.chord.boom, beatLength);
					break;
				case 'boom2':
					if (beats[''+(m2+1)])
						writeChick(thisChord.chord.chick, beatLength);
					else
						writeBoom(thisChord.chord.boom2, beatLength);
					break;
				case 'chick':
					writeChick(thisChord.chord.chick, beatLength);
					break;
				case '':
					if (beats[''+m2])	// If there is an explicit chord on this beat, play it.
						writeChick(thisChord.chord.chick, beatLength);
					else
						chordTrack.push({cmd: 'move', duration: beatLength*tempoChangeFactor });
					break;
			}
		}
	}

	function normalizeDrumDefinition(params) {
		// Be very strict with the drum definition. If anything is not perfect,
		// just turn the drums off.
		// Perhaps all of this logic belongs in the parser instead.
		if (params.pattern.length === 0 || params.on === false)
			return { on: false };

		var str = params.pattern[0];
		var events = [];
		var event = "";
		var totalPlay = 0;
		for (var i = 0; i < str.length; i++) {
			if (str[i] === 'd')
				totalPlay++;
			if (str[i] === 'd' || str[i] === 'z') {
				if (event.length !== 0) {
					events.push(event);
					event = str[i];
				} else
					event = event + str[i];
			} else {
				if (event.length === 0) {
					// there was an error: the string should have started with d or z
					return {on: false};
				}
				event = event + str[i];
			}
		}

		if (event.length !== 0)
			events.push(event);

		// Now the events array should have one item per event.
		// There should be two more params for each event: the volume and the pitch.
		if (params.pattern.length !== totalPlay*2 + 1)
			return { on: false };

		var ret = { on: true, bars: params.bars, pattern: []};
		var beatLength = 1/meter.den;
		var playCount = 0;
		for (var j = 0; j < events.length; j++) {
			event = events[j];
			var len = 1;
			var div = false;
			var num = 0;
			for (var k = 1; k < event.length; k++) {
				switch(event[k]) {
					case "/":
						if (num !== 0)
							len *= num;
						num = 0;
						div = true;
						break;
					case "1":
					case "2":
					case "3":
					case "4":
					case "5":
					case "6":
					case "7":
					case "8":
					case "9":
						num = num*10 +event[k];
						break;
					default:
						return { on: false };
				}
			}
			if (div) {
				if (num === 0) num = 2; // a slash by itself is interpreted as "/2"
				len /= num;
			} else if (num)
				len *= num;
			if (event[0] === 'd') {
				ret.pattern.push({ len: len * beatLength, pitch: params.pattern[1 + playCount], velocity: params.pattern[1 + playCount + totalPlay]});
				playCount++;
			} else
				ret.pattern.push({ len: len * beatLength, pitch: null});
		}
		// Now normalize the pattern to cover the correct number of measures. The note lengths passed are relative to each other and need to be scaled to fit a measure.
		var totalTime = 0;
		var measuresPerBeat = meter.num/meter.den;
		for (var ii = 0; ii < ret.pattern.length; ii++)
			totalTime += ret.pattern[ii].len;
		var numBars = params.bars ? params.bars : 1;
		var factor = totalTime /  numBars / measuresPerBeat;
		for (ii = 0; ii < ret.pattern.length; ii++)
			ret.pattern[ii].len = ret.pattern[ii].len / factor;
		return ret;
	}

	function drumBeat(pitch, soundLength, volume) {
		drumTrack.push({ cmd: 'start', pitch: pitch - 60, volume: volume});
		drumTrack.push({ cmd: 'move', duration: soundLength });
		drumTrack.push({ cmd: 'stop', pitch: pitch - 60 });
	}

	function writeDrum(channel) {
		if (drumTrack.length === 0 && !drumDefinition.on)
			return;

		var measureLen = meter.num/meter.den;
		if (drumTrack.length === 0) {
			drumTrack.push({cmd: 'program', channel: channel, instrument: drumInstrument});
			// need to figure out how far in time the bar started: if there are pickup notes before the chords start, we need pauses.
			var distance = timeFromStart();
			if (distance > 0 && distance < measureLen - 0.01) { // because of floating point, adding the notes might not exactly equal the measure size.
				drumTrack.push({cmd: 'move', duration: distance * tempoChangeFactor});
				return;
			}
		}

		if (!drumDefinition.on) {
			// this is the case where there has been a drum track, but it was specifically turned off.
			drumTrack.push({ cmd: 'move', duration: measureLen * tempoChangeFactor });
			return;
		}
		for (var i = 0; i < drumDefinition.pattern.length; i++) {
			var len = drumDefinition.pattern[i].len * tempoChangeFactor;
			if (drumDefinition.pattern[i].pitch)
				drumBeat(drumDefinition.pattern[i].pitch, len, drumDefinition.pattern[i].velocity);
			else
				drumTrack.push({ cmd: 'move', duration: len });
		}
	}
})();

module.exports = flatten;


/***/ }),

/***/ "./node_modules/abcjs/src/midi/abc_midi_sequencer.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/midi/abc_midi_sequencer.js ***!
  \***********************************************************/
/***/ (function(module) {

//    abc_midi_sequencer.js: Turn parsed abc into a linear series of events.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var sequence;

(function() {
	"use strict";

	var measureLength;
	// The abc is provided to us line by line. It might have repeats in it. We want to re arrange the elements to
	// be an array of voices with all the repeats embedded, and no lines. Then it is trivial to go through the events
	// one at a time and turn it into midi.

	var PERCUSSION_PROGRAM = 128;

	sequence = function(abctune, options) {
		// Global options
		options = options || {};
		var qpm = undefined;
		var program = options.program || 0;	// The program if there isn't a program specified.
		var transpose = options.midiTranspose || 0;
		var channel = options.channel || 0;
		var drumPattern = options.drum || "";
		var drumBars = options.drumBars || 1;
		var drumIntro = options.drumIntro || 0;
		var drumOn = drumPattern !== "";

		// All of the above overrides need to be integers
		program = parseInt(program, 10);
		transpose = parseInt(transpose, 10);
		channel = parseInt(channel, 10);
		if (channel === 10)
			program = PERCUSSION_PROGRAM;
		drumPattern = drumPattern.split(" ");
		drumBars = parseInt(drumBars, 10);
		drumIntro = parseInt(drumIntro, 10);

		var bagpipes = abctune.formatting.bagpipes; // If it is bagpipes, then the gracenotes are played on top of the main note.
		if (bagpipes)
			program = 71;

		// %%MIDI fermatafixed
		// %%MIDI fermataproportional
		// %%MIDI deltaloudness n
		// %%MIDI gracedivider b
		// %%MIDI ratio n m
		// %%MIDI beat a b c n
		// %%MIDI grace a/b
		// %%MIDI trim x/y

		// %MIDI gchordon
		// %MIDI gchordoff
		// %%MIDI bassprog 45
		// %%MIDI chordprog 24
		// %%MIDI chordname name n1 n2 n3 n4 n5 n6

		//%%MIDI beat int1 int2 int3 int4: controls the volumes of the notes in a measure. The first note in a bar has volume int1; other strong notes have volume int2 and all the rest have volume int3. These values must be in the range 0127. The parameter int4 determines which notes are strong. If the time signature is x/y, then each note is given a position number k = 0, 1, 2. . . x-1 within each bar. If k is a multiple of int4, then the note is strong.

		var startingMidi = [];
		if (abctune.formatting.midi) {
			//console.log("MIDI Formatting:", abctune.formatting.midi);
			var globals = abctune.formatting.midi;
			if (globals.program && globals.program.length > 0) {
				program = globals.program[0];
				if (globals.program.length > 1) {
					program = globals.program[1];
					channel = globals.program[0];
				}
			}
			if (globals.transpose)
				transpose = globals.transpose[0];
			if (globals.channel)
				channel = globals.channel[0];
			if (globals.drum)
				drumPattern = globals.drum;
			if (globals.drumbars)
				drumBars = globals.drumbars[0];
			if (globals.drumon)
				drumOn = true;
			if (channel === 10)
				program = PERCUSSION_PROGRAM;
			if (globals.beat)
				startingMidi.push({ el_type: 'beat', beats: globals.beat })
			if (globals.nobeataccents)
				startingMidi.push({ el_type: 'beataccents', value: false });

		}

		// Specified options in abc string.

		// If the tempo was passed in, use that.
		// If the tempo is specified, use that.
		// If there is a default, use that.
		// Otherwise, use the default.
		if (options.qpm)
			qpm = parseInt(options.qpm, 10);
		else if (abctune.metaText.tempo)
			qpm = interpretTempo(abctune.metaText.tempo);
		else if (options.defaultQpm)
			qpm = options.defaultQpm;
		else
			qpm = 180; 	// The tempo if there isn't a tempo specified.

		var startVoice = [];
		if (bagpipes)
			startVoice.push({ el_type: 'bagpipes' });
		startVoice.push({ el_type: 'instrument', program: program });
		if (channel)
			startVoice.push({ el_type: 'channel', channel: channel });
		if (transpose)
			startVoice.push({ el_type: 'transpose', transpose: transpose });
		startVoice.push({ el_type: 'tempo', qpm: qpm });
		for (var ss = 0; ss < startingMidi.length;ss++)
			startVoice.push(startingMidi[ss]);

		// the relevant part of the input structure is:
		// abctune
		//		array lines
		//			array staff
		//				object key
		//				object meter
		//				array voices
		//					array abcelem

		// visit each voice completely in turn
		var voices = [];
		var startRepeatPlaceholder = []; // There is a place holder for each voice.
		var skipEndingPlaceholder = []; // This is the place where the first ending starts.
		var startingDrumSet = false;
		for (var i = 0; i < abctune.lines.length; i++) {
			// For each group of staff lines in the tune.
			var line = abctune.lines[i];
			if (line.staff) {
				var staves = line.staff;
				var voiceNumber = 0;
				for (var j = 0; j < staves.length; j++) {
					var staff = staves[j];
					// For each staff line
					for (var k = 0; k < staff.voices.length; k++) {
						// For each voice in a staff line
						var voice = staff.voices[k];
						if (!voices[voiceNumber]) {
							voices[voiceNumber] = [].concat(JSON.parse(JSON.stringify(startVoice)));
						}
						if (staff.clef && staff.clef.type === 'perc') {
							for (var cl = 0; cl < voices[voiceNumber].length; cl++) {
								if (voices[voiceNumber][cl].el_type === 'instrument')
									voices[voiceNumber][cl].program = PERCUSSION_PROGRAM;
							}
						} else if (staff.key) {
							if (staff.key.root === 'HP')
								voices[voiceNumber].push({el_type: 'key', accidentals: [{acc: 'natural', note: 'g'}, {acc: 'sharp', note: 'f'}, {acc: 'sharp', note: 'c'}]});
							else
								voices[voiceNumber].push({el_type: 'key', accidentals: staff.key.accidentals });
						}
						if (staff.meter) {
							voices[voiceNumber].push(interpretMeter(staff.meter));
						}
						if (!startingDrumSet && drumOn) { // drum information is only needed once, so use the first line and track 0.
							voices[voiceNumber].push({el_type: 'drum', params: {pattern: drumPattern, bars: drumBars, on: drumOn, intro: drumIntro}});
							startingDrumSet = true;
						}
						if (staff.clef && staff.clef.transpose) {
							staff.clef.el_type = 'clef';
							voices[voiceNumber].push({ el_type: 'transpose', transpose: staff.clef.transpose });
						}
						if (abctune.formatting.midi && abctune.formatting.midi.drumoff) {
							// If there is a drum off command right at the beginning it is put in the metaText instead of the stream,
							// so we will just insert it here.
							voices[voiceNumber].push({ el_type: 'bar' });
							voices[voiceNumber].push({el_type: 'drum', params: {pattern: "", on: false }});
						}
						var noteEventsInBar = 0;
						for (var v = 0; v < voice.length; v++) {
							// For each element in a voice
							var elem = voice[v];
							switch (elem.el_type) {
								case "note":
									// regular items are just pushed.
									if (!elem.rest || elem.rest.type !== 'spacer') {
										if (elem.decoration) {
											if (elem.decoration.indexOf('ppp') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [30, 20, 10, 1] });
											else if (elem.decoration.indexOf('pp') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [45, 35, 20, 1] });
											else if (elem.decoration.indexOf('p') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [60, 50, 35, 1] });
											else if (elem.decoration.indexOf('mp') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [75, 65, 50, 1] });
											else if (elem.decoration.indexOf('mf') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [90, 80, 65, 1] });
											else if (elem.decoration.indexOf('f') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [105, 95, 80, 1] });
											else if (elem.decoration.indexOf('ff') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [120, 110, 95, 1] });
											else if (elem.decoration.indexOf('fff') >= 0)
												voices[voiceNumber].push({ el_type: 'beat', beats: [127, 125, 110, 1] });
										}
										voices[voiceNumber].push(elem);
										noteEventsInBar++;
									}
									break;
								case "key":
									if (elem.root === 'HP')
										voices[voiceNumber].push({el_type: 'key', accidentals: [{acc: 'natural', note: 'g'}, {acc: 'sharp', note: 'f'}, {acc: 'sharp', note: 'c'}]});
									else
										voices[voiceNumber].push({el_type: 'key', accidentals: elem.accidentals });
									break;
								case "meter":
									voices[voiceNumber].push(interpretMeter(elem));
									break;
								case "clef": // need to keep this to catch the "transpose" element.
									if (elem.transpose)
										voices[voiceNumber].push({ el_type: 'transpose', transpose: elem.transpose });
									break;
								case "tempo":
									qpm = interpretTempo(elem);
									voices[voiceNumber].push({ el_type: 'tempo', qpm: qpm });
									break;
								case "bar":
									if (noteEventsInBar > 0) // don't add two bars in a row.
										voices[voiceNumber].push({ el_type: 'bar' }); // We need the bar marking to reset the accidentals.
									noteEventsInBar = 0;
									// figure out repeats and endings --
									// The important part is where there is a start repeat, and end repeat, or a first ending.
									var endRepeat = (elem.type === "bar_right_repeat" || elem.type === "bar_dbl_repeat");
									var startEnding = (elem.startEnding === '1');
									var startRepeat = (elem.type === "bar_left_repeat" || elem.type === "bar_dbl_repeat" || elem.type === "bar_right_repeat");
									if (endRepeat) {
										var s = startRepeatPlaceholder[voiceNumber];
										if (!s) s = 0; // If there wasn't a left repeat, then we repeat from the beginning.
										var e = skipEndingPlaceholder[voiceNumber];
										if (!e) e = voices[voiceNumber].length; // If there wasn't a first ending marker, then we copy everything.
										voices[voiceNumber] = voices[voiceNumber].concat(voices[voiceNumber].slice(s, e));
										// reset these in case there is a second repeat later on.
										skipEndingPlaceholder[voiceNumber] = undefined;
										startRepeatPlaceholder[voiceNumber] = undefined;
									}
									if (startEnding)
										skipEndingPlaceholder[voiceNumber] = voices[voiceNumber].length;
									if (startRepeat)
										startRepeatPlaceholder[voiceNumber] = voices[voiceNumber].length;
									break;
								case 'style':
									// TODO-PER: If this is set to rhythm heads, then it should use the percussion channel.
									break;
								case 'part':
									// TODO-PER: If there is a part section in the header, then this should probably affect the repeats.
									break;
								case 'stem':
								case 'scale':
									// These elements don't affect sound
									break;
								case 'midi':
									//console.log("MIDI inline", elem); // TODO-PER: for debugging. Remove this.
									var drumChange = false;
									switch (elem.cmd) {
										case "drumon": drumOn = true; drumChange = true; break;
										case "drumoff": drumOn = false; drumChange = true; break;
										case "drum": drumPattern = elem.params; drumChange = true; break;
										case "drumbars": drumBars = elem.params[0]; drumChange = true; break;
										case "drummap":
											// This is handled before getting here so it can be ignored.
											break;
										case "program":
											voices[voiceNumber].push({ el_type: 'instrument', program: elem.params[0] });
											break;
										case "transpose":
											voices[voiceNumber].push({ el_type: 'transpose', transpose: elem.params[0] });
											break;
										case "gchordoff":
											voices[voiceNumber].push({ el_type: 'gchord', tacet: true });
											break;
										case "gchordon":
											voices[voiceNumber].push({ el_type: 'gchord', tacet: false });
											break;
										case "beat":
											voices[voiceNumber].push({ el_type: 'beat', beats: elem.params });
											break;
										case "nobeataccents":
											voices[voiceNumber].push({ el_type: 'beataccents', value: false });
											break;
										case "beataccents":
											voices[voiceNumber].push({ el_type: 'beataccents', value: true });
											break;
										case "vol":
											voices[voiceNumber].push({ el_type: 'vol', volume: elem.params[0] });
											break;
										case "volinc":
											voices[voiceNumber].push({ el_type: 'volinc', volume: elem.params[0] });
											break;
										default:
											console.log("MIDI seq: midi cmd not handled: ", elem.cmd, elem);
									}
									if (drumChange) {
										voices[0].push({el_type: 'drum', params: { pattern: drumPattern, bars: drumBars, intro: drumIntro, on: drumOn}});
										startingDrumSet = true;
									}
									break;
								default:
									console.log("MIDI: element type " + elem.el_type + " not handled.");
							}
						}
						voiceNumber++;
					}
				}
			}
		}
		if (drumIntro) {
			var pickups = abctune.getPickupLength();
			// add some measures of rests to the start of each track.
			for (var vv = 0; vv < voices.length; vv++) {
				var insertPoint = 0;
				while (voices[vv][insertPoint].el_type !== "note" && voices[vv].length > insertPoint)
					insertPoint++;
				if (voices[vv].length > insertPoint) {
					for (var w = 0; w < drumIntro; w++) {
						// If it is the last measure of intro, subtract the pickups.
						if (pickups === 0 || w < drumIntro-1)
							voices[vv].splice(insertPoint, 0, {el_type: "note", rest: {type: "rest"}, duration: measureLength},
								{ el_type: "bar" });
						else {
							voices[vv].splice(insertPoint, 0, {el_type: "note", rest: {type: "rest"}, duration: measureLength-pickups});
						}
					}
				}
			}
		}
		return voices;
	};

	function interpretTempo(element) {
		var duration = 1/4;
		if (element.duration) {
			duration = element.duration[0];
		}
		var bpm = 60;
		if (element.bpm) {
			bpm = element.bpm;
		}
		// The tempo is defined with a beat of a 1/4 note, so we need to adjust it if the tempo is expressed with other than a quarter note.
		// expressedDuration * expressedBeatsPerMinute / lengthOfQuarterNote = quarterNotesPerMinute
		return duration * bpm / 0.25;
	}

	function interpretMeter(element) {
		var meter;
		switch (element.type) {
			case "common_time":
				meter = { el_type: 'meter', num: 4, den: 4 };
				break;
			case "cut_time":
				meter = { el_type: 'meter', num: 2, den: 2 };
				break;
			case "specified":
				// TODO-PER: only taking the first meter, so the complex meters are not handled.
				meter = { el_type: 'meter', num: element.value[0].num, den: element.value[0].den };
				break;
			default:
				// This should never happen.
				meter = { el_type: 'meter' };
		}
		measureLength = meter.num/meter.den;
		return meter;
	}
})();

module.exports = sequence;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_common.js":
/*!****************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_common.js ***!
  \****************************************************/
/***/ (function(module) {

//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var parseCommon = {};

parseCommon.clone = function(source) {
	var destination = {};
	for (var property in source)
		if (source.hasOwnProperty(property))
			destination[property] = source[property];
	return destination;
};

parseCommon.cloneArray = function(source) {
	var destination = [];
	for (var i = 0; i < source.length; i++) {
		destination.push(parseCommon.clone(source[i]));
	}
	return destination;
};

parseCommon.cloneHashOfHash = function(source) {
	var destination = {};
	for (var property in source)
		if (source.hasOwnProperty(property))
			destination[property] = parseCommon.clone(source[property]);
	return destination;
};

parseCommon.cloneHashOfArrayOfHash = function(source) {
	var destination = {};
	for (var property in source)
		if (source.hasOwnProperty(property))
			destination[property] = parseCommon.cloneArray(source[property]);
	return destination;
};

parseCommon.gsub = function(source, pattern, replacement) {
	return source.split(pattern).join(replacement);
};

parseCommon.strip = function(str) {
	return str.replace(/^\s+/, '').replace(/\s+$/, '');
};

parseCommon.startsWith = function(str, pattern) {
	return str.indexOf(pattern) === 0;
};

parseCommon.endsWith = function(str, pattern) {
	var d = str.length - pattern.length;
	return d >= 0 && str.lastIndexOf(pattern) === d;
};

parseCommon.each = function(arr, iterator, context) {
	for (var i = 0, length = arr.length; i < length; i++)
	  iterator.apply(context, [arr[i],i]);
};

parseCommon.last = function(arr) {
	if (arr.length === 0)
		return null;
	return arr[arr.length-1];
};

parseCommon.compact = function(arr) {
	var output = [];
	for (var i = 0; i < arr.length; i++) {
		if (arr[i])
			output.push(arr[i]);
	}
	return output;
};

parseCommon.detect = function(arr, iterator) {
	for (var i = 0; i < arr.length; i++) {
		if (iterator(arr[i]))
			return true;
	}
	return false;
};

// The following is a polyfill for Object.remove for IE9, IE10, and IE11.
// from:https://github.com/jserz/js_piece/blob/master/DOM/ChildNode/remove()/remove().md
(function (arr) {
	arr.forEach(function (item) {
		if (item.hasOwnProperty('remove')) {
			return;
		}
		Object.defineProperty(item, 'remove', {
			configurable: true,
			enumerable: true,
			writable: true,
			value: function remove() {
				if (this.parentNode !== null)
					this.parentNode.removeChild(this);
			}
		});
	});
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

module.exports = parseCommon;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_parse.js":
/*!***************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_parse.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_parse.js: parses a string representing ABC Music Notation into a usable internal structure.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global window */

var parseCommon = __webpack_require__(/*! ./abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var parseDirective = __webpack_require__(/*! ./abc_parse_directive */ "./node_modules/abcjs/src/parse/abc_parse_directive.js");
var ParseHeader = __webpack_require__(/*! ./abc_parse_header */ "./node_modules/abcjs/src/parse/abc_parse_header.js");
var parseKeyVoice = __webpack_require__(/*! ./abc_parse_key_voice */ "./node_modules/abcjs/src/parse/abc_parse_key_voice.js");
var Tokenizer = __webpack_require__(/*! ./abc_tokenizer */ "./node_modules/abcjs/src/parse/abc_tokenizer.js");
var transpose = __webpack_require__(/*! ./abc_transpose */ "./node_modules/abcjs/src/parse/abc_transpose.js");
var wrap = __webpack_require__(/*! ./wrap_lines */ "./node_modules/abcjs/src/parse/wrap_lines.js");

var Tune = __webpack_require__(/*! ../data/abc_tune */ "./node_modules/abcjs/src/data/abc_tune.js");

var Parse = function() {
	"use strict";
	var tune = new Tune();
	var tokenizer = new Tokenizer();

	this.getTune = function() {
		return {
			formatting: tune.formatting,
			lines: tune.lines,
			media: tune.media,
			metaText: tune.metaText,
			version: tune.version,

			addElementToEvents: tune.addElementToEvents,
			addUsefulCallbackInfo: tune.addUsefulCallbackInfo,
			getBarLength: tune.getBarLength,
			getBeatLength: tune.getBeatLength,
			getBeatsPerMeasure: tune.getBeatsPerMeasure,
			getBpm: tune.getBpm,
			getMeter: tune.getMeter,
			getMeterFraction: tune.getMeterFraction,
			getPickupLength: tune.getPickupLength,
			getKeySignature: tune.getKeySignature,
			makeVoicesArray: tune.makeVoicesArray,
			millisecondsPerMeasure: tune.millisecondsPerMeasure,
			setupEvents: tune.setupEvents,
			setTiming: tune.setTiming
		};
	};

	function addPositioning(el, type, value) {
		if (!el.positioning) el.positioning = {};
		el.positioning[type] = value;
	}

	function addFont(el, type, value) {
		if (!el.fonts) el.fonts = {};
		el.fonts[type] = value;
	}

	var multilineVars = {
		reset: function() {
			for (var property in this) {
				if (this.hasOwnProperty(property) && typeof this[property] !== "function") {
					delete this[property];
				}
			}
			this.iChar = 0;
			this.key = {accidentals: [], root: 'none', acc: '', mode: '' };
			this.meter = null; // if no meter is specified, free meter is assumed
			this.origMeter = null;	// this is for new voices that are created after we set the meter.
			this.hasMainTitle = false;
			this.default_length = 0.125;
			this.clef = { type: 'treble', verticalPos: 0 };
			this.next_note_duration = 0;
			this.start_new_line = true;
			this.is_in_header = true;
			this.is_in_history = false;
			this.partForNextLine = {};
			this.havent_set_length = true;
			this.voices = {};
			this.staves = [];
			this.macros = {};
			this.currBarNumber = 1;
			this.barCounter = {};
			this.inTextBlock = false;
			this.inPsBlock = false;
			this.ignoredDecorations = [];
			this.textBlock = "";
			this.score_is_present = false;	// Can't have original V: lines when there is the score directive
			this.inEnding = false;
			this.inTie = [];
			this.inTieChord = {};
			this.vocalPosition = "auto";
			this.dynamicPosition = "auto";
			this.chordPosition = "auto";
			this.ornamentPosition = "auto";
			this.volumePosition = "auto";
			this.openSlurs = [];
			this.freegchord = false;
		},
		differentFont: function(type, defaultFonts) {
			if (this[type].decoration !== defaultFonts[type].decoration) return true;
			if (this[type].face !== defaultFonts[type].face) return true;
			if (this[type].size !== defaultFonts[type].size) return true;
			if (this[type].style !== defaultFonts[type].style) return true;
			if (this[type].weight !== defaultFonts[type].weight) return true;
			return false;
		},
		addFormattingOptions: function(el, defaultFonts, elType) {
			if (elType === 'note') {
				if (this.vocalPosition !== 'auto') addPositioning(el, 'vocalPosition', this.vocalPosition);
				if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);
				if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);
				if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);
				if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);
				if (this.differentFont("annotationfont", defaultFonts)) addFont(el, 'annotationfont', this.annotationfont);
				if (this.differentFont("gchordfont", defaultFonts)) addFont(el, 'gchordfont', this.gchordfont);
				if (this.differentFont("vocalfont", defaultFonts)) addFont(el, 'vocalfont', this.vocalfont);
				if (this.differentFont("tripletfont", defaultFonts)) addFont(el, 'tripletfont', this.tripletfont);
			} else if (elType === 'bar') {
				if (this.dynamicPosition !== 'auto') addPositioning(el, 'dynamicPosition', this.dynamicPosition);
				if (this.chordPosition !== 'auto') addPositioning(el, 'chordPosition', this.chordPosition);
				if (this.ornamentPosition !== 'auto') addPositioning(el, 'ornamentPosition', this.ornamentPosition);
				if (this.volumePosition !== 'auto') addPositioning(el, 'volumePosition', this.volumePosition);
				if (this.differentFont("measurefont", defaultFonts)) addFont(el, 'measurefont', this.measurefont);
				if (this.differentFont("repeatfont", defaultFonts)) addFont(el, 'repeatfont', this.repeatfont);
			}
		}
	};

	var addWarning = function(str) {
		if (!multilineVars.warnings)
			multilineVars.warnings = [];
		multilineVars.warnings.push(str);
	};

	var addWarningObject = function(warningObject) {
		if (!multilineVars.warningObjects)
			multilineVars.warningObjects = [];
		multilineVars.warningObjects.push(warningObject);
	};

	var encode = function(str) {
		var ret = parseCommon.gsub(str, '\x12', ' ');
		ret = parseCommon.gsub(ret, '&', '&amp;');
		ret = parseCommon.gsub(ret, '<', '&lt;');
		return parseCommon.gsub(ret, '>', '&gt;');
	};

	var warn = function(str, line, col_num) {
		if (!line) line = " ";
		var bad_char = line.charAt(col_num);
		if (bad_char === ' ')
			bad_char = "SPACE";
		var clean_line = encode(line.substring(0, col_num)) +
			'<span style="text-decoration:underline;font-size:1.3em;font-weight:bold;">' + bad_char + '</span>' +
			encode(line.substring(col_num+1));
		addWarning("Music Line:" + tune.getNumLines() + ":" + (col_num+1) + ': ' + str + ":  " + clean_line);
		addWarningObject({message:str, line:line, startChar: multilineVars.iChar + col_num, column: col_num});
	};
	var header = new ParseHeader(tokenizer, warn, multilineVars, tune);

	this.getWarnings = function() {
		return multilineVars.warnings;
	};
	this.getWarningObjects = function() {
		return multilineVars.warningObjects;
	};

	var letter_to_chord = function(line, i)
	{
		if (line.charAt(i) === '"')
		{
			var chord = tokenizer.getBrackettedSubstring(line, i, 5);
			if (!chord[2])
				warn("Missing the closing quote while parsing the chord symbol", line , i);
			// If it starts with ^, then the chord appears above.
			// If it starts with _ then the chord appears below.
			// (note that the 2.0 draft standard defines them as not chords, but annotations and also defines @.)
			if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '^') {
				chord[1] = chord[1].substring(1);
				chord[2] = 'above';
			} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '_') {
				chord[1] = chord[1].substring(1);
				chord[2] = 'below';
			} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '<') {
				chord[1] = chord[1].substring(1);
				chord[2] = 'left';
			} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '>') {
				chord[1] = chord[1].substring(1);
				chord[2] = 'right';
			} else if (chord[0] > 0 && chord[1].length > 0 && chord[1].charAt(0) === '@') {
				// @-15,5.7
				chord[1] = chord[1].substring(1);
				var x = tokenizer.getFloat(chord[1]);
				if (x.digits === 0)
					warn("Missing first position in absolutely positioned annotation.", line , i);
				chord[1] = chord[1].substring(x.digits);
				if (chord[1][0] !== ',')
					warn("Missing comma absolutely positioned annotation.", line , i);
				chord[1] = chord[1].substring(1);
				var y = tokenizer.getFloat(chord[1]);
				if (y.digits === 0)
					warn("Missing second position in absolutely positioned annotation.", line , i);
				chord[1] = chord[1].substring(y.digits);
				var ws = tokenizer.skipWhiteSpace(chord[1]);
				chord[1] = chord[1].substring(ws);
				chord[2] = null;
				chord[3] = { x: x.value, y: y.value };
			} else {
				if (multilineVars.freegchord !== true) {
					chord[1] = chord[1].replace(/([ABCDEFG0-9])b/g, "$1");
					chord[1] = chord[1].replace(/([ABCDEFG0-9])#/g, "$1");
				}
				chord[2] = 'default';
				chord[1] = transpose.chordName(multilineVars, chord[1]);
			}
			return chord;
		}
		return [0, ""];
	};

	var legalAccents = [ "trill", "lowermordent", "uppermordent", "mordent", "pralltriller", "accent",
		"fermata", "invertedfermata", "tenuto", "0", "1", "2", "3", "4", "5", "+", "wedge",
		"open", "thumb", "snap", "turn", "roll", "breath", "shortphrase", "mediumphrase", "longphrase",
		"segno", "coda", "D.S.", "D.C.", "fine",
		"slide", "^", "marcato",
		"upbow", "downbow", "/", "//", "///", "////", "trem1", "trem2", "trem3", "trem4",
		"turnx", "invertedturn", "invertedturnx", "trill(", "trill)", "arpeggio", "xstem", "mark", "umarcato",
		"style=normal", "style=harmonic", "style=rhythm", "style=x"
	];
	var volumeDecorations = [ "p", "pp", "f", "ff", "mf", "mp", "ppp", "pppp",  "fff", "ffff", "sfz" ];
	var dynamicDecorations = ["crescendo(", "crescendo)", "diminuendo(", "diminuendo)"];

	var accentPseudonyms = [ ["<", "accent"], [">", "accent"], ["tr", "trill"],
		["plus", "+"], [ "emphasis", "accent"],
		[ "^", "umarcato" ], [ "marcato", "umarcato" ] ];
	var accentDynamicPseudonyms = [ ["<(", "crescendo("], ["<)", "crescendo)"],
		[">(", "diminuendo("], [">)", "diminuendo)"] ];
	var letter_to_accent = function(line, i)
	{
		var macro = multilineVars.macros[line.charAt(i)];

		if (macro !== undefined) {
			if (macro.charAt(0) === '!' || macro.charAt(0) === '+')
				macro = macro.substring(1);
			if (macro.charAt(macro.length-1) === '!' || macro.charAt(macro.length-1) === '+')
				macro = macro.substring(0, macro.length-1);
			if (parseCommon.detect(legalAccents, function(acc) {
					return (macro === acc);
				}))
				return [ 1, macro ];
			else if (parseCommon.detect(volumeDecorations, function(acc) {
					return (macro === acc);
				})) {
				if (multilineVars.volumePosition === 'hidden')
					macro = "";
				return [1, macro];
			} else if (parseCommon.detect(dynamicDecorations, function(acc) {
					if (multilineVars.dynamicPosition === 'hidden')
						macro = "";
					return (macro === acc);
				})) {
				return [1, macro];
			} else {
				if (!parseCommon.detect(multilineVars.ignoredDecorations, function(dec) {
					return (macro === dec);
				}))
					warn("Unknown macro: " + macro, line, i);
				return [1, '' ];
			}
		}
		switch (line.charAt(i))
		{
			case '.':return [1, 'staccato'];
			case 'u':return [1, 'upbow'];
			case 'v':return [1, 'downbow'];
			case '~':return [1, 'irishroll'];
			case '!':
			case '+':
				var ret = tokenizer.getBrackettedSubstring(line, i, 5);
				// Be sure that the accent is recognizable.
			if (ret[1].length > 0 && (ret[1].charAt(0) === '^' || ret[1].charAt(0) ==='_'))
					ret[1] = ret[1].substring(1);	// TODO-PER: The test files have indicators forcing the ornament to the top or bottom, but that isn't in the standard. We'll just ignore them.
				if (parseCommon.detect(legalAccents, function(acc) {
					return (ret[1] === acc);
				}))
					return ret;
				if (parseCommon.detect(volumeDecorations, function(acc) {
						return (ret[1] === acc);
					})) {
					if (multilineVars.volumePosition === 'hidden' )
						ret[1] = '';
						return ret;
				}
				if (parseCommon.detect(dynamicDecorations, function(acc) {
						return (ret[1] === acc);
					})) {
					if (multilineVars.dynamicPosition === 'hidden' )
						ret[1] = '';
						return ret;
				}

				if (parseCommon.detect(accentPseudonyms, function(acc) {
					if (ret[1] === acc[0]) {
						ret[1] = acc[1];
						return true;
					} else
						return false;
				}))
					return ret;

				if (parseCommon.detect(accentDynamicPseudonyms, function(acc) {
					if (ret[1] === acc[0]) {
						ret[1] = acc[1];
						return true;
					} else
						return false;
				})) {
					if (multilineVars.dynamicPosition === 'hidden' )
						ret[1] = '';
						return ret;
				}
				// We didn't find the accent in the list, so consume the space, but don't return an accent.
				// Although it is possible that ! was used as a line break, so accept that.
			if (line.charAt(i) === '!' && (ret[0] === 1 || line.charAt(i+ret[0]-1) !== '!'))
					return [1, null ];
				warn("Unknown decoration: " + ret[1], line, i);
				ret[1] = "";
				return ret;
			case 'H':return [1, 'fermata'];
			case 'J':return [1, 'slide'];
			case 'L':return [1, 'accent'];
			case 'M':return [1, 'mordent'];
			case 'O':return[1, 'coda'];
			case 'P':return[1, 'pralltriller'];
			case 'R':return [1, 'roll'];
			case 'S':return [1, 'segno'];
			case 'T':return [1, 'trill'];
		}
		return [0, 0];
	};

	var letter_to_spacer = function(line, i)
	{
		var start = i;
		while (tokenizer.isWhiteSpace(line.charAt(i)))
			i++;
		return [ i-start ];
	};

	// returns the class of the bar line
	// the number of the repeat
	// and the number of characters used up
	// if 0 is returned, then the next element was not a bar line
	var letter_to_bar = function(line, curr_pos)
	{
		var ret = tokenizer.getBarLine(line, curr_pos);
		if (ret.len === 0)
			return [0,""];
		if (ret.warn) {
			warn(ret.warn, line, curr_pos);
			return [ret.len,""];
		}

		// Now see if this is a repeated ending
		// A repeated ending is all of the characters 1,2,3,4,5,6,7,8,9,0,-, and comma
		// It can also optionally start with '[', which is ignored.
		// Also, it can have white space before the '['.
		for (var ws = 0; ws < line.length; ws++)
			if (line.charAt(curr_pos + ret.len + ws) !== ' ')
				break;
		var orig_bar_len = ret.len;
		if (line.charAt(curr_pos+ret.len+ws) === '[') {
			ret.len += ws + 1;
		}

		// It can also be a quoted string. It is unclear whether that construct requires '[', but it seems like it would. otherwise it would be confused with a regular chord.
		if (line.charAt(curr_pos+ret.len) === '"' && line.charAt(curr_pos+ret.len-1) === '[') {
			var ending = tokenizer.getBrackettedSubstring(line, curr_pos+ret.len, 5);
			return [ret.len+ending[0], ret.token, ending[1]];
		}
		var retRep = tokenizer.getTokenOf(line.substring(curr_pos+ret.len), "1234567890-,");
		if (retRep.len === 0 || retRep.token[0] === '-')
			return [orig_bar_len, ret.token];

		return [ret.len+retRep.len, ret.token, retRep.token];
	};

	var tripletQ = {
		2: 3,
		3: 2,
		4: 3,
		5: 2, // TODO-PER: not handling 6/8 rhythm yet
		6: 2,
		7: 2, // TODO-PER: not handling 6/8 rhythm yet
		8: 3,
		9: 2 // TODO-PER: not handling 6/8 rhythm yet
	};
	var letter_to_open_slurs_and_triplets =  function(line, i) {
		// consume spaces, and look for all the open parens. If there is a number after the open paren,
		// that is a triplet. Otherwise that is a slur. Collect all the slurs and the first triplet.
		var ret = {};
		var start = i;
		while (line.charAt(i) === '(' || tokenizer.isWhiteSpace(line.charAt(i))) {
			if (line.charAt(i) === '(') {
				if (i+1 < line.length && (line.charAt(i+1) >= '2' && line.charAt(i+1) <= '9')) {
					if (ret.triplet !== undefined)
						warn("Can't nest triplets", line, i);
					else {
						ret.triplet = line.charAt(i+1) - '0';
						ret.tripletQ = tripletQ[ret.triplet];
						ret.num_notes = ret.triplet;
						if (i+2 < line.length && line.charAt(i+2) === ':') {
							// We are expecting "(p:q:r" or "(p:q" or "(p::r"
							// That is: "put p notes into the time of q for the next r notes"
							// if r is missing, then it is equal to p.
							// if q is missing, it is determined from this table:
							// (2 notes in the time of 3
							// (3 notes in the time of 2
							// (4 notes in the time of 3
							// (5 notes in the time of n | if time sig is (6/8, 9/8, 12/8), n=3, else n=2
							// (6 notes in the time of 2
							// (7 notes in the time of n
							// (8 notes in the time of 3
							// (9 notes in the time of n
							if (i+3 < line.length && line.charAt(i+3) === ':') {
								// The second number, 'q', is not present.
								if (i+4 < line.length && (line.charAt(i+4) >= '1' && line.charAt(i+4) <= '9')) {
									ret.num_notes = line.charAt(i+4) - '0';
									i += 3;
								} else
									warn("expected number after the two colons after the triplet to mark the duration", line, i);
							} else if (i+3 < line.length && (line.charAt(i+3) >= '1' && line.charAt(i+3) <= '9')) {
								ret.tripletQ = line.charAt(i+3) - '0';
								if (i+4 < line.length && line.charAt(i+4) === ':') {
									if (i+5 < line.length && (line.charAt(i+5) >= '1' && line.charAt(i+5) <= '9')) {
										ret.num_notes = line.charAt(i+5) - '0';
										i += 4;
									}
								} else {
									i += 2;
								}
							} else
								warn("expected number after the triplet to mark the duration", line, i);
						}
					}
					i++;
				}
				else {
					if (ret.startSlur === undefined)
						ret.startSlur = 1;
					else
						ret.startSlur++;
				}
			}
			i++;
		}
		ret.consumed = i-start;
		return ret;
	};

	var addWords = function(line, words) {
		if (!line) { warn("Can't add words before the first line of music", line, 0); return; }
		words = parseCommon.strip(words);
		if (words.charAt(words.length-1) !== '-')
			words = words + ' ';	// Just makes it easier to parse below, since every word has a divider after it.
		var word_list = [];
		// first make a list of words from the string we are passed. A word is divided on either a space or dash.
		var last_divider = 0;
		var replace = false;
		var addWord = function(i) {
			var word = parseCommon.strip(words.substring(last_divider, i));
			last_divider = i+1;
			if (word.length > 0) {
				if (replace)
					word = parseCommon.gsub(word,'~', ' ');
				var div = words.charAt(i);
				if (div !== '_' && div !== '-')
					div = ' ';
				word_list.push({syllable: tokenizer.translateString(word), divider: div});
				replace = false;
				return true;
			}
			return false;
		};
		for (var i = 0; i < words.length; i++) {
			switch (words.charAt(i)) {
				case ' ':
				case '\x12':
					addWord(i);
					break;
				case '-':
					if (!addWord(i) && word_list.length > 0) {
						parseCommon.last(word_list).divider = '-';
						word_list.push({skip: true, to: 'next'});
					}
					break;
				case '_':
					addWord(i);
					word_list.push({skip: true, to: 'slur'});
					break;
				case '*':
					addWord(i);
					word_list.push({skip: true, to: 'next'});
					break;
				case '|':
					addWord(i);
					word_list.push({skip: true, to: 'bar'});
					break;
				case '~':
					replace = true;
					break;
			}
		}

		var inSlur = false;
		parseCommon.each(line, function(el) {
			if (word_list.length !== 0) {
				if (word_list[0].skip) {
					switch (word_list[0].to) {
						case 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;
						case 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;
						case 'bar': if (el.el_type === 'bar') word_list.shift(); break;
					}
					if (el.el_type !== 'bar') {
						if (el.lyric === undefined)
							el.lyric = [{syllable: "", divider: " "}];
						else
							el.lyric.push({syllable: "", divider: " "});
					}
				} else {
					if (el.el_type === 'note' && el.rest === undefined && !inSlur) {
						var lyric = word_list.shift();
						if (lyric.syllable)
							lyric.syllable = lyric.syllable.replace(/ +/g,'\xA0');
						if (el.lyric === undefined)
							el.lyric = [ lyric ];
						else
							el.lyric.push(lyric);
					}
				}
			}
		});
	};

	var addSymbols = function(line, words) {
		// TODO-PER: Currently copied from w: line. This needs to be read as symbols instead.
		if (!line) { warn("Can't add symbols before the first line of music", line, 0); return; }
		words = parseCommon.strip(words);
		if (words.charAt(words.length-1) !== '-')
			words = words + ' ';	// Just makes it easier to parse below, since every word has a divider after it.
		var word_list = [];
		// first make a list of words from the string we are passed. A word is divided on either a space or dash.
		var last_divider = 0;
		var replace = false;
		var addWord = function(i) {
			var word = parseCommon.strip(words.substring(last_divider, i));
			last_divider = i+1;
			if (word.length > 0) {
				if (replace)
					word = parseCommon.gsub(word, '~', ' ');
				var div = words.charAt(i);
				if (div !== '_' && div !== '-')
					div = ' ';
				word_list.push({syllable: tokenizer.translateString(word), divider: div});
				replace = false;
				return true;
			}
			return false;
		};
		for (var i = 0; i < words.length; i++) {
			switch (words.charAt(i)) {
				case ' ':
				case '\x12':
					addWord(i);
					break;
				case '-':
					if (!addWord(i) && word_list.length > 0) {
						parseCommon.last(word_list).divider = '-';
						word_list.push({skip: true, to: 'next'});
					}
					break;
				case '_':
					addWord(i);
					word_list.push({skip: true, to: 'slur'});
					break;
				case '*':
					addWord(i);
					word_list.push({skip: true, to: 'next'});
					break;
				case '|':
					addWord(i);
					word_list.push({skip: true, to: 'bar'});
					break;
				case '~':
					replace = true;
					break;
			}
		}

		var inSlur = false;
		parseCommon.each(line, function(el) {
			if (word_list.length !== 0) {
				if (word_list[0].skip) {
					switch (word_list[0].to) {
						case 'next': if (el.el_type === 'note' && el.pitches !== null && !inSlur) word_list.shift(); break;
						case 'slur': if (el.el_type === 'note' && el.pitches !== null) word_list.shift(); break;
						case 'bar': if (el.el_type === 'bar') word_list.shift(); break;
					}
				} else {
					if (el.el_type === 'note' && el.rest === undefined && !inSlur) {
						var lyric = word_list.shift();
						if (el.lyric === undefined)
							el.lyric = [ lyric ];
						else
							el.lyric.push(lyric);
					}
				}
			}
		});
	};

	var getBrokenRhythm = function(line, index) {
		switch (line.charAt(index)) {
			case '>':
			if (index < line.length - 1 && line.charAt(index+1) === '>')	// double >>
					return [2, 1.75, 0.25];
				else
					return [1, 1.5, 0.5];
				break;
			case '<':
			if (index < line.length - 1 && line.charAt(index+1) === '<')	// double <<
					return [2, 0.25, 1.75];
				else
					return [1, 0.5, 1.5];
				break;
		}
		return null;
	};

	// TODO-PER: make this a method in el.
	var addEndBeam = function(el) {
		if (el.duration !== undefined && el.duration < 0.25)
			el.end_beam = true;
		return el;
	};

	var pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};
	var rests = {x: 'invisible', y: 'spacer', z: 'rest', Z: 'multimeasure' };
	var getCoreNote = function(line, index, el, canHaveBrokenRhythm) {
		//var el = { startChar: index };
		var isComplete = function(state) {
			return (state === 'octave' || state === 'duration' || state === 'Zduration' || state === 'broken_rhythm' || state === 'end_slur');
		};
		var state = 'startSlur';
		var durationSetByPreviousNote = false;
		while (1) {
			switch(line.charAt(index)) {
				case '(':
					if (state === 'startSlur') {
						if (el.startSlur === undefined) el.startSlur = 1; else el.startSlur++;
					} else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case ')':
					if (isComplete(state)) {
						if (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;
					} else return null;
					break;
				case '^':
					if (state === 'startSlur') {el.accidental = 'sharp';state = 'sharp2';}
					else if (state === 'sharp2') {el.accidental = 'dblsharp';state = 'pitch';}
					else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case '_':
					if (state === 'startSlur') {el.accidental = 'flat';state = 'flat2';}
					else if (state === 'flat2') {el.accidental = 'dblflat';state = 'pitch';}
					else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case '=':
					if (state === 'startSlur') {el.accidental = 'natural';state = 'pitch';}
					else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
					if (state === 'startSlur' || state === 'sharp2' || state === 'flat2' || state === 'pitch') {
						el.pitch = pitches[line.charAt(index)];
						transpose.note(multilineVars, el);
						state = 'octave';
						// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below
						if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
							el.duration = multilineVars.default_length * multilineVars.next_note_duration;
							multilineVars.next_note_duration = 0;
							durationSetByPreviousNote = true;
						} else
							el.duration = multilineVars.default_length;
						// If the clef is percussion, there is probably some translation of the pitch to a particular drum kit item.
						if ((multilineVars.clef && multilineVars.clef.type === "perc") ||
							(multilineVars.currentVoice && multilineVars.currentVoice.clef === "perc")) {
							var key = line.charAt(index);
							if (el.accidental) {
								var accMap = { 'dblflat': '__', 'flat': '_', 'natural': '=', 'sharp': '^', 'dblsharp': '^^'};
								key = accMap[el.accidental] + key;
							}
							if (tune.formatting && tune.formatting.midi && tune.formatting.midi.drummap)
								el.midipitch = tune.formatting.midi.drummap[key];
						}
					} else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case ',':
					if (state === 'octave') {el.pitch -= 7;}
					else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case '\'':
					if (state === 'octave') {el.pitch += 7;}
					else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case 'x':
				case 'y':
				case 'z':
				case 'Z':
					if (state === 'startSlur') {
						el.rest = { type: rests[line.charAt(index)] };
						// There shouldn't be some of the properties that notes have. If some sneak in due to bad syntax in the abc file,
						// just nix them here.
						delete el.accidental;
						delete el.startSlur;
						delete el.startTie;
						delete el.endSlur;
						delete el.endTie;
						delete el.end_beam;
						delete el.grace_notes;
						// At this point we have a valid note. The rest is optional. Set the duration in case we don't get one below
						if (el.rest.type === 'multimeasure') {
							el.duration = 1;
							state = 'Zduration';
						} else {
							if (canHaveBrokenRhythm && multilineVars.next_note_duration !== 0) {
								el.duration = multilineVars.default_length * multilineVars.next_note_duration;
								multilineVars.next_note_duration = 0;
								durationSetByPreviousNote = true;
							} else
								el.duration = multilineVars.default_length;
							state = 'duration';
						}
					} else if (isComplete(state)) {el.endChar = index;return el;}
					else return null;
					break;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case '0':
				case '/':
					if (state === 'octave' || state === 'duration') {
						var fraction = tokenizer.getFraction(line, index);
						//if (!durationSetByPreviousNote)
							el.duration = el.duration * fraction.value;
						// TODO-PER: We can test the returned duration here and give a warning if it isn't the one expected.
						el.endChar = fraction.index;
						while (fraction.index < line.length && (tokenizer.isWhiteSpace(line.charAt(fraction.index)) || line.charAt(fraction.index) === '-')) {
							if (line.charAt(fraction.index) === '-')
								el.startTie = {};
							else
								el = addEndBeam(el);
							fraction.index++;
						}
						index = fraction.index-1;
						state = 'broken_rhythm';
					} else if (state === 'sharp2') {
						el.accidental = 'quartersharp';state = 'pitch';
					} else if (state === 'flat2') {
						el.accidental = 'quarterflat';state = 'pitch';
					} else if (state === 'Zduration') {
						var num = tokenizer.getNumber(line, index);
						el.duration = num.num;
						el.endChar = num.index;
						return el;
					} else return null;
					break;
				case '-':
					if (state === 'startSlur') {
						// This is the first character, so it must have been meant for the previous note. Correct that here.
						tune.addTieToLastNote();
						el.endTie = true;
					} else if (state === 'octave' || state === 'duration' || state === 'end_slur') {
						el.startTie = {};
						if (!durationSetByPreviousNote && canHaveBrokenRhythm)
							state = 'broken_rhythm';
						else {
							// Peek ahead to the next character. If it is a space, then we have an end beam.
							if (tokenizer.isWhiteSpace(line.charAt(index + 1)))
								addEndBeam(el);
							el.endChar = index+1;
							return el;
						}
					} else if (state === 'broken_rhythm') {el.endChar = index;return el;}
					else return null;
					break;
				case ' ':
				case '\t':
					if (isComplete(state)) {
						el.end_beam = true;
						// look ahead to see if there is a tie
						do {
							if (line.charAt(index) === '-')
								el.startTie = {};
							index++;
						} while (index < line.length && (tokenizer.isWhiteSpace(line.charAt(index)) || line.charAt(index) === '-'));
						el.endChar = index;
						if (!durationSetByPreviousNote && canHaveBrokenRhythm && (line.charAt(index) === '<' || line.charAt(index) === '>')) {	// TODO-PER: Don't need the test for < and >, but that makes the endChar work out for the regression test.
							index--;
							state = 'broken_rhythm';
						} else
							return el;
					}
					else return null;
					break;
				case '>':
				case '<':
					if (isComplete(state)) {
						if (canHaveBrokenRhythm) {
							var br2 = getBrokenRhythm(line, index);
							index += br2[0] - 1;	// index gets incremented below, so we'll let that happen
							multilineVars.next_note_duration = br2[2];
							el.duration = br2[1]*el.duration;
							state = 'end_slur';
						} else {
							el.endChar = index;
							return el;
						}
					} else
						return null;
					break;
				default:
					if (isComplete(state)) {
						el.endChar = index;
						return el;
					}
					return null;
			}
			index++;
			if (index === line.length) {
				if (isComplete(state)) {el.endChar = index;return el;}
				else return null;
			}
		}
		return null;
	};

	function startNewLine() {
		var params = { startChar: -1, endChar: -1};
		if (multilineVars.partForNextLine.title)
			params.part = multilineVars.partForNextLine;
		params.clef = multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].clef !== undefined ? parseCommon.clone(multilineVars.staves[multilineVars.currentVoice.staffNum].clef) : parseCommon.clone(multilineVars.clef);
		var scoreTranspose = multilineVars.currentVoice ? multilineVars.currentVoice.scoreTranspose : 0;
		params.key = parseKeyVoice.standardKey(multilineVars.key.root+multilineVars.key.acc+multilineVars.key.mode, multilineVars.key.root, multilineVars.key.acc, scoreTranspose);
		params.key.mode = multilineVars.key.mode;
		if (multilineVars.key.impliedNaturals)
			params.key.impliedNaturals = multilineVars.key.impliedNaturals;
		if (multilineVars.key.explicitAccidentals) {
			for (var i = 0; i < multilineVars.key.explicitAccidentals.length; i++) {
				var found = false;
				for (var j = 0; j < params.key.accidentals.length; j++) {
					if (params.key.accidentals[j].note === multilineVars.key.explicitAccidentals[i].note) {
						// If the note is already in the list, override it with the new value
						params.key.accidentals[j].acc = multilineVars.key.explicitAccidentals[i].acc;
						found = true;
					}
				}
				if (!found)
					params.key.accidentals.push(multilineVars.key.explicitAccidentals[i]);
			}
		}
		multilineVars.targetKey = params.key;
		if (params.key.explicitAccidentals)
			delete params.key.explicitAccidentals;
		parseKeyVoice.addPosToKey(params.clef, params.key);
		if (multilineVars.meter !== null) {
			if (multilineVars.currentVoice) {
				parseCommon.each(multilineVars.staves, function(st) {
					st.meter = multilineVars.meter;
				});
				params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
				multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
			} else
				params.meter = multilineVars.meter;
			multilineVars.meter = null;
		} else if (multilineVars.currentVoice && multilineVars.staves[multilineVars.currentVoice.staffNum].meter) {
			// Make sure that each voice gets the meter marking.
			params.meter = multilineVars.staves[multilineVars.currentVoice.staffNum].meter;
			multilineVars.staves[multilineVars.currentVoice.staffNum].meter = null;
		}
		if (multilineVars.currentVoice && multilineVars.currentVoice.name)
			params.name = multilineVars.currentVoice.name;
		if (multilineVars.vocalfont)
			params.vocalfont = multilineVars.vocalfont;
		if (multilineVars.tripletfont)
			params.tripletfont = multilineVars.tripletfont;
		if (multilineVars.style)
			params.style = multilineVars.style;
		if (multilineVars.currentVoice) {
			var staff = multilineVars.staves[multilineVars.currentVoice.staffNum];
			if (staff.brace) params.brace = staff.brace;
			if (staff.bracket) params.bracket = staff.bracket;
			if (staff.connectBarLines) params.connectBarLines = staff.connectBarLines;
			if (staff.name) params.name = staff.name[multilineVars.currentVoice.index];
			if (staff.subname) params.subname = staff.subname[multilineVars.currentVoice.index];
			if (multilineVars.currentVoice.stem)
				params.stem = multilineVars.currentVoice.stem;
			if (multilineVars.currentVoice.stafflines)
				params.stafflines = multilineVars.currentVoice.stafflines;
			if (multilineVars.currentVoice.staffscale)
				params.staffscale = multilineVars.currentVoice.staffscale;
			if (multilineVars.currentVoice.scale)
				params.scale = multilineVars.currentVoice.scale;
			if (multilineVars.currentVoice.style)
				params.style = multilineVars.currentVoice.style;
			if (multilineVars.currentVoice.transpose)
				params.clef.transpose = multilineVars.currentVoice.transpose;
		}
		var isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);
		if (multilineVars.barNumbers === 0 && isFirstVoice && multilineVars.currBarNumber !== 1)
			params.barNumber = multilineVars.currBarNumber;
		tune.startNewLine(params);
		if (multilineVars.key.impliedNaturals)
			delete multilineVars.key.impliedNaturals;

		multilineVars.partForNextLine = {};
	}

	var letter_to_grace =  function(line, i) {
		// Grace notes are an array of: startslur, note, endslur, space; where note is accidental, pitch, duration
		if (line.charAt(i) === '{') {
			// fetch the gracenotes string and consume that into the array
			var gra = tokenizer.getBrackettedSubstring(line, i, 1, '}');
			if (!gra[2])
				warn("Missing the closing '}' while parsing grace note", line, i);
			// If there is a slur after the grace construction, then move it to the last note inside the grace construction
			if (line[i+gra[0]] === ')') {
				gra[0]++;
				gra[1] += ')';
			}

			var gracenotes = [];
			var ii = 0;
			var inTie = false;
			while (ii < gra[1].length) {
				var acciaccatura = false;
				if (gra[1].charAt(ii) === '/') {
					acciaccatura = true;
					ii++;
				}
				var note = getCoreNote(gra[1], ii, {}, false);
				if (note !== null) {
					// The grace note durations should not be affected by the default length: they should be based on 1/16, so if that isn't the default, then multiply here.
					note.duration = note.duration / (multilineVars.default_length * 8);
					if (acciaccatura)
						note.acciaccatura = true;
					gracenotes.push(note);

					if (inTie) {
						note.endTie = true;
						inTie = false;
					}
					if (note.startTie)
						inTie = true;

					ii  = note.endChar;
					delete note.endChar;
				}
				else {
					// We shouldn't get anything but notes or a space here, so report an error
					if (gra[1].charAt(ii) === ' ') {
						if (gracenotes.length > 0)
							gracenotes[gracenotes.length-1].end_beam = true;
					} else
						warn("Unknown character '" + gra[1].charAt(ii) + "' while parsing grace note", line, i);
					ii++;
				}
			}
			if (gracenotes.length)
				return [gra[0], gracenotes];
		}
		return [ 0 ];
	};

	function letter_to_overlay(line, i) {
		if (line.charAt(i) === '&') {
			var start = i;
			while (line.charAt(i) && line.charAt(i) !== ':' && line.charAt(i) !== '|')
				i++;
			return [ i-start, line.substring(start+1, i) ];
		}
		return [ 0 ];
	}

	function durationOfMeasure(multilineVars) {
		// TODO-PER: This could be more complicated if one of the unusual measures is used.
		var meter = multilineVars.origMeter;
		if (!meter || meter.type !== 'specified')
			return 1;
		if (!meter.value || meter.value.length === 0)
			return 1;
		return parseInt(meter.value[0].num, 10) / parseInt(meter.value[0].den, 10);
	}

	//
	// Parse line of music
	//
	// This is a stream of <(bar-marking|header|note-group)...> in any order, with optional spaces between each element
	// core-note is <open-slur, accidental, pitch:required, octave, duration, close-slur&|tie> with no spaces within that
	// chord is <open-bracket:required, core-note:required... close-bracket:required duration> with no spaces within that
	// grace-notes is <open-brace:required, (open-slur|core-note:required|close-slur)..., close-brace:required> spaces are allowed
	// note-group is <grace-notes, chord symbols&|decorations..., grace-notes, slur&|triplet, chord|core-note, end-slur|tie> spaces are allowed between items
	// bar-marking is <ampersand> or <chord symbols&|decorations..., bar:required> spaces allowed
	// header is <open-bracket:required, K|M|L|V:required, colon:required, field:required, close-bracket:required> spaces can occur between the colon, in the field, and before the close bracket
	// header can also be the only thing on a line. This is true even if it is a continuation line. In this case the brackets are not required.
	// a space is a back-tick, a space, or a tab. If it is a back-tick, then there is no end-beam.

	// Line preprocessing: anything after a % is ignored (the double %% should have been taken care of before this)
	// Then, all leading and trailing spaces are ignored.
	// If there was a line continuation, the \n was replaced by a \r and the \ was replaced by a space. This allows the construct
	// of having a header mid-line conceptually, but actually be at the start of the line. This is equivolent to putting the header in [ ].

	// TODO-PER: How to handle ! for line break?
	// TODO-PER: dots before bar, dots before slur
	// TODO-PER: U: redefinable symbols.

	// Ambiguous symbols:
	// "[" can be the start of a chord, the start of a header element or part of a bar line.
	// --- if it is immediately followed by "|", it is a bar line
	// --- if it is immediately followed by K: L: M: V: it is a header (note: there are other headers mentioned in the standard, but I'm not sure how they would be used.)
	// --- otherwise it is the beginning of a chord
	// "(" can be the start of a slur or a triplet
	// --- if it is followed by a number from 2-9, then it is a triplet
	// --- otherwise it is a slur
	// "]"
	// --- if there is a chord open, then this is the close
	// --- if it is after a [|, then it is an invisible bar line
	// --- otherwise, it is par of a bar
	// "." can be a bar modifier or a slur modifier, or a decoration
	// --- if it comes immediately before a bar, it is a bar modifier
	// --- if it comes immediately before a slur, it is a slur modifier
	// --- otherwise it is a decoration for the next note.
	// number:
	// --- if it is after a bar, with no space, it is an ending marker
	// --- if it is after a ( with no space, it is a triplet count
	// --- if it is after a pitch or octave or slash, then it is a duration

	// Unambiguous symbols (except inside quoted strings):
	// vertical-bar, colon: part of a bar
	// ABCDEFGabcdefg: pitch
	// xyzZ: rest
	// comma, prime: octave
	// close-paren: end-slur
	// hyphen: tie
	// tilde, v, u, bang, plus, THLMPSO: decoration
	// carat, underscore, equal: accidental
	// ampersand: time reset
	// open-curly, close-curly: grace notes
	// double-quote: chord symbol
	// less-than, greater-than, slash: duration
	// back-tick, space, tab: space
	var nonDecorations = "ABCDEFGabcdefgxyzZ[]|^_{";	// use this to prescreen so we don't have to look for a decoration at every note.

	var parseRegularMusicLine = function(line) {
		header.resolveTempo();
		//multilineVars.havent_set_length = false;	// To late to set this now.
		multilineVars.is_in_header = false;	// We should have gotten a key header by now, but just in case, this is definitely out of the header.
		var i = 0;
		var startOfLine = multilineVars.iChar;
		// see if there is nothing but a comment on this line. If so, just ignore it. A full line comment is optional white space followed by %
		while (tokenizer.isWhiteSpace(line.charAt(i)) && i < line.length)
			i++;
		if (i === line.length || line.charAt(i) === '%')
			return;

		// Start with the standard staff, clef and key symbols on each line
		var delayStartNewLine = multilineVars.start_new_line;
		if (multilineVars.continueall === undefined)
			multilineVars.start_new_line = true;
		else
			multilineVars.start_new_line = false;
		var tripletNotesLeft = 0;

		// See if the line starts with a header field
		var retHeader = header.letter_to_body_header(line, i);
		if (retHeader[0] > 0) {
			i += retHeader[0];
			if (retHeader[1] === 'V')
				delayStartNewLine = true; // fixes bug on this: c[V:2]d
			// TODO-PER: Handle inline headers
		}
		var el = { };

		var overlayLevel = 0;
		while (i < line.length)
		{
			var startI = i;
			if (line.charAt(i) === '%')
				break;

			var retInlineHeader = header.letter_to_inline_header(line, i);
			if (retInlineHeader[0] > 0) {
					i += retInlineHeader[0];
					if (retInlineHeader[1] === 'V')
						delayStartNewLine = true; // fixes bug on this: c[V:2]d
					// TODO-PER: Handle inline headers
					//multilineVars.start_new_line = false;
			} else {
				// Wait until here to actually start the line because we know we're past the inline statements.
				if (delayStartNewLine) {
					startNewLine();
					delayStartNewLine = false;
				}

				// We need to decide if the following characters are a bar-marking or a note-group.
				// Unfortunately, that is ambiguous. Both can contain chord symbols and decorations.
				// If there is a grace note either before or after the chord symbols and decorations, then it is definitely a note-group.
				// If there is a bar marker, it is definitely a bar-marking.
				// If there is either a core-note or chord, it is definitely a note-group.
				// So, loop while we find grace-notes, chords-symbols, or decorations. [It is an error to have more than one grace-note group in a row; the others can be multiple]
				// Then, if there is a grace-note, we know where to go.
				// Else see if we have a chord, core-note, slur, triplet, or bar.

				var ret;
				while (1) {
					ret = tokenizer.eatWhiteSpace(line, i);
					if (ret > 0) {
						i += ret;
					}
					if (i > 0 && line.charAt(i-1) === '\x12') {
						// there is one case where a line continuation isn't the same as being on the same line, and that is if the next character after it is a header.
						ret = header.letter_to_body_header(line, i);
						if (ret[0] > 0) {
							if (ret[1] === 'V')
								startNewLine(); // fixes bug on this: c\\nV:2]\\nd
							// TODO: insert header here
							i = ret[0];
							multilineVars.start_new_line = false;
						}
					}
					// gather all the grace notes, chord symbols and decorations
					ret = letter_to_spacer(line, i);
					if (ret[0] > 0) {
						i += ret[0];
					}

					ret = letter_to_chord(line, i);
					if (ret[0] > 0) {
						// There could be more than one chord here if they have different positions.
						// If two chords have the same position, then connect them with newline.
						if (!el.chord)
							el.chord = [];
						var chordName = tokenizer.translateString(ret[1]);
						chordName = chordName.replace(/;/g, "\n");
						var addedChord = false;
						for (var ci = 0; ci < el.chord.length; ci++) {
							if (el.chord[ci].position === ret[2]) {
								addedChord = true;
								el.chord[ci].name += "\n" + chordName;
							}
						}
						if (addedChord === false) {
							if (ret[2] === null && ret[3])
								el.chord.push({name: chordName, rel_position: ret[3]});
							else
								el.chord.push({name: chordName, position: ret[2]});
						}

						i += ret[0];
						var ii = tokenizer.skipWhiteSpace(line.substring(i));
						if (ii > 0)
							el.force_end_beam_last = true;
						i += ii;
					} else {
						if (nonDecorations.indexOf(line.charAt(i)) === -1)
							ret = letter_to_accent(line, i);
						else ret = [ 0 ];
						if (ret[0] > 0) {
							if (ret[1] === null) {
								if (i + 1 < line.length)
									startNewLine();	// There was a ! in the middle of the line. Start a new line if there is anything after it.
							} else if (ret[1].length > 0) {
								if (ret[1].indexOf("style=") === 0) {
									el.style = ret[1].substr(6);
								} else {
									if (el.decoration === undefined)
										el.decoration = [];
									el.decoration.push(ret[1]);
								}
							}
							i += ret[0];
						} else {
							ret = letter_to_grace(line, i);
							// TODO-PER: Be sure there aren't already grace notes defined. That is an error.
							if (ret[0] > 0) {
								el.gracenotes = ret[1];
								i += ret[0];
							} else
								break;
						}
					}
				}

				ret = letter_to_bar(line, i);
				if (ret[0] > 0) {
					// This is definitely a bar
					overlayLevel = 0;
					if (el.gracenotes !== undefined) {
						// Attach the grace note to an invisible note
						el.rest = { type: 'spacer' };
						el.duration = 0.125; // TODO-PER: I don't think the duration of this matters much, but figure out if it does.
						multilineVars.addFormattingOptions(el, tune.formatting, 'note');
						tune.appendElement('note', startOfLine+i, startOfLine+i+ret[0], el);
						multilineVars.measureNotEmpty = true;
						el = {};
					}
					var bar = {type: ret[1]};
					if (bar.type.length === 0)
						warn("Unknown bar type", line, i);
					else {
						if (multilineVars.inEnding && bar.type !== 'bar_thin') {
							bar.endEnding = true;
							multilineVars.inEnding = false;
						}
						if (ret[2]) {
							bar.startEnding = ret[2];
							if (multilineVars.inEnding)
								bar.endEnding = true;
							multilineVars.inEnding = true;
						}
						if (el.decoration !== undefined)
							bar.decoration = el.decoration;
						if (el.chord !== undefined)
							bar.chord = el.chord;
						if (bar.startEnding && multilineVars.barFirstEndingNum === undefined)
							multilineVars.barFirstEndingNum = multilineVars.currBarNumber;
						else if (bar.startEnding && bar.endEnding && multilineVars.barFirstEndingNum)
							multilineVars.currBarNumber = multilineVars.barFirstEndingNum;
						else if (bar.endEnding)
							multilineVars.barFirstEndingNum = undefined;
						if (bar.type !== 'bar_invisible' && multilineVars.measureNotEmpty) {
							var isFirstVoice = multilineVars.currentVoice === undefined || (multilineVars.currentVoice.staffNum ===  0 && multilineVars.currentVoice.index ===  0);
							if (isFirstVoice) {
								multilineVars.currBarNumber++;
								if (multilineVars.barNumbers && multilineVars.currBarNumber % multilineVars.barNumbers === 0)
									bar.barNumber = multilineVars.currBarNumber;
							}
						}
						multilineVars.addFormattingOptions(el, tune.formatting, 'bar');
						tune.appendElement('bar', startOfLine+i, startOfLine+i+ret[0], bar);
						multilineVars.measureNotEmpty = false;
						el = {};
					}
					i += ret[0];
					var cv = multilineVars.currentVoice ? multilineVars.currentVoice.staffNum + '-' + multilineVars.currentVoice.index : 'ONLY';
					// if (multilineVars.lineBreaks) {
					// 	if (!multilineVars.barCounter[cv])
					// 		multilineVars.barCounter[cv] = 0;
					// 	var breakNow = multilineVars.lineBreaks[''+multilineVars.barCounter[cv]];
					// 	multilineVars.barCounter[cv]++;
					// 	if (breakNow)
					// 		startNewLine();
					// }
				} else if (line[i] === '&') {	// backtrack to beginning of measure
					ret = letter_to_overlay(line, i);
					if (ret[0] > 0) {
						tune.appendElement('overlay', startOfLine, startOfLine+1, {});
						i += 1;
						overlayLevel++;
					}

				} else {
					// This is definitely a note group
					//
					// Look for as many open slurs and triplets as there are. (Note: only the first triplet is valid.)
					ret = letter_to_open_slurs_and_triplets(line, i);
					if (ret.consumed > 0) {
						if (ret.startSlur !== undefined)
							el.startSlur = ret.startSlur;
						if (ret.triplet !== undefined) {
							if (tripletNotesLeft > 0)
								warn("Can't nest triplets", line, i);
							else {
								el.startTriplet = ret.triplet;
								el.tripletMultiplier = ret.tripletQ / ret.triplet;
								tripletNotesLeft = ret.num_notes === undefined ? ret.triplet : ret.num_notes;
							}
						}
						i += ret.consumed;
					}

					// handle chords.
					if (line.charAt(i) === '[') {
						var chordStartChar = i;
						i++;
						var chordDuration = null;
						var rememberEndBeam = false;

						var done = false;
						while (!done) {
							var accent = letter_to_accent(line, i);
							if (accent[0] > 0) {
								i += accent[0];
							}

							var chordNote = getCoreNote(line, i, {}, false);
							if (chordNote !== null) {
								if (accent[0] > 0) { // If we found a decoration above, it modifies the entire chord. "style" is handled below.
									if (accent[1].indexOf("style=") !== 0) {
										if (el.decoration === undefined)
											el.decoration = [];
										el.decoration.push(accent[1]);
									}
								}
								if (chordNote.end_beam) {
									el.end_beam = true;
									delete chordNote.end_beam;
								}
								if (el.pitches === undefined) {
									el.duration = chordNote.duration;
									el.pitches = [ chordNote ];
								} else	// Just ignore the note lengths of all but the first note. The standard isn't clear here, but this seems less confusing.
									el.pitches.push(chordNote);
								delete chordNote.duration;
								if (accent[0] > 0) { // If we found a style above, it modifies the individual pitch, not the entire chord.
									if (accent[1].indexOf("style=") === 0) {
										el.pitches[el.pitches.length-1].style = accent[1].substr(6);
									}
								}

								if (multilineVars.inTieChord[el.pitches.length]) {
									chordNote.endTie = true;
									multilineVars.inTieChord[el.pitches.length] = undefined;
								}
								if (chordNote.startTie)
									multilineVars.inTieChord[el.pitches.length] = true;

								i  = chordNote.endChar;
								delete chordNote.endChar;
							} else if (line.charAt(i) === ' ') {
								// Spaces are not allowed in chords, but we can recover from it by ignoring it.
								warn("Spaces are not allowed in chords", line, i);
								i++;
							} else {
								if (i < line.length && line.charAt(i) === ']') {
									// consume the close bracket
									i++;

									if (multilineVars.next_note_duration !== 0) {
										el.duration = el.duration * multilineVars.next_note_duration;
										multilineVars.next_note_duration = 0;
									}

									if (isInTie(multilineVars,  overlayLevel, el)) {
										parseCommon.each(el.pitches, function(pitch) { pitch.endTie = true; });
										setIsInTie(multilineVars,  overlayLevel, false);
									}

									if (tripletNotesLeft > 0) {
										tripletNotesLeft--;
										if (tripletNotesLeft === 0) {
											el.endTriplet = true;
										}
									}

									var postChordDone = false;
									while (i < line.length && !postChordDone) {
										switch (line.charAt(i)) {
											case ' ':
											case '\t':
												addEndBeam(el);
												break;
											case ')':
												if (el.endSlur === undefined) el.endSlur = 1; else el.endSlur++;
												break;
											case '-':
												parseCommon.each(el.pitches, function(pitch) { pitch.startTie = {}; });
												setIsInTie(multilineVars,  overlayLevel, true);
												break;
											case '>':
											case '<':
												var br2 = getBrokenRhythm(line, i);
												i += br2[0] - 1;	// index gets incremented below, so we'll let that happen
												multilineVars.next_note_duration = br2[2];
												if (chordDuration)
													chordDuration = chordDuration * br2[1];
												else
													chordDuration = br2[1];
												break;
											case '1':
											case '2':
											case '3':
											case '4':
											case '5':
											case '6':
											case '7':
											case '8':
											case '9':
											case '/':
												var fraction = tokenizer.getFraction(line, i);
												chordDuration = fraction.value;
												i = fraction.index;
												if (line.charAt(i) === ' ')
													rememberEndBeam = true;
												if (line.charAt(i) === '-' || line.charAt(i) === ')' || line.charAt(i) === ' ' || line.charAt(i) === '<' || line.charAt(i) === '>')
													i--; // Subtracting one because one is automatically added below
												else
													postChordDone = true;
												break;
											default:
												postChordDone = true;
												break;
										}
										if (!postChordDone) {
											i++;
										}
									}
								} else
									warn("Expected ']' to end the chords", line, i);

								if (el.pitches !== undefined) {
									if (chordDuration !== null) {
										el.duration = el.duration * chordDuration;
										if (rememberEndBeam)
											addEndBeam(el);
									}

									multilineVars.addFormattingOptions(el, tune.formatting, 'note');
									tune.appendElement('note', startOfLine+chordStartChar, startOfLine+i, el);
									multilineVars.measureNotEmpty = true;
									el = {};
								}
								done = true;
							}
						}

					} else {
						// Single pitch
						var el2 = {};
						var core = getCoreNote(line, i, el2, true);
						if (el2.endTie !== undefined) setIsInTie(multilineVars,  overlayLevel, true);
						if (core !== null) {
							if (core.pitch !== undefined) {
								el.pitches = [ { } ];
								// TODO-PER: straighten this out so there is not so much copying: getCoreNote shouldn't change e'
								if (core.accidental !== undefined) el.pitches[0].accidental = core.accidental;
								el.pitches[0].pitch = core.pitch;
								if (core.midipitch)
									el.pitches[0].midipitch = core.midipitch;
								if (core.endSlur !== undefined) el.pitches[0].endSlur = core.endSlur;
								if (core.endTie !== undefined) el.pitches[0].endTie = core.endTie;
								if (core.startSlur !== undefined) el.pitches[0].startSlur = core.startSlur;
								if (el.startSlur !== undefined) el.pitches[0].startSlur = el.startSlur;
								if (core.startTie !== undefined) el.pitches[0].startTie = core.startTie;
								if (el.startTie !== undefined) el.pitches[0].startTie = el.startTie;
							} else {
								el.rest = core.rest;
								if (core.endSlur !== undefined) el.endSlur = core.endSlur;
								if (core.endTie !== undefined) el.rest.endTie = core.endTie;
								if (core.startSlur !== undefined) el.startSlur = core.startSlur;
								if (core.startTie !== undefined) el.rest.startTie = core.startTie;
								if (el.startTie !== undefined) el.rest.startTie = el.startTie;
							}

							if (core.chord !== undefined) el.chord = core.chord;
							if (core.duration !== undefined) el.duration = core.duration;
							if (core.decoration !== undefined) el.decoration = core.decoration;
							if (core.graceNotes !== undefined) el.graceNotes = core.graceNotes;
							delete el.startSlur;
							if (isInTie(multilineVars,  overlayLevel, el)) {
								if (el.pitches !== undefined) {
									el.pitches[0].endTie = true;
								} else if (el.rest.type !== 'spacer') {
									el.rest.endTie = true;
								}
								setIsInTie(multilineVars,  overlayLevel, false);
							}
							if (core.startTie || el.startTie)
								setIsInTie(multilineVars,  overlayLevel, true);
							i  = core.endChar;

							if (tripletNotesLeft > 0) {
								tripletNotesLeft--;
								if (tripletNotesLeft === 0) {
									el.endTriplet = true;
								}
							}

							if (core.end_beam)
								addEndBeam(el);

							// If there is a whole rest, then it should be the duration of the measure, not it's own duration. We need to special case it.
							// If the time signature length is greater than 4/4, though, then a whole rest has no special treatment.
							if (el.rest && el.rest.type === 'rest' && el.duration === 1 && durationOfMeasure(multilineVars) <= 1) {
								el.rest.type = 'whole';

								el.duration = durationOfMeasure(multilineVars);
							}

							multilineVars.addFormattingOptions(el, tune.formatting, 'note');
							tune.appendElement('note', startOfLine+startI, startOfLine+i, el);
							multilineVars.measureNotEmpty = true;
							el = {};
						}
					}

					if (i === startI) {	// don't know what this is, so ignore it.
						if (line.charAt(i) !== ' ' && line.charAt(i) !== '`')
							warn("Unknown character ignored", line, i);
						i++;
					}
				}
			}
		}
	};

	var isInTie = function(multilineVars, overlayLevel, el) {
		if (multilineVars.inTie[overlayLevel] === undefined)
			return false;
		// If this is single voice music then the voice index isn't set, so we use the first voice.
		var voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;
		if (multilineVars.inTie[overlayLevel][voiceIndex]) {
			if (el.pitches !== undefined || el.rest.type !== 'spacer')
				return true;
		}
		return false;
	};

	var setIsInTie =function(multilineVars, overlayLevel, value) {
		// If this is single voice music then the voice index isn't set, so we use the first voice.
		var voiceIndex = multilineVars.currentVoice ? multilineVars.currentVoice.index : 0;
		if (multilineVars.inTie[overlayLevel] === undefined)
			multilineVars.inTie[overlayLevel] = [];
		multilineVars.inTie[overlayLevel][voiceIndex] = value;
	};

	var parseLine = function(line) {
		var ret = header.parseHeader(line);
		if (ret.regular)
			parseRegularMusicLine(ret.str);
		if (ret.newline)
			startNewLine();
		if (ret.words)
			addWords(tune.getCurrentVoice(), line.substring(2));
		if (ret.symbols)
			addSymbols(tune.getCurrentVoice(), line.substring(2));
		if (ret.recurse)
			parseLine(ret.str);
	};

	function appendLastMeasure(voice, nextVoice) {
		voice.push({
			el_type: 'hint'
		});
		for (var i = 0; i < nextVoice.length; i++) {
			var element = nextVoice[i];
			var hint = parseCommon.clone(element);
			voice.push(hint);
			if (element.el_type === 'bar')
					return;
		}
	}

	function addHintMeasure(staff, nextStaff) {
		for (var i = 0; i < staff.length; i++) {
			var stave = staff[i];
			var nextStave = nextStaff[i];
			if (nextStave) { // Be sure there is the same number of staves on the next line.
				for (var j = 0; j < nextStave.voices.length; j++) {
					var nextVoice = nextStave.voices[j];
					var voice = stave.voices[j];
					if (voice) { // Be sure there are the same number of voices on the previous line.
						appendLastMeasure(voice, nextVoice);
					}
				}
			}
		}
	}

	function addHintMeasures() {
		for (var i = 0; i < tune.lines.length; i++) {
			var line = tune.lines[i].staff;
			if (line) {
				var j = i+1;
				while (j < tune.lines.length && tune.lines[j].staff === undefined)
					j++;
				if (j < tune.lines.length) {
					var nextLine = tune.lines[j].staff;
					addHintMeasure(line, nextLine);
				}
			}
		}
	}

	this.parse = function(strTune, switches, startPos) {
		// the switches are optional and cause a difference in the way the tune is parsed.
		// switches.header_only : stop parsing when the header is finished
		// switches.stop_on_warning : stop at the first warning encountered.
		// switches.print: format for the page instead of the browser.
		// switches.format: a hash of the desired formatting commands.
		// switches.hint_measures: put the next measure at the end of the current line.
		// switches.transpose: change the key signature, chords, and notes by a number of half-steps.
		if (!switches) switches = {};
		if (!startPos) startPos = 0;
		tune.reset();
		if (switches.print)
			tune.media = 'print';
		multilineVars.reset();
		multilineVars.iChar = startPos;
		if (switches.visualTranspose) {
			multilineVars.globalTranspose = parseInt(switches.visualTranspose);
			if (multilineVars.globalTranspose === 0)
				multilineVars.globalTranspose = undefined;
		} else
			multilineVars.globalTranspose = undefined;
		if (switches.lineBreaks) {
			// change the format of the the line breaks for easy testing.
			// The line break numbers are 0-based and they reflect the last measure of the current line.
			multilineVars.lineBreaks = {};
			//multilineVars.continueall = true;
			for (var i = 0; i < switches.lineBreaks.length; i++)
				multilineVars.lineBreaks[''+(switches.lineBreaks[i]+1)] = true; // Add 1 so that the line break is the first measure of the next line.
		}
		header.reset(tokenizer, warn, multilineVars, tune);

		// Take care of whatever line endings come our way
		strTune = parseCommon.gsub(strTune, '\r\n', '\n');
		strTune = parseCommon.gsub(strTune, '\r', '\n');
		strTune += '\n';	// Tacked on temporarily to make the last line continuation work
		strTune = strTune.replace(/\n\\.*\n/g, "\n");	// get rid of latex commands.
		var continuationReplacement = function(all, backslash, comment){
			var spaces = "                                                                                                                                                                                                     ";
			var padding = comment ? spaces.substring(0, comment.length) : "";
			return backslash + " \x12" + padding;
		};
		strTune = strTune.replace(/\\([ \t]*)(%.*)*\n/g, continuationReplacement);	// take care of line continuations right away, but keep the same number of characters
		var lines = strTune.split('\n');
		if (parseCommon.last(lines).length === 0)	// remove the blank line we added above.
			lines.pop();
		try {
			if (switches.format) {
				parseDirective.globalFormatting(switches.format);
			}
			parseCommon.each(lines,  function(line) {
				if (switches.header_only && multilineVars.is_in_header === false)
					throw "normal_abort";
				if (switches.stop_on_warning && multilineVars.warnings)
					throw "normal_abort";
				if (multilineVars.is_in_history) {
					if (line.charAt(1) === ':') {
						multilineVars.is_in_history = false;
						parseLine(line);
					} else
						tune.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line)));
				} else if (multilineVars.inTextBlock) {
					if (parseCommon.startsWith(line, "%%endtext")) {
						//tune.addMetaText("textBlock", multilineVars.textBlock);
						tune.addText(multilineVars.textBlock);
						multilineVars.inTextBlock = false;
					}
					else {
						if (parseCommon.startsWith(line, "%%"))
							multilineVars.textBlock += ' ' + line.substring(2);
						else
							multilineVars.textBlock += ' ' + line;
					}
				} else if (multilineVars.inPsBlock) {
					if (parseCommon.startsWith(line, "%%endps")) {
						// Just ignore postscript
						multilineVars.inPsBlock = false;
					}
					else
						multilineVars.textBlock += ' ' + line;
				} else
					parseLine(line);
				multilineVars.iChar += line.length + 1;
			});
			var ph = 11*72;
			var pl = 8.5*72;
			switch (multilineVars.papersize) {
				//case "letter": ph = 11*72; pl = 8.5*72; break;
				case "legal": ph = 14*72; pl = 8.5*72; break;
				case "A4": ph = 11.7*72; pl = 8.3*72; break;
			}
			if (multilineVars.landscape) {
				var x = ph;
				ph = pl;
				pl = x;
			}
			multilineVars.openSlurs = tune.cleanUp(pl, ph, multilineVars.barsperstaff, multilineVars.staffnonote, multilineVars.openSlurs);
		} catch (err) {
			if (err !== "normal_abort")
				throw err;
		}
		if (switches.hint_measures) {
			addHintMeasures();
		}

		wrap.wrapLines(tune, multilineVars.lineBreaks);
	};
};

module.exports = Parse;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_parse_directive.js":
/*!*************************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_parse_directive.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*global window */

var parseCommon = __webpack_require__(/*! ./abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");

var parseDirective = {};

(function() {
	"use strict";
	var tokenizer;
	var warn;
	var multilineVars;
	var tune;
	parseDirective.initialize = function(tokenizer_, warn_, multilineVars_, tune_) {
		tokenizer = tokenizer_;
		warn = warn_;
		multilineVars = multilineVars_;
		tune = tune_;
		initializeFonts();
	};

	function initializeFonts() {
		multilineVars.annotationfont  = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.gchordfont  = { face: "Helvetica", size: 12, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.historyfont  = { face: "\"Times New Roman\"", size: 16, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.infofont  = { face: "\"Times New Roman\"", size: 14, weight: "normal", style: "italic", decoration: "none" };
		multilineVars.measurefont  = { face: "\"Times New Roman\"", size: 14, weight: "normal", style: "italic", decoration: "none" };
		multilineVars.partsfont  = { face: "\"Times New Roman\"", size: 15, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.repeatfont  = { face: "\"Times New Roman\"", size: 13, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.textfont  = { face: "\"Times New Roman\"", size: 16, weight: "normal", style: "normal", decoration: "none" };
		multilineVars.tripletfont = {face: "Times", size: 11, weight: "normal", style: "italic", decoration: "none"};
		multilineVars.vocalfont  = { face: "\"Times New Roman\"", size: 13, weight: "bold", style: "normal", decoration: "none" };
		multilineVars.wordsfont  = { face: "\"Times New Roman\"", size: 16, weight: "normal", style: "normal", decoration: "none" };

		// These fonts are global for the entire tune.
		tune.formatting.composerfont  = { face: "\"Times New Roman\"", size: 14, weight: "normal", style: "italic", decoration: "none" };
		tune.formatting.subtitlefont  = { face: "\"Times New Roman\"", size: 16, weight: "normal", style: "normal", decoration: "none" };
		tune.formatting.tempofont  = { face: "\"Times New Roman\"", size: 15, weight: "bold", style: "normal", decoration: "none" };
		tune.formatting.titlefont  = { face: "\"Times New Roman\"", size: 20, weight: "normal", style: "normal", decoration: "none" };
		tune.formatting.footerfont  = { face: "\"Times New Roman\"", size: 12, weight: "normal", style: "normal", decoration: "none" };
		tune.formatting.headerfont  = { face: "\"Times New Roman\"", size: 12, weight: "normal", style: "normal", decoration: "none" };
		tune.formatting.voicefont  = { face: "\"Times New Roman\"", size: 13, weight: "bold", style: "normal", decoration: "none" };

		// these are the default fonts for these element types. In the printer, these fonts might change as the tune progresses.
		tune.formatting.annotationfont  = multilineVars.annotationfont;
		tune.formatting.gchordfont  = multilineVars.gchordfont;
		tune.formatting.historyfont  = multilineVars.historyfont;
		tune.formatting.infofont  = multilineVars.infofont;
		tune.formatting.measurefont  = multilineVars.measurefont;
		tune.formatting.partsfont  = multilineVars.partsfont;
		tune.formatting.repeatfont  = multilineVars.repeatfont;
		tune.formatting.textfont  = multilineVars.textfont;
		tune.formatting.tripletfont  = multilineVars.tripletfont;
		tune.formatting.vocalfont  = multilineVars.vocalfont;
		tune.formatting.wordsfont  = multilineVars.wordsfont;
	}

	var fontTypeCanHaveBox = { gchordfont: true, measurefont: true, partsfont: true };

	var fontTranslation = function(fontFace) {
		// This translates Postscript fonts for a web alternative.
		// Note that the postscript fonts contain italic and bold info in them, so what is returned is a hash.

		switch (fontFace) {
			case "Arial-Italic":
				return { face: "Arial", weight: "normal", style: "italic", decoration: "none" };
			case "Arial-Bold":
				return { face: "Arial", weight: "bold", style: "normal", decoration: "none" };
			case "Bookman-Demi":
				return { face: "Bookman,serif", weight: "bold", style: "normal", decoration: "none" };
			case "Bookman-DemiItalic":
				return { face: "Bookman,serif", weight: "bold", style: "italic", decoration: "none" };
			case "Bookman-Light":
				return { face: "Bookman,serif", weight: "normal", style: "normal", decoration: "none" };
			case "Bookman-LightItalic":
				return { face: "Bookman,serif", weight: "normal", style: "italic", decoration: "none" };
			case "Courier":
				return { face: "\"Courier New\"", weight: "normal", style: "normal", decoration: "none" };
			case "Courier-Oblique":
				return { face: "\"Courier New\"", weight: "normal", style: "italic", decoration: "none" };
			case "Courier-Bold":
				return { face: "\"Courier New\"", weight: "bold", style: "normal", decoration: "none" };
			case "Courier-BoldOblique":
				return { face: "\"Courier New\"", weight: "bold", style: "italic", decoration: "none" };
			case "AvantGarde-Book":
				return { face: "AvantGarde,Arial", weight: "normal", style: "normal", decoration: "none" };
			case "AvantGarde-BookOblique":
				return { face: "AvantGarde,Arial", weight: "normal", style: "italic", decoration: "none" };
			case "AvantGarde-Demi":
			case "Avant-Garde-Demi":
				return { face: "AvantGarde,Arial", weight: "bold", style: "normal", decoration: "none" };
			case "AvantGarde-DemiOblique":
				return { face: "AvantGarde,Arial", weight: "bold", style: "italic", decoration: "none" };
			case "Helvetica-Oblique":
				return { face: "Helvetica", weight: "normal", style: "italic", decoration: "none" };
			case "Helvetica-Bold":
				return { face: "Helvetica", weight: "bold", style: "normal", decoration: "none" };
			case "Helvetica-BoldOblique":
				return { face: "Helvetica", weight: "bold", style: "italic", decoration: "none" };
			case "Helvetica-Narrow":
				return { face: "\"Helvetica Narrow\",Helvetica", weight: "normal", style: "normal", decoration: "none" };
			case "Helvetica-Narrow-Oblique":
				return { face: "\"Helvetica Narrow\",Helvetica", weight: "normal", style: "italic", decoration: "none" };
			case "Helvetica-Narrow-Bold":
				return { face: "\"Helvetica Narrow\",Helvetica", weight: "bold", style: "normal", decoration: "none" };
			case "Helvetica-Narrow-BoldOblique":
				return { face: "\"Helvetica Narrow\",Helvetica", weight: "bold", style: "italic", decoration: "none" };
			case "Palatino-Roman":
				return { face: "Palatino", weight: "normal", style: "normal", decoration: "none" };
			case "Palatino-Italic":
				return { face: "Palatino", weight: "normal", style: "italic", decoration: "none" };
			case "Palatino-Bold":
				return { face: "Palatino", weight: "bold", style: "normal", decoration: "none" };
			case "Palatino-BoldItalic":
				return { face: "Palatino", weight: "bold", style: "italic", decoration: "none" };
			case "NewCenturySchlbk-Roman":
				return { face: "\"New Century\",serif", weight: "normal", style: "normal", decoration: "none" };
			case "NewCenturySchlbk-Italic":
				return { face: "\"New Century\",serif", weight: "normal", style: "italic", decoration: "none" };
			case "NewCenturySchlbk-Bold":
				return { face: "\"New Century\",serif", weight: "bold", style: "normal", decoration: "none" };
			case "NewCenturySchlbk-BoldItalic":
				return { face: "\"New Century\",serif", weight: "bold", style: "italic", decoration: "none" };
			case "Times":
			case "Times-Roman":
			case "Times-Narrow":
			case "Times-Courier":
			case "Times-New-Roman":
				return { face: "\"Times New Roman\"", weight: "normal", style: "normal", decoration: "none" };
			case "Times-Italic":
			case "Times-Italics":
				return { face: "\"Times New Roman\"", weight: "normal", style: "italic", decoration: "none" };
			case "Times-Bold":
				return { face: "\"Times New Roman\"", weight: "bold", style: "normal", decoration: "none" };
			case "Times-BoldItalic":
				return { face: "\"Times New Roman\"", weight: "bold", style: "italic", decoration: "none" };
			case "ZapfChancery-MediumItalic":
				return { face: "\"Zapf Chancery\",cursive,serif", weight: "normal", style: "normal", decoration: "none" };
			default:
				return null;
		}
	};

	var getFontParameter = function(tokens, currentSetting, str, position, cmd) {
		// Every font parameter has the following format:
		// <face> <utf8> <size> <modifiers> <box>
		// Where:
		// face: either a standard web font name, or a postscript font, enumerated in fontTranslation. This could also be an * or be missing if the face shouldn't change.
		// utf8: This is optional, and specifies utf8. That's all that is supported so the field is just silently ignored.
		// size: The size, in pixels. This may be omitted if the size is not changing.
		// modifiers: zero or more of "bold", "italic", "underline"
		// box: Only applies to the measure numbers, gchords, and the parts. If present, then a box is drawn around the characters.
		// If face is present, then all the modifiers are cleared. If face is absent, then the modifiers are illegal.
		// The face can be a single word, a set of words separated by hyphens, or a quoted string.
		//
		// So, in practicality, there are three types of font definitions: a number only, an asterisk and a number only, or the full definition (with an optional size).
		function processNumberOnly() {
			var size = parseInt(tokens[0].token);
			tokens.shift();
			if (!currentSetting) {
				warn("Can't set just the size of the font since there is no default value.", str, position);
				return { face: "\"Times New Roman\"", weight: "normal", style: "normal", decoration: "none", size: size};
			}
			if (tokens.length === 0) {
				return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size};
			}
			if (tokens.length === 1 && tokens[0].token === "box" && fontTypeCanHaveBox[cmd])
				return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size, box: true};
			warn("Extra parameters in font definition.", str, position);
			return { face: currentSetting.face, weight: currentSetting.weight, style: currentSetting.style, decoration: currentSetting.decoration, size: size};
		}

		// format 1: asterisk and number only
		if (tokens[0].token === '*') {
			tokens.shift();
			if (tokens[0].type === 'number')
				return processNumberOnly();
			else {
				warn("Expected font size number after *.", str, position);
			}
		}

		// format 2: number only
		if (tokens[0].type === 'number') {
			return processNumberOnly();
		}

		// format 3: whole definition
		var face = [];
		var size;
		var weight = "normal";
		var style = "normal";
		var decoration = "none";
		var box = false;
		var state = 'face';
		var hyphenLast = false;
		while (tokens.length) {
			var currToken = tokens.shift();
			var word = currToken.token.toLowerCase();
			switch (state) {
				case 'face':
					if (hyphenLast || (word !== 'utf' && currToken.type !== 'number' && word !== "bold" && word !== "italic" && word !== "underline" && word !== "box")) {
						if (face.length > 0 && currToken.token === '-') {
							hyphenLast = true;
							face[face.length-1] = face[face.length-1] + currToken.token;
						}
						else {
							if (hyphenLast) {
								hyphenLast = false;
								face[face.length-1] = face[face.length-1] + currToken.token;
							} else
								face.push(currToken.token);
						}
					} else {
						if (currToken.type === 'number') {
							if (size) {
								warn("Font size specified twice in font definition.", str, position);
							} else {
								size = currToken.token;
							}
							state = 'modifier';
						} else if (word === "bold")
							weight = "bold";
						else if (word === "italic")
							style = "italic";
						else if (word === "underline")
							decoration = "underline";
						else if (word === "box") {
							if (fontTypeCanHaveBox[cmd])
								box = true;
							else
								warn("This font style doesn't support \"box\"", str, position);
							state = "finished";
						} else if (word === "utf") {
							currToken = tokens.shift(); // this gets rid of the "8" after "utf"
							state = "size";
						} else
							warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
					}
					break;
				case "size":
					if (currToken.type === 'number') {
						if (size) {
							warn("Font size specified twice in font definition.", str, position);
						} else {
							size = currToken.token;
						}
					} else {
						warn("Expected font size in font definition.", str, position);
					}
					state = 'modifier';
					break;
				case "modifier":
					if (word === "bold")
						weight = "bold";
					else if (word === "italic")
						style = "italic";
					else if (word === "underline")
						decoration = "underline";
					else if (word === "box") {
						if (fontTypeCanHaveBox[cmd])
							box = true;
						else
							warn("This font style doesn't support \"box\"", str, position);
						state = "finished";
					} else
						warn("Unknown parameter " + currToken.token + " in font definition.", str, position);
					break;
				case "finished":
					warn("Extra characters found after \"box\" in font definition.", str, position);
					break;
			}
		}

		if (size === undefined) {
			if (!currentSetting) {
				warn("Must specify the size of the font since there is no default value.", str, position);
				size = 12;
			} else
				size = currentSetting.size;
		} else
			size = parseFloat(size);

		face = face.join(' ');
		var psFont = fontTranslation(face);
		var font = {};
		if (psFont) {
			font.face = psFont.face;
			font.weight = psFont.weight;
			font.style = psFont.style;
			font.decoration = psFont.decoration;
			font.size = size;
			if (box)
				font.box = true;
			return font;
		}
		font.face = face;
		font.weight = weight;
		font.style = style;
		font.decoration = decoration;
		font.size = size;
		if (box)
			font.box = true;
		return font;
	};

	var getChangingFont = function(cmd, tokens, str) {
		if (tokens.length === 0)
			return "Directive \"" + cmd + "\" requires a font as a parameter.";
		multilineVars[cmd] = getFontParameter(tokens, multilineVars[cmd], str, 0, cmd);
		if (multilineVars.is_in_header) // If the font appears in the header, then it becomes the default font.
			tune.formatting[cmd] = multilineVars[cmd];
		return null;
	};
	var getGlobalFont = function(cmd, tokens, str) {
		if (tokens.length === 0)
			return "Directive \"" + cmd + "\" requires a font as a parameter.";
		tune.formatting[cmd] = getFontParameter(tokens, tune.formatting[cmd], str, 0, cmd);
		return null;
	};

	var setScale = function(cmd, tokens) {
		var scratch = "";
		parseCommon.each(tokens, function(tok) {
			scratch += tok.token;
		});
		var num = parseFloat(scratch);
		if (isNaN(num) || num === 0)
			return "Directive \"" + cmd + "\" requires a number as a parameter.";
		tune.formatting.scale = num;

	};

	var getRequiredMeasurement = function(cmd, tokens) {
		var points = tokenizer.getMeasurement(tokens);
		if (points.used === 0 || tokens.length !== 0)
			return { error: "Directive \"" + cmd + "\" requires a measurement as a parameter."};
		return points.value;
	};
	var oneParameterMeasurement = function(cmd, tokens) {
		var points = tokenizer.getMeasurement(tokens);
		if (points.used === 0 || tokens.length !== 0)
			return "Directive \"" + cmd + "\" requires a measurement as a parameter.";
		tune.formatting[cmd] = points.value;
		return null;
	};

	var addMultilineVar = function(key, cmd, tokens, min, max) {
		if (tokens.length !== 1 || tokens[0].type !== 'number')
			return "Directive \"" + cmd + "\" requires a number as a parameter.";
		var i = tokens[0].intt;
		if (min !== undefined && i < min)
			return "Directive \"" + cmd + "\" requires a number greater than or equal to " + min + " as a parameter.";
		if (max !== undefined && i > max)
			return "Directive \"" + cmd + "\" requires a number less than or equal to " + max + " as a parameter.";
		multilineVars[key] = i;
		return null;
	};

	var addMultilineVarBool = function(key, cmd, tokens) {
		if (tokens.length === 1 && (tokens[0].token === 'true' || tokens[0].token === 'false')) {
			multilineVars[key] = tokens[0].token === 'true';
			return null;
		}
		var str = addMultilineVar(key, cmd, tokens, 0, 1);
		if (str !== null) return str;
		multilineVars[key] = (multilineVars[key] === 1);
		return null;
	};

	var addMultilineVarOneParamChoice = function(key, cmd, tokens, choices) {
		if (tokens.length !== 1)
			return "Directive \"" + cmd + "\" requires one of [ " + choices.join(", ") + " ] as a parameter.";
		var choice = tokens[0].token;
		var found = false;
		for (var i = 0; !found && i < choices.length; i++) {
			if (choices[i] === choice)
				found = true;
		}
		if (!found)
			return "Directive \"" + cmd + "\" requires one of [ " + choices.join(", ") + " ] as a parameter.";
		multilineVars[key] = choice;
		return null;
	};

	var midiCmdParam0 = [
		"nobarlines",
		"barlines",
		"beataccents",
		"nobeataccents",
		"droneon",
		"droneoff",
		"drumon",
		"drumoff",
		"fermatafixed",
		"fermataproportional",
		"gchordon",
		"gchordoff",
		"controlcombo",
		"temperamentnormal",
		"noportamento"
	];
	var midiCmdParam1String = [
		"gchord",
		"ptstress",
		"beatstring"
	];
	var midiCmdParam1Integer = [
		"bassvol",
		"chordvol",
		"c",
		"channel",
		"beatmod",
		"deltaloudness",
		"drumbars",
		"gracedivider",
		"makechordchannels",
		"randomchordattack",
		"chordattack",
		"stressmodel",
		"transpose",
		"rtranspose",
		"vol",
		"volinc"
	];
	var midiCmdParam1Integer1OptionalInteger = [
		"program"
	];
	var midiCmdParam2Integer = [
		"ratio",
		"snt",
		"bendvelocity",
		"pitchbend",
		"control",
		"temperamentlinear"
	];
	var midiCmdParam4Integer = [
		"beat"
	];
	var midiCmdParam5Integer = [
		"drone"
	];
	var midiCmdParam1IntegerOptionalOctave = [
		"bassprog",
		"chordprog"
	];
	var midiCmdParam1String1Integer = [
		"portamento"
	];
	var midiCmdParamFraction = [
		"expand",
		"grace",
		"trim"
	];
	var midiCmdParam1StringVariableIntegers = [
		"drum",
		"chordname"
	];

	var parseMidiCommand = function(midi, tune, restOfString) {
		var midi_cmd = midi.shift().token;
		var midi_params = [];
		if (midiCmdParam0.indexOf(midi_cmd) >= 0) {
			// NO PARAMETERS
			if (midi.length !== 0)
				warn("Unexpected parameter in MIDI " + midi_cmd, restOfString, 0);
		} else if (midiCmdParam1String.indexOf(midi_cmd) >= 0) {
			// ONE STRING PARAMETER
			if (midi.length !== 1)
				warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
			else
				midi_params.push(midi[0].token);
		} else if (midiCmdParam1Integer.indexOf(midi_cmd) >= 0) {
			// ONE INT PARAMETER
			if (midi.length !== 1)
				warn("Expected one parameter in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number")
				warn("Expected one integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else
				midi_params.push(midi[0].intt);
		} else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
			// ONE INT PARAMETER, ONE OPTIONAL PARAMETER
			if (midi.length !== 1 && midi.length !== 2)
				warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number")
				warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else if (midi.length === 2 && midi[1].type !== "number")
				warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].intt);
				if (midi.length === 2)
					midi_params.push(midi[1].intt);
			}
		} else if (midiCmdParam2Integer.indexOf(midi_cmd) >= 0) {
			// TWO INT PARAMETERS
			if (midi.length !== 2)
				warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number" || midi[1].type !== "number")
				warn("Expected two integer parameters in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].intt);
				midi_params.push(midi[1].intt);
			}
		} else if (midiCmdParam1String1Integer.indexOf(midi_cmd) >= 0) {
			// ONE STRING PARAMETER, ONE INT PARAMETER
			if (midi.length !== 2)
				warn("Expected two parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "alpha" || midi[1].type !== "number")
				warn("Expected one string and one integer parameters in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].token);
				midi_params.push(midi[1].intt);
			}
		} else if (midi_cmd === 'drummap') {
			// BUILD AN OBJECT OF ABC NOTE => MIDI NOTE
			if (midi.length === 2 && midi[0].type === 'alpha' && midi[1].type === 'number') {
				if (!tune.formatting) tune.formatting = {};
				if (!tune.formatting.midi) tune.formatting.midi = {};
				if (!tune.formatting.midi.drummap) tune.formatting.midi.drummap = {};
				tune.formatting.midi.drummap[midi[0].token] = midi[1].intt;
				midi_params = tune.formatting.midi.drummap;
			} else if (midi.length === 3 && midi[0].type === 'punct' && midi[1].type === 'alpha' && midi[2].type === 'number') {
				if (!tune.formatting) tune.formatting = {};
				if (!tune.formatting.midi) tune.formatting.midi = {};
				if (!tune.formatting.midi.drummap) tune.formatting.midi.drummap = {};
				tune.formatting.midi.drummap[midi[0].token+midi[1].token] = midi[2].intt;
				midi_params = tune.formatting.midi.drummap;
			} else {
				warn("Expected one note name and one integer parameter in MIDI " + midi_cmd, restOfString, 0);
			}
		} else if (midiCmdParamFraction.indexOf(midi_cmd) >= 0) {
			// ONE FRACTION PARAMETER
			if (midi.length !== 3)
				warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number" || midi[1].token !== "/" || midi[2].type !== "number")
				warn("Expected fraction parameter in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].intt);
				midi_params.push(midi[2].intt);
			}
		} else if (midiCmdParam4Integer.indexOf(midi_cmd) >= 0) {
			// FOUR INT PARAMETERS
			if (midi.length !== 4)
				warn("Expected four parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number")
				warn("Expected four integer parameters in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].intt);
				midi_params.push(midi[1].intt);
				midi_params.push(midi[2].intt);
				midi_params.push(midi[3].intt);
			}
		} else if (midiCmdParam5Integer.indexOf(midi_cmd) >= 0) {
			// FIVE INT PARAMETERS
			if (midi.length !== 5)
				warn("Expected five parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number" || midi[1].type !== "number" || midi[2].type !== "number" || midi[3].type !== "number" || midi[4].type !== "number")
				warn("Expected five integer parameters in MIDI " + midi_cmd, restOfString, 0);
			else {
				midi_params.push(midi[0].intt);
				midi_params.push(midi[1].intt);
				midi_params.push(midi[2].intt);
				midi_params.push(midi[3].intt);
				midi_params.push(midi[4].intt);
			}
		} else if (midiCmdParam1Integer1OptionalInteger.indexOf(midi_cmd) >= 0) {
			// ONE INT PARAMETER, ONE OPTIONAL OCTAVE PARAMETER
			if (midi.length !== 1 || midi.length !== 4)
				warn("Expected one or two parameters in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "number")
				warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else if (midi.length === 4) {
				if (midi[1].token !== "octave")
					warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
				if (midi[2].token !== "=")
					warn("Expected octave parameter in MIDI " + midi_cmd, restOfString, 0);
				if (midi[3].type !== "number")
					warn("Expected integer parameter for octave in MIDI " + midi_cmd, restOfString, 0);
			} else {
				midi_params.push(midi[0].intt);
				if (midi.length === 4)
					midi_params.push(midi[3].intt);
			}
		} else if (midiCmdParam1StringVariableIntegers.indexOf(midi_cmd) >= 0) {
			// ONE STRING, VARIABLE INT PARAMETERS
			if (midi.length < 2)
				warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else if (midi[0].type !== "alpha")
				warn("Expected string parameter and at least one integer parameter in MIDI " + midi_cmd, restOfString, 0);
			else {
				var p = midi.shift();
				midi_params.push(p.token);
				while (midi.length > 0) {
					p = midi.shift();
					if (p.type !== "number")
						warn("Expected integer parameter in MIDI " + midi_cmd, restOfString, 0);
					midi_params.push(p.intt);
				}
			}
		}

		if (tune.hasBeginMusic())
			tune.appendElement('midi', -1, -1, { cmd: midi_cmd, params: midi_params });
		else {
			if (tune.formatting['midi'] === undefined)
				tune.formatting['midi'] = {};
			tune.formatting['midi'][midi_cmd] = midi_params;
		}
	};

	parseDirective.parseFontChangeLine = function(textstr) {
		var textParts = textstr.split('$');
		if (textParts.length > 1 && multilineVars.setfont) {
			var textarr = [ { text: textParts[0] }];
			for (var i = 1; i < textParts.length; i++) {
				if (textParts[i].charAt(0) === '0')
					textarr.push({ text: textParts[i].substring(1) });
				else if (textParts[i].charAt(0) === '1' && multilineVars.setfont[1])
					textarr.push({font: multilineVars.setfont[1], text: textParts[i].substring(1) });
				else if (textParts[i].charAt(0) === '2' && multilineVars.setfont[2])
					textarr.push({font: multilineVars.setfont[2], text: textParts[i].substring(1) });
				else if (textParts[i].charAt(0) === '3' && multilineVars.setfont[3])
					textarr.push({font: multilineVars.setfont[3], text: textParts[i].substring(1) });
				else if (textParts[i].charAt(0) === '4' && multilineVars.setfont[4])
					textarr.push({font: multilineVars.setfont[4], text: textParts[i].substring(1) });
				else
					textarr[textarr.length-1].text += '$' + textParts[i];
			}
			if (textarr.length > 1)
				return textarr;
		}
		return textstr;
	};

	var positionChoices = [ 'auto', 'above', 'below', 'hidden' ];
	parseDirective.addDirective = function(str) {
		var tokens = tokenizer.tokenize(str, 0, str.length);	// 3 or more % in a row, or just spaces after %% is just a comment
		if (tokens.length === 0 || tokens[0].type !== 'alpha') return null;
		var restOfString = str.substring(str.indexOf(tokens[0].token)+tokens[0].token.length);
		restOfString = tokenizer.stripComment(restOfString);
		var cmd = tokens.shift().token.toLowerCase();
		var scratch = "";
		switch (cmd)
		{
			// The following directives were added to abc_parser_lint, but haven't been implemented here.
			// Most of them are direct translations from the directives that will be parsed in. See abcm2ps's format.txt for info on each of these.
			//					alignbars: { type: "number", optional: true },
			//					aligncomposer: { type: "string", Enum: [ 'left', 'center','right' ], optional: true },
			//					bstemdown: { type: "boolean", optional: true },
			//					continueall: { type: "boolean", optional: true },
			//					dynalign: { type: "boolean", optional: true },
			//					exprabove: { type: "boolean", optional: true },
			//					exprbelow: { type: "boolean", optional: true },
			//					gchordbox: { type: "boolean", optional: true },
			//					graceslurs: { type: "boolean", optional: true },
			//					gracespacebefore: { type: "number", optional: true },
			//					gracespaceinside: { type: "number", optional: true },
			//					gracespaceafter: { type: "number", optional: true },
			//					infospace: { type: "number", optional: true },
			//					lineskipfac: { type: "number", optional: true },
			//					maxshrink: { type: "number", optional: true },
			//					maxstaffsep: { type: "number", optional: true },
			//					maxsysstaffsep: { type: "number", optional: true },
			//					notespacingfactor: { type: "number", optional: true },
			//					parskipfac: { type: "number", optional: true },
			//					slurheight: { type: "number", optional: true },
			//					splittune: { type: "boolean", optional: true },
			//					squarebreve: { type: "boolean", optional: true },
			//					stemheight: { type: "number", optional: true },
			//					straightflags: { type: "boolean", optional: true },
			//					stretchstaff: { type: "boolean", optional: true },
			//					titleformat: { type: "string", optional: true },
			case "bagpipes":tune.formatting.bagpipes = true;break;
			case "flatbeams":tune.formatting.flatbeams = true;break;
			case "landscape":multilineVars.landscape = true;break;
			case "papersize":multilineVars.papersize = restOfString;break;
			case "slurgraces":tune.formatting.slurgraces = true;break;
			case "stretchlast":tune.formatting.stretchlast = true;break;
			case "titlecaps":multilineVars.titlecaps = true;break;
			case "titleleft":tune.formatting.titleleft = true;break;
			case "measurebox":tune.formatting.measurebox = true;break;

			case "vocal": return addMultilineVarOneParamChoice("vocalPosition", cmd, tokens, positionChoices);
			case "dynamic": return addMultilineVarOneParamChoice("dynamicPosition", cmd, tokens, positionChoices);
			case "gchord": return addMultilineVarOneParamChoice("chordPosition", cmd, tokens, positionChoices);
			case "ornament": return addMultilineVarOneParamChoice("ornamentPosition", cmd, tokens, positionChoices);
			case "volume": return addMultilineVarOneParamChoice("volumePosition", cmd, tokens, positionChoices);

			case "botmargin":
			case "botspace":
			case "composerspace":
			case "indent":
			case "leftmargin":
			case "linesep":
			case "musicspace":
			case "partsspace":
			case "pageheight":
			case "pagewidth":
			case "rightmargin":
			case "staffsep":
			case "staffwidth":
			case "subtitlespace":
			case "sysstaffsep":
			case "systemsep":
			case "textspace":
			case "titlespace":
			case "topmargin":
			case "topspace":
			case "vocalspace":
			case "wordsspace":
				return oneParameterMeasurement(cmd, tokens);
			case "voicescale":
				if (tokens.length !== 1 || tokens[0].type !== 'number')
					return "voicescale requires one float as a parameter";
				var voiceScale = tokens.shift();
				if (multilineVars.currentVoice) {
					multilineVars.currentVoice.scale = voiceScale.floatt;
					tune.changeVoiceScale(multilineVars.currentVoice.scale);
				}
				return null;
			case "vskip":
				var vskip = getRequiredMeasurement(cmd, tokens);
				if (vskip.error)
					return vskip.error;
				tune.addSpacing(vskip);
				return null;
			case "scale":
				setScale(cmd, tokens);
				break;
			case "sep":
				if (tokens.length === 0)
					tune.addSeparator();
				else {
					var points = tokenizer.getMeasurement(tokens);
					if (points.used === 0)
						return "Directive \"" + cmd + "\" requires 3 numbers: space above, space below, length of line";
					var spaceAbove = points.value;

					points = tokenizer.getMeasurement(tokens);
					if (points.used === 0)
						return "Directive \"" + cmd + "\" requires 3 numbers: space above, space below, length of line";
					var spaceBelow = points.value;

					points = tokenizer.getMeasurement(tokens);
					if (points.used === 0 || tokens.length !== 0)
						return "Directive \"" + cmd + "\" requires 3 numbers: space above, space below, length of line";
					var lenLine = points.value;
					tune.addSeparator(spaceAbove, spaceBelow, lenLine);
				}
				break;
			case "barsperstaff":
				scratch = addMultilineVar('barsperstaff', cmd, tokens);
				if (scratch !== null) return scratch;
				break;
			case "staffnonote":
				// The sense of the boolean is opposite here. "0" means true.
				if (tokens.length !== 1)
					return "Directive staffnonote requires one parameter: 0 or 1";
				if (tokens[0].token === '0')
					multilineVars.staffnonote = true;
				else if (tokens[0].token === '1')
					multilineVars.staffnonote = false;
				else
					return "Directive staffnonote requires one parameter: 0 or 1 (received " + tokens[0].token + ')';
				break;
			case "printtempo":
				scratch = addMultilineVarBool('printTempo', cmd, tokens);
				if (scratch !== null) return scratch;
				break;
			case "partsbox":
				scratch = addMultilineVarBool('partsBox', cmd, tokens);
				if (scratch !== null) return scratch;
				multilineVars.partsfont.box = multilineVars.partsBox;
				break;
			case "freegchord":
				scratch = addMultilineVarBool('freegchord', cmd, tokens);
				if (scratch !== null) return scratch;
				break;
			case "measurenb":
			case "barnumbers":
				scratch = addMultilineVar('barNumbers', cmd, tokens);
				if (scratch !== null) return scratch;
				break;
			case "setbarnb":
				if (tokens.length !== 1 || tokens[0].type !== 'number') {
					return 'Directive setbarnb requires a number as a parameter.';
				}
				multilineVars.currBarNumber = tune.setBarNumberImmediate(tokens[0].intt);
				break;
			case "begintext":
				multilineVars.inTextBlock = true;
				break;
			case "continueall":
				multilineVars.continueall = true;
				break;
			case "beginps":
				multilineVars.inPsBlock = true;
				warn("Postscript ignored", str, 0);
				break;
			case "deco":
				if (restOfString.length > 0)
					multilineVars.ignoredDecorations.push(restOfString.substring(0, restOfString.indexOf(' ')));
				warn("Decoration redefinition ignored", str, 0);
				break;
			case "text":
				var textstr = tokenizer.translateString(restOfString);
				tune.addText(parseDirective.parseFontChangeLine(textstr));
				break;
			case "center":
				var centerstr = tokenizer.translateString(restOfString);
				tune.addCentered(parseDirective.parseFontChangeLine(centerstr));
				break;
			case "font":
				// don't need to do anything for this; it is a useless directive
				break;
			case "setfont":
				var sfTokens = tokenizer.tokenize(restOfString, 0, restOfString.length);
//				var sfDone = false;
				if (sfTokens.length >= 4) {
					if (sfTokens[0].token === '-' && sfTokens[1].type === 'number') {
						var sfNum = parseInt(sfTokens[1].token);
						if (sfNum >= 1 && sfNum <= 4) {
							if (!multilineVars.setfont)
								multilineVars.setfont = [];
							sfTokens.shift();
							sfTokens.shift();
							multilineVars.setfont[sfNum] = getFontParameter(sfTokens, multilineVars.setfont[sfNum], str, 0, 'setfont');
//							var sfSize = sfTokens.pop();
//							if (sfSize.type === 'number') {
//								sfSize = parseInt(sfSize.token);
//								var sfFontName = '';
//								for (var sfi = 2; sfi < sfTokens.length; sfi++)
//									sfFontName += sfTokens[sfi].token;
//								multilineVars.setfont[sfNum] = { face: sfFontName, size: sfSize };
//								sfDone = true;
//							}
						}
					}
				}
//				if (!sfDone)
//					return "Bad parameters: " + cmd;
				break;
			case "gchordfont":
			case "partsfont":
			case "tripletfont":
			case "vocalfont":
			case "textfont":
			case "annotationfont":
			case "historyfont":
			case "infofont":
			case "measurefont":
			case "repeatfont":
			case "wordsfont":
				return getChangingFont(cmd, tokens, str);
			case "composerfont":
			case "subtitlefont":
			case "tempofont":
			case "titlefont":
			case "voicefont":
			case "footerfont":
			case "headerfont":
				return getGlobalFont(cmd, tokens, str);
			case "barlabelfont":
			case "barnumberfont":
			case "barnumfont":
				return getChangingFont("measurefont", tokens, str);
			case "staves":
			case "score":
				multilineVars.score_is_present = true;
				var addVoice = function(id, newStaff, bracket, brace, continueBar) {
					if (newStaff || multilineVars.staves.length === 0) {
						multilineVars.staves.push({index: multilineVars.staves.length, numVoices: 0});
					}
					var staff = parseCommon.last(multilineVars.staves);
					if (bracket !== undefined) staff.bracket = bracket;
					if (brace !== undefined) staff.brace = brace;
					if (continueBar) staff.connectBarLines = 'end';
					if (multilineVars.voices[id] === undefined) {
						multilineVars.voices[id] = {staffNum: staff.index, index: staff.numVoices};
						staff.numVoices++;
					}
				};

				var openParen = false;
				var openBracket = false;
				var openBrace = false;
				var justOpenParen = false;
				var justOpenBracket = false;
				var justOpenBrace = false;
				var continueBar = false;
				var lastVoice;
				var addContinueBar = function() {
					continueBar = true;
					if (lastVoice) {
						var ty = 'start';
						if (lastVoice.staffNum > 0) {
							if (multilineVars.staves[lastVoice.staffNum-1].connectBarLines === 'start' ||
								multilineVars.staves[lastVoice.staffNum-1].connectBarLines === 'continue')
								ty = 'continue';
						}
						multilineVars.staves[lastVoice.staffNum].connectBarLines = ty;
					}
				};
				while (tokens.length) {
					var t = tokens.shift();
					switch (t.token) {
						case '(':
							if (openParen) warn("Can't nest parenthesis in %%score", str, t.start);
							else {openParen = true;justOpenParen = true;}
							break;
						case ')':
							if (!openParen || justOpenParen) warn("Unexpected close parenthesis in %%score", str, t.start);
							else openParen = false;
							break;
						case '[':
							if (openBracket) warn("Can't nest brackets in %%score", str, t.start);
							else {openBracket = true;justOpenBracket = true;}
							break;
						case ']':
							if (!openBracket || justOpenBracket) warn("Unexpected close bracket in %%score", str, t.start);
							else {openBracket = false;multilineVars.staves[lastVoice.staffNum].bracket = 'end';}
							break;
						case '{':
							if (openBrace ) warn("Can't nest braces in %%score", str, t.start);
							else {openBrace = true;justOpenBrace = true;}
							break;
						case '}':
							if (!openBrace || justOpenBrace) warn("Unexpected close brace in %%score", str, t.start);
							else {openBrace = false;multilineVars.staves[lastVoice.staffNum].brace = 'end';}
							break;
						case '|':
							addContinueBar();
							break;
						default:
							var vc = "";
							while (t.type === 'alpha' || t.type === 'number') {
								vc += t.token;
								if (t.continueId)
									t = tokens.shift();
								else
									break;
							}
							var newStaff = !openParen || justOpenParen;
							var bracket = justOpenBracket ? 'start' : openBracket ? 'continue' : undefined;
							var brace = justOpenBrace ? 'start' : openBrace ? 'continue' : undefined;
							addVoice(vc, newStaff, bracket, brace, continueBar);
							justOpenParen = false;
							justOpenBracket = false;
							justOpenBrace = false;
							continueBar = false;
							lastVoice = multilineVars.voices[vc];
							if (cmd === 'staves')
								addContinueBar();
							break;
					}
				}
				break;

			case "newpage":
				var pgNum = tokenizer.getInt(restOfString);
				tune.addNewPage(pgNum.digits === 0 ? -1 : pgNum.value);
				break;

			case "abc":
				var arr = restOfString.split(' ');
				switch (arr[0]) {
					case "-copyright":
					case "-creator":
					case "-edited-by":
					case "-version":
					case "-charset":
						var subCmd = arr.shift();
						tune.addMetaText(cmd+subCmd, arr.join(' '));
						break;
					default:
						return "Unknown directive: " + cmd+arr[0];
				}
				break;
			case "header":
			case "footer":
				var footerStr = tokenizer.getMeat(restOfString, 0, restOfString.length);
				footerStr = restOfString.substring(footerStr.start, footerStr.end);
				if (footerStr.charAt(0) === '"' && footerStr.charAt(footerStr.length-1) === '"' )
					footerStr = footerStr.substring(1, footerStr.length-1);
				var footerArr = footerStr.split('\t');
				var footer = {};
				if (footerArr.length === 1)
					footer = { left: "", center: footerArr[0], right: "" };
				else if (footerArr.length === 2)
					footer = { left: footerArr[0], center: footerArr[1], right: "" };
				else
					footer = { left: footerArr[0], center: footerArr[1], right: footerArr[2] };
				if (footerArr.length > 3)
					warn("Too many tabs in " + cmd + ": " + footerArr.length + " found.", restOfString, 0);

				tune.addMetaTextObj(cmd, footer);
				break;

			case "midi":
				var midi = tokenizer.tokenize(restOfString, 0, restOfString.length, true);
				if (midi.length > 0 && midi[0].token === '=')
					midi.shift();
				if (midi.length === 0)
					warn("Expected midi command", restOfString, 0);
				else
					parseMidiCommand(midi, tune, restOfString);
				break;

			case "map":
			case "percmap":
			case "playtempo":
			case "auquality":
			case "continuous":
			case "nobarcheck":
				// TODO-PER: Actually handle the parameters of these
				tune.formatting[cmd] = restOfString;
				break;
			default:
				return "Unknown directive: " + cmd;
		}
		return null;
	};
	parseDirective.globalFormatting = function(formatHash) {
		for (var cmd in formatHash) {
			if (formatHash.hasOwnProperty(cmd)) {
				var value = ''+formatHash[cmd];
				var tokens = tokenizer.tokenize(value, 0, value.length);
				var scratch;
				switch (cmd) {
					case "titlefont":
					case "gchordfont":
					case "composerfont":
					case "footerfont":
					case "headerfont":
					case "historyfont":
					case "infofont":
					case "measurefont":
					case "partsfont":
					case "repeatfont":
					case "subtitlefont":
					case "tempofont":
					case "textfont":
					case "voicefont":
					case "tripletfont":
					case "vocalfont":
					case "wordsfont":
					case "annotationfont":
						getChangingFont(cmd, tokens, value);
						break;
					case "scale":
						setScale(cmd, tokens);
						break;
					case "partsbox":
						scratch = addMultilineVarBool('partsBox', cmd, tokens);
						if (scratch !== null) warn(scratch);
						multilineVars.partsfont.box = multilineVars.partsBox;
						break;
					case "freegchord":
						scratch = addMultilineVarBool('freegchord', cmd, tokens);
						if (scratch !== null) warn(scratch);
					default:
						warn("Formatting directive unrecognized: ", cmd, 0);
				}
			}
		}
	};
})();

module.exports = parseDirective;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_parse_header.js":
/*!**********************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_parse_header.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_parse_header.js: parses a the header fields from a string representing ABC Music Notation into a usable internal structure.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global window */

var parseCommon = __webpack_require__(/*! ./abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var parseDirective = __webpack_require__(/*! ./abc_parse_directive */ "./node_modules/abcjs/src/parse/abc_parse_directive.js");
var parseKeyVoice = __webpack_require__(/*! ./abc_parse_key_voice */ "./node_modules/abcjs/src/parse/abc_parse_key_voice.js");

var ParseHeader = function(tokenizer, warn, multilineVars, tune) {
	this.reset = function(tokenizer, warn, multilineVars, tune) {
		parseKeyVoice.initialize(tokenizer, warn, multilineVars, tune);
		parseDirective.initialize(tokenizer, warn, multilineVars, tune);
	};
	this.reset(tokenizer, warn, multilineVars, tune);

	this.setTitle = function(title) {
		if (multilineVars.hasMainTitle)
			tune.addSubtitle(tokenizer.translateString(tokenizer.stripComment(title)));	// display secondary title
		else
		{
			var titleStr = tokenizer.translateString(tokenizer.theReverser(tokenizer.stripComment(title)));
			if (multilineVars.titlecaps)
				titleStr = titleStr.toUpperCase();
			tune.addMetaText("title", titleStr);
			multilineVars.hasMainTitle = true;
		}
	};

	this.setMeter = function(line) {
		line = tokenizer.stripComment(line);
		if (line === 'C') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'common_time'};
		} else if (line === 'C|') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'cut_time'};
		} else if (line === 'o') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'tempus_perfectum'};
		} else if (line === 'c') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'tempus_imperfectum'};
		} else if (line === 'o.') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'tempus_perfectum_prolatio'};
		} else if (line === 'c.') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return {type: 'tempus_imperfectum_prolatio'};
		} else if (line.length === 0 || line.toLowerCase() === 'none') {
			if (multilineVars.havent_set_length === true) {
				multilineVars.default_length = 0.125;
				multilineVars.havent_set_length = false;
			}
			return null;
		}
		else
		{
			var tokens = tokenizer.tokenize(line, 0, line.length);
			// the form is [open_paren] decimal [ plus|dot decimal ]... [close_paren] slash decimal [plus same_as_before]
			try {
				var parseNum = function() {
					// handles this much: [open_paren] decimal [ plus|dot decimal ]... [close_paren]
					var ret = {value: 0, num: ""};

					var tok = tokens.shift();
					if (tok.token === '(')
						tok = tokens.shift();
					while (1) {
						if (tok.type !== 'number') throw "Expected top number of meter";
						ret.value += parseInt(tok.token);
						ret.num += tok.token;
						if (tokens.length === 0 || tokens[0].token === '/') return ret;
						tok = tokens.shift();
						if (tok.token === ')') {
							if (tokens.length === 0 || tokens[0].token === '/') return ret;
							throw "Unexpected paren in meter";
						}
						if (tok.token !== '.' && tok.token !== '+') throw "Expected top number of meter";
						ret.num += tok.token;
						if (tokens.length === 0) throw "Expected top number of meter";
						tok = tokens.shift();
					}
					return ret;	// just to suppress warning
				};

				var parseFraction = function() {
					// handles this much: parseNum slash decimal
					var ret = parseNum();
					if (tokens.length === 0) return ret;
					var tok = tokens.shift();
					if (tok.token !== '/') throw "Expected slash in meter";
					tok = tokens.shift();
					if (tok.type !== 'number') throw "Expected bottom number of meter";
					ret.den = tok.token;
					ret.value = ret.value / parseInt(ret.den);
					return ret;
				};

				if (tokens.length === 0) throw "Expected meter definition in M: line";
				var meter = {type: 'specified', value: [ ]};
				var totalLength = 0;
				while (1) {
					var ret = parseFraction();
					totalLength += ret.value;
					var mv = { num: ret.num };
					if (ret.den !== undefined)
						mv.den = ret.den;
					meter.value.push(mv);
					if (tokens.length === 0) break;
					//var tok = tokens.shift();
					//if (tok.token !== '+') throw "Extra characters in M: line";
				}

				if (multilineVars.havent_set_length === true) {
					multilineVars.default_length = totalLength < 0.75 ? 0.0625 : 0.125;
					multilineVars.havent_set_length = false;
				}
				return meter;
			} catch (e) {
				warn(e, line, 0);
			}
		}
		return null;
	};

	this.calcTempo = function(relTempo) {
		var dur = 1/4;
		if (multilineVars.meter && multilineVars.meter.type === 'specified') {
			dur = 1 / parseInt(multilineVars.meter.value[0].den);
		} else if (multilineVars.origMeter && multilineVars.origMeter.type === 'specified') {
			dur = 1 / parseInt(multilineVars.origMeter.value[0].den);
		}
		//var dur = multilineVars.default_length ? multilineVars.default_length : 1;
		for (var i = 0; i < relTempo.duration; i++)
			relTempo.duration[i] = dur * relTempo.duration[i];
		return relTempo;
	};

	this.resolveTempo = function() {
		if (multilineVars.tempo) {	// If there's a tempo waiting to be resolved
			this.calcTempo(multilineVars.tempo);
			tune.metaText.tempo = multilineVars.tempo;
			delete multilineVars.tempo;
		}
	};

	this.addUserDefinition = function(line, start, end) {
		var equals = line.indexOf('=', start);
		if (equals === -1) {
			warn("Need an = in a macro definition", line, start);
			return;
		}

		var before = parseCommon.strip(line.substring(start, equals));
		var after = parseCommon.strip(line.substring(equals+1));

		if (before.length !== 1) {
			warn("Macro definitions can only be one character", line, start);
			return;
		}
		var legalChars = "HIJKLMNOPQRSTUVWXYhijklmnopqrstuvw~";
		if (legalChars.indexOf(before) === -1) {
			warn("Macro definitions must be H-Y, h-w, or tilde", line, start);
			return;
		}
		if (after.length === 0) {
			warn("Missing macro definition", line, start);
			return;
		}
		if (multilineVars.macros === undefined)
			multilineVars.macros = {};
		multilineVars.macros[before] = after;
	};

	this.setDefaultLength = function(line, start, end) {
		var len = parseCommon.gsub(line.substring(start, end), " ", "");
		var len_arr = len.split('/');
		if (len_arr.length === 2) {
			var n = parseInt(len_arr[0]);
			var d = parseInt(len_arr[1]);
			if (d > 0) {
				multilineVars.default_length = n / d;	// a whole note is 1
				multilineVars.havent_set_length = false;
			}
		} else if (len_arr.length === 1 && len_arr[0] === '1') {
			multilineVars.default_length = 1;
			multilineVars.havent_set_length = false;
		}
	};


	var tempoString = {

		larghissimo: 20,
		adagissimo: 24,
		sostenuto: 28,
		grave: 32,
		largo: 40,
		lento: 50,
		larghetto: 60,
		adagio: 68,
		adagietto: 74,
		andante: 80,
		andantino: 88,
		"marcia moderato": 84,
		"andante moderato": 100,
		moderato: 112,
		allegretto: 116,
		"allegro moderato": 120,
		allegro: 126,
		animato: 132,
		agitato: 140,
		veloce: 148,
		"mosso vivo": 156,
		vivace: 164,
		vivacissimo: 172,
		allegrissimo: 176,
		presto: 184,
		prestissimo: 210,
	};

	this.setTempo = function(line, start, end) {
		//Q - tempo; can be used to specify the notes per minute, e.g. If
		//the meter denominator is a 4 note then Q:120 or Q:C=120
		//is 120 quarter notes per minute. Similarly  Q:C3=40 would be 40
		//dotted half notes per minute. An absolute tempo may also be
		//set, e.g. Q:1/8=120 is 120 eighth notes per minute,
		//irrespective of the meter's denominator.
		//
		// This is either a number, "C=number", "Cnumber=number", or fraction [fraction...]=number
		// It depends on the M: field, which may either not be present, or may appear after this.
		// If M: is not present, an eighth note is used.
		// That means that this field can't be calculated until the end, if it is the first three types, since we don't know if we'll see an M: field.
		// So, if it is the fourth type, set it here, otherwise, save the info in the multilineVars.
		// The temporary variables we keep are the duration and the bpm. In the first two forms, the duration is 1.
		// In addition, a quoted string may both precede and follow. If a quoted string is present, then the duration part is optional.
		try {
			var tokens = tokenizer.tokenize(line, start, end);

			if (tokens.length === 0) throw "Missing parameter in Q: field";

			var tempo = {};
			var delaySet = true;
			var token = tokens.shift();
			if (token.type === 'quote') {
				tempo.preString = token.token;
				token = tokens.shift();
				if (tokens.length === 0) {	// It's ok to just get a string for the tempo
					// If the string is a well-known tempo, put in the bpm
					if (tempoString[tempo.preString.toLowerCase()]) {
						tempo.bpm = tempoString[tempo.preString.toLowerCase()];
						tempo.suppressBpm = true;
					}
					return {type: 'immediate', tempo: tempo};
				}
			}
			if (token.type === 'alpha' && token.token === 'C')	 { // either type 2 or type 3
				if (tokens.length === 0) throw "Missing tempo after C in Q: field";
				token = tokens.shift();
				if (token.type === 'punct' && token.token === '=') {
					// This is a type 2 format. The duration is an implied 1
					if (tokens.length === 0) throw "Missing tempo after = in Q: field";
					token = tokens.shift();
					if (token.type !== 'number') throw "Expected number after = in Q: field";
					tempo.duration = [1];
					tempo.bpm = parseInt(token.token);
				} else if (token.type === 'number') {
					// This is a type 3 format.
					tempo.duration = [parseInt(token.token)];
					if (tokens.length === 0) throw "Missing = after duration in Q: field";
					token = tokens.shift();
					if (token.type !== 'punct' || token.token !== '=') throw "Expected = after duration in Q: field";
					if (tokens.length === 0) throw "Missing tempo after = in Q: field";
					token = tokens.shift();
					if (token.type !== 'number') throw "Expected number after = in Q: field";
					tempo.bpm = parseInt(token.token);
				} else throw "Expected number or equal after C in Q: field";

			} else if (token.type === 'number') {	// either type 1 or type 4
				var num = parseInt(token.token);
				if (tokens.length === 0 || tokens[0].type === 'quote') {
					// This is type 1
					tempo.duration = [1];
					tempo.bpm = num;
				} else {	// This is type 4
					delaySet = false;
					token = tokens.shift();
					if (token.type !== 'punct' && token.token !== '/') throw "Expected fraction in Q: field";
					token = tokens.shift();
					if (token.type !== 'number') throw "Expected fraction in Q: field";
					var den = parseInt(token.token);
					tempo.duration = [num/den];
					// We got the first fraction, keep getting more as long as we find them.
					while (tokens.length > 0  && tokens[0].token !== '=' && tokens[0].type !== 'quote') {
						token = tokens.shift();
						if (token.type !== 'number') throw "Expected fraction in Q: field";
						num = parseInt(token.token);
						token = tokens.shift();
						if (token.type !== 'punct' && token.token !== '/') throw "Expected fraction in Q: field";
						token = tokens.shift();
						if (token.type !== 'number') throw "Expected fraction in Q: field";
						den = parseInt(token.token);
						tempo.duration.push(num/den);
					}
					token = tokens.shift();
					if (token.type !== 'punct' && token.token !== '=') throw "Expected = in Q: field";
					token = tokens.shift();
					if (token.type !== 'number') throw "Expected tempo in Q: field";
					tempo.bpm = parseInt(token.token);
				}
			} else throw "Unknown value in Q: field";
			if (tokens.length !== 0) {
				token = tokens.shift();
				if (token.type === 'quote') {
					tempo.postString = token.token;
					token = tokens.shift();
				}
				if (tokens.length !== 0) throw "Unexpected string at end of Q: field";
			}
			if (multilineVars.printTempo === false)
				tempo.suppress = true;
			return {type: delaySet?'delaySet':'immediate', tempo: tempo};
		} catch (msg) {
			warn(msg, line, start);
			return {type: 'none'};
		}
	};

	this.letter_to_inline_header = function(line, i)
	{
		var ws = tokenizer.eatWhiteSpace(line, i);
		i +=ws;
		if (line.length >= i+5 && line.charAt(i) === '[' && line.charAt(i+2) === ':') {
			var e = line.indexOf(']', i);
			var startChar = multilineVars.iChar + i;
			var endChar = multilineVars.iChar + e + 1;
			switch(line.substring(i, i+3))
			{
				case "[I:":
					var err = parseDirective.addDirective(line.substring(i+3, e));
					if (err) warn(err, line, i);
					return [ e-i+1+ws ];
				case "[M:":
					var meter = this.setMeter(line.substring(i+3, e));
					if (tune.hasBeginMusic() && meter)
						tune.appendStartingElement('meter', startChar, endChar, meter);
					else
						multilineVars.meter = meter;
					return [ e-i+1+ws ];
				case "[K:":
					var result = parseKeyVoice.parseKey(line.substring(i+3, e));
					if (result.foundClef && tune.hasBeginMusic())
						tune.appendStartingElement('clef', startChar, endChar, multilineVars.clef);
					if (result.foundKey && tune.hasBeginMusic())
						tune.appendStartingElement('key', startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
					return [ e-i+1+ws ];
				case "[P:":
					if (tune.lines.length <= tune.lineNum)
						multilineVars.partForNextLine = { title: line.substring(i+3, e), startChar: startChar, endChar: endChar };
					else
						tune.appendElement('part', startChar, endChar, {title: line.substring(i+3, e)});
					return [ e-i+1+ws ];
				case "[L:":
					this.setDefaultLength(line, i+3, e);
					return [ e-i+1+ws ];
				case "[Q:":
					if (e > 0) {
						var tempo = this.setTempo(line, i+3, e);
						if (tempo.type === 'delaySet') tune.appendElement('tempo', startChar, endChar, this.calcTempo(tempo.tempo));
						else if (tempo.type === 'immediate') tune.appendElement('tempo', startChar, endChar, tempo.tempo);
						return [ e-i+1+ws, line.charAt(i+1), line.substring(i+3, e)];
					}
					break;
				case "[V:":
					if (e > 0) {
						parseKeyVoice.parseVoice(line, i+3, e);
						//startNewLine();
						return [ e-i+1+ws, line.charAt(i+1), line.substring(i+3, e)];
					}
					break;

				default:
					// TODO: complain about unhandled header
			}
		}
		return [ 0 ];
	};

	this.letter_to_body_header = function(line, i)
	{
		if (line.length >= i+3) {
			switch(line.substring(i, i+2))
			{
				case "I:":
					var err = parseDirective.addDirective(line.substring(i+2));
					if (err) warn(err, line, i);
					return [ line.length ];
				case "M:":
					var meter = this.setMeter(line.substring(i+2));
					if (tune.hasBeginMusic() && meter)
						tune.appendStartingElement('meter', multilineVars.iChar + i, multilineVars.iChar + line.length, meter);
					return [ line.length ];
				case "K:":
					var result = parseKeyVoice.parseKey(line.substring(i+2));
					if (result.foundClef && tune.hasBeginMusic())
						tune.appendStartingElement('clef', multilineVars.iChar + i, multilineVars.iChar + line.length, multilineVars.clef);
					if (result.foundKey && tune.hasBeginMusic())
						tune.appendStartingElement('key', multilineVars.iChar + i, multilineVars.iChar + line.length, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
					return [ line.length ];
				case "P:":
					if (tune.hasBeginMusic())
						tune.appendElement('part', multilineVars.iChar + i, multilineVars.iChar + line.length, {title: line.substring(i+2)});
					return [ line.length ];
				case "L:":
					this.setDefaultLength(line, i+2, line.length);
					return [ line.length ];
				case "Q:":
					var e = line.indexOf('\x12', i+2);
					if (e === -1) e = line.length;
					var tempo = this.setTempo(line, i+2, e);
					if (tempo.type === 'delaySet') tune.appendElement('tempo', multilineVars.iChar + i, multilineVars.iChar + line.length, this.calcTempo(tempo.tempo));
					else if (tempo.type === 'immediate') tune.appendElement('tempo', multilineVars.iChar + i, multilineVars.iChar + line.length, tempo.tempo);
				return [ e, line.charAt(i), parseCommon.strip(line.substring(i+2))];
				case "V:":
					parseKeyVoice.parseVoice(line, i+2, line.length);
//						startNewLine();
					return [ line.length, line.charAt(i), parseCommon.strip(line.substring(i+2))];
				default:
					// TODO: complain about unhandled header
			}
		}
		return [ 0 ];
	};

	var metaTextHeaders = {
		A: 'author',
		B: 'book',
		C: 'composer',
		D: 'discography',
		F: 'url',
		G: 'group',
		I: 'instruction',
		N: 'notes',
		O: 'origin',
		R: 'rhythm',
		S: 'source',
		W: 'unalignedWords',
		Z: 'transcription'
	};

	this.parseHeader = function(line) {
		if (parseCommon.startsWith(line, '%%')) {
			var err = parseDirective.addDirective(line.substring(2));
			if (err) warn(err, line, 2);
			return {};
		}
		var i = line.indexOf('%');
		if (i >= 0)
			line = line.substring(0, i);
		line = line.replace(/\s+$/, '');

		if (line.length === 0)
			return {};

		if (line.length >= 2) {
			if (line.charAt(1) === ':') {
				var nextLine = "";
				if (line.indexOf('\x12') >= 0 && line.charAt(0) !== 'w') {	// w: is the only header field that can have a continuation.
					nextLine = line.substring(line.indexOf('\x12')+1);
					line = line.substring(0, line.indexOf('\x12'));	//This handles a continuation mark on a header field
				}
				var field = metaTextHeaders[line.charAt(0)];
				if (field !== undefined) {
					if (field === 'unalignedWords')
						tune.addMetaTextArray(field, parseDirective.parseFontChangeLine(tokenizer.translateString(tokenizer.stripComment(line.substring(2)))));
					else
						tune.addMetaText(field, tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
					return {};
				} else {
					var startChar = multilineVars.iChar;
					var endChar = startChar + line.length;
					switch(line.charAt(0))
					{
						case  'H':
							tune.addMetaText("history", tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
							multilineVars.is_in_history = true;
							break;
						case  'K':
							// since the key is the last thing that can happen in the header, we can resolve the tempo now
							this.resolveTempo();
							var result = parseKeyVoice.parseKey(line.substring(2));
							if (!multilineVars.is_in_header && tune.hasBeginMusic()) {
								if (result.foundClef)
									tune.appendStartingElement('clef', startChar, endChar, multilineVars.clef);
								if (result.foundKey)
									tune.appendStartingElement('key', startChar, endChar, parseKeyVoice.fixKey(multilineVars.clef, multilineVars.key));
							}
							multilineVars.is_in_header = false;	// The first key signifies the end of the header.
							break;
						case  'L':
							this.setDefaultLength(line, 2, line.length);
							break;
						case  'M':
							multilineVars.origMeter = multilineVars.meter = this.setMeter(line.substring(2));
							break;
						case  'P':
							// TODO-PER: There is more to do with parts, but the writer doesn't care.
							if (multilineVars.is_in_header)
								tune.addMetaText("partOrder", tokenizer.translateString(tokenizer.stripComment(line.substring(2))));
							else
								multilineVars.partForNextLine = { title: tokenizer.translateString(tokenizer.stripComment(line.substring(2))), startChar: startChar, endChar: endChar};
							break;
						case  'Q':
							var tempo = this.setTempo(line, 2, line.length);
							if (tempo.type === 'delaySet') multilineVars.tempo = tempo.tempo;
							else if (tempo.type === 'immediate') tune.metaText.tempo = tempo.tempo;
							break;
						case  'T':
							this.setTitle(line.substring(2));
							break;
						case 'U':
							this.addUserDefinition(line, 2, line.length);
							break;
						case  'V':
							parseKeyVoice.parseVoice(line, 2, line.length);
							if (!multilineVars.is_in_header)
								return {newline: true};
							break;
						case  's':
							return {symbols: true};
						case  'w':
							return {words: true};
						case 'X':
							break;
						case 'E':
						case 'm':
							warn("Ignored header", line, 0);
							break;
						default:
							// It wasn't a recognized header value, so parse it as music.
							if (nextLine.length)
								nextLine = "\x12" + nextLine;
							//parseRegularMusicLine(line+nextLine);
							//nextLine = "";
							return {regular: true, str: line+nextLine};
					}
				}
				if (nextLine.length > 0)
					return {recurse: true, str: nextLine};
				return {};
			}
		}

		// If we got this far, we have a regular line of mulsic
		return {regular: true, str: line};
	};
};

module.exports = ParseHeader;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_parse_key_voice.js":
/*!*************************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_parse_key_voice.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*global window */

var parseCommon = __webpack_require__(/*! ./abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
var parseDirective = __webpack_require__(/*! ./abc_parse_directive */ "./node_modules/abcjs/src/parse/abc_parse_directive.js");
var transpose = __webpack_require__(/*! ./abc_transpose */ "./node_modules/abcjs/src/parse/abc_transpose.js");

var parseKeyVoice = {};

(function() {
	var tokenizer;
	var warn;
	var multilineVars;
	var tune;
	parseKeyVoice.initialize = function(tokenizer_, warn_, multilineVars_, tune_) {
		tokenizer = tokenizer_;
		warn = warn_;
		multilineVars = multilineVars_;
		tune = tune_;
	};

	parseKeyVoice.standardKey = function(keyName, root, acc, localTranspose) {
		var key1sharp = {acc: 'sharp', note: 'f'};
		var key2sharp = {acc: 'sharp', note: 'c'};
		var key3sharp = {acc: 'sharp', note: 'g'};
		var key4sharp = {acc: 'sharp', note: 'd'};
		var key5sharp = {acc: 'sharp', note: 'A'};
		var key6sharp = {acc: 'sharp', note: 'e'};
		var key7sharp = {acc: 'sharp', note: 'B'};
		var key1flat = {acc: 'flat', note: 'B'};
		var key2flat = {acc: 'flat', note: 'e'};
		var key3flat = {acc: 'flat', note: 'A'};
		var key4flat = {acc: 'flat', note: 'd'};
		var key5flat = {acc: 'flat', note: 'G'};
		var key6flat = {acc: 'flat', note: 'c'};
		var key7flat = {acc: 'flat', note: 'F'};

		var keys = {
			'C#': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'A#m': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'G#Mix': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'D#Dor': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'E#Phr': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'F#Lyd': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],
			'B#Loc': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ],

			'F#': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'D#m': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'C#Mix': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'G#Dor': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'A#Phr': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'BLyd': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],
			'E#Loc': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp ],

			'B': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'G#m': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'F#Mix': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'C#Dor': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'D#Phr': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'ELyd': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],
			'A#Loc': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp ],

			'E': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'C#m': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'BMix': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'F#Dor': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'G#Phr': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'ALyd': [ key1sharp, key2sharp, key3sharp, key4sharp ],
			'D#Loc': [ key1sharp, key2sharp, key3sharp, key4sharp ],

			'A': [ key1sharp, key2sharp, key3sharp ],
			'F#m': [ key1sharp, key2sharp, key3sharp ],
			'EMix': [ key1sharp, key2sharp, key3sharp ],
			'BDor': [ key1sharp, key2sharp, key3sharp ],
			'C#Phr': [ key1sharp, key2sharp, key3sharp ],
			'DLyd': [ key1sharp, key2sharp, key3sharp ],
			'G#Loc': [ key1sharp, key2sharp, key3sharp ],

			'D': [ key1sharp, key2sharp ],
			'Bm': [ key1sharp, key2sharp ],
			'AMix': [ key1sharp, key2sharp ],
			'EDor': [ key1sharp, key2sharp ],
			'F#Phr': [ key1sharp, key2sharp ],
			'GLyd': [ key1sharp, key2sharp ],
			'C#Loc': [ key1sharp, key2sharp ],

			'G': [ key1sharp ],
			'Em': [ key1sharp ],
			'DMix': [ key1sharp ],
			'ADor': [ key1sharp ],
			'BPhr': [ key1sharp ],
			'CLyd': [ key1sharp ],
			'F#Loc': [ key1sharp ],

			'C': [],
			'Am': [],
			'GMix': [],
			'DDor': [],
			'EPhr': [],
			'FLyd': [],
			'BLoc': [],

			'F': [ key1flat ],
			'Dm': [ key1flat ],
			'CMix': [ key1flat ],
			'GDor': [ key1flat ],
			'APhr': [ key1flat ],
			'BbLyd': [ key1flat ],
			'ELoc': [ key1flat ],

			'Bb': [ key1flat, key2flat ],
			'Gm': [ key1flat, key2flat ],
			'FMix': [ key1flat, key2flat ],
			'CDor': [ key1flat, key2flat ],
			'DPhr': [ key1flat, key2flat ],
			'EbLyd': [ key1flat, key2flat ],
			'ALoc': [ key1flat, key2flat ],

			'Eb': [ key1flat, key2flat, key3flat ],
			'Cm': [ key1flat, key2flat, key3flat ],
			'BbMix': [ key1flat, key2flat, key3flat ],
			'FDor': [ key1flat, key2flat, key3flat ],
			'GPhr': [ key1flat, key2flat, key3flat ],
			'AbLyd': [ key1flat, key2flat, key3flat ],
			'DLoc': [ key1flat, key2flat, key3flat ],

			'Ab': [ key1flat, key2flat, key3flat, key4flat ],
			'Fm': [ key1flat, key2flat, key3flat, key4flat ],
			'EbMix': [ key1flat, key2flat, key3flat, key4flat ],
			'BbDor': [ key1flat, key2flat, key3flat, key4flat ],
			'CPhr': [ key1flat, key2flat, key3flat, key4flat ],
			'DbLyd': [ key1flat, key2flat, key3flat, key4flat ],
			'GLoc': [ key1flat, key2flat, key3flat, key4flat ],

			'Db': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'Bbm': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'AbMix': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'EbDor': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'FPhr': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'GbLyd': [ key1flat, key2flat, key3flat, key4flat, key5flat ],
			'CLoc': [ key1flat, key2flat, key3flat, key4flat, key5flat ],

			'Gb': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'Ebm': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'DbMix': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'AbDor': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'BbPhr': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'CbLyd': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],
			'FLoc': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat ],

			'Cb': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'Abm': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'GbMix': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'DbDor': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'EbPhr': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'FbLyd': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],
			'BbLoc': [ key1flat, key2flat, key3flat, key4flat, key5flat, key6flat, key7flat ],

			// The following are not in the 2.0 spec, but seem normal enough.
			// TODO-PER: These SOUND the same as what's written, but they aren't right
			'A#': [ key1flat, key2flat ],
			'B#': [],
			'D#': [ key1flat, key2flat, key3flat ],
			'E#': [ key1flat ],
			'G#': [ key1flat, key2flat, key3flat, key4flat ],
			'Gbm': [ key1sharp, key2sharp, key3sharp, key4sharp, key5sharp, key6sharp, key7sharp ]
		};

		return transpose.keySignature(multilineVars, keys, keyName, root, acc, localTranspose);
	};

	var clefLines = {
		'treble': { clef: 'treble', pitch: 4, mid: 0 },
		'treble+8': { clef: 'treble+8', pitch: 4, mid: 0 },
		'treble-8': { clef: 'treble-8', pitch: 4, mid: 0 },
		'treble^8': { clef: 'treble+8', pitch: 4, mid: 0 },
		'treble_8': { clef: 'treble-8', pitch: 4, mid: 0 },
		'treble1': { clef: 'treble', pitch: 2, mid: 2 },
		'treble2': { clef: 'treble', pitch: 4, mid: 0 },
		'treble3': { clef: 'treble', pitch: 6, mid: -2 },
		'treble4': { clef: 'treble', pitch: 8, mid: -4 },
		'treble5': { clef: 'treble', pitch: 10, mid: -6 },
		'perc': { clef: 'perc', pitch: 6, mid: 0 },
		'none': { clef: 'none', mid: 0 },
		'bass': { clef: 'bass', pitch: 8, mid: -12 },
		'bass+8': { clef: 'bass+8', pitch: 8, mid: -12 },
		'bass-8': { clef: 'bass-8', pitch: 8, mid: -12 },
		'bass^8': { clef: 'bass+8', pitch: 8, mid: -12 },
		'bass_8': { clef: 'bass-8', pitch: 8, mid: -12 },
		'bass+16': { clef: 'bass', pitch: 8, mid: -12 },
		'bass-16': { clef: 'bass', pitch: 8, mid: -12 },
		'bass^16': { clef: 'bass', pitch: 8, mid: -12 },
		'bass_16': { clef: 'bass', pitch: 8, mid: -12 },
		'bass1': { clef: 'bass', pitch: 2, mid: -6 },
		'bass2': { clef: 'bass', pitch: 4, mid: -8 },
		'bass3': { clef: 'bass', pitch: 6, mid: -10 },
		'bass4': { clef: 'bass', pitch: 8, mid: -12 },
		'bass5': { clef: 'bass', pitch: 10, mid: -14 },
		'tenor': { clef: 'alto', pitch: 8, mid: -8 },
		'tenor1': { clef: 'alto', pitch: 2, mid: -2 },
		'tenor2': { clef: 'alto', pitch: 4, mid: -4 },
		'tenor3': { clef: 'alto', pitch: 6, mid: -6 },
		'tenor4': { clef: 'alto', pitch: 8, mid: -8 },
		'tenor5': { clef: 'alto', pitch: 10, mid: -10 },
		'alto': { clef: 'alto', pitch: 6, mid: -6 },
		'alto1': { clef: 'alto', pitch: 2, mid: -2 },
		'alto2': { clef: 'alto', pitch: 4, mid: -4 },
		'alto3': { clef: 'alto', pitch: 6, mid: -6 },
		'alto4': { clef: 'alto', pitch: 8, mid: -8 },
		'alto5': { clef: 'alto', pitch: 10, mid: -10 },
		'alto+8': { clef: 'alto+8', pitch: 6, mid: -6 },
		'alto-8': { clef: 'alto-8', pitch: 6, mid: -6 },
		'alto^8': { clef: 'alto+8', pitch: 6, mid: -6 },
		'alto_8': { clef: 'alto-8', pitch: 6, mid: -6 }
	};

	var calcMiddle = function(clef, oct) {
		var value = clefLines[clef];
		var mid = value ? value.mid : 0;
		return mid+oct;
	};

	parseKeyVoice.fixClef = function(clef) {
		var value = clefLines[clef.type];
		if (value) {
			clef.clefPos = value.pitch;
			clef.type = value.clef;
		}
	};

	parseKeyVoice.deepCopyKey = function(key) {
		var ret = { accidentals: [], root: key.root, acc: key.acc, mode: key.mode };
		parseCommon.each(key.accidentals, function(k) {
		ret.accidentals.push(parseCommon.clone(k));
		});
		return ret;
	};

	var pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};

	parseKeyVoice.addPosToKey = function(clef, key) {
		// Shift the key signature from the treble positions to whatever position is needed for the clef.
		// This may put the key signature unnaturally high or low, so if it does, then shift it.
		var mid = clef.verticalPos;
		parseCommon.each(key.accidentals, function(acc) {
			var pitch = pitches[acc.note];
			pitch = pitch - mid;
			acc.verticalPos = pitch;
		});
		if (key.impliedNaturals)
			parseCommon.each(key.impliedNaturals, function(acc) {
				var pitch = pitches[acc.note];
				pitch = pitch - mid;
				acc.verticalPos = pitch;
			});

		if (mid < -10) {
			parseCommon.each(key.accidentals, function(acc) {
				acc.verticalPos -= 7;
				if (acc.verticalPos >= 11 || (acc.verticalPos === 10 && acc.acc === 'flat'))
					acc.verticalPos -= 7;
				if (acc.note === 'A' && acc.acc === 'sharp' )
					acc.verticalPos -=7;
				if ((acc.note === 'G' || acc.note === 'F') && acc.acc === 'flat' )
					acc.verticalPos -=7;
			});
			if (key.impliedNaturals)
				parseCommon.each(key.impliedNaturals, function(acc) {
					acc.verticalPos -= 7;
					if (acc.verticalPos >= 11 || (acc.verticalPos === 10 && acc.acc === 'flat'))
						acc.verticalPos -= 7;
					if (acc.note === 'A' && acc.acc === 'sharp' )
						acc.verticalPos -=7;
					if ((acc.note === 'G' || acc.note === 'F') && acc.acc === 'flat' )
						acc.verticalPos -=7;
				});
		} else if (mid < -4) {
			parseCommon.each(key.accidentals, function(acc) {
				acc.verticalPos -= 7;
				if (mid === -8 && (acc.note === 'f' || acc.note === 'g') && acc.acc === 'sharp' )
					acc.verticalPos -=7;
			});
			if (key.impliedNaturals)
				parseCommon.each(key.impliedNaturals, function(acc) {
					acc.verticalPos -= 7;
					if (mid === -8 && (acc.note === 'f' || acc.note === 'g') && acc.acc === 'sharp' )
						acc.verticalPos -=7;
				});
		} else if (mid >= 7) {
			parseCommon.each(key.accidentals, function(acc) {
				acc.verticalPos += 7;
			});
			if (key.impliedNaturals)
				parseCommon.each(key.impliedNaturals, function(acc) {
					acc.verticalPos += 7;
				});
		}
	};

	parseKeyVoice.fixKey = function(clef, key) {
		var fixedKey = parseCommon.clone(key);
		parseKeyVoice.addPosToKey(clef, fixedKey);
		return fixedKey;
	};

	var parseMiddle = function(str) {
		var i = 0;
		var p = str.charAt(i++);
		if (p === '^' || p === '_')
			p = str.charAt(i++);
	  var mid = pitches[p];
		if (mid === undefined)
			mid = 6; // If a legal middle note wasn't received, just ignore it.
		for ( ; i < str.length; i++) {
			if (str.charAt(i) === ',') mid -= 7;
			else if (str.charAt(i) === "'") mid += 7;
			else break;
		}
		return { mid: mid - 6, str: str.substring(i) };	// We get the note in the middle of the staff. We want the note that appears as the first ledger line below the staff.
	};

	var normalizeAccidentals = function(accs) {
		for (var i = 0; i < accs.length; i++) {
			if (accs[i].note === 'b')
				accs[i].note = 'B';
			else if (accs[i].note === 'a')
				accs[i].note = 'A';
			else if (accs[i].note === 'F')
				accs[i].note = 'f';
			else if (accs[i].note === 'E')
				accs[i].note = 'e';
			else if (accs[i].note === 'D')
				accs[i].note = 'd';
			else if (accs[i].note === 'C')
				accs[i].note = 'c';
			else if (accs[i].note === 'G' && accs[i].acc === 'sharp')
				accs[i].note = 'g';
			else if (accs[i].note === 'g' && accs[i].acc === 'flat')
				accs[i].note = 'G';
		}
	};

	parseKeyVoice.parseKey = function(str)	// (and clef)
	{
		// returns:
		//		{ foundClef: true, foundKey: true }
		// Side effects:
		//		calls warn() when there is a syntax error
		//		sets these members of multilineVars:
		//			clef
		//			key
		//			style
		//
		// The format is:
		// K: [key] [modifiers*]
		// modifiers are any of the following in any order:
		//  [clef] [middle=pitch] [transpose=[-]number] [stafflines=number] [staffscale=number][style=style]
		// key is none|HP|Hp|specified_key
		// clef is [clef=] [clef type] [line number] [+8|-8]
		// specified_key is pitch[#|b][mode(first three chars are significant)][accidentals*]
		if (str.length === 0) {
			// an empty K: field is the same as K:none
			str = 'none';
		}
		var tokens = tokenizer.tokenize(str, 0, str.length);
		var ret = {};

		// first the key
		switch (tokens[0].token) {
			case 'HP':
				parseDirective.addDirective("bagpipes");
				multilineVars.key = { root: "HP", accidentals: [], acc: "", mode: "" };
				ret.foundKey = true;
				tokens.shift();
				break;
			case 'Hp':
				parseDirective.addDirective("bagpipes");
				multilineVars.key = { root: "Hp", accidentals: [{acc: 'natural', note: 'g'}, {acc: 'sharp', note: 'f'}, {acc: 'sharp', note: 'c'}], acc: "", mode: "" };
				ret.foundKey = true;
				tokens.shift();
				break;
			case 'none':
				// we got the none key - that's the same as C to us
				multilineVars.key = { root: "none", accidentals: [], acc: "", mode: "" };
				ret.foundKey = true;
				tokens.shift();
				break;
			default:
				var retPitch = tokenizer.getKeyPitch(tokens[0].token);
				if (retPitch.len > 0) {
					ret.foundKey = true;
					var acc = "";
					var mode = "";
					// The accidental and mode might be attached to the pitch, so we might want to just remove the first character.
					if (tokens[0].token.length > 1)
						tokens[0].token = tokens[0].token.substring(1);
					else
						tokens.shift();
					var key = retPitch.token;
					// We got a pitch to start with, so we might also have an accidental and a mode
					if (tokens.length > 0) {
						var retAcc = tokenizer.getSharpFlat(tokens[0].token);
						if (retAcc.len > 0) {
							if (tokens[0].token.length > 1)
								tokens[0].token = tokens[0].token.substring(1);
							else
								tokens.shift();
							key += retAcc.token;
							acc = retAcc.token;
						}
						if (tokens.length > 0) {
							var retMode = tokenizer.getMode(tokens[0].token);
							if (retMode.len > 0) {
								tokens.shift();
								key += retMode.token;
								mode = retMode.token;
							}
						}
						// Be sure that the key specified is in the list: not all keys are physically possible, like Cbmin.
						if (parseKeyVoice.standardKey(key, retPitch.token, acc, 0) === undefined) {
							warn("Unsupported key signature: " + key, str, 0);
							return ret;
						}
					}
					// We need to do a deep copy because we are going to modify it
					var oldKey = parseKeyVoice.deepCopyKey(multilineVars.key);
					//TODO-PER: HACK! To get the local transpose to work, the transposition is done for each line. This caused the global transposition variable to be factored in twice, so, instead of rewriting that right now, I'm just subtracting one of them here.
					var keyCompensate = multilineVars.globalTranspose ? -multilineVars.globalTranspose : 0;
					multilineVars.key = parseKeyVoice.deepCopyKey(parseKeyVoice.standardKey(key, retPitch.token, acc, keyCompensate));
					multilineVars.key.mode = mode;
					if (oldKey) {
						// Add natural in all places that the old key had an accidental.
						var kk;
						for (var k = 0; k < multilineVars.key.accidentals.length; k++) {
							for (kk = 0; kk < oldKey.accidentals.length; kk++) {
								if (oldKey.accidentals[kk].note && multilineVars.key.accidentals[k].note.toLowerCase() === oldKey.accidentals[kk].note.toLowerCase())
									oldKey.accidentals[kk].note = null;
							}
						}
						for (kk = 0; kk < oldKey.accidentals.length; kk++) {
							if (oldKey.accidentals[kk].note) {
								if (!multilineVars.key.impliedNaturals)
									multilineVars.key.impliedNaturals = [];
								multilineVars.key.impliedNaturals.push({ acc: 'natural', note: oldKey.accidentals[kk].note });
							}
						}
					}
				}
				break;
		}

		// There are two special cases of deprecated syntax. Ignore them if they occur
		if (tokens.length === 0) return ret;
		if (tokens[0].token === 'exp') tokens.shift();
		if (tokens.length === 0) return ret;
		if (tokens[0].token === 'oct') tokens.shift();

		// now see if there are extra accidentals
		if (tokens.length === 0) return ret;
		var accs = tokenizer.getKeyAccidentals2(tokens);
		if (accs.warn)
			warn(accs.warn, str, 0);
		// If we have extra accidentals, first replace ones that are of the same pitch before adding them to the end.
		if (accs.accs) {
			if (!ret.foundKey) {		// if there are only extra accidentals, make sure this is set.
				ret.foundKey = true;
				multilineVars.key = { root: "none", acc: "", mode: "", accidentals: [] };
			}
			normalizeAccidentals(accs.accs);
			for (var i = 0; i < accs.accs.length; i++) {
				var found = false;
				for (var j = 0; j < multilineVars.key.accidentals.length && !found; j++) {
					if (multilineVars.key.accidentals[j].note === accs.accs[i].note) {
						found = true;
						if (multilineVars.key.accidentals[j].acc !== accs.accs[i].acc) {
							// If the accidental is different, then replace it. If it is the same, then the declaration was redundant, so just ignore it.
							multilineVars.key.accidentals[j].acc = accs.accs[i].acc;
							if (!multilineVars.key.explicitAccidentals)
								multilineVars.key.explicitAccidentals = [];
							multilineVars.key.explicitAccidentals.push(accs.accs[i]);
						}
					}
				}
				if (!found) {
					if (!multilineVars.key.explicitAccidentals)
						multilineVars.key.explicitAccidentals = [];
					multilineVars.key.explicitAccidentals.push(accs.accs[i]);
					multilineVars.key.accidentals.push(accs.accs[i]);
					if (multilineVars.key.impliedNaturals) {
						for (var kkk = 0; kkk < multilineVars.key.impliedNaturals.length; kkk++) {
							if (multilineVars.key.impliedNaturals[kkk].note === accs.accs[i].note)
								multilineVars.key.impliedNaturals.splice(kkk, 1);
						}
					}
				}
			}
		}

		// Now see if any optional parameters are present. They have the form "key=value", except that "clef=" is optional
		var token;
		while (tokens.length > 0) {
			switch (tokens[0].token) {
				case "m":
				case "middle":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after middle", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after middle", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after middle=", str, 0); return ret; }
					var pitch = tokenizer.getPitchFromTokens(tokens);
					if (pitch.warn)
						warn(pitch.warn, str, 0);
					if (pitch.position)
						multilineVars.clef.verticalPos = pitch.position - 6;	// we get the position from the middle line, but want to offset it to the first ledger line.
					break;
				case "transpose":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after transpose", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after transpose", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after transpose=", str, 0); return ret; }
					if (tokens[0].type !== 'number') { warn("Expected number after transpose", str, tokens[0].start); break; }
					multilineVars.clef.transpose = tokens[0].intt;
					tokens.shift();
					break;
				case "stafflines":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after stafflines", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after stafflines", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after stafflines=", str, 0); return ret; }
					if (tokens[0].type !== 'number') { warn("Expected number after stafflines", str, tokens[0].start); break; }
					multilineVars.clef.stafflines = tokens[0].intt;
					tokens.shift();
					break;
				case "staffscale":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after staffscale", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after staffscale", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after staffscale=", str, 0); return ret; }
					if (tokens[0].type !== 'number') { warn("Expected number after staffscale", str, tokens[0].start); break; }
					multilineVars.clef.staffscale = tokens[0].floatt;
					tokens.shift();
					break;
				case "style":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after style", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after style", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after style=", str, 0); return ret; }
					switch (tokens[0].token) {
						case "normal":
						case "harmonic":
						case "rhythm":
						case "x":
							multilineVars.style = tokens[0].token;
							tokens.shift();
							break;
						default:
							warn("error parsing style element: " + tokens[0].token, str, tokens[0].start);
							break;
					}
					break;
				case "clef":
					tokens.shift();
					if (tokens.length === 0) { warn("Expected = after clef", str, 0); return ret; }
					token = tokens.shift();
					if (token.token !== "=") { warn("Expected = after clef", str, token.start); break; }
					if (tokens.length === 0) { warn("Expected parameter after clef=", str, 0); return ret; }
					//break; yes, we want to fall through. That allows "clef=" to be optional.
				case "treble":
				case "bass":
				case "alto":
				case "tenor":
				case "perc":
					// clef is [clef=] [clef type] [line number] [+8|-8]
					var clef = tokens.shift();
					switch (clef.token) {
						case 'treble':
						case 'tenor':
						case 'alto':
						case 'bass':
						case 'perc':
						case 'none':
							break;
						case 'C': clef.token = 'alto'; break;
						case 'F': clef.token = 'bass'; break;
						case 'G': clef.token = 'treble'; break;
						case 'c': clef.token = 'alto'; break;
						case 'f': clef.token = 'bass'; break;
						case 'g': clef.token = 'treble'; break;
						default:
							warn("Expected clef name. Found " + clef.token, str, clef.start);
							break;
					}
					if (tokens.length > 0 && tokens[0].type === 'number') {
						clef.token += tokens[0].token;
						tokens.shift();
					}
					if (tokens.length > 1 && (tokens[0].token === '-' || tokens[0].token === '+' || tokens[0].token === '^' || tokens[0].token === '_') && tokens[1].token === '8') {
						clef.token += tokens[0].token + tokens[1].token;
						tokens.shift();
						tokens.shift();
					}
					multilineVars.clef = {type: clef.token, verticalPos: calcMiddle(clef.token, 0)};
					if (multilineVars.currentVoice && multilineVars.currentVoice.transpose !== undefined)
						multilineVars.clef.transpose = multilineVars.currentVoice.transpose;
					ret.foundClef = true;
					break;
				default:
					warn("Unknown parameter: " + tokens[0].token, str, tokens[0].start);
					tokens.shift();
			}
		}
		return ret;
	};

	var setCurrentVoice = function(id) {
		multilineVars.currentVoice = multilineVars.voices[id];
		tune.setCurrentVoice(multilineVars.currentVoice.staffNum, multilineVars.currentVoice.index);
	};

	parseKeyVoice.parseVoice = function(line, i, e) {
		//First truncate the string to the first non-space character after V: through either the
		//end of the line or a % character. Then remove trailing spaces, too.
		var ret = tokenizer.getMeat(line, i, e);
		var start = ret.start;
		var end = ret.end;
		//The first thing on the line is the ID. It can be any non-space string and terminates at the
		//first space.
		var id = tokenizer.getToken(line, start, end);
		if (id.length === 0) {
			warn("Expected a voice id", line, start);
			return;
		}
		var isNew = false;
		if (multilineVars.voices[id] === undefined) {
			multilineVars.voices[id] = {};
			isNew = true;
			if (multilineVars.score_is_present)
				warn("Can't have an unknown V: id when the %score directive is present", line, start);
		}
		start += id.length;
		start += tokenizer.eatWhiteSpace(line, start);

		var staffInfo = {startStaff: isNew};
		var addNextTokenToStaffInfo = function(name) {
			var attr = tokenizer.getVoiceToken(line, start, end);
			if (attr.warn !== undefined)
				warn("Expected value for " + name + " in voice: " + attr.warn, line, start);
			else if (attr.token.length === 0 && line.charAt(start) !== '"')
				warn("Expected value for " + name + " in voice", line, start);
			else
				staffInfo[name] = attr.token;
			start += attr.len;
		};
		var addNextTokenToVoiceInfo = function(id, name, type) {
			var attr = tokenizer.getVoiceToken(line, start, end);
			if (attr.warn !== undefined)
				warn("Expected value for " + name + " in voice: " + attr.warn, line, start);
			else if (attr.token.length === 0 && line.charAt(start) !== '"')
				warn("Expected value for " + name + " in voice", line, start);
			else {
				if (type === 'number')
					attr.token = parseFloat(attr.token);
				multilineVars.voices[id][name] = attr.token;
			}
			start += attr.len;
		};
		var getNextToken = function(name, type) {
			var attr = tokenizer.getVoiceToken(line, start, end);
			if (attr.warn !== undefined)
				warn("Expected value for " + name + " in voice: " + attr.warn, line, start);
			else if (attr.token.length === 0 && line.charAt(start) !== '"')
				warn("Expected value for " + name + " in voice", line, start);
			else {
				if (type === 'number')
					attr.token = parseFloat(attr.token);
				return attr.token;
			}
			start += attr.len;
		};
		var addNextNoteTokenToVoiceInfo = function(id, name) {
			var noteToTransposition = {
				"_B": 2,
				"_E": 9,
				"_b": -10,
				"_e": -3
			};
			var attr = tokenizer.getVoiceToken(line, start, end);
			if (attr.warn !== undefined)
				warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice: " + attr.warn, line, start);
			else if (attr.token.length === 0 && line.charAt(start) !== '"')
				warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
			else {
				var t = noteToTransposition[attr.token];
				if (!t)
					warn("Expected one of (_B, _E, _b, _e) for " + name + " in voice", line, start);
				else
					multilineVars.voices[id][name] = t;
			}
			start += attr.len;
		};

		//Then the following items can occur in any order:
		while (start < end) {
			var token = tokenizer.getVoiceToken(line, start, end);
			start += token.len;

			if (token.warn) {
				warn("Error parsing voice: " + token.warn, line, start);
			} else {
				var attr = null;
				switch (token.token) {
					case 'clef':
					case 'cl':
						addNextTokenToStaffInfo('clef');
						// TODO-PER: check for a legal clef; do octavizing
						var oct = 0;
	//							for (var ii = 0; ii < staffInfo.clef.length; ii++) {
	//								if (staffInfo.clef[ii] === ',') oct -= 7;
	//								else if (staffInfo.clef[ii] === "'") oct += 7;
	//							}
						if (staffInfo.clef !== undefined) {
						  staffInfo.clef = staffInfo.clef.replace(/[',]/g, ""); //'//comment for emacs formatting of regexp
							if (staffInfo.clef.indexOf('+16') !== -1) {
								oct += 14;
								staffInfo.clef = staffInfo.clef.replace('+16', '');
							}
							staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct);
						}
						break;
					case 'treble':
					case 'bass':
					case 'tenor':
					case 'alto':
					case 'perc':
					case 'none':
					case 'treble\'':
					case 'bass\'':
					case 'tenor\'':
					case 'alto\'':
					case 'none\'':
					case 'treble\'\'':
					case 'bass\'\'':
					case 'tenor\'\'':
					case 'alto\'\'':
					case 'none\'\'':
					case 'treble,':
					case 'bass,':
					case 'tenor,':
					case 'alto,':
					case 'none,':
					case 'treble,,':
					case 'bass,,':
					case 'tenor,,':
					case 'alto,,':
					case 'none,,':
						// TODO-PER: handle the octave indicators on the clef by changing the middle property
						var oct2 = 0;
	//							for (var iii = 0; iii < token.token.length; iii++) {
	//								if (token.token[iii] === ',') oct2 -= 7;
	//								else if (token.token[iii] === "'") oct2 += 7;
	//							}
											  staffInfo.clef = token.token.replace(/[',]/g, ""); //'//comment for emacs formatting of regexp
						staffInfo.verticalPos = calcMiddle(staffInfo.clef, oct2);
						multilineVars.voices[id].clef = token.token;
						break;
					case 'staves':
					case 'stave':
					case 'stv':
						addNextTokenToStaffInfo('staves');
						break;
					case 'brace':
					case 'brc':
						addNextTokenToStaffInfo('brace');
						break;
					case 'bracket':
					case 'brk':
						addNextTokenToStaffInfo('bracket');
						break;
					case 'name':
					case 'nm':
						addNextTokenToStaffInfo('name');
						break;
					case 'subname':
					case 'sname':
					case 'snm':
						addNextTokenToStaffInfo('subname');
						break;
					case 'merge':
						staffInfo.startStaff = false;
						break;
					case 'stem':
					case 'stems':
						attr = tokenizer.getVoiceToken(line, start, end);
						if (attr.warn !== undefined)
							warn("Expected value for stems in voice: " + attr.warn, line, start);
						else if (attr.token === 'up' || attr.token === 'down')
							multilineVars.voices[id].stem = attr.token;
						else
							warn("Expected up or down for voice stem", line, start);
						start += attr.len;
						break;
					case 'up':
					case 'down':
						multilineVars.voices[id].stem = token.token;
						break;
					case 'middle':
					case 'm':
						addNextTokenToStaffInfo('verticalPos');
						staffInfo.verticalPos = parseMiddle(staffInfo.verticalPos).mid;
						break;
					case 'gchords':
					case 'gch':
						multilineVars.voices[id].suppressChords = true;
						// gchords can stand on its own, or it could be gchords=0.
						attr = tokenizer.getVoiceToken(line, start, end);
						if (attr.token === "0")
							start = start + attr.len;
						break;
					case 'space':
					case 'spc':
						addNextTokenToStaffInfo('spacing');
						break;
					case 'scale':
						addNextTokenToVoiceInfo(id, 'scale', 'number');
						break;
					case 'score':
						addNextNoteTokenToVoiceInfo(id, 'scoreTranspose');
						break;
					case 'transpose':
						addNextTokenToVoiceInfo(id, 'transpose', 'number');
						break;
					case 'stafflines':
						addNextTokenToVoiceInfo(id, 'stafflines', 'number');
						break;
					case 'staffscale':
						// TODO-PER: This is passed to the engraver, but the engraver ignores it.
						addNextTokenToVoiceInfo(id, 'staffscale', 'number');
						break;
					case 'octave':
						// TODO-PER: This is accepted, but not implemented, yet.
						addNextTokenToVoiceInfo(id, 'octave', 'number');
						break;
					case 'volume':
						// TODO-PER: This is accepted, but not implemented, yet.
						addNextTokenToVoiceInfo(id, 'volume', 'number');
						break;
					case 'cue':
						// TODO-PER: This is accepted, but not implemented, yet.
						var cue = getNextToken('cue', 'string');
						if (cue === 'on')
							multilineVars.voices[id].scale = 0.6;
						else multilineVars.voices[id].scale = 1;
						break;
					case "style":
						attr = tokenizer.getVoiceToken(line, start, end);
						if (attr.warn !== undefined)
							warn("Expected value for style in voice: " + attr.warn, line, start);
						else if (attr.token === 'normal' || attr.token === 'harmonic' || attr.token === 'rhythm' || attr.token === 'x')
							multilineVars.voices[id].style = attr.token;
						else
							warn("Expected one of [normal, harmonic, rhythm, x] for voice style", line, start);
						start += attr.len;
						break;
					// default:
					// Use this to find V: usages that aren't handled.
					// 	console.log("parse voice", token, tune.metaText.title);
				}
			}
			start += tokenizer.eatWhiteSpace(line, start);
		}

		// now we've filled up staffInfo, figure out what to do with this voice
		// TODO-PER: It is unclear from the standard and the examples what to do with brace, bracket, and staves, so they are ignored for now.
		if (staffInfo.startStaff || multilineVars.staves.length === 0) {
			multilineVars.staves.push({index: multilineVars.staves.length, meter: multilineVars.origMeter});
			if (!multilineVars.score_is_present)
				multilineVars.staves[multilineVars.staves.length-1].numVoices = 0;
		}
		if (multilineVars.voices[id].staffNum === undefined) {
			// store where to write this for quick access later.
			multilineVars.voices[id].staffNum = multilineVars.staves.length-1;
			var vi = 0;
			for(var v in multilineVars.voices) {
				if(multilineVars.voices.hasOwnProperty(v)) {
					if (multilineVars.voices[v].staffNum === multilineVars.voices[id].staffNum)
						vi++;
				}
			}
			multilineVars.voices[id].index = vi-1;
		}
		var s = multilineVars.staves[multilineVars.voices[id].staffNum];
		if (!multilineVars.score_is_present)
			s.numVoices++;
		if (staffInfo.clef) s.clef = {type: staffInfo.clef, verticalPos: staffInfo.verticalPos};
		if (staffInfo.spacing) s.spacing_below_offset = staffInfo.spacing;
		if (staffInfo.verticalPos) s.verticalPos = staffInfo.verticalPos;

		if (staffInfo.name) {if (s.name) s.name.push(staffInfo.name); else s.name = [ staffInfo.name ];}
		if (staffInfo.subname) {if (s.subname) s.subname.push(staffInfo.subname); else s.subname = [ staffInfo.subname ];}

		setCurrentVoice(id);
	};

})();

module.exports = parseKeyVoice;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_tokenizer.js":
/*!*******************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_tokenizer.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_tokenizer.js: tokenizes an ABC Music Notation string to support abc_parse.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var parseCommon = __webpack_require__(/*! ./abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");

// this is a series of functions that get a particular element out of the passed stream.
// the return is the number of characters consumed, so 0 means that the element wasn't found.
// also returned is the element found. This may be a different length because spaces may be consumed that aren't part of the string.
// The return structure for most calls is { len: num_chars_consumed, token: str }
var Tokenizer = function() {
	this.skipWhiteSpace = function(str) {
		for (var i = 0; i < str.length; i++) {
		  if (!this.isWhiteSpace(str.charAt(i)))
				return i;
		}
		return str.length;	// It must have been all white space
	};
	var finished = function(str, i) {
		return i >= str.length;
	};
	this.eatWhiteSpace = function(line, index) {
		for (var i = index; i < line.length; i++) {
		  if (!this.isWhiteSpace(line.charAt(i)))
				return i-index;
		}
		return i-index;
	};

	// This just gets the basic pitch letter, ignoring leading spaces, and normalizing it to a capital
	this.getKeyPitch = function(str) {
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		switch (str.charAt(i)) {
			case 'A':return {len: i+1, token: 'A'};
			case 'B':return {len: i+1, token: 'B'};
			case 'C':return {len: i+1, token: 'C'};
			case 'D':return {len: i+1, token: 'D'};
			case 'E':return {len: i+1, token: 'E'};
			case 'F':return {len: i+1, token: 'F'};
			case 'G':return {len: i+1, token: 'G'};
//			case 'a':return {len: i+1, token: 'A'};
//			case 'b':return {len: i+1, token: 'B'};
//			case 'c':return {len: i+1, token: 'C'};
//			case 'd':return {len: i+1, token: 'D'};
//			case 'e':return {len: i+1, token: 'E'};
//			case 'f':return {len: i+1, token: 'F'};
//			case 'g':return {len: i+1, token: 'G'};
		}
		return {len: 0};
	};

	// This just gets the basic accidental, ignoring leading spaces, and only the ones that appear in a key
	this.getSharpFlat = function(str) {
		if (str === 'bass')
			return {len: 0};
		switch (str.charAt(0)) {
			case '#':return {len: 1, token: '#'};
			case 'b':return {len: 1, token: 'b'};
		}
		return {len: 0};
	};

	this.getMode = function(str) {
		var skipAlpha = function(str, start) {
			// This returns the index of the next non-alphabetic char, or the entire length of the string if not found.
		  while (start < str.length && ((str.charAt(start) >= 'a' && str.charAt(start) <= 'z') || (str.charAt(start) >= 'A' && str.charAt(start) <= 'Z')))
				start++;
			return start;
		};

		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		var firstThree = str.substring(i,i+3).toLowerCase();
		if (firstThree.length > 1 && firstThree.charAt(1) === ' ' || firstThree.charAt(1) === '^' || firstThree.charAt(1) === '_' || firstThree.charAt(1) === '=') firstThree = firstThree.charAt(0);	// This will handle the case of 'm'
		switch (firstThree) {
			case 'mix':return {len: skipAlpha(str, i), token: 'Mix'};
			case 'dor':return {len: skipAlpha(str, i), token: 'Dor'};
			case 'phr':return {len: skipAlpha(str, i), token: 'Phr'};
			case 'lyd':return {len: skipAlpha(str, i), token: 'Lyd'};
			case 'loc':return {len: skipAlpha(str, i), token: 'Loc'};
			case 'aeo':return {len: skipAlpha(str, i), token: 'm'};
			case 'maj':return {len: skipAlpha(str, i), token: ''};
			case 'ion':return {len: skipAlpha(str, i), token: ''};
			case 'min':return {len: skipAlpha(str, i), token: 'm'};
			case 'm':return {len: skipAlpha(str, i), token: 'm'};
		}
		return {len: 0};
	};

	this.getClef = function(str, bExplicitOnly) {
		var strOrig = str;
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		// The word 'clef' is optional, but if it appears, a clef MUST appear
		var needsClef = false;
		var strClef = str.substring(i);
		if (parseCommon.startsWith(strClef, 'clef=')) {
			needsClef = true;
			strClef = strClef.substring(5);
			i += 5;
		}
		if (strClef.length === 0 && needsClef)
			return {len: i+5, warn: "No clef specified: " + strOrig};

		var j = this.skipWhiteSpace(strClef);
		if (finished(strClef, j))
			return {len: 0};
		if (j > 0) {
			i += j;
			strClef = strClef.substring(j);
		}
		var name = null;
		if (parseCommon.startsWith(strClef, 'treble'))
			name = 'treble';
		else if (parseCommon.startsWith(strClef, 'bass3'))
			name = 'bass3';
		else if (parseCommon.startsWith(strClef, 'bass'))
			name = 'bass';
		else if (parseCommon.startsWith(strClef, 'tenor'))
			name = 'tenor';
		else if (parseCommon.startsWith(strClef, 'alto2'))
			name = 'alto2';
		else if (parseCommon.startsWith(strClef, 'alto1'))
			name = 'alto1';
		else if (parseCommon.startsWith(strClef, 'alto'))
			name = 'alto';
		else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'none')))
			name = 'none';
		else if (parseCommon.startsWith(strClef, 'perc'))
			name = 'perc';
		else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'C')))
			name = 'tenor';
		else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'F')))
			name = 'bass';
		else if (!bExplicitOnly && (needsClef && parseCommon.startsWith(strClef, 'G')))
			name = 'treble';
		else
			return {len: i+5, warn: "Unknown clef specified: " + strOrig};

		strClef = strClef.substring(name.length);
		j = this.isMatch(strClef, '+8');
		if (j > 0)
			name += "+8";
		else {
			j = this.isMatch(strClef, '-8');
			if (j > 0)
				name += "-8";
		}
		return {len: i+name.length, token: name, explicit: needsClef};
	};

	// This returns one of the legal bar lines
	// This is called alot and there is no obvious tokenable items, so this is broken apart.
	this.getBarLine = function(line, i) {
		switch (line.charAt(i)) {
			case ']':
				++i;
				switch (line.charAt(i)) {
					case '|': return {len: 2, token: "bar_thick_thin"};
					case '[':
						++i;
						if ((line.charAt(i) >= '1' && line.charAt(i) <= '9') || line.charAt(i) === '"')
							return {len: 2, token: "bar_invisible"};
						return {len: 1, warn: "Unknown bar symbol"};
					default:
						return {len: 1, token: "bar_invisible"};
				}
				break;
			case ':':
				++i;
				switch (line.charAt(i)) {
					case ':': return {len: 2, token: "bar_dbl_repeat"};
					case '|':	// :|
						++i;
						switch (line.charAt(i)) {
							case ']':	// :|]
								++i;
								switch (line.charAt(i)) {
									case '|':	// :|]|
										++i;
										if (line.charAt(i) === ':')  return {len: 5, token: "bar_dbl_repeat"};
										return {len: 3, token: "bar_right_repeat"};
									default:
										return {len: 3, token: "bar_right_repeat"};
								}
								break;
							case '|':	// :||
								++i;
								if (line.charAt(i) === ':')  return {len: 4, token: "bar_dbl_repeat"};
								return {len: 3, token: "bar_right_repeat"};
							default:
								return {len: 2, token: "bar_right_repeat"};
						}
						break;
					default:
						return {len: 1, warn: "Unknown bar symbol"};
				}
				break;
			case '[':	// [
				++i;
				if (line.charAt(i) === '|') {	// [|
					++i;
					switch (line.charAt(i)) {
						case ':': return {len: 3, token: "bar_left_repeat"};
						case ']': return {len: 3, token: "bar_invisible"};
						default: return {len: 2, token: "bar_thick_thin"};
					}
				} else {
					if ((line.charAt(i) >= '1' && line.charAt(i) <= '9') || line.charAt(i) === '"')
						return {len: 1, token: "bar_invisible"};
					return {len: 0};
				}
				break;
			case '|':	// |
				++i;
				switch (line.charAt(i)) {
					case ']': return {len: 2, token: "bar_thin_thick"};
					case '|': // ||
						++i;
						if (line.charAt(i) === ':') return {len: 3, token: "bar_left_repeat"};
						return {len: 2, token: "bar_thin_thin"};
					case ':':	// |:
						var colons = 0;
						while (line.charAt(i+colons) === ':') colons++;
						return { len: 1+colons, token: "bar_left_repeat"};
					default: return {len: 1, token: "bar_thin"};
				}
				break;
		}
		return {len: 0};
	};

	// this returns all the characters in the string that match one of the characters in the legalChars string
	this.getTokenOf = function(str, legalChars) {
		for (var i = 0; i < str.length; i++) {
			if (legalChars.indexOf(str.charAt(i)) < 0)
				return {len: i, token: str.substring(0, i)};
		}
		return {len: i, token: str};
	};

	this.getToken = function(str, start, end) {
		// This returns the next set of chars that doesn't contain spaces
		var i = start;
		while (i < end && !this.isWhiteSpace(str.charAt(i)))
			i++;
		return str.substring(start, i);
	};

	// This just sees if the next token is the word passed in, with possible leading spaces
	this.isMatch = function(str, match) {
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return 0;
		if (parseCommon.startsWith(str.substring(i), match))
			return i+match.length;
		return 0;
	};

	this.getPitchFromTokens = function(tokens) {
		var ret = { };
		var pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};
		ret.position = pitches[tokens[0].token];
		if (ret.position === undefined)
			return { warn: "Pitch expected. Found: " + tokens[0].token };
		tokens.shift();
		while (tokens.length) {
			switch (tokens[0].token) {
				case ',': ret.position -= 7; tokens.shift(); break;
				case '\'': ret.position += 7; tokens.shift(); break;
				default: return ret;
			}
		}
		return ret;
	};

	this.getKeyAccidentals2 = function(tokens) {
		var accs;
		// find and strip off all accidentals in the token list
		while (tokens.length > 0) {
			var acc;
			if (tokens[0].token === '^') {
				acc = 'sharp';
				tokens.shift();
				if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
				switch (tokens[0].token) {
					case '^': acc = 'dblsharp'; tokens.shift(); break;
					case '/': acc = 'quartersharp'; tokens.shift(); break;
				}
			} else if (tokens[0].token === '=') {
				acc = 'natural';
				tokens.shift();
			} else if (tokens[0].token === '_') {
				acc = 'flat';
				tokens.shift();
				if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
				switch (tokens[0].token) {
					case '_': acc = 'dblflat'; tokens.shift(); break;
					case '/': acc = 'quarterflat'; tokens.shift(); break;
				}
			} else {
				// Not an accidental, we'll assume that a later parse will recognize it.
				return { accs: accs };
			}
			if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
			switch (tokens[0].token.charAt(0))
			{
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
					if (accs === undefined)
						accs = [];
					accs.push({ acc: acc, note: tokens[0].token.charAt(0) });
					if (tokens[0].token.length === 1)
						tokens.shift();
					else
						tokens[0].token = tokens[0].token.substring(1);
					break;
				default:
					return {accs: accs, warn: 'Expected note name after ' + acc + ' Found: ' + tokens[0].token };
			}
		}
		return { accs: accs };
	};

	// This gets an accidental marking for the key signature. It has the accidental then the pitch letter.
	this.getKeyAccidental = function(str) {
		var accTranslation = {
			'^': 'sharp',
			'^^': 'dblsharp',
			'=': 'natural',
			'_': 'flat',
			'__': 'dblflat',
			'_/': 'quarterflat',
			'^/': 'quartersharp'
		};
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		var acc = null;
		switch (str.charAt(i))
		{
			case '^':
			case '_':
			case '=':
				acc = str.charAt(i);
				break;
			default:return {len: 0};
		}
		i++;
		if (finished(str, i))
			return {len: 1, warn: 'Expected note name after accidental'};
		switch (str.charAt(i))
		{
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
				return {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};
			case '^':
			case '_':
			case '/':
				acc += str.charAt(i);
				i++;
				if (finished(str, i))
					return {len: 2, warn: 'Expected note name after accidental'};
				switch (str.charAt(i))
				{
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
						return {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};
					default:
						return {len: 2, warn: 'Expected note name after accidental'};
				}
				break;
			default:
				return {len: 1, warn: 'Expected note name after accidental'};
		}
	};

	this.isWhiteSpace = function(ch) {
		return ch === ' ' || ch === '\t' || ch === '\x12';
	};

	this.getMeat = function(line, start, end) {
		// This removes any comments starting with '%' and trims the ends of the string so that there are no leading or trailing spaces.
		// it returns just the start and end characters that contain the meat.
		var comment = line.indexOf('%', start);
		if (comment >= 0 && comment < end)
			end = comment;
		while (start < end && (line.charAt(start) === ' ' || line.charAt(start) === '\t' || line.charAt(start) === '\x12'))
			start++;
		while (start < end && (line.charAt(end-1) === ' ' || line.charAt(end-1) === '\t' || line.charAt(end-1) === '\x12'))
			end--;
		return {start: start, end: end};
	};

	var isLetter = function(ch) {
		return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');
	};

	var isNumber = function(ch) {
		return (ch >= '0' && ch <= '9');
	};

	this.tokenize = function(line, start, end, alphaUntilWhiteSpace) {
		// this returns all the tokens inside the passed string. A token is a punctuation mark, a string of digits, a string of letters.
		//  Quoted strings are one token.
		//  If there is a minus sign next to a number, then it is included in the number.
		// If there is a period immediately after a number, with a number immediately following, then a float is returned.
		// The type of token is returned: quote, alpha, number, punct
		// If alphaUntilWhiteSpace is true, then the behavior of the alpha token changes.

		var ret = this.getMeat(line, start, end);
		start = ret.start;
		end = ret.end;
		var tokens = [];
		var i;
		while (start < end) {
			if (line.charAt(start) === '"') {
				i = start+1;
				while (i < end && line.charAt(i) !== '"') i++;
				tokens.push({ type: 'quote', token: line.substring(start+1, i), start: start+1, end: i});
				i++;
			} else if (isLetter(line.charAt(start))) {
				i = start+1;
				if (alphaUntilWhiteSpace)
					while (i < end && !this.isWhiteSpace(line.charAt(i))) i++;
				else
					while (i < end && isLetter(line.charAt(i))) i++;
				tokens.push({ type: 'alpha', token: line.substring(start, i), continueId: isNumber(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (line.charAt(start) === '.' && isNumber(line.charAt(i+1))) {
				i = start+1;
				var int2 = null;
				var float2 = null;
				while (i < end && isNumber(line.charAt(i))) i++;

				float2 = parseFloat(line.substring(start, i));
				tokens.push({ type: 'number', token: line.substring(start, i), intt: int2, floatt: float2, continueId: isLetter(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (isNumber(line.charAt(start)) || (line.charAt(start) === '-' && isNumber(line.charAt(i+1)))) {
				i = start+1;
				var intt = null;
				var floatt = null;
				while (i < end && isNumber(line.charAt(i))) i++;
				if (line.charAt(i) === '.' && isNumber(line.charAt(i+1))) {
					i++;
					while (i < end && isNumber(line.charAt(i))) i++;
				} else
					intt = parseInt(line.substring(start, i));

				floatt = parseFloat(line.substring(start, i));
				tokens.push({ type: 'number', token: line.substring(start, i), intt: intt, floatt: floatt, continueId: isLetter(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (line.charAt(start) === ' ' || line.charAt(start) === '\t') {
				i = start+1;
			} else {
				tokens.push({ type: 'punct', token: line.charAt(start), start: start, end: start+1});
				i = start+1;
			}
			start = i;
		}
		return tokens;
	};

	this.getVoiceToken = function(line, start, end) {
		// This finds the next token. A token is delimited by a space or an equal sign. If it starts with a quote, then the portion between the quotes is returned.
		var i = start;
		while (i < end && this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === '=')
			i++;

		if (line.charAt(i) === '"') {
			var close = line.indexOf('"', i+1);
			if (close === -1 || close >= end)
				return {len: 1, err: "Missing close quote"};
			return {len: close-start+1, token: this.translateString(line.substring(i+1, close))};
		} else {
			var ii = i;
			while (ii < end && !this.isWhiteSpace(line.charAt(ii)) && line.charAt(ii) !== '=')
				ii++;
			return {len: ii-start+1, token: line.substring(i, ii)};
		}
	};

	var charMap = {
		"`a": '', "'a": "", "^a": "", "~a": "", "\"a": "", "oa": "", "aa": "", "=a": "", "ua": "", ";a": "",
		"`e": '', "'e": "", "^e": "", "\"e": "", "=e": "", "ue": "", ";e": "", ".e": "",
		"`i": '', "'i": "", "^i": "", "\"i": "", "=i": "", "ui": "", ";i": "",
		"`o": '', "'o": "", "^o": "", "~o": "", "\"o": "", "=o": "", "uo": "", "/o": "",
		"`u": '', "'u": "", "^u": "", "~u": "", "\"u": "", "ou": "", "=u": "", "uu": "", ";u": "",
		"`A": '', "'A": "", "^A": "", "~A": "", "\"A": "", "oA": "", "AA": "", "=A": "", "uA": "", ";A": "",
		"`E": '', "'E": "", "^E": "", "\"E": "", "=E": "", "uE": "", ";E": "", ".E": "",
		"`I": '', "'I": "", "^I": "", "~I": "", "\"I": "", "=I": "", "uI": "", ";I": "", ".I": "",
		"`O": '', "'O": "", "^O": "", "~O": "", "\"O": "", "=O": "", "uO": "", "/O": "",
		"`U": '', "'U": "", "^U": "", "~U": "", "\"U": "", "oU": "", "=U": "", "uU": "", ";U": "",
		"ae": "", "AE": "", "oe": "", "OE": "", "ss": "",
		"'c": "", "^c": "", "uc": "", "cc": "", ".c": "", "cC": "", "'C": "", "^C": "", "uC": "", ".C": "",
		"~N": "", "~n": "",
		"=s": "", "vs": "",
		"DH": "", "dh": "",
		"HO": "", "Ho": "", "HU": "", "Hu": "",
		"'Y": "", "'y": "", "^Y": "", "^y": "", "\"Y": "", "\"y": "",
		"vS": "", "vZ": "", "vz": ''

// More chars:                                                                    
	};
	var charMap1 = {
		"#": "",
		"b": "",
		"=": ""
	};
	var charMap2 = {
		"201": "",
		"202": "",
		"203": "",
		"241": "",
		"242": "", "252": "a", "262": "2", "272": "o", "302": "", "312": "", "322": "", "332": "", "342": "", "352": "", "362": "", "372": "",
		"243": "", "253": "", "263": "3", "273": "", "303": "", "313": "", "323": "", "333": "", "343": "", "353": "", "363": "", "373": "",
		"244": "", "254": "", "264": "  ", "274": "14", "304": "", "314": "", "324": "", "334": "", "344": "", "354": "", "364": "", "374": "",
		"245": "", "255": "-", "265": "", "275": "12", "305": "", "315": "", "325": "", "335": "",  "345": "", "355": "", "365": "", "375": "",
		"246": "", "256": "", "266": "", "276": "34", "306": "", "316": "", "326": "", "336": "", "346": "", "356": "", "366": "", "376": "",
		"247": "", "257": " ", "267": "", "277": "", "307": "", "317": "", "327": "", "337": "", "347": "", "357": "", "367": "", "377": "",
		"250": " ", "260": "", "270": " ", "300": "", "310": "", "320": "", "330": "", "340": "", "350": "", "360": "", "370": "",
		"251": "", "261": "", "271": "1", "301": "", "311": "", "321": "", "331": "", "341": "", "351": "", "361": "", "371": "" };
	this.translateString = function(str) {
		var arr = str.split('\\');
		if (arr.length === 1) return str;
		var out = null;
		parseCommon.each(arr, function(s) {
			if (out === null)
				out = s;
			else {
				var c = charMap[s.substring(0, 2)];
				if (c !== undefined)
					out += c + s.substring(2);
				else {
					c = charMap2[s.substring(0, 3)];
					if (c !== undefined)
						out += c + s.substring(3);
					else {
						c = charMap1[s.substring(0, 1)];
						if (c !== undefined)
							out += c + s.substring(1);
						else
							out += "\\" + s;
					}
				}
			}
		});
		return out;
	};
	this.getNumber = function(line, index) {
		var num = 0;
		while (index < line.length) {
			switch (line.charAt(index)) {
				case '0':num = num*10;index++;break;
				case '1':num = num*10+1;index++;break;
				case '2':num = num*10+2;index++;break;
				case '3':num = num*10+3;index++;break;
				case '4':num = num*10+4;index++;break;
				case '5':num = num*10+5;index++;break;
				case '6':num = num*10+6;index++;break;
				case '7':num = num*10+7;index++;break;
				case '8':num = num*10+8;index++;break;
				case '9':num = num*10+9;index++;break;
				default:
					return {num: num, index: index};
			}
		}
		return {num: num, index: index};
	};

	this.getFraction = function(line, index) {
		var num = 1;
		var den = 1;
		if (line.charAt(index) !== '/') {
			var ret = this.getNumber(line, index);
			num = ret.num;
			index = ret.index;
		}
		if (line.charAt(index) === '/') {
			index++;
			if (line.charAt(index) === '/') {
				var div = 0.5;
				while (line.charAt(index++) === '/')
					div = div /2;
				return {value: num * div, index: index-1};
			} else {
				var iSave = index;
				var ret2 = this.getNumber(line, index);
				if (ret2.num === 0 && iSave === index)	// If we didn't use any characters, it is an implied 2
					ret2.num = 2;
				if (ret2.num !== 0)
					den = ret2.num;
				index = ret2.index;
			}
		}

		return {value: num/den, index: index};
	};

	this.theReverser = function(str) {
		if (parseCommon.endsWith(str, ", The"))
			return "The " + str.substring(0, str.length-5);
		if (parseCommon.endsWith(str, ", A"))
			return "A " + str.substring(0, str.length-3);
		return str;
	};

	this.stripComment = function(str) {
		var i = str.indexOf('%');
		if (i >= 0)
			return parseCommon.strip(str.substring(0, i));
		return parseCommon.strip(str);
	};

	this.getInt = function(str) {
		// This parses the beginning of the string for a number and returns { value: num, digits: num }
		// If digits is 0, then the string didn't point to a number.
		var x = parseInt(str);
		if (isNaN(x))
			return {digits: 0};
		var s = "" + x;
		var i = str.indexOf(s);	// This is to account for leading spaces
		return {value: x, digits: i+s.length};
	};

	this.getFloat = function(str) {
		// This parses the beginning of the string for a number and returns { value: num, digits: num }
		// If digits is 0, then the string didn't point to a number.
		var x = parseFloat(str);
		if (isNaN(x))
			return {digits: 0};
		var s = "" + x;
		var i = str.indexOf(s);	// This is to account for leading spaces
		return {value: x, digits: i+s.length};
	};

	this.getMeasurement = function(tokens) {
		if (tokens.length === 0) return { used: 0 };
		var used = 1;
		var num = '';
		if (tokens[0].token === '-') {
			tokens.shift();
			num = '-';
			used++;
		}
		else if (tokens[0].type !== 'number') return { used: 0 };
		num += tokens.shift().token;
		if (tokens.length === 0) return { used: 1, value: parseInt(num) };
		var x = tokens.shift();
		if (x.token === '.') {
			used++;
			if (tokens.length === 0) return { used: used, value: parseInt(num) };
			if (tokens[0].type === 'number') {
				x = tokens.shift();
				num = num + '.' + x.token;
				used++;
				if (tokens.length === 0) return { used: used, value: parseFloat(num) };
			}
			x = tokens.shift();
		}
		switch (x.token) {
			case 'pt': return { used: used+1, value: parseFloat(num) };
			case 'cm': return { used: used+1, value: parseFloat(num)/2.54*72 };
			case 'in': return { used: used+1, value: parseFloat(num)*72 };
			default: tokens.unshift(x); return { used: used, value: parseFloat(num) };
		}
		return { used: 0 };
	};
	var substInChord = function(str)
	{
		while ( str.indexOf("\\n") !== -1)
		{
			str = str.replace("\\n", "\n");
		}
		return str;
	};
	this.getBrackettedSubstring = function(line, i, maxErrorChars, _matchChar)
	{
		// This extracts the sub string by looking at the first character and searching for that
		// character later in the line (or search for the optional _matchChar).
		// For instance, if the first character is a quote it will look for
		// the end quote. If the end of the line is reached, then only up to the default number
		// of characters are returned, so that a missing end quote won't eat up the entire line.
		// It returns the substring and the number of characters consumed.
		// The number of characters consumed is normally two more than the size of the substring,
		// but in the error case it might not be.
		var matchChar = _matchChar || line.charAt(i);
		var pos = i+1;
		while ((pos < line.length) && (line.charAt(pos) !== matchChar))
			++pos;
		if (line.charAt(pos) === matchChar)
			return [pos-i+1,substInChord(line.substring(i+1, pos)), true];
		else	// we hit the end of line, so we'll just pick an arbitrary num of chars so the line doesn't disappear.
		{
			pos = i+maxErrorChars;
			if (pos > line.length-1)
				pos = line.length-1;
			return [pos-i+1, substInChord(line.substring(i+1, pos)), false];
		}
	};
};

module.exports = Tokenizer;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/abc_transpose.js":
/*!*******************************************************!*\
  !*** ./node_modules/abcjs/src/parse/abc_transpose.js ***!
  \*******************************************************/
/***/ (function(module) {

//    abc_transpose.js: Handles the automatic transposition of key signatures, chord symbols, and notes.
//    Copyright (C) 2010-2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var transpose = {};

var keyIndex = {
	'C': 0,
	'C#': 1,
	'Db': 1,
	'D': 2,
	'D#': 3,
	'Eb': 3,
	'E': 4,
	'F': 5,
	'F#': 6,
	'Gb': 6,
	'G': 7,
	'G#': 8,
	'Ab': 8,
	'A': 9,
	'A#': 10,
	'Bb': 10,
	'B': 11
};
var newKey = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];
var newKeyMinor = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'];

transpose.keySignature = function(multilineVars, keys, keyName, root, acc, localTranspose) {
	if (!localTranspose) localTranspose = 0;
	multilineVars.localTransposeVerticalMovement = 0;
	multilineVars.localTransposePreferFlats = false;
	var k = keys[keyName];
	if (!k) return multilineVars.key; // If the key isn't in the list, it is non-standard. We won't attempt to transpose it.
	multilineVars.localTranspose = (multilineVars.globalTranspose ? multilineVars.globalTranspose : 0) + localTranspose;

	if (!multilineVars.localTranspose)
		return { accidentals: k, root: root, acc: acc };
	multilineVars.globalTransposeOrigKeySig = k;
	if (multilineVars.localTranspose % 12 === 0) {
		multilineVars.localTransposeVerticalMovement = (multilineVars.localTranspose / 12) * 7;
		return { accidentals: k, root: root, acc: acc };
	}

	var baseKey = keyName[0];
	if (keyName[1] === 'b' || keyName[1] === '#') {
		baseKey += keyName[1];
		keyName = keyName.substr(2);
	} else
		keyName = keyName.substr(1);
	var index = keyIndex[baseKey] + multilineVars.localTranspose;
	while (index < 0) index += 12;
	if (index > 11) index = index % 12;
	var newKeyName = (keyName[0] === 'm' ? newKeyMinor[index] : newKey[index]);
	var transposedKey = newKeyName + keyName;
	var newKeySig = keys[transposedKey];
	if (newKeySig.length > 0 && newKeySig[0].acc === 'flat')
		multilineVars.localTransposePreferFlats = true;
	var distance = transposedKey.charCodeAt(0) - baseKey.charCodeAt(0);
	if (multilineVars.localTranspose > 0) {
		if (distance < 0)
			distance += 7;
		else if (distance === 0) {
			// There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.
			// If the distance is positive (we are raising pitch), and the change is higher (that is, Ab -> A), then raise an octave.
			// This test is easier because we know the keys are not equal (or we wouldn't get this far), so if the base key is a flat key, then
			// the transposed key must be higher. Likewise, if the transposed key is sharp, then the base key must be lower. And one
			// of those two things must be true because they are not both natural.
			if (baseKey[1] === '#' ||  transposedKey[1] === 'b')
				distance += 7;
		}
	} else if (multilineVars.localTranspose < 0) {
		if (distance > 0)
			distance -= 7;
		else if (distance === 0) {
			// There's a funny thing that happens when the key changes only an accidental's distance, for instance, from Ab to A.
			// If the distance is negative (we are dropping pitch), and the change is lower (that is, A -> Ab), then drop an octave.
			if (baseKey[1] === 'b' ||  transposedKey[1] === '#')
				distance -= 7;
		}
	}

	if (multilineVars.localTranspose > 0)
		multilineVars.localTransposeVerticalMovement = distance + Math.floor(multilineVars.localTranspose / 12) * 7;
	else
		multilineVars.localTransposeVerticalMovement = distance + Math.ceil(multilineVars.localTranspose / 12) * 7;
	return { accidentals: newKeySig, root: newKeyName[0], acc: newKeyName.length > 1 ? newKeyName[1] : "" };
};

var sharpChords = [ 'C', 'C', 'D', "D", 'E', 'F', "F", 'G', 'G', 'A', 'A', 'B'];
var flatChords = [ 'C', 'D', 'D', 'E', 'E', 'F', 'G', 'G', 'A', 'A', 'B', 'B'];
var sharpChordsFree = [ 'C', 'C#', 'D', "D#", 'E', 'F', "F#", 'G', 'G#', 'A', 'A#', 'B'];
var flatChordsFree = [ 'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

transpose.chordName = function(multilineVars, chord) {
	if (multilineVars.localTranspose && (multilineVars.localTranspose % 12 !== 0)) { // The chords are the same if it is an exact octave change.
		var transposeFactor = multilineVars.localTranspose;
		while (transposeFactor < 0) transposeFactor += 12;
		if (transposeFactor > 11) transposeFactor = transposeFactor % 12;
		if (multilineVars.freegchord) {
			chord = chord.replace(/Cb/g, "`~11`");
			chord = chord.replace(/Db/g, "`~1`");
			chord = chord.replace(/Eb/g, "`~3`");
			chord = chord.replace(/Fb/g, "`~4`");
			chord = chord.replace(/Gb/g, "`~6`");
			chord = chord.replace(/Ab/g, "`~8`");
			chord = chord.replace(/Bb/g, "`~10`");
			chord = chord.replace(/C#/g, "`~1`");
			chord = chord.replace(/D#/g, "`~3`");
			chord = chord.replace(/E#/g, "`~5`");
			chord = chord.replace(/F#/g, "`~6`");
			chord = chord.replace(/G#/g, "`~8`");
			chord = chord.replace(/A#/g, "`~10`");
			chord = chord.replace(/B#/g, "`~0`");
		} else {
			chord = chord.replace(/C/g, "`~11`");
			chord = chord.replace(/D/g, "`~1`");
			chord = chord.replace(/E/g, "`~3`");
			chord = chord.replace(/F/g, "`~4`");
			chord = chord.replace(/G/g, "`~6`");
			chord = chord.replace(/A/g, "`~8`");
			chord = chord.replace(/B/g, "`~10`");
			chord = chord.replace(/C/g, "`~1`");
			chord = chord.replace(/D/g, "`~3`");
			chord = chord.replace(/E/g, "`~5`");
			chord = chord.replace(/F/g, "`~6`");
			chord = chord.replace(/G/g, "`~8`");
			chord = chord.replace(/A/g, "`~10`");
			chord = chord.replace(/B/g, "`~0`");
		}
		chord = chord.replace(/C/g, "`~0`");
		chord = chord.replace(/D/g, "`~2`");
		chord = chord.replace(/E/g, "`~4`");
		chord = chord.replace(/F/g, "`~5`");
		chord = chord.replace(/G/g, "`~7`");
		chord = chord.replace(/A/g, "`~9`");
		chord = chord.replace(/B/g, "`~11`");
		var arr = chord.split("`");
		for (var i = 0; i < arr.length; i++) {
			if (arr[i][0] === '~') {
				var chordNum = parseInt(arr[i].substr(1),10);
				chordNum += transposeFactor;
				if (chordNum > 11) chordNum -= 12;
				if (multilineVars.freegchord)
					arr[i] = multilineVars.localTransposePreferFlats ? flatChordsFree[chordNum] : sharpChordsFree[chordNum];
				else
					arr[i] = multilineVars.localTransposePreferFlats ? flatChords[chordNum] : sharpChords[chordNum];
			}
		}
		chord = arr.join("");
	}
	return chord;
};

var pitchToLetter = [ 'c', 'd', 'e', 'f', 'g', 'a', 'b' ];
function accidentalChange(origPitch, newPitch, accidental, origKeySig, newKeySig) {
	var origPitchLetter = pitchToLetter[(origPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.
	var origAccidental = 0;
	for (var i = 0; i < origKeySig.length; i++) {
		if (origKeySig[i].note.toLowerCase() === origPitchLetter)
			origAccidental = accidentals[origKeySig[i].acc];
	}

	var currentAccidental = accidentals[accidental];
	var delta = currentAccidental - origAccidental;

	var newPitchLetter = pitchToLetter[(newPitch + 49) % 7]; // Make sure it is a positive pitch before normalizing.
	var newAccidental = 0;
	for (var j = 0; j < newKeySig.accidentals.length; j++) {
		if (newKeySig.accidentals[j].note.toLowerCase() === newPitchLetter)
			newAccidental = accidentals[newKeySig.accidentals[j].acc];
	}
	var calcAccidental = delta + newAccidental;
	if (calcAccidental < -2) {
		newPitch--;
		calcAccidental += (newPitchLetter === 'c' || newPitchLetter === 'f') ? 1 : 2;
	}
	if (calcAccidental > 2) {
		newPitch++;
		calcAccidental -= (newPitchLetter === 'b' || newPitchLetter === 'e') ? 1 : 2;
	}
	return [newPitch, calcAccidental];
}

var accidentals = {
	dblflat: -2,
	flat: -1,
	natural: 0,
	sharp: 1,
	dblsharp: 2
};
var accidentals2 = {
	"-2": "dblflat",
	"-1": "flat",
	"0": "natural",
	"1": "sharp",
	"2": "dblsharp"
};
transpose.note = function(multilineVars, el) {
	// the "el" that is passed in has el.accidental, and el.pitch. "pitch" is the vertical position (0=middle C)
	// localTranspose is the number of half steps
	// localTransposeVerticalMovement is the vertical distance to move.
	if (!multilineVars.localTranspose)
		return;
	var origPitch = el.pitch;
	el.pitch = el.pitch + multilineVars.localTransposeVerticalMovement;

	if (el.accidental) {
		var ret = accidentalChange(origPitch, el.pitch, el.accidental, multilineVars.globalTransposeOrigKeySig, multilineVars.targetKey);
		el.pitch = ret[0];
		el.accidental = accidentals2[ret[1]];
	}

};

module.exports = transpose;


/***/ }),

/***/ "./node_modules/abcjs/src/parse/wrap_lines.js":
/*!****************************************************!*\
  !*** ./node_modules/abcjs/src/parse/wrap_lines.js ***!
  \****************************************************/
/***/ (function(module) {

//    wrap_lines.js: does line wrap on an already parsed tune.
//    Copyright (C) 2018 Paul Rosen (paul at paulrosen dot net)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function wrapLines(tune, lineBreaks) {
	if (!lineBreaks || tune.lines.length === 0)
		return;

	// tune.lines contains nested arrays: there is an array of lines (that's the part this function rewrites),
	// there is an array of staffs per line (for instance, piano will have 2, orchestra will have many)
	// there is an array of voices per staff (for instance, 4-part harmony might have bass and tenor on a single staff)
	// The measure numbers start at zero for each staff, but on the succeeding lines, the measure numbers are reset to the beginning of the line.
	var newLines = [];
	// keep track of our counters for each staff and voice
	var startNewLine = [];
	var currentLine = [];
	var measureNumber = [];
	var measureMarker = [];
	var lastMeter = '';
	var voiceStart = {};
	var linesWithoutStaff = 0;

	for (var i = 0; i < tune.lines.length; i++) {
		var line = tune.lines[i];
		if (line.staff) {
			var staffs = line.staff;
			for (var j = 0; j < staffs.length; j++) {
				if (startNewLine[j] === undefined) {
					startNewLine[j] = [];
					currentLine[j] = [];
					measureNumber[j] = [];
					measureMarker[j] = [];
				}
				var staff = staffs[j];
				var voices = staff.voices;
				for (var k = 0; k < voices.length; k++) {
					if (startNewLine[j][k] === undefined) {
						startNewLine[j][k] = true;
						currentLine[j][k] = 0;
						measureNumber[j][k] = 0;
						measureMarker[j][k] = 0;
					}
					if (linesWithoutStaff > 0) currentLine[j][k] += linesWithoutStaff;
					var voice = voices[k];
					for (var e = 0; e < voice.length; e++) {
						if (startNewLine[j][k]) {
							if (!newLines[currentLine[j][k]])
								newLines[currentLine[j][k]] = { staff: [] };
							if (!newLines[currentLine[j][k]].staff[j]) {
								newLines[currentLine[j][k]].staff[j] = {voices: []};
								for (var key in staff) {
									if (staff.hasOwnProperty(key)) {
										if (key === 'meter') {
											if (newLines.length === 1 || lastMeter !== JSON.stringify(staff[key])) {
												lastMeter = JSON.stringify(staff[key]);
												newLines[currentLine[j][k]].staff[j][key] = staff[key];
											}
										} else if (key !== 'voices') {
											newLines[currentLine[j][k]].staff[j][key] = staff[key];
										}
									}
								}
							}
							if (measureMarker[j][k])
								newLines[currentLine[j][k]].staff[j].barNumber = measureMarker[j][k];
							startNewLine[j][k] = false;
						}
						var element = voice[e];
						if (!newLines[currentLine[j][k]].staff[j].voices[k]) {
							newLines[currentLine[j][k]].staff[j].voices[k] = [];
							for (var startItem in voiceStart) {
								if (voiceStart.hasOwnProperty(startItem)) {
									newLines[currentLine[j][k]].staff[j].voices[k].push(voiceStart[startItem])
								}
							}
						}
						newLines[currentLine[j][k]].staff[j].voices[k].push(element);
						if (element.el_type === 'stem') {
							// This is a nice trick to just pay attention to the last setting of each type.
							voiceStart[element.el_type] = element;
						}

						if (element.el_type === 'bar') {
							measureNumber[j][k]++;
							if (lineBreaks[measureNumber[j][k]]) {
								startNewLine[j][k] = true;
								currentLine[j][k]++;
								measureMarker[j][k] = element.barNumber;
								delete element.barNumber;
							}
						}
					}

				}
			}
			linesWithoutStaff = 0;
		} else {
			newLines.push(line);
			linesWithoutStaff++;
		}
	}
	tune.lines = newLines;
}

function freeFormLineBreaks(widths, lineBreakPoint) {
	var lineBreaks = [];
	var totals = [];
	var totalThisLine = 0;
	// run through each measure and see if the accumulation is less than the ideal.
	// if it passes the ideal, then see whether the last or this one is closer to the ideal.
	for (var i = 0; i < widths.length; i++) {
		var width = widths[i];
		var attemptedWidth = totalThisLine + width;
		if (attemptedWidth < lineBreakPoint)
			totalThisLine = attemptedWidth;
		else {
			// This just passed the ideal, so see whether the previous or the current number of measures is closer.
			var oldDistance = lineBreakPoint - totalThisLine;
			var newDistance = attemptedWidth - lineBreakPoint;
			if (oldDistance < newDistance && totalThisLine > 0) {
				lineBreaks.push(i - 1);
				totals.push(Math.round(totalThisLine - width));
				totalThisLine = width;
			} else {
				if (i < widths.length-1) {
					lineBreaks.push(i);
					totals.push(Math.round(totalThisLine));
					totalThisLine = 0;
				}
			}
		}
	}
	totals.push(Math.round(totalThisLine));
	return { lineBreaks: lineBreaks, totals: totals };
}

// function createLineTestArray(numLines, numMeasures, maxMeasuresPerLine, minMeasuresPerLine) {
// 	var tries = [];
// 	// To get all the iterations, it is every digit in a particular base-numbering system.
// 	// That is, we want to generate every number that is (numLines-1) digits, in base (max-min+1)
// 	// For instance, for 5 lines where the min is 6 and max is 8, we want ever combination of 4 digits in base 3.
// 	var base = maxMeasuresPerLine - minMeasuresPerLine + 1;
// 	var digits = numLines - 1; // The last digit is fixed: it is what ever is needed to sum up to the total number of measures.
// 	var done = false;
// 	var iter = 0;
// 	while (!done) {
// 		var attempt = [];
// 		var num = iter;
// 		var total = 0;
// 		for (var d = digits - 1; d >= 0; d--) {
// 			attempt[d] = (num % base) + minMeasuresPerLine;
// 			num = Math.floor(num / base);
// 			total += attempt[d];
// 		}
// 		if (num > 0)
// 			done = true; // continue until we exceed the greatest number. We know because there is a remainer.
// 		else {
// 			var lastLine = numMeasures - total;
// 			if (lastLine >= minMeasuresPerLine && lastLine <= maxMeasuresPerLine) {
// 				attempt[digits] = lastLine;
// 				tries.push(attempt);
// 			}
// 			iter++;
// 		}
// 	}
// 	return tries;
// }

// function getVariance(attempt, idealLineBreak, widths, allowableOverage) {
// 	var measureNumber = 0;
// 	var thisWorstVariance = 0;
// 	for (var j = 0; j < attempt.length; j++) {
// 		var lineWidth = 0;
// 		var measuresThisLine = attempt[j];
// 		for (var k = 0; k < measuresThisLine; k++) {
// 			lineWidth += widths[measureNumber++];
// 		}
// 		if (lineWidth > allowableOverage)
// 			return null;
// 		var variance = Math.abs(lineWidth - idealLineBreak);
// 		if (variance > thisWorstVariance)
// 			thisWorstVariance = variance;
// 	}
// 	return thisWorstVariance;
// }

// function getMaxVariance(widths, lineBreakPoint, lineBreaks) {
// 	var maxVariance = 0;
// 	var numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break
// 	var measureNumber = 0;
// 	var totals = [];
// 	for (var i = 0; i <= lineBreaks.length; i++) {
// 		var breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];
// 		var thisTotal = 0;
// 		for (var j = measureNumber; j < breakMeasure; j++) {
// 			thisTotal += widths[j];
// 		}
// 		measureNumber = breakMeasure;
// 		var thisVariance = thisTotal <= lineBreakPoint ? lineBreakPoint - thisTotal : 1000000;
// 		totals.push({total: thisTotal, variance: thisVariance})
// 		maxVariance = Math.max(maxVariance, thisVariance);
// 	}
//
// 	console.log(lineBreakPoint, totals)
// 	return maxVariance;
// }

function getVariance(widths, lineBreaks) {
	var numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break
	var avg = widths.total / numLines;
	var largestVariance = 0;
	var measureNumber = 0;
	for (var i = 0; i <= lineBreaks.length; i++) {
		var breakMeasure = (i === lineBreaks.length) ? widths.measureWidths.length-1 : lineBreaks[i];
		var thisVariance = lineVariance(widths.measureWidths, measureNumber, breakMeasure, avg);
		measureNumber = breakMeasure+1;
		largestVariance = Math.max(largestVariance, thisVariance);
	}

	return largestVariance;
}

// function getAvgVariance(widths, lineBreakPoint, lineBreaks) {
// 	var totalVariance = 0;
// 	var numLines = lineBreaks.length + 1; // the last line doesn't have an explicit break
// 	var measureNumber = 0;
// 	for (var i = 0; i <= lineBreaks.length; i++) {
// 		var breakMeasure = (i === lineBreaks.length) ? widths.length : lineBreaks[i];
// 		var thisTotal = 0;
// 		for (var j = measureNumber; j < breakMeasure; j++) {
// 			thisTotal += widths[j];
// 		}
// 		measureNumber = breakMeasure;
// 		var thisVariance = Math.abs(lineBreakPoint - thisTotal);
// 		totalVariance += thisVariance;
// 	}
//
// 	return totalVariance / numLines;
// }

function lineVariance(widths, start, end, avg) {
	var thisTotal = lineWidth(widths, start, end);
	var thisVariance = Math.abs(avg - thisTotal);
	return thisVariance;
}

function lineWidth(widths, start, end) {
	var thisTotal = 0;
	for (var j = start; j <= end; j++)
		thisTotal += widths[j];
	return thisTotal;
}

// TODO-PER: For long pieces of music, this can get long, so stop finding the combinations at an arbitrary place.
function getAttempts(widths, start, linesLeft, min, max, lastLines) {
	var MAX_COMBINATIONS = 1200;
	var acc = 0;
	var attempts = [];
	for (var i = start; i < widths.length && acc < max; i++) {
		acc += widths[i];
		if (acc > max)
			break;
		if (acc > min) {
			if (linesLeft > 0 && attempts.length < MAX_COMBINATIONS) {
				var nextLines = getAttempts(widths, i + 1, linesLeft - 1, min, max, lastLines);
				for (var j = 0; j < nextLines.length; j++)
					attempts.push([i].concat(nextLines[j]));
			}
			if (linesLeft === 1 && lastLines.indexOf(i) >= 0)
				attempts.push([i]);
		}
	}
	return attempts;
}

function lastLinePossibilities(widths, start, min, max) {
	var acc = 0;
	var possibilities = [];
	for (var i = widths.length-1; i >= 0; i--) {
		acc += widths[i];
		if (acc > max)
			break;
		if (acc > min && i < start) {
			possibilities.push(i-1);
		}
	}
	return possibilities;
}

function clone(arr) {
	var newArr = [];
	for (var i = 0; i < arr.length; i++)
		newArr.push(arr[i]);
	return newArr;
}

function oneTry(measureWidths, idealWidths, accumulator, lineAccumulator, lineWidths, lastVariance, highestVariance, currLine, lineBreaks, startIndex, otherTries) {
	for (var i = startIndex; i < measureWidths.length; i++) {
		var measureWidth = measureWidths[i];
		accumulator += measureWidth;
		lineAccumulator += measureWidth;
		var thisVariance = Math.abs(accumulator - idealWidths[currLine]);
		var varianceIsClose = Math.abs(thisVariance - lastVariance) < idealWidths[0] / 10; // see if the difference is less than 10%, if so, run the test both ways.
		if (varianceIsClose) {
			if (thisVariance < lastVariance) {
				// Also attempt one less measure on the current line - sometimes that works out better.
				var newWidths = clone(lineWidths);
				var newBreaks = clone(lineBreaks);
				newBreaks.push(i-1);
				newWidths.push(lineAccumulator - measureWidth);
				otherTries.push({
					accumulator: accumulator,
					lineAccumulator: measureWidth,
					lineWidths: newWidths,
					lastVariance: Math.abs(accumulator - idealWidths[currLine+1]),
					highestVariance: Math.max(highestVariance, lastVariance),
					currLine: currLine+1,
					lineBreaks: newBreaks,
					startIndex: i+1});
			} else if (thisVariance > lastVariance && i < measureWidths.length-1) {
				// Also attempt one extra measure on this line.
				newWidths = clone(lineWidths);
				newBreaks = clone(lineBreaks);
				// newBreaks[newBreaks.length-1] = i;
				// newWidths[newWidths.length-1] = lineAccumulator;
				otherTries.push({
					accumulator: accumulator,
					lineAccumulator: lineAccumulator,
					lineWidths: newWidths,
					lastVariance: thisVariance,
					highestVariance: Math.max(highestVariance, thisVariance),
					currLine: currLine,
					lineBreaks: newBreaks,
					startIndex: i+1});
			}
		}
		if (thisVariance > lastVariance) {
			lineBreaks.push(i - 1);
			currLine++;
			highestVariance = Math.max(highestVariance, lastVariance);
			lastVariance = Math.abs(accumulator - idealWidths[currLine]);
			lineWidths.push(lineAccumulator - measureWidth);
			lineAccumulator = measureWidth;
		} else {
			lastVariance = thisVariance;
		}
	}
	lineWidths.push(lineAccumulator);
}

function optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation) {
	//	figure out how many lines - That's one more than was tried before.
	var numLines = Math.ceil(widths.total / lineBreakPoint) + 1;

	//	get the ideal width for a line (cumulative width / num lines) - approx the same as lineBreakPoint except for rounding
	var idealWidth = Math.floor(widths.total / numLines);

	//	get each ideal line width (1*ideal, 2*ideal, 3*ideal, etc)
	var idealWidths = [];
	for (var i = 0; i < numLines; i++)
		idealWidths.push(idealWidth*(i+1));

	//	from first measure, step through accum. Widths until the abs of the ideal is greater than the last one.
	// This can sometimes look funny in edge cases, so when the length is within 10%, try one more or one less to see which is better.
	// This is better than trying all the possibilities because that would get to be a huge number for even a medium size piece.
	// This method seems to never generate more than about 16 tries and it is usually 4 or less.
	var otherTries = [];
	otherTries.push({
		accumulator: 0,
		lineAccumulator: 0,
		lineWidths: [],
		lastVariance: 999999,
		highestVariance: 0,
		currLine: 0,
		lineBreaks: [], // These are the zero-based last measure on each line
		startIndex: 0});
	var index = 0;
	while (index < otherTries.length) {
		oneTry(widths.measureWidths,
			idealWidths,
			otherTries[index].accumulator,
			otherTries[index].lineAccumulator,
			otherTries[index].lineWidths,
			otherTries[index].lastVariance,
			otherTries[index].highestVariance,
			otherTries[index].currLine,
			otherTries[index].lineBreaks,
			otherTries[index].startIndex,
			otherTries);
		index++;
	}
	for (i = 0; i < otherTries.length; i++) {
		var otherTry = otherTries[i];
		otherTry.variances = [];
		otherTry.aveVariance = 0;
		for (var j = 0; j < otherTry.lineWidths.length; j++) {
			var lineWidth = otherTry.lineWidths[j];
			otherTry.variances.push(lineWidth - idealWidths[0]);
			otherTry.aveVariance += Math.abs(lineWidth - idealWidths[0]);
		}
		otherTry.aveVariance =  otherTry.aveVariance / otherTry.lineWidths.length;
		explanation.attempts.push({ type: "optimizeLineWidths", lineBreaks: otherTry.lineBreaks, variances: otherTry.variances, aveVariance: otherTry.aveVariance, widths: widths.measureWidths });
	}
	var smallest = 9999999;
	var smallestIndex = -1;
	for (i = 0; i < otherTries.length; i++) {
		otherTry = otherTries[i];
		if (otherTry.aveVariance < smallest) {
			smallest = otherTry.aveVariance;
			smallestIndex = i;
		}
	}
	return { failed: false, lineBreaks: otherTries[smallestIndex].lineBreaks, variance: otherTries[smallestIndex].highestVariance };
}
// 	// Instead of having to try all the different combinations to find the best, we start with an important piece of knowledge about the lineBreaks we are given:
// 	// If there is a line too short, it is the last one.
// 	// So, let's just do a couple of tweaks to see how it works to add one or two measures to the last line.
// 	var avg = widths.total / (lineBreaks.length + 1);
// 	var variance = getVariance(widths, lineBreaks);
// 	var variancePct = variance/lineBreakPoint*100;
//
// 	if (lineBreaks.length === 0)
// 		return { failed: true, reason: "Only one line." };
//
// 	var lastLineStart = lineBreaks[lineBreaks.length-1]+1;
// 	var lastLineVariance = lineVariance(widths.measureWidths, lastLineStart, widths.measureWidths.length, avg);
// 	if (variance > lastLineVariance)
// 		return { failed: true, reason: "Last line is not too short." };
//
// 	// Let's get a list of all combinations that have a possibility of working. That is, all combinations where no line has a variance larger than "variance".
// 	var lastLines = lastLinePossibilities(widths.measureWidths, lastLineStart, avg - variance, avg + variance);
// 	var attempts = getAttempts(widths.measureWidths, 0, lineBreaks.length, avg - variance, avg + variance, lastLines);
// 	//console.log(attempts, avg - variance, avg + variance);
//
// 	var failed = true;
// 	for (var i = 0; i < attempts.length; i++) {
// 		var newVariance = getVariance(widths, attempts[i]);
// 		if (newVariance < variance) {
// 			explanation.attempts.push({
// 				type: "Optimize try", lineBreaks: attempts[i],
// 				variance: Math.round(variance), newVariance: Math.round(newVariance),
// 				totalAttempts: attempts.length
// 			});
// 			variance = newVariance;
// 			lineBreaks = attempts[i];
// 			failed = false;
// 		}
// 	}
// 	if (failed) {
// 		explanation.attempts.push({ type: "Optimize try", lineBreaks: lineBreaks, variance: variance, reason: "None of the " + attempts.length + " attempts were better." });
// 		// TODO-PER: This shouldn't be necessary, but just try to move one measure down and see if it helps.
// 		if (lineBreaks.length > 0) {
// 			var attempt = [].concat(lineBreaks);
// 			attempt[attempt.length - 1]--;
// 			newVariance = getVariance(widths, attempt);
// 			explanation.attempts.push({
// 				type: "Optimize last try", lineBreaks: attempts[i],
// 				variance: Math.round(variance), newVariance: Math.round(newVariance),
// 				totalAttempts: attempts.length
// 			});
// 			if (newVariance < variance) {
// 				variance = newVariance;
// 				lineBreaks = attempt;
// 				failed = false;
// 			}
// 		}
// 	}
// 	// Let's squeeze the line successively until it spills onto an extra line, then take the option with the lowest variance
// 	// var targetNumLines = lineBreaks.length;
// 	// var newNumLines = targetNumLines;
// 	// var TRY_INCREMENT = 1;
// 	// var tryBreakPoint = lineBreakPoint - TRY_INCREMENT;
// 	// var failed = true;
// 	// while (targetNumLines === newNumLines && tryBreakPoint > 50) {
// 	// 	var ff = freeFormLineBreaks(widths.measureWidths, tryBreakPoint);
// 	// 	newNumLines = ff.lineBreaks.length;
// 	// 	if (newNumLines === targetNumLines) {
// 	// 		var newVariance = getVariance(widths, ff.lineBreaks);
// 	// 		var newVariancePct = newVariance/tryBreakPoint*100;
// 	// 		explanation.attempts.push({type: "Optimize try", tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals,
// 	// 			variance: Math.round(variance), newVariance: Math.round(newVariance), variancePct: Math.round(variancePct), newVariancePct: Math.round(newVariancePct)
// 	// 		});
// 	// 		if (newVariancePct < variancePct) {
// 	// 			variancePct = newVariancePct;
// 	// 			lineBreaks = ff.lineBreaks;
// 	// 			failed = false;
// 	// 		}
// 	// 	} else {
// 	// 		explanation.attempts.push({type: "Optimize try", explanation: "Exceeded number of lines." , tryBreakPoint: Math.round(tryBreakPoint), lineBreaks: ff.lineBreaks, totals: ff.totals, variance: variance, avg: avg, variancePct: variancePct});
// 	// 	}
// 	// 	tryBreakPoint -= TRY_INCREMENT;
// 	// }
//
// 	return { failed: failed, lineBreaks: lineBreaks, variance: variance };
// }

// function fixedNumLinesBreaks(widths, numLines, allowOver, allowableVariance) {
// 	var idealLineBreak = widths.total / numLines;
// 	// If all the measures had the same amount of stuff, then the ave would be correct.
// 	// We will test all the combinations from one less to one more than the average.
// 	var averageMeasuresPerLine = Math.round(widths.measureWidths.length / numLines);
// 	var minMeasuresPerLine = Math.max(averageMeasuresPerLine - 1, 1);
// 	var maxMeasuresPerLine = averageMeasuresPerLine + 1;
// 	var tries = createLineTestArray(numLines, widths.measureWidths.length, maxMeasuresPerLine, minMeasuresPerLine);
// 	console.log("fixedNumLinesBreaks tests ("+minMeasuresPerLine+'-'+maxMeasuresPerLine+")", numLines, tries.length)
//
// 	// For each possible number of measures per line, see which has the closest spacing to the ideal.
// 	var bestCase = -1;
// 	var bestCaseVariance = 1000000;
// 	for (var i = 0 ; i < tries.length; i++) {
// 		var attempt = tries[i];
// 		var variance = getVariance(attempt, idealLineBreak, widths.measureWidths, allowOver ? allowableVariance : 0);
// 		if (variance !== null) {
// 			if (variance < bestCaseVariance) {
// 				bestCaseVariance = variance;
// 				bestCase = i;
// 			}
// 		}
// 	}
// 	var failed = true;
// 	// For debugging, recreate the line widths
// 	var totals = [];
// 	if (bestCase >= 0) {
// 		failed = false;
// 		var index = 0;
// 		for (i = 0; i < tries[bestCase].length; i++) {
// 			var total = 0;
// 			for (var j = 0; j < tries[bestCase][i]; j++) {
// 				total += widths.measureWidths[index++];
// 			}
// 			totals.push(Math.round(total));
// 		}
// 		// We now have an array that contains the number of measures per line, but we want to return the absolute measure number to break on.
// 		if (tries[bestCase].length > 0) {
// 			tries[bestCase][0]--; // The results should contain the last measure number on the line, zero-based.
// 			for (i = 1; i < tries[bestCase].length; i++)
// 				tries[bestCase][i] += tries[bestCase][i - 1]; // This sets the zero-based measure number
// 			// The last line is implied and we don't need to return it
// 			tries[bestCase].pop();
// 		}
// 	}
// 	return { failed: failed, lineBreaks: tries[bestCase], bestCaseVariance: Math.round(bestCaseVariance), totals: totals };
// }

function fixedMeasureLineBreaks(widths, lineBreakPoint, preferredMeasuresPerLine) {
	var lineBreaks = [];
	var totals = [];
	var thisWidth = 0;
	var failed = false;
	for (var i = 0; i < widths.length; i++) {
		thisWidth += widths[i];
		if (thisWidth > lineBreakPoint) {
			failed = true;
		}
		if (i % preferredMeasuresPerLine === (preferredMeasuresPerLine-1)) {
			if (i !== widths.length-1) // Don't bother putting a line break for the last line - it's already a break.
				lineBreaks.push(i);
			totals.push(Math.round(thisWidth));
			thisWidth = 0;
		}
	}
	return { failed: failed, totals: totals, lineBreaks: lineBreaks };
}

function getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse) {
	var abcParser = new Parse();
	var revisedParams = {
		lineBreaks: lineBreaks,
		staffwidth: staffWidth
	};
	for (var key in params) {
		if (params.hasOwnProperty(key) && key !== 'wrap' && key !== 'staffwidth') {
			revisedParams[key] = params[key];
		}
	}

	abcParser.parse(abcString, revisedParams);
	return { tune: abcParser.getTune(), revisedParams: revisedParams };
}

function calcLineWraps(tune, widths, abcString, params, Parse, engraver_controller) {
	// For calculating how much can go on the line, it depends on the width of the line. It is a convenience to just divide it here
	// by the minimum spacing instead of multiplying the min spacing later.
	// The scaling works differently: this is done by changing the scaling of the outer SVG, so the scaling needs to be compensated
	// for here, because the actual width will be different from the calculated numbers.

	// If the desired width is less than the margin, just punt and return the original tune
	if (params.staffwidth < widths.left) {
		return {
			explanation: "Staffwidth is narrower than the margin",
			tune: tune,
			revisedParams: params
		};
	}
	var scale = params.scale ? Math.max(params.scale, 0.1) : 1;
	var minSpacing = params.wrap.minSpacing ? Math.max(parseFloat(params.wrap.minSpacing), 1) : 1;
	var minSpacingLimit = params.wrap.minSpacingLimit ? Math.max(parseFloat(params.wrap.minSpacingLimit), 1) : minSpacing - 0.1;
	var maxSpacing = params.wrap.maxSpacing ? Math.max(parseFloat(params.wrap.maxSpacing), 1) : undefined;
	if (params.wrap.lastLineLimit && !maxSpacing)
		maxSpacing = Math.max(parseFloat(params.wrap.lastLineLimit), 1);
	var targetHeight = params.wrap.targetHeight ? Math.max(parseInt(params.wrap.targetHeight, 10), 100) : undefined;
	var preferredMeasuresPerLine = params.wrap.preferredMeasuresPerLine ? Math.max(parseInt(params.wrap.preferredMeasuresPerLine, 10), 1) : undefined;

	var lineBreakPoint = (params.staffwidth - widths.left) / minSpacing / scale;
	var minLineSize = (params.staffwidth - widths.left) / maxSpacing / scale;
	var allowableVariance = (params.staffwidth - widths.left) / minSpacingLimit / scale;
	var explanation = { widths: widths, lineBreakPoint: lineBreakPoint, minLineSize: minLineSize, attempts: [], staffWidth: params.staffwidth, minWidth: Math.round(allowableVariance) };

	// If there is a preferred number of measures per line, test that first. If none of the lines is too long, then we're finished.
	var lineBreaks = null;
	if (preferredMeasuresPerLine) {
		var f = fixedMeasureLineBreaks(widths.measureWidths, lineBreakPoint, preferredMeasuresPerLine);
		explanation.attempts.push({ type: "Fixed Measures Per Line", preferredMeasuresPerLine: preferredMeasuresPerLine, lineBreaks: f.lineBreaks, failed: f.failed, totals: f.totals });
		if (!f.failed)
			lineBreaks = f.lineBreaks;
	}

	// If we don't have lineBreaks yet, use the free form method of line breaks.
	// This will be called either if Preferred Measures is not used, or if the music is just weird - like a single measure is way too crowded.
	if (!lineBreaks) {
		var ff = freeFormLineBreaks(widths.measureWidths, lineBreakPoint);
		explanation.attempts.push({ type: "Free Form", lineBreaks: ff.lineBreaks, totals: ff.totals });
		lineBreaks = ff.lineBreaks;

		// We now have an acceptable number of lines, but the measures may not be optimally distributed. See if there is a better distribution.
		ff = optimizeLineWidths(widths, lineBreakPoint, lineBreaks, explanation);
		explanation.attempts.push({ type: "Optimize", failed: ff.failed, reason: ff.reason, lineBreaks: ff.lineBreaks, totals: ff.totals });
		if (!ff.failed)
			lineBreaks = ff.lineBreaks;
	}

	// If the vertical space exceeds targetHeight, remove a line and try again. If that is too crowded, then don't use it.
	var staffWidth = params.staffwidth;
	var ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);
	var newWidths = engraver_controller.getMeasureWidths(ret.tune);
	var gotTune = true; // If we adjust the num lines, set this to false
	explanation.attempts.push({type: "heightCheck", height: newWidths.height });

	// 	if all of the lines are too sparse, make the width narrower.
	// TODO-PER: implement this case.

	// If one line and the spacing is > maxSpacing, make the width narrower.
	if (lineBreaks.length === 0 && minLineSize > widths.total) {
		staffWidth = (widths.total * maxSpacing * scale) + widths.left;
		explanation.attempts.push({type: "too sparse", newWidth: Math.round(staffWidth)})
		gotTune = false;
	}

	// if (ret.lineBreaks.length === 0) {
	// 	// Everything fits on one line, so see if there is TOO much space and the staff width needs to be shortened.
	// 	if (minLineSize > 0 && ret.totalThisLine > 0 && ret.totalThisLine < minLineSize)
	// 		staffWidth = staffWidth / (minLineSize / ret.totalThisLine);
	// } else if (ret.totalThisLine < minLineSize) {
	// 	// the last line is too short, so attempt to redistribute by changing the min.
	// 	// We will try more and less space alternatively. The space can't be less than 1.0, and we'll try in 0.1 increments.
	// 	var minTrys = [];
	// 	if (minSpacing > 1.1)
	// 		minTrys.push(minSpacing - 0.1);
	// 	minTrys.push(minSpacing + 0.1);
	// 	if (minSpacing > 1.2)
	// 		minTrys.push(minSpacing - 0.2);
	// 	minTrys.push(minSpacing + 0.2);
	// 	if (minSpacing > 1.3)
	// 		minTrys.push(minSpacing - 0.3);
	// 	minTrys.push(minSpacing + 0.3);
	// 	for (var i = 0; i < minTrys.length && ret.totalThisLine < minLineSize; i++) {
	// 		lineBreakPoint = (params.staffwidth - widths.left) / minTrys[i] / scale;
	// 		ret = calcLineBreaks(widths.measureWidths, lineBreakPoint);
	// 	}
	// }

	if (!gotTune)
		ret = getRevisedTune(lineBreaks, staffWidth, abcString, params, Parse);
	ret.explanation = explanation;
	return ret;
}

module.exports = { wrapLines: wrapLines, calcLineWraps: calcLineWraps };


/***/ }),

/***/ "./node_modules/abcjs/src/synth/active-audio-context.js":
/*!**************************************************************!*\
  !*** ./node_modules/abcjs/src/synth/active-audio-context.js ***!
  \**************************************************************/
/***/ (function(module) {

function activeAudioContext() {
	return window.abcjsAudioContext;
}

module.exports = activeAudioContext;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/create-note-map.js":
/*!*********************************************************!*\
  !*** ./node_modules/abcjs/src/synth/create-note-map.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Convert the input structure to a more useful structure where each item has a length of its own.

var instrumentIndexToName = __webpack_require__(/*! ./instrument-index-to-name */ "./node_modules/abcjs/src/synth/instrument-index-to-name.js");

var createNoteMap = function(sequence) {
	var map = [];
	for (var i = 0; i < sequence.tracks.length; i++)
		map.push([]);

	// TODO-PER: handle more than one note in a track
	var nextNote = {};
	var currentInstrument = instrumentIndexToName[0];
	sequence.tracks.forEach(function(track, i) {
		var currentTime = 0;
		track.forEach(function(ev) {
			switch (ev.cmd) {
				case "start":
					nextNote[ev.pitch] = { time: currentTime, instrument: currentInstrument, volume: ev.volume };
					break;
				case "move":
					currentTime += ev.duration;
					break;
				case "stop":
					map[i].push({pitch: ev.pitch, instrument: nextNote[ev.pitch].instrument, start: nextNote[ev.pitch].time, end: currentTime, volume: nextNote[ev.pitch].volume});
					delete nextNote[ev.pitch];
					break;
				case "program":
					currentInstrument = instrumentIndexToName[ev.instrument];
					break;
				default:
					// TODO-PER: handle other event types
					console.log("Unhanded midi event", ev);
			}
		});
	});
	return map;
};

module.exports = createNoteMap;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/create-synth-control.js":
/*!**************************************************************!*\
  !*** ./node_modules/abcjs/src/synth/create-synth-control.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var supportsAudio = __webpack_require__(/*! ./supports-audio */ "./node_modules/abcjs/src/synth/supports-audio.js");
var registerAudioContext = __webpack_require__(/*! ./register-audio-context */ "./node_modules/abcjs/src/synth/register-audio-context.js");
var activeAudioContext = __webpack_require__(/*! ./active-audio-context */ "./node_modules/abcjs/src/synth/active-audio-context.js");
var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");
// TODO-PER: The require statements for svg don't play well for node apps without extra plugins. The following lines would be clearer than inlining the SVG
// var loopImage = require('./images/loop.svg');
// var playImage = require('./images/play.svg');
// var pauseImage = require('./images/pause.svg');
// var loadingImage = require('./images/loading.svg');
// var resetImage = require('./images/reset.svg');
var loopImage = '<svg version="1.0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 700" preserveAspectRatio="xMidYMid meet">\n' +
	'<g transform="translate(0,700) scale(0.1,-0.1)" >\n' +
	'<path d="M3111 6981 c-20 -37 -90 -55 -364 -96 -120 -18 -190 -33 -244 -55 ' +
	'-42 -17 -124 -42 -182 -56 -78 -18 -119 -34 -157 -60 -28 -19 -86 -46 -128 ' +
	'-60 -43 -13 -107 -42 -144 -64 -37 -23 -84 -46 -106 -52 -21 -7 -56 -29 -79 ' +
	'-50 -22 -22 -61 -50 -86 -63 -26 -13 -67 -40 -91 -60 -24 -20 -65 -47 -90 -60 ' +
	'-25 -13 -53 -31 -61 -41 -8 -9 -32 -30 -54 -46 -75 -54 -486 -460 -512 -507 ' +
	'-15 -25 -48 -69 -75 -98 -26 -28 -48 -57 -48 -63 0 -6 -18 -29 -39 -53 -21 ' +
	'-23 -56 -71 -77 -107 -20 -36 -50 -80 -65 -97 -16 -18 -33 -52 -40 -75 -12 ' +
	'-47 -47 -115 -84 -166 -13 -18 -30 -56 -38 -83 -8 -27 -34 -80 -56 -118 -33 ' +
	'-53 -46 -91 -62 -167 -12 -63 -34 -127 -59 -179 -42 -84 -60 -166 -60 -270 0 ' +
	'-90 26 -122 125 -154 54 -17 96 -19 430 -20 305 -1 381 2 430 14 82 22 140 51 ' +
	'153 78 6 12 22 47 37 77 14 30 38 77 54 103 15 27 34 73 40 103 7 30 28 78 48 ' +
	'107 19 28 44 74 55 101 10 28 34 67 53 87 18 20 49 61 68 90 19 30 44 63 57 ' +
	'74 13 11 36 40 52 65 59 94 232 270 306 313 20 11 57 37 82 58 25 20 70 52 ' +
	'100 72 30 19 66 47 79 61 13 14 49 35 80 46 30 12 80 37 111 56 31 19 95 45 ' +
	'143 58 48 12 110 37 139 55 63 40 127 55 323 76 83 9 208 28 279 41 156 29 ' +
	'165 29 330 4 453 -71 514 -84 606 -130 31 -16 83 -36 116 -45 32 -9 84 -34 ' +
	'115 -56 31 -21 82 -48 113 -60 32 -11 72 -33 89 -48 18 -16 59 -45 92 -65 33 ' +
	'-21 74 -51 90 -66 17 -15 49 -40 73 -54 52 -32 65 -61 50 -113 -8 -31 -61 -90 ' +
	'-277 -308 -300 -303 -361 -382 -369 -481 -2 -29 0 -66 6 -81 13 -40 88 -138 ' +
	'115 -151 12 -6 54 -26 92 -44 l70 -33 945 -2 c520 -1 975 2 1012 7 64 8 191 ' +
	'50 231 76 11 7 33 34 50 60 22 34 42 51 65 58 l32 9 0 1101 0 1102 -32 9 c-21 ' +
	'7 -44 26 -64 55 -60 84 -77 97 -140 110 -44 9 -76 10 -127 2 -59 -9 -77 -17 ' +
	'-134 -62 -37 -28 -172 -155 -301 -281 -129 -127 -249 -237 -267 -245 -25 -10 ' +
	'-41 -11 -71 -2 -58 15 -112 45 -124 69 -6 11 -35 35 -64 54 -28 18 -58 41 -66 ' +
	'50 -8 9 -41 35 -75 58 -33 22 -77 56 -99 75 -21 18 -64 46 -95 61 -31 14 -73 ' +
	'39 -93 55 -20 15 -70 40 -110 55 -40 15 -97 44 -127 64 -29 21 -78 44 -107 53 ' +
	'-30 8 -77 31 -105 51 -42 28 -73 39 -173 60 -68 14 -154 39 -196 58 -95 43 ' +
	'-131 51 -343 76 -209 24 -242 32 -279 70 l-30 29 -328 0 c-312 0 -330 -1 -339 ' +
	'-19z"></path>\n' +
	'<path d="M254 2875 c-89 -16 -107 -26 -145 -78 -32 -44 -62 -66 -91 -67 -17 0 ' +
	'-18 -61 -18 -1140 l0 -1140 24 0 c16 0 41 -17 72 -50 40 -42 61 -55 117 -72 ' +
	'l69 -21 82 23 c44 12 96 30 114 39 18 9 148 132 290 272 141 141 267 261 279 ' +
	'268 51 26 86 14 176 -61 32 -26 62 -48 66 -48 5 0 36 -25 70 -55 34 -30 74 ' +
	'-61 89 -69 15 -8 37 -28 50 -45 12 -17 50 -45 84 -62 34 -17 78 -44 98 -60 19 ' +
	'-16 61 -37 93 -48 32 -11 81 -37 107 -56 27 -20 76 -45 109 -56 33 -12 75 -31 ' +
	'93 -44 62 -45 93 -58 191 -82 54 -12 130 -37 168 -54 68 -29 180 -58 226 -59 ' +
	'62 0 183 -64 183 -96 0 -12 88 -14 639 -14 l639 0 12 30 c18 44 76 66 233 89 ' +
	'89 14 160 30 200 47 34 15 106 42 159 60 54 18 112 44 130 57 47 35 85 52 146 ' +
	'67 29 7 76 28 105 48 29 20 77 48 107 63 30 15 66 39 80 54 14 15 50 40 81 56 ' +
	'31 15 78 46 104 69 26 22 61 46 79 54 17 7 43 26 56 42 14 16 41 41 60 56 64 ' +
	'48 380 362 408 405 15 23 40 51 55 63 15 12 36 38 46 58 11 21 37 57 58 82 22 ' +
	'25 49 62 62 83 13 20 38 56 57 78 19 23 50 74 69 113 19 39 46 86 59 104 14 ' +
	'18 34 62 46 98 12 36 32 77 45 92 31 38 60 97 80 167 9 33 26 76 37 95 29 50 ' +
	'47 103 68 206 10 52 32 117 51 155 29 56 33 74 34 140 0 94 -10 108 -101 138 ' +
	'-61 20 -83 21 -463 21 -226 0 -421 -4 -451 -10 -63 -12 -86 -30 -110 -85 -10 ' +
	'-22 -33 -63 -52 -92 -21 -31 -42 -80 -53 -123 -11 -44 -32 -93 -56 -128 -20 ' +
	'-32 -47 -83 -59 -115 -12 -32 -37 -77 -56 -100 -19 -23 -50 -65 -69 -94 -19 ' +
	'-29 -44 -57 -54 -63 -11 -5 -29 -27 -42 -47 -52 -85 -234 -277 -300 -315 -25 ' +
	'-15 -53 -38 -62 -51 -9 -14 -42 -39 -74 -57 -32 -18 -75 -48 -95 -66 -21 -18 ' +
	'-59 -44 -85 -58 -26 -13 -72 -40 -100 -59 -35 -24 -78 -41 -128 -52 -47 -11 ' +
	'-99 -31 -139 -56 -69 -42 -94 -49 -391 -110 -245 -51 -425 -66 -595 -50 -168 ' +
	'16 -230 27 -330 61 -47 16 -123 35 -170 44 -98 17 -123 25 -172 58 -20 14 -71 ' +
	'37 -114 53 -44 15 -95 40 -115 56 -20 16 -70 42 -110 59 -40 16 -88 45 -108 ' +
	'63 -20 19 -55 46 -78 61 -24 14 -49 35 -55 47 -7 11 -34 33 -60 49 -50 31 -65 ' +
	'61 -53 102 4 13 130 147 281 298 236 238 277 283 299 335 15 32 35 71 46 86 ' +
	'12 18 19 44 19 76 0 42 -8 63 -53 138 -92 151 11 139 -1207 141 -798 2 -1030 ' +
	'0 -1086 -11z"></path>\n' +
	'</g>\n' +
	'</svg>\n';
var playImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-play-svg">\n' +
	'    <g>\n' +
	'    <polygon points="4 0 23 12.5 4 25"/>\n' +
	'    </g>\n' +
	'</svg>';
var pauseImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="abcjs-pause-svg">\n' +
	'  <g>\n' +
	'    <rect width="8.23" height="25"/>\n' +
	'    <rect width="8.23" height="25" x="17"/>\n' +
	'  </g>\n' +
	'</svg>';
var loadingImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="abcjs-loading-svg">\n' +
	'    <circle cx="50" cy="50" fill="none" stroke-width="20" r="35" stroke-dasharray="160 55"></circle>\n' +
	'</svg>';
var resetImage = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25">\n' +
	'  <g>\n' +
	'    <polygon points="5 12.5 24 0 24 25"/>\n' +
	'    <rect width="3" height="25" x="0" y="0"/>\n' +
	'  </g>\n' +
	'</svg>';

function CreateSynthControl(parent, options) {
	var self = this;
	// parent is either an element or a selector.
	if (typeof parent === "string") {
		var selector = parent;
		parent = document.querySelector(selector);
		if (!parent)
			throw new Error("Cannot find element \"" + selector + "\" in the DOM.");
	} else if (!(parent instanceof HTMLElement))
		throw new Error("The first parameter must be a valid element or selector in the DOM.");

	self.parent = parent;
	self.options = {};
	if (options)
		self.options = parseCommon.clone(options);

	// This can be called in the following cases:
	// AC already registered and not suspended
	// AC already registered and suspended
	// AC not registered and not passed in
	// AC not registered but passed in (but suspended)
	// AC not registered but passed in (not suspended)
	// If the AC is already registered, then just use it - ignore what is passed in
	// Create the AC if necessary if there isn't one already.
	// We don't care right now if the AC is suspended - whenever a button is clicked then we check it.
	if (self.options.ac)
		registerAudioContext(self.options.ac);
	buildDom(self.parent, self.options);
	attachListeners(self);

	self.setTempo = function(tempo) {
		var el = self.parent.querySelector(".abcjs-midi-current-tempo");
		if (el)
			el.innerHTML = tempo;
	};
	self.resetAll = function() {
		var pushedButtons = self.parent.querySelectorAll(".abcjs-pushed");
		for (var i = 0; i < pushedButtons.length; i++) {
			var button = pushedButtons[i];
			button.classList.remove("abcjs-pushed");
		}
	};
	self.pushPlay = function(push) {
		var startButton = self.parent.querySelector(".abcjs-midi-start");
		if (!startButton)
			return;
		if (push)
			startButton.classList.add("abcjs-pushed");
		else
			startButton.classList.remove("abcjs-pushed");
	};
	self.pushLoop = function(push) {
		var loopButton = self.parent.querySelector(".abcjs-midi-loop");
		if (!loopButton)
			return;
		if (push)
			loopButton.classList.add("abcjs-pushed");
		else
			loopButton.classList.remove("abcjs-pushed");
	};

	self.setProgress = function (percent, totalTime) {
		var progressBackground = self.parent.querySelector(".abcjs-midi-progress-background");
		var progressThumb = self.parent.querySelector(".abcjs-midi-progress-indicator");
		if (!progressBackground || !progressThumb)
			return;
		var width = progressBackground.clientWidth;
		var left = width * percent;
		progressThumb.style.left = left + "px";

		var clock = self.parent.querySelector(".abcjs-midi-clock");
		if (clock) {
			var totalSeconds = (totalTime * percent) / 1000;
			var minutes = Math.floor(totalSeconds / 60);
			var seconds = Math.floor(totalSeconds % 60);
			var secondsFormatted = seconds < 10 ? "0" + seconds : seconds;
			clock.innerHTML = minutes + ":" + secondsFormatted;
		}
	};

	if (self.options.afterResume) {
		var isResumed = false;
		if (self.options.ac) {
			isResumed = self.options.ac.state !== "suspended";
		} else if (activeAudioContext()) {
			isResumed = activeAudioContext().state !== "suspended";
		}
		if (isResumed)
			self.options.afterResume();
	}
}

function buildDom(parent, options) {
	var hasLoop = !!options.loopHandler;
	var hasRestart = !!options.restartHandler;
	var hasPlay = !!options.playHandler || !!options.playPromiseHandler;
	var hasProgress = !!options.progressHandler;
	var hasWarp = !!options.warpHandler;
	var hasClock = options.hasClock !== false;

	var html = '<div class="abcjs-inline-audio">\n';
	if (hasLoop) {
		var repeatTitle = options.repeatTitle ? options.repeatTitle : "Click to toggle play once/repeat.";
		var repeatAria = options.repeatAria ? options.repeatAria : repeatTitle;
		html += '<button type="button" class="abcjs-midi-loop abcjs-btn" title="' + repeatTitle + '" aria-label="' + repeatAria + '">' + loopImage + '</button>\n';
	}
	if (hasRestart) {
		var restartTitle = options.restartTitle ? options.restartTitle : "Click to go to beginning.";
		var restartAria = options.restartAria ? options.restartAria : restartTitle;
		html += '<button type="button" class="abcjs-midi-reset abcjs-btn" title="' + restartTitle + '" aria-label="' + restartAria + '">' + resetImage + '</button>\n';
	}
	if (hasPlay) {
		var playTitle = options.playTitle ? options.playTitle : "Click to play/pause.";
		var playAria = options.playAria ? options.playAria : playTitle;
		html += '<button type="button" class="abcjs-midi-start abcjs-btn" title="' + playTitle + '" aria-label="' + playAria + '">' + playImage + pauseImage + loadingImage + '</button>\n';
	}
	if (hasProgress) {
		var randomTitle = options.randomTitle ? options.randomTitle : "Click to change the playback position.";
		var randomAria = options.randomAria ? options.randomAria : randomTitle;
		html += '<button type="button" class="abcjs-midi-progress-background" title="' + randomTitle + '" aria-label="' + randomAria + '"><span class="abcjs-midi-progress-indicator"></span></button>\n';
	}
	if (hasClock) {
		html += '<span class="abcjs-midi-clock"></span>\n';
	}
	if (hasWarp) {
		var warpTitle = options.warpTitle ? options.warpTitle : "Change the playback speed.";
		var warpAria = options.warpAria ? options.warpAria : warpTitle;
		var bpm = options.bpm ? options.bpm : "BPM";
		html += '<span class="abcjs-tempo-wrapper"><label><input class="abcjs-midi-tempo" type="number" min="1" max="300" value="100" title="' + warpTitle + '" aria-label="' + warpAria + '">%</label><span>&nbsp;(<span class="abcjs-midi-current-tempo"></span> ' + bpm + ')</span></span>\n';
	}
	html += '</div>\n';
	parent.innerHTML = html;
}

function acResumerMiddleWare(next, ev, playBtn, afterResume, isPromise) {
	var needsInit = true;
	if (!activeAudioContext()) {
		registerAudioContext();
	} else {
		needsInit = activeAudioContext().state === "suspended";
	}
	if (!supportsAudio()) {
		throw { status: "NotSupported", message: "This browser does not support audio."};
	}

	if ((needsInit || isPromise) && playBtn)
		playBtn.classList.add("abcjs-loading");

	if (needsInit) {
		activeAudioContext().resume().then(function () {
			if (afterResume) {
				afterResume().then(function (response) {
					doNext(next, ev, playBtn, isPromise);
				});
			} else {
				doNext(next, ev, playBtn, isPromise);
			}
		});
	} else {
		doNext(next, ev, playBtn, isPromise);
	}
}

function doNext(next, ev, playBtn, isPromise) {
	if (isPromise) {
		next(ev).then(function() {
			if (playBtn)
				playBtn.classList.remove("abcjs-loading");
		});
	} else {
		next(ev);
		if (playBtn)
			playBtn.classList.remove("abcjs-loading");
	}
}

function attachListeners(self) {
	var hasLoop = !!self.options.loopHandler;
	var hasRestart = !!self.options.restartHandler;
	var hasPlay = !!self.options.playHandler || !!self.options.playPromiseHandler;
	var hasProgress = !!self.options.progressHandler;
	var hasWarp = !!self.options.warpHandler;
	var playBtn = self.parent.querySelector(".abcjs-midi-start");

	if (hasLoop)
		self.parent.querySelector(".abcjs-midi-loop").addEventListener("click", function(ev){acResumerMiddleWare(self.options.loopHandler, ev, playBtn, self.options.afterResume)});
	if (hasRestart)
		self.parent.querySelector(".abcjs-midi-reset").addEventListener("click", function(ev){acResumerMiddleWare(self.options.restartHandler, ev, playBtn, self.options.afterResume)});
	if (hasPlay)
		playBtn.addEventListener("click", function(ev){
			acResumerMiddleWare(
				self.options.playPromiseHandler || self.options.playHandler,
				ev,
				playBtn,
				self.options.afterResume,
				!!self.options.playPromiseHandler)
		});
	if (hasProgress)
		self.parent.querySelector(".abcjs-midi-progress-background").addEventListener("click", function(ev){acResumerMiddleWare(self.options.progressHandler, ev, playBtn, self.options.afterResume)});
	if (hasWarp)
		self.parent.querySelector(".abcjs-midi-tempo").addEventListener("change", function(ev){acResumerMiddleWare(self.options.warpHandler, ev, playBtn, self.options.afterResume)});
}
module.exports = CreateSynthControl;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/create-synth.js":
/*!******************************************************!*\
  !*** ./node_modules/abcjs/src/synth/create-synth.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getNote = __webpack_require__(/*! ./load-note */ "./node_modules/abcjs/src/synth/load-note.js");
var soundsCache = __webpack_require__(/*! ./sounds-cache */ "./node_modules/abcjs/src/synth/sounds-cache.js");
var createNoteMap = __webpack_require__(/*! ./create-note-map */ "./node_modules/abcjs/src/synth/create-note-map.js");
var registerAudioContext = __webpack_require__(/*! ./register-audio-context */ "./node_modules/abcjs/src/synth/register-audio-context.js");
var activeAudioContext = __webpack_require__(/*! ./active-audio-context */ "./node_modules/abcjs/src/synth/active-audio-context.js");
var supportsAudio = __webpack_require__(/*! ./supports-audio */ "./node_modules/abcjs/src/synth/supports-audio.js");
var pitchToNoteName = __webpack_require__(/*! ./pitch-to-note-name */ "./node_modules/abcjs/src/synth/pitch-to-note-name.js");
var instrumentIndexToName = __webpack_require__(/*! ./instrument-index-to-name */ "./node_modules/abcjs/src/synth/instrument-index-to-name.js");
var downloadBuffer = __webpack_require__(/*! ./download-buffer */ "./node_modules/abcjs/src/synth/download-buffer.js");
var sequence = __webpack_require__(/*! ../midi/abc_midi_sequencer */ "./node_modules/abcjs/src/midi/abc_midi_sequencer.js");
var flatten = __webpack_require__(/*! ../midi/abc_midi_flattener */ "./node_modules/abcjs/src/midi/abc_midi_flattener.js");

// TODO-PER: remove the midi tests from here: I don't think the object can be constructed unless it passes.
var notSupportedMessage = "MIDI is not supported in this browser.";

var defaultSoundFontUrl = "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/";


function CreateSynth() {
	var self = this;
	self.audioBufferPossible = undefined;
	self.directSource = []; // type: AudioBufferSourceNode
	self.startTimeSec = undefined; // the time that the midi started: used for pause/resume.
	self.pausedTimeSec = undefined; // the time that the midi was paused: used for resume.
	self.audioBuffers = []; // cache of the buffers so starting play can be fast.
	self.duration = undefined; // the duration of the tune in seconds.
	self.isRunning = false; // whether there is currently a sound buffer running.

	// Load and cache all needed sounds
	self.init = function(options) {
		if (!options)
			options = {};
		registerAudioContext(options.audioContext); // This works no matter what - if there is already an ac it is a nop; if the context is not passed in, then it creates one.
		var startTime = activeAudioContext().currentTime;
		self.debugCallback = options.debugCallback;
		if (self.debugCallback)
			self.debugCallback("init called");
		self.audioBufferPossible = self._deviceCapable();
		if (!self.audioBufferPossible)
			return Promise.reject({ status: "NotSupported", message: notSupportedMessage});
		self.soundFontUrl = options.soundFontUrl ? options.soundFontUrl : defaultSoundFontUrl;
		self.millisecondsPerMeasure = options.millisecondsPerMeasure ? options.millisecondsPerMeasure : (options.visualObj ? options.visualObj.millisecondsPerMeasure() : 1000);
		var params = options.options ? options.options : {};
		self.meterSize = 1;
		if (options.visualObj) {
			var seq = sequence(options.visualObj, params);
			self.flattened = flatten(seq, params);
			self.meterSize = options.visualObj.getMeterFraction().num / options.visualObj.getMeterFraction().den;
		} else if (options.sequence)
			self.flattened = options.sequence;
		else
			return Promise.reject(new Error("Must pass in either a visualObj or a sequence"));
		self.sequenceCallback = params.sequenceCallback;
		self.callbackContext = params.callbackContext;
		self.onEnded = options.onEnded;

		var allNotes = {};
		var currentInstrument = instrumentIndexToName[0];
		self.flattened.tracks.forEach(function(track) {
			track.forEach(function(event) {
				if (event.cmd === "program" && instrumentIndexToName[event.instrument])
					currentInstrument = instrumentIndexToName[event.instrument];
				if (event.pitch !== undefined) {
					var pitchNumber = event.pitch + 60;
					var noteName = pitchToNoteName[pitchNumber];
					if (noteName) {
						if (!allNotes[currentInstrument])
							allNotes[currentInstrument] = {};
						allNotes[currentInstrument][pitchToNoteName[pitchNumber]] = true;
					} else
						console.log("Can't find note: ", pitchNumber);
				}
			});
		});
		if (self.debugCallback)
			self.debugCallback("note gathering time = " + Math.floor((activeAudioContext().currentTime - startTime)*1000)+"ms");
		startTime = activeAudioContext().currentTime;

		var notes = [];
		Object.keys(allNotes).forEach(function(instrument) {
			Object.keys(allNotes[instrument]).forEach(function(note) {
				notes.push({ instrument: instrument, note: note });
			});
		});
		// If there are lots of notes, load them in batches
		var batches = [];
		var CHUNK = 256;
		for (var i=0; i < notes.length; i += CHUNK) {
			batches.push(notes.slice(i, i + CHUNK));
		}

		return new Promise(function(resolve, reject) {
			var results = [];

			var index = 0;
			var next = function() {
				if (index < batches.length) {
					self._loadBatch(batches[index], self.soundFontUrl, startTime).then(function(data) {
						startTime = activeAudioContext().currentTime;
						results.push(data);
						index++;
						next();
					}, reject);
				} else {
					resolve(results);
				}
			};
			next();
		});
	};

	self._loadBatch = (function(batch, soundFontUrl, startTime) {
		var promises = [];
		batch.forEach(function(item) {
			promises.push(getNote(soundFontUrl, item.instrument, item.note, activeAudioContext()));
		});
		return Promise.all(promises).then(function(response) {
			if (self.debugCallback)
				self.debugCallback("mp3 load time = " + Math.floor((activeAudioContext().currentTime - startTime)*1000)+"ms");
			return Promise.resolve(response);
		});
	});

	self.prime = function() {
		self.isRunning = false;
		if (!self.audioBufferPossible)
			return Promise.reject(new Error(notSupportedMessage));
		if (self.debugCallback)
			self.debugCallback("prime called");
		return new Promise(function(resolve) {
			var startTime = activeAudioContext().currentTime;
			var tempoMultiplier = self.millisecondsPerMeasure / 1000 / self.meterSize;
			self.duration = self.flattened.totalDuration * tempoMultiplier;
			var totalSamples = Math.floor(activeAudioContext().sampleRate * self.duration);

			// There might be a previous run that needs to be turned off.
			self.stop();

			var noteMapTracks = createNoteMap(self.flattened);
			if (self.sequenceCallback)
				self.sequenceCallback(noteMapTracks, self.callbackContext);
			//console.log(noteMapTracks);

			self.audioBuffers = [];
			noteMapTracks.forEach(function(noteMap) {
				var audioBuffer = activeAudioContext().createBuffer(1, totalSamples, activeAudioContext().sampleRate);
				var chanData = audioBuffer.getChannelData(0);

				noteMap.forEach(function(note) {
					self._placeNote(chanData, note, tempoMultiplier, soundsCache);
				});

				self.audioBuffers.push(audioBuffer);
			});

			if (self.debugCallback) {
				self.debugCallback("sampleRate = " + activeAudioContext().sampleRate);
				self.debugCallback("totalSamples = " + totalSamples);
				self.debugCallback("creationTime = " + Math.floor((activeAudioContext().currentTime - startTime)*1000) + "ms");
			}
			resolve({
				status: "ok",
				seconds: 0
			});
		});
	};

	// This is called after everything is set up, so it can quickly make sound
	self.start = function() {
		if (self.pausedTimeSec) {
			self.resume();
			return;
		}

		if (!self.audioBufferPossible)
			throw new Error(notSupportedMessage);
		if (self.debugCallback)
			self.debugCallback("start called");

		self._kickOffSound(0);
		self.startTimeSec = activeAudioContext().currentTime;
		self.pausedTimeSec = undefined;

		if (self.debugCallback)
			self.debugCallback("MIDI STARTED", self.startTimeSec);
	};

	self.pause = function() {
		if (!self.audioBufferPossible)
			throw new Error(notSupportedMessage);
		if (self.debugCallback)
			self.debugCallback("pause called");

		if (!self.pausedTimeSec) { // ignore if self is already paused.
			self.stop();
			self.pausedTimeSec = activeAudioContext().currentTime;
		}
	};

	self.resume = function() {
		if (!self.audioBufferPossible)
			throw new Error(notSupportedMessage);
		if (self.debugCallback)
			self.debugCallback("resume called");

		var offset = self.pausedTimeSec - self.startTimeSec;
		self.startTimeSec = activeAudioContext().currentTime - offset; // We move the start time in case there is another pause/resume.
		self.pausedTimeSec = undefined;
		self._kickOffSound(offset);
	};

	self.seek = function(percent) {
		var offset = self.duration * percent;

		// TODO-PER: can seek when paused or when playing
		if (!self.audioBufferPossible)
			throw new Error(notSupportedMessage);
		if (self.debugCallback)
			self.debugCallback("seek called sec=" + offset);

		if (self.isRunning) {
			self.stop();
			self._kickOffSound(offset);
		}
		var pauseDistance = self.pausedTimeSec ? self.pausedTimeSec - self.startTimeSec : undefined;
		self.startTimeSec = activeAudioContext().currentTime - offset;
		if (self.pausedTimeSec)
			self.pausedTimeSec = self.startTimeSec + pauseDistance;
	};

	self.stop = function() {
		self.isRunning = false;
		self.pausedTimeSec = undefined;
		self.directSource.forEach(function(source) {
			try {
				source.stop();
			} catch (error) {
				// We don't care if self succeeds: it might fail if something else turned off the sound or it ended for some reason.
				console.log("direct source didn't stop:", error)
			}
		});
		self.directSource = [];
	};

	self.download = function() {
		return downloadBuffer(self);
	};

	/////////////// Private functions //////////////

	self._deviceCapable = function() {
		if (!supportsAudio()) {
			console.warn(notSupportedMessage);
			if (self.debugCallback)
				self.debugCallback(notSupportedMessage);
			return false;
		}
		return true;
	};

	self._kickOffSound = function(seconds) {
		self.isRunning = true;
		self.directSource = [];
		self.audioBuffers.forEach(function(audioBuffer, trackNum) {
			self.directSource[trackNum] = activeAudioContext().createBufferSource(); // creates a sound source
			self.directSource[trackNum].buffer = audioBuffer; // tell the source which sound to play
			self.directSource[trackNum].connect(activeAudioContext().destination); // connect the source to the context's destination (the speakers)
		});
		self.directSource.forEach(function(source) {
			source.start(0, seconds);
		});
		if (self.onEnded) {
			self.directSource[0].onended = function () {
				self.onEnded(self.callbackContext);
			};
		}
	};

	self._placeNote = function(chanData, note, tempoMultiplier, soundsCache) {
		var start = Math.floor(note.start*activeAudioContext().sampleRate * tempoMultiplier);
		var numBeats = note.end - note.start;
		var noteTimeSec = numBeats * tempoMultiplier;
		var noteName = pitchToNoteName[note.pitch+60];
		if (noteName) { // Just ignore pitches that don't exist.
			var pitch = soundsCache[note.instrument][noteName].getChannelData(0);
			var duration = Math.min(pitch.length, Math.floor(noteTimeSec * activeAudioContext().sampleRate));
			//console.log(pitchToNote[note.pitch+''], start, numBeats, noteTimeSec, duration);
			for (var i = 0; i < duration; i++) {
				var thisSample = pitch[i] * note.volume / 128;
				if (chanData[start + i])
					chanData[start + i] = (chanData[start + i] + thisSample) *0.75;
				else
					chanData[start + i] = thisSample;
			}
		}
	};
}

module.exports = CreateSynth;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/download-buffer.js":
/*!*********************************************************!*\
  !*** ./node_modules/abcjs/src/synth/download-buffer.js ***!
  \*********************************************************/
/***/ (function(module) {

var downloadBuffer = function(buffer) {
	return window.URL.createObjectURL(bufferToWave(buffer.audioBuffers));
};

// Convert an AudioBuffer to a Blob using WAVE representation
function bufferToWave(audioBuffers) {
	var numOfChan = audioBuffers.length;
	var length = audioBuffers[0].length * numOfChan * 2 + 44;
	var buffer = new ArrayBuffer(length);
	var view = new DataView(buffer);
	var channels = [];
	var i;
	var sample;
	var offset = 0;
	var pos = 0;

	// write WAVE header
	setUint32(0x46464952);                         // "RIFF"
	setUint32(length - 8);                         // file length - 8
	setUint32(0x45564157);                         // "WAVE"

	setUint32(0x20746d66);                         // "fmt " chunk
	setUint32(16);                                 // length = 16
	setUint16(1);                                  // PCM (uncompressed)
	setUint16(numOfChan);
	setUint32(audioBuffers[0].sampleRate);
	setUint32(audioBuffers[0].sampleRate * 2 * numOfChan); // avg. bytes/sec
	setUint16(numOfChan * 2);                      // block-align
	setUint16(16);                                 // 16-bit (hardcoded in this demo)

	setUint32(0x61746164);                         // "data" - chunk
	setUint32(length - pos - 4);                   // chunk length

	// write interleaved data
	for(i = 0; i < audioBuffers.length; i++)
		channels.push(audioBuffers[i].getChannelData(0));

	while(pos < length) {
		for(i = 0; i < channels.length; i++) {             // interleave channels
			sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
			sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
			view.setInt16(pos, sample, true);          // write 16-bit sample
			pos += 2;
		}
		offset++; // next source sample
	}

	// create Blob
	return new Blob([buffer], {type: "audio/wav"});

	function setUint16(data) {
		view.setUint16(pos, data, true);
		pos += 2;
	}

	function setUint32(data) {
		view.setUint32(pos, data, true);
		pos += 4;
	}
}

module.exports = downloadBuffer;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/instrument-index-to-name.js":
/*!******************************************************************!*\
  !*** ./node_modules/abcjs/src/synth/instrument-index-to-name.js ***!
  \******************************************************************/
/***/ (function(module) {

var instrumentIndexToName = [
	"acoustic_grand_piano",
	"bright_acoustic_piano",
	"electric_grand_piano",
	"honkytonk_piano",
	"electric_piano_1",
	"electric_piano_2",
	"harpsichord",
	"clavinet",

	"celesta",
	"glockenspiel",
	"music_box",
	"vibraphone",
	"marimba",
	"xylophone",
	"tubular_bells",
	"dulcimer",

	"drawbar_organ",
	"percussive_organ",
	"rock_organ",
	"church_organ",
	"reed_organ",
	"accordion",
	"harmonica",
	"tango_accordion",

	"acoustic_guitar_nylon",
	"acoustic_guitar_steel",
	"electric_guitar_jazz",
	"electric_guitar_clean",
	"electric_guitar_muted",
	"overdriven_guitar",
	"distortion_guitar",
	"guitar_harmonics",

	"acoustic_bass",
	"electric_bass_finger",
	"electric_bass_pick",
	"fretless_bass",
	"slap_bass_1",
	"slap_bass_2",
	"synth_bass_1",
	"synth_bass_2",

	"violin",
	"viola",
	"cello",
	"contrabass",
	"tremolo_strings",
	"pizzicato_strings",
	"orchestral_harp",
	"timpani",

	"string_ensemble_1",
	"string_ensemble_2",
	"synth_strings_1",
	"synth_strings_2",
	"choir_aahs",
	"voice_oohs",
	"synth_choir",
	"orchestra_hit",

	"trumpet",
	"trombone",
	"tuba",
	"muted_trumpet",
	"french_horn",
	"brass_section",
	"synth_brass_1",
	"synth_brass_2",

	"soprano_sax",
	"alto_sax",
	"tenor_sax",
	"baritone_sax",
	"oboe",
	"english_horn",
	"bassoon",
	"clarinet",

	"piccolo",
	"flute",
	"recorder",
	"pan_flute",
	"blown_bottle",
	"shakuhachi",
	"whistle",
	"ocarina",

	"lead_1_square",
	"lead_2_sawtooth",
	"lead_3_calliope",
	"lead_4_chiff",
	"lead_5_charang",
	"lead_6_voice",
	"lead_7_fifths",
	"lead_8_bass__lead",

	"pad_1_new_age",
	"pad_2_warm",
	"pad_3_polysynth",
	"pad_4_choir",
	"pad_5_bowed",
	"pad_6_metallic",
	"pad_7_halo",
	"pad_8_sweep",

	"fx_1_rain",
	"fx_2_soundtrack",
	"fx_3_crystal",
	"fx_4_atmosphere",
	"fx_5_brightness",
	"fx_6_goblins",
	"fx_7_echoes",
	"fx_8_scifi",

	"sitar",
	"banjo",
	"shamisen",
	"koto",
	"kalimba",
	"bagpipe",
	"fiddle",
	"shanai",

	"tinkle_bell",
	"agogo",
	"steel_drums",
	"woodblock",
	"taiko_drum",
	"melodic_tom",
	"synth_drum",
	"reverse_cymbal",

	"guitar_fret_noise",
	"breath_noise",
	"seashore",
	"bird_tweet",
	"telephone_ring",
	"helicopter",
	"applause",
	"gunshot",

	"percussion"
];

module.exports = instrumentIndexToName;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/load-note.js":
/*!***************************************************!*\
  !*** ./node_modules/abcjs/src/synth/load-note.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Load one mp3 file for one note.
// url = the base url for the soundfont
// instrument = the instrument name (e.g. "acoustic_grand_piano")
// name = the pitch name (e.g. "A3")
var soundsCache = __webpack_require__(/*! ./sounds-cache */ "./node_modules/abcjs/src/synth/sounds-cache.js");

var getNote = function(url, instrument, name, audioContext) {
	return new Promise(function (resolve, reject) {
		if (!soundsCache[instrument])
			soundsCache[instrument] = {};
		var instrumentCache = soundsCache[instrument];

		if (instrumentCache[name] === 'error') {
			return reject(new Error("Unable to load sound font" + ' ' + url + ' ' + instrument + ' ' + name));
		}
		if (instrumentCache[name]) {
			return resolve({instrument: instrument, name: name});
		}

		// if (this.debugCallback)
		// 	this.debugCallback(`Loading sound: ${instrument} ${name}`);
		instrumentCache[name] = "pending"; // This can be called in parallel, so don't call it a second time before the first one has loaded.
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url+instrument+'-mp3/'+name+'.mp3', true);
		xhr.responseType = 'arraybuffer';

		var self = this;
		function onSuccess(audioBuffer) {
			instrumentCache[name] = audioBuffer;
			// if (self.debugCallback)
			// 	self.debugCallback(`Sound loaded: ${instrument} ${name} ${url}`);
			resolve({instrument: instrument, name: name});
		}

		function onFailure(error) {
			if (self.debugCallback)
				self.debugCallback(error);
			console.log(error);
			reject(error);
		}

		xhr.onload = function (e) {
			if (this.status === 200) {
				audioContext.decodeAudioData(this.response, onSuccess, onFailure);//.then(function() {
				// 	return resolve({instrument: instrument, name: name});
				// }).catch(function(error) {
				// 	return reject(new Error(cantLoadMp3 + error));
				// });
			} else {
				instrumentCache[name] = "error"; // To keep this from trying to load repeatedly.
				var cantLoadMp3 = "Onload error loading sound: " +  name + " " + url + " " + e.currentTarget.status + " " + e.currentTarget.statusText;
				if (self.debugCallback)
					self.debugCallback(cantLoadMp3);
				return reject(new Error(cantLoadMp3));
			}
		};
		xhr.addEventListener("error", function () {
			instrumentCache[name] = "error"; // To keep this from trying to load repeatedly.
			var cantLoadMp3 = "Error in loading sound: " + " " + url;
			if (self.debugCallback)
				self.debugCallback(cantLoadMp3);
			return reject(new Error(cantLoadMp3));
		}, false);
		xhr.send();
	});
};

module.exports = getNote;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/pitch-to-note-name.js":
/*!************************************************************!*\
  !*** ./node_modules/abcjs/src/synth/pitch-to-note-name.js ***!
  \************************************************************/
/***/ (function(module) {

var pitchToNoteName = {
	21: 'A0',
	22: 'Bb0',
	23: 'B0',
	24: 'C1',
	25: 'Db1',
	26: 'D1',
	27: 'Eb1',
	28: 'E1',
	29: 'F1',
	30: 'Gb1',
	31: 'G1',
	32: 'Ab1',
	33: 'A1',
	34: 'Bb1',
	35: 'B1',
	36: 'C2',
	37: 'Db2',
	38: 'D2',
	39: 'Eb2',
	40: 'E2',
	41: 'F2',
	42: 'Gb2',
	43: 'G2',
	44: 'Ab2',
	45: 'A2',
	46: 'Bb2',
	47: 'B2',
	48: 'C3',
	49: 'Db3',
	50: 'D3',
	51: 'Eb3',
	52: 'E3',
	53: 'F3',
	54: 'Gb3',
	55: 'G3',
	56: 'Ab3',
	57: 'A3',
	58: 'Bb3',
	59: 'B3',
	60: 'C4',
	61: 'Db4',
	62: 'D4',
	63: 'Eb4',
	64: 'E4',
	65: 'F4',
	66: 'Gb4',
	67: 'G4',
	68: 'Ab4',
	69: 'A4',
	70: 'Bb4',
	71: 'B4',
	72: 'C5',
	73: 'Db5',
	74: 'D5',
	75: 'Eb5',
	76: 'E5',
	77: 'F5',
	78: 'Gb5',
	79: 'G5',
	80: 'Ab5',
	81: 'A5',
	82: 'Bb5',
	83: 'B5',
	84: 'C6',
	85: 'Db6',
	86: 'D6',
	87: 'Eb6',
	88: 'E6',
	89: 'F6',
	90: 'Gb6',
	91: 'G6',
	92: 'Ab6',
	93: 'A6',
	94: 'Bb6',
	95: 'B6',
	96: 'C7',
	97: 'Db7',
	98: 'D7',
	99: 'Eb7',
	100: 'E7',
	101: 'F7',
	102: 'Gb7',
	103: 'G7',
	104: 'Ab7',
	105: 'A7',
	106: 'Bb7',
	107: 'B7',
	108: 'C8',
	109: 'Db8',
	110: 'D8',
	111: 'Eb8',
	112: 'E8',
	113: 'F8',
	114: 'Gb8',
	115: 'G8',
	116: 'Ab8',
	117: 'A8',
	118: 'Bb8',
	119: 'B8',
	120: 'C9',
	121: 'Db9'
};

module.exports = pitchToNoteName;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/play-event.js":
/*!****************************************************!*\
  !*** ./node_modules/abcjs/src/synth/play-event.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var SynthSequence = __webpack_require__(/*! ./synth-sequence */ "./node_modules/abcjs/src/synth/synth-sequence.js");
var CreateSynth = __webpack_require__(/*! ./create-synth */ "./node_modules/abcjs/src/synth/create-synth.js");

function playEvent(midiPitches, midiGracePitches, millisecondsPerMeasure) {
	var sequence = new SynthSequence();

	for (var i = 0; i < midiPitches.length; i++) {
		var note = midiPitches[i];
		var trackNum = sequence.addTrack();
		sequence.setInstrument(trackNum, note.instrument);
		if (i === 0 && midiGracePitches) {
			for (var j = 0; j < midiGracePitches.length; j++) {
				var grace = midiGracePitches[j];
				sequence.appendNote(trackNum, grace.pitch, 1 / 64, grace.volume);
			}
		}
		sequence.appendNote(trackNum, note.pitch, note.durationInMeasures, note.volume);
	}

	var buffer = new CreateSynth();
	return buffer.init({
		sequence: sequence,
		millisecondsPerMeasure: millisecondsPerMeasure
	}).then(function () {
		return buffer.prime();
	}).then(function () {
		return buffer.start();
	});
}
module.exports = playEvent;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/register-audio-context.js":
/*!****************************************************************!*\
  !*** ./node_modules/abcjs/src/synth/register-audio-context.js ***!
  \****************************************************************/
/***/ (function(module) {

// Call this when it is safe for the abcjs to produce sound. This is after the first user gesture on the page.
// If you call it with no parameters, then an AudioContext is created and stored.
// If you call it with a parameter, that is used as an already created AudioContext.

function registerAudioContext(ac) {
	if (!window.abcjsAudioContext) {
		if (!ac) {
			ac = window.AudioContext ||
				window.webkitAudioContext ||
				navigator.mozAudioContext ||
				navigator.msAudioContext;
			ac = new ac();
		}
		window.abcjsAudioContext = ac;
	}
	return window.abcjsAudioContext.state !== "suspended";
}

module.exports = registerAudioContext;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/sounds-cache.js":
/*!******************************************************!*\
  !*** ./node_modules/abcjs/src/synth/sounds-cache.js ***!
  \******************************************************/
/***/ (function(module) {

var soundsCache = {
};

module.exports = soundsCache;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/supports-audio.js":
/*!********************************************************!*\
  !*** ./node_modules/abcjs/src/synth/supports-audio.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var activeAudioContext = __webpack_require__(/*! ./active-audio-context */ "./node_modules/abcjs/src/synth/active-audio-context.js");

//
// Support for audio depends on three things: support for Promise, support for AudioContext, and support for AudioContext.resume.
// Unfortunately, AudioContext.resume cannot be detected unless an AudioContext is created, and creating an AudioContext can't
// be done until a user click, so there is no way to know for sure if audio is supported until the user tries.
// We can get close, though - we can test for Promises and AudioContext - there are just a few evergreen browsers that supported
// that before supporting resume, so we'll test what we can.

// The best use of this routine is to call it before doing any audio related stuff to decide whether to bother.
// But then, call it again after a user interaction to test for resume.

function supportsAudio() {
	var aac = activeAudioContext();
	if (aac)
		return aac.resume !== undefined;

	if (!window.Promise)
		return false;

	return window.AudioContext ||
		window.webkitAudioContext ||
		navigator.mozAudioContext ||
		navigator.msAudioContext;
}

module.exports = supportsAudio;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/synth-controller.js":
/*!**********************************************************!*\
  !*** ./node_modules/abcjs/src/synth/synth-controller.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var CreateSynthControl = __webpack_require__(/*! ./create-synth-control */ "./node_modules/abcjs/src/synth/create-synth-control.js");
var CreateSynth = __webpack_require__(/*! ./create-synth */ "./node_modules/abcjs/src/synth/create-synth.js");
var TimingCallbacks = __webpack_require__(/*! ../api/abc_timing_callbacks */ "./node_modules/abcjs/src/api/abc_timing_callbacks.js");

function SynthController() {
	var self = this;
	self.warp = 100;
	self.cursorControl = null;
	self.visualObj = null;
	self.timer = null;
	self.midiBuffer = null;
	self.options = null;
	self.currentTempo = null;
	self.control = null;
	self.isLooping = false;
	self.isStarted = false;
	self.isLoaded = false;

	self.load = function (selector, cursorControl, visualOptions) {
		if (!visualOptions)
			visualOptions = {};
		self.control = new CreateSynthControl(selector, {
			loopHandler: visualOptions.displayLoop ? self.toggleLoop : undefined,
			restartHandler: visualOptions.displayRestart ? self.restart : undefined,
			playPromiseHandler: visualOptions.displayPlay ? self.play : undefined,
			progressHandler: visualOptions.displayProgress ? self.randomAccess : undefined,
			warpHandler: visualOptions.displayWarp ? self.onWarp : undefined,
			afterResume: self.init
		});
		self.cursorControl = cursorControl;
	};

	self.setTune = function(visualObj, userAction, audioParams) {
		self.isLoaded = false;
		self.visualObj = visualObj;
		self.options = audioParams;

		if (self.control) {
			self.pause();
			self.setProgress(0, 1);
			self.control.resetAll();
			self.restart();
			self.isStarted = false;
		}
		self.isLooping = false;

		if (userAction)
			return self.go();
		else {
			return Promise.resolve({status: "no-audio-context"});
		}
	};

	self.go = function () {
		var millisecondsPerMeasure = self.visualObj.millisecondsPerMeasure() * 100 / self.warp;
		self.currentTempo = Math.round(self.visualObj.getBeatsPerMeasure() / millisecondsPerMeasure * 60000);
		if (self.control)
			self.control.setTempo(self.currentTempo);
		self.percent = 0;

		if (!self.midiBuffer)
			self.midiBuffer = new CreateSynth();
		return self.midiBuffer.init({
			visualObj: self.visualObj,
			options: self.options,
			millisecondsPerMeasure: millisecondsPerMeasure
		}).then(function () {
			return self.midiBuffer.prime();
		}).then(function () {
			var subdivisions = 16;
			if (self.cursorControl &&
				self.cursorControl.beatSubdivisions !== undefined &&
				parseInt(self.cursorControl.beatSubdivisions, 10) >= 1 &&
				parseInt(self.cursorControl.beatSubdivisions, 10) <= 64)
				subdivisions = parseInt(self.cursorControl.beatSubdivisions, 10);

			// Need to create the TimingCallbacks after priming the midi so that the midi data is available for the callbacks.
			self.timer = new TimingCallbacks(self.visualObj, {
				beatCallback: self.beatCallback,
				eventCallback: self.eventCallback,
				lineEndCallback: self.lineEndCallback,
				qpm: self.currentTempo,

				extraMeasuresAtBeginning: self.cursorControl ? self.cursorControl.extraMeasuresAtBeginning : undefined,
				lineEndAnticipation: self.cursorControl ? self.cursorControl.lineEndAnticipation : undefined,
				beatSubdivisions: subdivisions,
			});
			if (self.cursorControl && self.cursorControl.onReady && typeof self.cursorControl.onReady  === 'function')
				self.cursorControl.onReady(self);
			self.isLoaded = true;
			return Promise.resolve({ status: "created" });
		});
	};

	self.destroy = function () {
		if (self.timer) {
			self.timer.reset();
			self.timer.stop();
			self.timer = null;
		}
		if (self.midiBuffer) {
			self.midiBuffer.stop();
			self.midiBuffer = null;
		}
		self.setProgress(0, 1);
		if (self.control)
			self.control.resetAll();
	};

	self.play = function () {
		if (!self.isLoaded) {
			return self.go().then(function() {
				return self._play();
			});
		} else
			return self._play();
	};

	self._play = function () {
		self.isStarted = !self.isStarted;
		if (self.isStarted) {
			if (self.cursorControl && self.cursorControl.onStart && typeof self.cursorControl.onStart  === 'function')
				self.cursorControl.onStart();
			self.midiBuffer.start();
			self.timer.start();
			if (self.control)
				self.control.pushPlay(true);
		} else {
			self.pause();
		}
		return Promise.resolve({ status: "ok" });
	};

	self.pause = function() {
		if (self.timer) {
			self.timer.pause();
			self.midiBuffer.pause();
			if (self.control)
				self.control.pushPlay(false);
		}
	};

	self.toggleLoop = function () {
		self.isLooping = !self.isLooping;
		if (self.control)
			self.control.pushLoop(self.isLooping);
	};

	self.restart = function () {
		if (self.timer) {
			self.timer.setProgress(0);
			self.midiBuffer.seek(0);
		}
	};

	self.randomAccess = function (ev) {
		if (!self.isLoaded) {
			return self.go().then(function() {
				return self._randomAccess(ev);
			});
		} else
			return self._randomAccess(ev);
	};

	self._randomAccess = function (ev) {
		var background = (ev.target.classList.contains('abcjs-midi-progress-indicator')) ? ev.target.parentNode : ev.target;
		var percent = (ev.x - background.offsetLeft) / background.offsetWidth;
		if (percent < 0)
			percent = 0;
		if (percent > 100)
			percent = 100;
		self.timer.setProgress(percent);
		self.midiBuffer.seek(percent);
	};

	self.onWarp = function (ev) {
		var newWarp = ev.target.value;
		if (parseInt(newWarp, 10) > 0) {
			self.warp = parseInt(newWarp, 10);
			var wasPlaying = self.isStarted;
			var startPercent = self.percent;
			self.destroy();
			self.isStarted = false;
			self.go().then(function () {
				self.setProgress(startPercent, self.midiBuffer.duration * 1000);
				if (wasPlaying) {
					self.play();
				}
				self.timer.setProgress(startPercent);
				self.midiBuffer.seek(startPercent);
			});
		}
	};

	self.setProgress = function (percent, totalTime) {
		self.percent = percent;
		if (self.control)
			self.control.setProgress(percent, totalTime);
	};

	self.finished = function () {
		self.timer.reset();
		if (self.isLooping) {
			self.timer.start();
			self.midiBuffer.start();
		} else {
			self.timer.stop();
			if (self.isStarted) {
				if (self.control)
					self.control.pushPlay(false);
				self.isStarted = false;
				if (self.cursorControl && self.cursorControl.onFinished && typeof self.cursorControl.onFinished  === 'function')
					self.cursorControl.onFinished();
				self.setProgress(0, 1);
			}
		}
	};

	self.beatCallback = function (beatNumber, totalBeats, totalTime) {
		var percent = beatNumber / totalBeats;
		self.setProgress(percent, totalTime);
		if (self.cursorControl && self.cursorControl.onBeat && typeof self.cursorControl.onBeat  === 'function')
			self.cursorControl.onBeat(beatNumber, totalBeats, totalTime);
	};

	self.eventCallback = function (event) {
		if (event) {
			if (self.cursorControl && self.cursorControl.onEvent && typeof self.cursorControl.onEvent  === 'function')
				self.cursorControl.onEvent(event);
		} else {
			self.finished();
		}
	};

	self.lineEndCallback = function (data) {
		if (self.cursorControl && self.cursorControl.onLineEnd && typeof self.cursorControl.onLineEnd  === 'function')
			self.cursorControl.onLineEnd(data);
	};

	self.getUrl = function () {
		return self.midiBuffer.download();
	};

	self.download = function(fileName) {
		var url = self.getUrl();
		var link = document.createElement('a');
		document.body.appendChild(link);
		link.setAttribute("style","display: none;");
		link.href = url;
		link.download = fileName ? fileName : 'output.wav';
		link.click();
		window.URL.revokeObjectURL(url);
		document.body.removeChild(link);
	};
}

module.exports = SynthController;


/***/ }),

/***/ "./node_modules/abcjs/src/synth/synth-sequence.js":
/*!********************************************************!*\
  !*** ./node_modules/abcjs/src/synth/synth-sequence.js ***!
  \********************************************************/
/***/ (function(module) {

var SynthSequence = function() {
	var self = this;
	self.tracks = [];
	self.totalDuration = 0;

	self.addTrack = function() {
		self.tracks.push([]);
		return self.tracks.length - 1;
	};

	self.setInstrument = function(trackNumber, instrumentNumber) {
		self.tracks[trackNumber].push({
			channel: 0,
			cmd: "program",
			instrument: instrumentNumber
		});
	};

	self.appendNote = function(trackNumber, pitch, durationInMeasures, volume) {
		self.tracks[trackNumber].push({
			cmd: "start",
			pitch: pitch - 60,
			volume: volume
		});
		self.tracks[trackNumber].push({
			cmd: "move",
			duration: durationInMeasures
		});
		self.tracks[trackNumber].push({
			cmd: "stop",
			pitch: pitch - 60
		});
		var duration = 0;
		self.tracks[trackNumber].forEach(function(event) {
			if (event.duration)
				duration += event.duration;
		});
		self.totalDuration = Math.max(self.totalDuration, duration);
	};
};

module.exports = SynthSequence;


/***/ }),

/***/ "./node_modules/abcjs/src/transform/abc2abc_write.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/transform/abc2abc_write.js ***!
  \***********************************************************/
/***/ (function(module) {

//    abc2abc_write.js: Prints an abc file in text format parsed by abc_parse.js
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var TextPrinter = function(elem, reposition) {
    this.elem = elem;
    this.text = "";
    this.l = 1/8;
    this.reposition = reposition || false;
}

TextPrinter.prototype.printString = function(str, elem) {
    if (this.reposition && elem) elem.startChar = this.text.length;
    this.text += str;
    if (this.reposition && elem) elem.endChar = this.text.length;
};

TextPrinter.prototype.printNewLine = function () {
    this.text += "\n";
};

TextPrinter.prototype.printSpace = function () {
    if (this.text[this.text.length-1].match(/\s/)) return; //TODO match whitespace
    this.text += " ";
};

TextPrinter.prototype.printABC = function(abctune) {
    this.text = "";
    this.abctune = abctune;
    //TODO formatting
    this.printHeader();
    this.printBody();
    this.elem.value=this.text;
};

TextPrinter.prototype.printHeader = function() {
    // much of this info is duplicated in metaTextHEaders in abc_parse_header.js
    this.printHeaderLine("x","X","1");
    this.printHeaderLine("title","T");
    this.printHeaderLine("composer","C");
    this.printHeaderLine("history","H");
    this.printHeaderLine("author","A");
    this.printHeaderLine("book","B");  
    this.printHeaderLine("discography","D");  
    this.printHeaderLine("url","F");
    this.printHeaderLine("group","G");
    this.printHeaderLine("instruction","I");
    this.printHeaderLine("notes","N");
    this.printHeaderLine("origin","O");
    this.printHeaderLine("rhythm","R");
    this.printHeaderLine("source","S");
    this.printHeaderLine("unalignedwords","W");
    this.printHeaderLine("transcription","Z");
    //TODO part order
    //TODO Q tempo
    //TODO textBlock
    this.printHeaderLine("NULL","L","1/8"); //TODO L

    this.printHeaderLine("NULL","M",this.getMeterString(this.abctune.lines[0].staff[0].meter));
    this.printHeaderLine("NULL","K",this.getKeyString(this.abctune.lines[0].staff[0].key));//TODO K
};

TextPrinter.prototype.getKeyString = function(key) {
    return key.root+key.acc+key.mode;
};

TextPrinter.prototype.getMeterString = function(meter) {
    switch (meter.type) {
    case "cut_time": return "C|";
    case "common_time": return "C";
    case "specified":
      if (meter.value[0].den)
		return meter.value[0].num+"/"+meter.value[0].den;
      else
	    return meter.value[0].num;
    }
    return "";
};

TextPrinter.prototype.printHeaderLine = function(fieldname, abcfield, defaut) {
    var val = this.abctune.metaText[fieldname] || defaut;
    if (val !== undefined) {
	var valarray = val.split("\n");
	for (var i=0; i<valarray.length; i++) {
	    this.printString(abcfield+": "+valarray[i]);
	    this.printNewLine();
	} 
    }
};

TextPrinter.prototype.getElem = function() {
    if (this.abcline.length <= this.pos)
	return null;
    return this.abcline[this.pos];
};

TextPrinter.prototype.getNextElem = function() {
    if (this.abcline.length <= this.pos+1)
	return null;
    return this.abcline[this.pos+1];
};

TextPrinter.prototype.printBody = function() {
    for(var line=0; line<this.abctune.lines.length; line++) {
	var abcline = this.abctune.lines[line];
	if (abcline.staff) {
	    this.printABCLine(abcline.staff);
	} else if (abcline.subtitle && line!==0) {
	    //TODO
	} else if (abcline.text) {
	    //TODO
	}
    }
};

TextPrinter.prototype.printABCLine = function(staffs) {
    for (this.s = 0; this.s < staffs.length; this.s++) {
	this.printABCStaff(staffs[this.s]);
    }
};

TextPrinter.prototype.printABCStaff = function(abcstaff) {
    
    // TODO if (abcstaff.bracket) header += "bracket "+abcstaff.bracket+" ";
    // TODO if (abcstaff.brace) header += "brace "+abcstaff.brace+" ";
    
    
    for (this.v = 0; this.v < abcstaff.voices.length; this.v++) {
	// TODO stuff about voices
	
	// TODO this is where key sig is this.voice.addChild(this.printClef(abcstaff.clef));
	// this.voice.addChild(this.printKeySignature(abcstaff.key));
	// if (abcstaff.meter) this.voice.addChild(this.printTimeSignature(abcstaff.meter));
	this.printABCVoice(abcstaff.voices[this.v]);
    }
    
};

TextPrinter.prototype.printABCVoice = function(abcline) {
    this.abcline = abcline;
    for (this.pos=0; this.pos<this.abcline.length; this.pos++) {
	this.printABCElement();
    }
    this.printNewLine();
};

TextPrinter.prototype.printABCElement = function() {
    var elem = this.getElem();
    switch (elem.el_type) {
    case "note":
	this.printBeam();
	break;
    case "bar":
	this.printBarLine(elem);
	break;
    case "meter":
	//TODO this.printTimeSignature(elem);
	break;
    case "clef":
	//TODO this.printClef(elem);
	break;
    case "key":
	//TODO this.printKeySignature(elem);
    case "stem":
	//TODO do nothing?
	break;
    case "part":
	//TODO print part
	break;
    default:
	//TODO show we're missing something
    }
};

TextPrinter.prototype.printBeam = function() {
    this.printSpace();
    if (this.getElem().startBeam && !this.getElem().endBeam) {
	while (this.getElem()) {
	    this.printNote(this.getElem());
	    if (this.getElem().endBeam) {
		break;
	    }
	    this.pos++;
	}
    } else {
	this.printNote(this.getElem());
    }
    this.printSpace();
};

TextPrinter.prototype.printNote = function(elem) {
    var str = "";
	var i;
    if (elem.chord !== undefined) {
	for (i=0; i<elem.chord.length; i++) {
	    str+= '"'+elem.chord[i].name+'"';
	}
    }
    
    //TODO unify map between names and symbols (to be used with abcparse?)
    var decorations = {
	"staccato" : ".",
	"upbow" : "u",
	"downbow" : "v",
	"roll" : "~",
	"fermata" : "H",
	"slide" : "J",
	"accent" : "L",
	"mordent" : "M",
	"pralltriller" : "P",
	"trill" : "T",
	"lower" : "."
    };

    if (elem.decoration !== undefined) {
	for (i=0; i<elem.decoration.length; i++) {
	    var dec = elem.decoration[i];
	    if (decorations[dec]) {
		str+=decorations[dec];
	    } else {
		str+="!"; //TODO hardcoded
		str+=dec;
		str+="!"; //TODO hardcoded
	    }
	}
    }

    if (elem.gracenotes !== undefined) {
	str+="{";
	for (i=0; i<elem.gracenotes.length; i++) {
	    str+=this.getNoteString(elem.gracenotes[i]);
	}
	str+="}";
    }

    var ignoreslur = false;
    if (elem.pitches.length === 1 && elem.pitches[0].startSlur) {
	ignoreslur = true;
	str+=this.multiplyString("(",elem.pitches[0].startSlur.length);
    }

    if (elem.startSlur) {
	str+=this.multiplyString("(",elem.startSlur.length);
    }

    if ((elem.pitches.length === 1 && elem.pitches[0].endSlur) || elem.endSlur) {
	ignoreslur = true;
    }

    if (elem.startTriplet) {
	str+="(3";
    }

    if (elem.pitches) {
	if (elem.pitches.length > 1) str+="[";
	for (i=0; i<elem.pitches.length; i++) {
	    elem.pitches[i].duration = elem.duration;
	    str+=this.getNoteString(elem.pitches[i], ignoreslur);
	}
	if (elem.pitches.length > 1) str+="]";
    } 

    if (elem.pitches.length === 1 && elem.pitches[0].endSlur) {
	str+=this.multiplyString(")",elem.pitches[0].endSlur.length);
    }

    if (elem.endSlur) {
	str+=this.multiplyString(")",elem.endSlur.length);
    }

    this.printString(str,elem);

};

// accidentals, ties and sometimes slurs, sometimes duration
TextPrinter.prototype.getNoteString = function(pitchelem, ignoreslur) {
    var str = "";
    if (!ignoreslur && pitchelem.startSlur) {
	str+="(";
    }

    var symb = "";
    switch (pitchelem.accidental) {
    case "quartersharp":
	symb = "^/";
	break;
    case "dblsharp":
	symb = "^^";
	break;
    case "sharp":
	symb = "^";
	break;
    case "quarterflat":
	symb = "_/";
	break;
    case "flat":
	symb = "_";
	break;
    case "dblflat":
	symb = "__";
	break;
    case "natural":
	symb = "=";
    }
    str+=symb;

    var pitches = ["C","D","E","F","G","A","B"];
    var pitchstr = pitches[this.extractNote(pitchelem.pitch)];
    var octave = this.extractOctave(pitchelem.pitch);
    if (octave>0) {
	pitchstr = pitchstr.toLowerCase();
	octave--;
	while (octave>0) {
	    pitchstr+="'";
	    octave--;
	}
    } else {
	while (octave<0) {
	    pitchstr+=",";
	    octave++;
	}
    }
    
    str+=pitchstr;
    
    if (pitchelem.duration) {
	str+=this.getDurationString(pitchelem.duration);
    }

    if (!ignoreslur && pitchelem.endSlur) {
	str+=")";
    }

    if (pitchelem.startTie) {
	str+="-";
    }

    return str;
};

TextPrinter.prototype.getDurationString = function(duration) {
    //TODO detect crooked rhythm
    if (duration/this.l > 1) {
	return duration/this.l;
    } 
    var ret = "";
    if (this.l/duration>1) {
	ret+="/";
	if (this.l/duration>2) {
	    ret+=this.l/duration;
	}   
    }
    return ret;
};

TextPrinter.prototype.extractNote = function(pitch) {
    var pitch2 = pitch%7;
    if (pitch2<0) pitch2+=7;
    return pitch2;
};

TextPrinter.prototype.extractOctave = function(pitch) {
    return Math.floor(pitch/7);
};

TextPrinter.prototype.printBarLine = function(elem) {
    var barstr = "";
    switch (elem.type) {
    case "bar_thin": barstr+="|"; break;
    case "bar_thin_thick": barstr+="|]"; break;
    case "bar_thin_thin": barstr+="||"; break;
    case "bar_thick_thin": barstr+="[|"; break;
    case "bar_dbl_repeat": barstr+=":||:"; break;
    case "bar_left_repeat": barstr+="|:"; break;
    case "bar_right_repeat": barstr+=":|"; break;
    case "bar_invisible": barstr+=""; break;
    }
    this.printString(barstr,elem);
};

TextPrinter.prototype.multiplyString = function (s, n) {
    var ret = "";
    for (;n>0;n--) ret+=s;
    return ret;
};

module.exports = TextPrinter;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_absolute_element.js":
/*!**************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_absolute_element.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_absolute_element.js: Definition of the AbsoluteElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

// duration - actual musical duration - different from notehead duration in triplets. refer to abcelem to get the notehead duration
// minspacing - spacing which must be taken on top of the width defined by the duration
// type is a meta-type for the element. It is not necessary for drawing, but it is useful to make semantic sense of the element. For instance, it can be used in the element's class name.
var AbsoluteElement = function AbsoluteElement(abcelem, duration, minspacing, type, tuneNumber, options) {
	//console.log("Absolute:",abcelem, type);
	if (!options)
		options = {};
	this.tuneNumber = tuneNumber;
	this.abcelem = abcelem;
	this.duration = duration;
	this.durationClass = options.durationClassOveride ? options.durationClassOveride : this.duration;
	this.minspacing = minspacing || 0;
	this.x = 0;
	this.children = [];
	this.heads = [];
	this.extra = [];
	this.extraw = 0;
	//this.decs = [];
	this.w = 0;
	this.right = [];
	this.invisible = false;
	this.bottom = undefined;
	this.top = undefined;
	this.type = type;
	// these are the heights of all of the vertical elements that can't be placed until the end of the line.
	// the vertical order of elements that are above is: tempo, part, volume/dynamic, ending/chord, lyric
	// the vertical order of elements that are below is: lyric, chord, volume/dynamic
	this.specialY = {
		tempoHeightAbove: 0,
		partHeightAbove: 0,
		volumeHeightAbove: 0,
		dynamicHeightAbove: 0,
		endingHeightAbove: 0,
		chordHeightAbove: 0,
		lyricHeightAbove: 0,

		lyricHeightBelow: 0,
		chordHeightBelow: 0,
		volumeHeightBelow: 0,
		dynamicHeightBelow: 0
	};
};

// For each of the relative elements that can't be placed in advance (because their vertical placement depends on everything
// else on the line), this iterates through them and sets their pitch. By the time this is called, specialYResolved contains a
// hash with the vertical placement (in pitch units) for each type.
// TODO-PER: I think this needs to be separated by "above" and "below". How do we know that for dynamics at the point where they are being defined, though? We need a pass through all the relative elements to set "above" and "below".
AbsoluteElement.prototype.setUpperAndLowerElements = function(specialYResolved) {
	// specialYResolved contains the actual pitch for each of the classes of elements.
	for (var i = 0; i < this.children.length; i++) {
		var child = this.children[i];
		for (var key in this.specialY) { // for each class of element that needs to be placed vertically
			if (this.specialY.hasOwnProperty(key)) {
				if (child[key]) { // If this relative element has defined a height for this class of element
					child.pitch = specialYResolved[key];
					if (child.top === undefined) { // TODO-PER: HACK! Not sure this is the right place to do this.
						child.setUpperAndLowerElements(specialYResolved);
						this.pushTop(child.top);
						this.pushBottom(child.bottom);
					}
				}
			}
		}
	}
};

AbsoluteElement.prototype.getMinWidth = function () { // absolute space taken to the right of the note
	return this.w;
};

AbsoluteElement.prototype.getExtraWidth = function () { // space needed to the left of the note
	return -this.extraw;
};

AbsoluteElement.prototype.addExtra = function (extra) {
	if (extra.dx<this.extraw) this.extraw = extra.dx;
	this.extra[this.extra.length] = extra;
	this.addChild(extra);
};

AbsoluteElement.prototype.addHead = function (head) {
	if (head.dx<this.extraw) this.extraw = head.dx;
	this.heads[this.heads.length] = head;
	this.addRight(head);
};

AbsoluteElement.prototype.addRight = function (right) {
	if (right.dx+right.w>this.w) this.w = right.dx+right.w;
	this.right[this.right.length] = right;
	this.addChild(right);
};

AbsoluteElement.prototype.addCentered = function (elem) {
	var half = elem.w/2;
	if (-half<this.extraw) this.extraw = -half;
	this.extra[this.extra.length] = elem;
	if (elem.dx+half>this.w) this.w = elem.dx+half;
	this.right[this.right.length] = elem;
	this.addChild(elem);
};

AbsoluteElement.prototype.setLimit = function(member, child) {
	if (!child[member]) return;
	if (!this.specialY[member])
		this.specialY[member] = child[member];
	else
		this.specialY[member] = Math.max(this.specialY[member], child[member]);
};

AbsoluteElement.prototype.addChild = function (child) {
	//console.log("Relative:",child);
	child.parent = this;
	this.children[this.children.length] = child;
	this.pushTop(child.top);
	this.pushBottom(child.bottom);
	this.setLimit('tempoHeightAbove', child);
	this.setLimit('partHeightAbove', child);
	this.setLimit('volumeHeightAbove', child);
	this.setLimit('dynamicHeightAbove', child);
	this.setLimit('endingHeightAbove', child);
	this.setLimit('chordHeightAbove', child);
	this.setLimit('lyricHeightAbove', child);
	this.setLimit('lyricHeightBelow', child);
	this.setLimit('chordHeightBelow', child);
	this.setLimit('volumeHeightBelow', child);
	this.setLimit('dynamicHeightBelow', child);
};

AbsoluteElement.prototype.pushTop = function (top) {
	if (top !== undefined) {
		if (this.top === undefined)
			this.top = top;
		else
			this.top = Math.max(top, this.top);
	}
};

AbsoluteElement.prototype.pushBottom = function (bottom) {
	if (bottom !== undefined) {
		if (this.bottom === undefined)
			this.bottom = bottom;
		else
			this.bottom = Math.min(bottom, this.bottom);
	}
};

AbsoluteElement.prototype.setX = function (x) {
	this.x = x;
	for (var i=0; i<this.children.length; i++)
		this.children[i].setX(x);
};

AbsoluteElement.prototype.setHint = function () {
	this.hint = true;
};

AbsoluteElement.prototype.draw = function (renderer, bartop) {
	if (this.invisible) return;
	this.elemset = [];
	renderer.beginGroup();
	for (var i=0; i<this.children.length; i++) {
		if (/*ABCJS.write.debugPlacement*/false) {}
		var el = this.children[i].draw(renderer,bartop);
		if (el)
			this.elemset.push(el);
	}
	var klass = this.type;
	if (this.type === 'note' || this.type === 'rest') {
		klass += ' d' + this.durationClass;
		klass = klass.replace(/\./g, '-');
		if (this.abcelem.pitches) {
			for (var j = 0; j < this.abcelem.pitches.length; j++) {
				klass += ' p' + this.abcelem.pitches[j].pitch;
			}
		}
	}
	var g = renderer.endGroup(klass);
	if (g)
		this.elemset.push(g);
	if (this.klass)
		this.setClass("mark", "", "#00ff00");
	if (this.hint)
		this.setClass("abcjs-hint", "", null);
	var opacity = /*ABCJS.write.debugPlacement*/ false ? 0 : 0; // Create transparent box that encompasses the element, and not so transparent to debug it.
	var target = renderer.printShadedBox(this.x, renderer.calcY(this.top), this.w, renderer.calcY(this.bottom)-renderer.calcY(this.top), "#000000", opacity);
	var self = this;
	var controller = renderer.controller;
	target.addEventListener('mouseup', function () {
		var classes = [];
		if (self.elemset) {
			for (var j = 0; j < self.elemset.length; j++) {
				var es = self.elemset[j];
				if (es)
					classes.push(es.getAttribute("class"));
			}
		}
		controller.notifySelect(self, self.tuneNumber, classes);
	});
	this.abcelem.abselem = this;

	var step = spacing.STEP;
};

AbsoluteElement.prototype.isIE=/*@cc_on!@*/false;//IE detector

AbsoluteElement.prototype.setClass = function (addClass, removeClass, color) {
	for (var i = 0; i < this.elemset.length; i++) {
		var el = this.elemset[i];
		el.setAttribute("fill", color);
		var kls = el.getAttribute("class");
		if (!kls) kls = "";
		kls = kls.replace(removeClass, "");
		kls = kls.replace(addClass, "");
		if (addClass.length > 0) {
			if (kls.length > 0 && kls.charAt(kls.length - 1) !== ' ') kls += " ";
			kls += addClass;
		}
		el.setAttribute("class", kls);
	}
};

AbsoluteElement.prototype.highlight = function (klass, color) {
	if (klass === undefined)
		klass = "abcjs-note_selected";
	if (color === undefined)
		color = "#ff0000";
	this.setClass(klass, "", color);
};

AbsoluteElement.prototype.unhighlight = function (klass, color) {
	if (klass === undefined)
		klass = "abcjs-note_selected";
	if (color === undefined)
		color = "#000000";
	this.setClass("", klass, color);
};

module.exports = AbsoluteElement;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_abstract_engraver.js":
/*!***************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_abstract_engraver.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// abc_abstract_engraver.js: Creates a data structure suitable for printing a line of abc
// Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var BeamElem = __webpack_require__(/*! ./abc_beam_element */ "./node_modules/abcjs/src/write/abc_beam_element.js");
var BraceElem = __webpack_require__(/*! ./abc_brace_element */ "./node_modules/abcjs/src/write/abc_brace_element.js");
var createClef = __webpack_require__(/*! ./abc_create_clef */ "./node_modules/abcjs/src/write/abc_create_clef.js");
var createKeySignature = __webpack_require__(/*! ./abc_create_key_signature */ "./node_modules/abcjs/src/write/abc_create_key_signature.js");
var createTimeSignature = __webpack_require__(/*! ./abc_create_time_signature */ "./node_modules/abcjs/src/write/abc_create_time_signature.js");
var Decoration = __webpack_require__(/*! ./abc_decoration */ "./node_modules/abcjs/src/write/abc_decoration.js");
var EndingElem = __webpack_require__(/*! ./abc_ending_element */ "./node_modules/abcjs/src/write/abc_ending_element.js");
var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");
var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");
var StaffGroupElement = __webpack_require__(/*! ./abc_staff_group_element */ "./node_modules/abcjs/src/write/abc_staff_group_element.js");
var TempoElement = __webpack_require__(/*! ./abc_tempo_element */ "./node_modules/abcjs/src/write/abc_tempo_element.js");
var TieElem = __webpack_require__(/*! ./abc_tie_element */ "./node_modules/abcjs/src/write/abc_tie_element.js");
var TripletElem = __webpack_require__(/*! ./abc_triplet_element */ "./node_modules/abcjs/src/write/abc_triplet_element.js");
var VoiceElement = __webpack_require__(/*! ./abc_voice_element */ "./node_modules/abcjs/src/write/abc_voice_element.js");

var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");

var AbstractEngraver;

(function() {
	"use strict";

var getDuration = function(elem) {
  var d = 0;
  if (elem.duration) {
    d = elem.duration;
  }
  return d;
};

var hint = false;

	var chartable = {
		rest:{0:"rests.whole", 1:"rests.half", 2:"rests.quarter", 3:"rests.8th", 4: "rests.16th",5: "rests.32nd", 6: "rests.64th", 7: "rests.128th", "multi": "rests.multimeasure"},
		note:{"-1": "noteheads.dbl", 0:"noteheads.whole", 1:"noteheads.half", 2:"noteheads.quarter", 3:"noteheads.quarter", 4:"noteheads.quarter", 5:"noteheads.quarter", 6:"noteheads.quarter", 7:"noteheads.quarter", 'nostem':"noteheads.quarter"},
		rhythm:{"-1": "noteheads.slash.whole", 0:"noteheads.slash.whole", 1:"noteheads.slash.whole", 2:"noteheads.slash.quarter", 3:"noteheads.slash.quarter", 4:"noteheads.slash.quarter", 5:"noteheads.slash.quarter", 6:"noteheads.slash.quarter", 7:"noteheads.slash.quarter", nostem: "noteheads.slash.nostem"},
		x:{"-1": "noteheads.indeterminate", 0:"noteheads.indeterminate", 1:"noteheads.indeterminate", 2:"noteheads.indeterminate", 3:"noteheads.indeterminate", 4:"noteheads.indeterminate", 5:"noteheads.indeterminate", 6:"noteheads.indeterminate", 7:"noteheads.indeterminate", nostem: "noteheads.indeterminate"},
		harmonic:{"-1": "noteheads.harmonic.quarter", 0:"noteheads.harmonic.quarter", 1:"noteheads.harmonic.quarter", 2:"noteheads.harmonic.quarter", 3:"noteheads.harmonic.quarter", 4:"noteheads.harmonic.quarter", 5:"noteheads.harmonic.quarter", 6:"noteheads.harmonic.quarter", 7:"noteheads.harmonic.quarter", nostem: "noteheads.harmonic.quarter"},
		uflags:{3:"flags.u8th", 4:"flags.u16th", 5:"flags.u32nd", 6:"flags.u64th"},
		dflags:{3:"flags.d8th", 4:"flags.d16th", 5:"flags.d32nd", 6:"flags.d64th"}
	};

AbstractEngraver = function(renderer, tuneNumber, options) {
	this.decoration = new Decoration();
	this.renderer = renderer;
	this.tuneNumber = tuneNumber;
	this.isBagpipes = options.bagpipes;
	this.flatBeams = options.flatbeams;
	this.reset();
};

AbstractEngraver.prototype.reset = function() {
	this.slurs = {};
	this.ties = [];
	this.voiceScale = 1;
	this.slursbyvoice = {};
	this.tiesbyvoice = {};
	this.endingsbyvoice = {};
	this.scaleByVoice = {};
	this.tripletmultiplier = 1;

	this.abcline = undefined;
	this.accidentalSlot = undefined;
	this.accidentalshiftx = undefined;
	this.dotshiftx = undefined;
	this.hasVocals = false;
	this.minY = undefined;
	this.partstartelem = undefined;
	this.startlimitelem = undefined;
	this.stemdir = undefined;
};

AbstractEngraver.prototype.setStemHeight = function(heightInPixels) {
	this.stemHeight = heightInPixels / spacing.STEP;
};

AbstractEngraver.prototype.getCurrentVoiceId = function(s,v) {
  return "s"+s+"v"+v;
};

AbstractEngraver.prototype.pushCrossLineElems = function(s,v) {
  this.slursbyvoice[this.getCurrentVoiceId(s,v)] = this.slurs;
  this.tiesbyvoice[this.getCurrentVoiceId(s,v)] = this.ties;
  this.endingsbyvoice[this.getCurrentVoiceId(s,v)] = this.partstartelem;
  this.scaleByVoice[this.getCurrentVoiceId(s,v)] = this.voiceScale;
};

AbstractEngraver.prototype.popCrossLineElems = function(s,v) {
  this.slurs = this.slursbyvoice[this.getCurrentVoiceId(s,v)] || {};
  this.ties = this.tiesbyvoice[this.getCurrentVoiceId(s,v)] || [];
  this.partstartelem = this.endingsbyvoice[this.getCurrentVoiceId(s,v)];
  this.voiceScale = this.scaleByVoice[this.getCurrentVoiceId(s,v)];
  if (this.voiceScale === undefined) this.voiceScale = 1;
};

	AbstractEngraver.prototype.containsLyrics = function(staves) {
		for (var i = 0; i < staves.length; i++) {
			for (var j = 0; j < staves[i].voices.length; j++) {
				for (var k = 0; k < staves[i].voices[j].length; k++) {
					var el = staves[i].voices[j][k];
					if (el.lyric) {
						// We just want to see if there are vocals below the music to know where to put the dynamics.
						if (!el.positioning || el.positioning.vocalPosition === 'below')
							this.hasVocals = true;
						return;
					}
				}
			}
		}
	};

AbstractEngraver.prototype.createABCLine = function(staffs, tempo) {
    this.minY = 2; // PER: This will be the lowest that any note reaches. It will be used to set the dynamics row.
	// See if there are any lyrics on this line.
	this.containsLyrics(staffs);
  var staffgroup = new StaffGroupElement();
	this.tempoSet = false;
  for (var s = 0; s < staffs.length; s++) {
	  if (hint)
		  this.restoreState();
	  hint = false;
    this.createABCStaff(staffgroup, staffs[s], tempo, s);
  }
  return staffgroup;
};

AbstractEngraver.prototype.createABCStaff = function(staffgroup, abcstaff, tempo, s) {
// If the tempo is passed in, then the first element should get the tempo attached to it.
  for (var v = 0; v < abcstaff.voices.length; v++) {
    var voice = new VoiceElement(v,abcstaff.voices.length);
    if (v===0) {
	    voice.barfrom = (abcstaff.connectBarLines==="start" || abcstaff.connectBarLines==="continue");
	    voice.barto = (abcstaff.connectBarLines==="continue" || abcstaff.connectBarLines==="end");
    } else {
	    voice.duplicate = true; // bar lines and other duplicate info need not be created
    }
    if (abcstaff.title && abcstaff.title[v]) voice.header=abcstaff.title[v];
	  var clef = createClef(abcstaff.clef, this.tuneNumber);
	  if (clef) {
		  if (v ===0 && abcstaff.barNumber) {
			  this.addMeasureNumber(abcstaff.barNumber, clef);
		  }
		  voice.addChild(clef);
	  }
	  var keySig = createKeySignature(abcstaff.key, this.tuneNumber);
	  if (keySig) {
		  voice.addChild(keySig);
		  this.startlimitelem = keySig; // limit ties here
	  }
    if (abcstaff.meter) {
    	if (abcstaff.meter.type === 'specified') {
    		this.measureLength = abcstaff.meter.value[0].num / abcstaff.meter.value[0].den;
	    } else
	    	this.measureLength = 1;
		var ts = createTimeSignature(abcstaff.meter, this.tuneNumber);
	    voice.addChild(ts);
		this.startlimitelem = ts; // limit ties here
	}
	  if (voice.duplicate)
		  voice.children = []; // we shouldn't reprint the above if we're reusing the same staff. We just created them to get the right spacing.
    var staffLines = abcstaff.clef.stafflines || abcstaff.clef.stafflines === 0 ? abcstaff.clef.stafflines : 5;
    staffgroup.addVoice(voice,s,staffLines);
	  var isSingleLineStaff = staffLines === 1;
	  this.createABCVoice(abcstaff.voices[v],tempo, s, v, isSingleLineStaff, voice);
	  staffgroup.setStaffLimits(voice);
            //Tony: Here I am following what staves need to be surrounded by the brace, by incrementing the length of the brace class.
            //So basically this keeps incrementing the number of staff surrounded by the brace until it sees "end".
            //This then gets processed in abc_staff_group_element.js, so that it will have the correct top and bottom coordinates for the brace.
			if(abcstaff.brace === "start"){
				staffgroup.brace = new BraceElem(1, true);
			}
			else if(abcstaff.brace === "end" && staffgroup.brace) {
				staffgroup.brace.increaseStavesIncluded();
			}
			else if(abcstaff.brace === "continue" && staffgroup.brace){
				staffgroup.brace.increaseStavesIncluded();
			}
  }
};

function getBeamGroup(abcline, pos) {
	// If there are notes beamed together, they are handled as a group, so find all of them here.
	var elem = abcline[pos];
	if (elem.el_type !== 'note' || !elem.startBeam || elem.endBeam)
		return { count: 1, elem: elem };

	var group = [];
	while (pos < abcline.length && abcline[pos].el_type === 'note') {
		group.push(abcline[pos]);
		if (abcline[pos].endBeam)
			break;
		pos++;
	}
	return { count: group.length, elem: group };
}

AbstractEngraver.prototype.createABCVoice = function(abcline, tempo, s, v, isSingleLineStaff, voice) {
  this.popCrossLineElems(s,v);
  this.stemdir = (this.isBagpipes)?"down":null;
  this.abcline = abcline;
  if (this.partstartelem) {
    this.partstartelem = new EndingElem("", null, null);
	  voice.addOther(this.partstartelem);
  }
	var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
  for (var slur in this.slurs) {
    if (this.slurs.hasOwnProperty(slur)) {
	    // this is already a slur element, but it was created for the last line, so recreate it.
      this.slurs[slur]= new TieElem({force: this.slurs[slur].force, voiceNumber: voiceNumber, stemDir: this.slurs[slur].stemDir});
		if (hint) this.slurs[slur].setHint();
	    voice.addOther(this.slurs[slur]);
    }
  }
  for (var i=0; i<this.ties.length; i++) {
  	// this is already a tie element, but it was created for the last line, so recreate it.
    this.ties[i]=new TieElem({ force: this.ties[i].force, stemDir: this.ties[i].stemDir, voiceNumber: voiceNumber });
	  if (hint) this.ties[i].setHint();
	  voice.addOther(this.ties[i]);
  }

  for (var j = 0; j < this.abcline.length; j++) {
	  setAveragePitch(this.abcline[j]);
	  this.minY = Math.min(this.abcline[j].minpitch, this.minY);
  }

	var isFirstStaff = (s === 0);
	var pos = 0;
	while (pos < this.abcline.length) {
		var ret = getBeamGroup(this.abcline, pos);
		var abselems = this.createABCElement(isFirstStaff, isSingleLineStaff, voice, ret.elem);
		if (abselems) {
			for (i = 0; i < abselems.length; i++) {
				if (!this.tempoSet && tempo && !tempo.suppress) {
					this.tempoSet = true;
					var tempoElement = new AbsoluteElement(ret.elem, 0, 0, "tempo", this.tuneNumber, {});
					tempoElement.addChild(new TempoElement(tempo, this.tuneNumber, createNoteHead));
					voice.addChild(tempoElement);
				}
				voice.addChild(abselems[i]);
			}
		}
		pos += ret.count;
	}
	this.pushCrossLineElems(s, v);
};

	AbstractEngraver.prototype.saveState = function() {
		this.tiesSave = parseCommon.cloneArray(this.ties);
		this.slursSave = parseCommon.cloneHashOfHash(this.slurs);
		this.slursbyvoiceSave = parseCommon.cloneHashOfHash(this.slursbyvoice);
		this.tiesbyvoiceSave = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoice);
	};

	AbstractEngraver.prototype.restoreState = function() {
		this.ties = parseCommon.cloneArray(this.tiesSave);
		this.slurs = parseCommon.cloneHashOfHash(this.slursSave);
		this.slursbyvoice = parseCommon.cloneHashOfHash(this.slursbyvoiceSave);
		this.tiesbyvoice = parseCommon.cloneHashOfArrayOfHash(this.tiesbyvoiceSave);
	};

	// function writeMeasureWidth(voice) {
	// 	var width = 0;
	// 	for (var i = voice.children.length-1; i >= 0; i--) {
	// 		var elem = voice.children[i];
	// 		if (elem.abcelem.el_type === 'bar')
	// 			break;
	// 		width += elem.w;
	// 	}
	// 	return new RelativeElement(width.toFixed(2), -70, 0, undefined, {type:"debug"});
	// }

	// return an array of AbsoluteElement
AbstractEngraver.prototype.createABCElement = function(isFirstStaff, isSingleLineStaff, voice, elem) {
  var elemset = [];
  switch (elem.el_type) {
	  case undefined:
	  	// it is undefined if we were passed an array in - an array means a set of notes that should be beamed together.
		  elemset = this.createBeam(isSingleLineStaff, voice, elem);
	  	break;
  case "note":
	  elemset[0] = this.createNote(elem, false, isSingleLineStaff, voice);
	  if (this.triplet && this.triplet.isClosed()) {
		  voice.addOther(this.triplet);
		  this.triplet = null;
		  this.tripletmultiplier = 1;
	  }
    break;
  case "bar":
    elemset[0] = this.createBarLine(voice, elem, isFirstStaff);
    if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
//	  elemset[0].addChild(writeMeasureWidth(voice));
    break;
  case "meter":
    elemset[0] = createTimeSignature(elem, this.tuneNumber);
	  this.startlimitelem = elemset[0]; // limit ties here
    if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
    break;
  case "clef":
    elemset[0] = createClef(elem, this.tuneNumber);
	  if (!elemset[0]) return null;
    if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
    break;
  case "key":
	  var absKey = createKeySignature(elem, this.tuneNumber);
	  if (absKey) {
		  elemset[0] = absKey;
		  this.startlimitelem = elemset[0]; // limit ties here
	  }
    if (voice.duplicate && elemset.length > 0) elemset[0].invisible = true;
    break;
  case "stem":
    this.stemdir=elem.direction;
    break;
  case "part":
    var abselem = new AbsoluteElement(elem,0,0, 'part', this.tuneNumber);
	  var dim = this.renderer.getTextSize(elem.title, 'partsfont', "part");
    abselem.addChild(new RelativeElement(elem.title, 0, 0, undefined, {type:"part", height: dim.height/spacing.STEP}));
    elemset[0] = abselem;
    break;
  case "tempo":
    var abselem3 = new AbsoluteElement(elem,0,0, 'tempo', this.tuneNumber);
    abselem3.addChild(new TempoElement(elem, this.tuneNumber, createNoteHead));
    elemset[0] = abselem3;
    break;
	  case "style":
		  if (elem.head === "normal")
			  delete this.style;
		  else
			  this.style = elem.head;
		  break;
	  case "hint":
		  hint = true;
		  this.saveState();
		  break;
	  case "midi":
		// This has no effect on the visible music, so just skip it.
		break;
	  case "scale":
	  	this.voiceScale = elem.size;
	  	break;

  default:
    var abselem2 = new AbsoluteElement(elem,0,0, 'unsupported', this.tuneNumber);
    abselem2.addChild(new RelativeElement("element type "+elem.el_type, 0, 0, undefined, {type:"debug"}));
    elemset[0] = abselem2;
  }

  return elemset;
};

	function setAveragePitch(elem) {
		if (elem.pitches) {
			sortPitch(elem);
			var sum = 0;
			for (var p = 0; p < elem.pitches.length; p++) {
				sum += elem.pitches[p].verticalPos;
			}
			elem.averagepitch = sum / elem.pitches.length;
			elem.minpitch = elem.pitches[0].verticalPos;
			elem.maxpitch = elem.pitches[elem.pitches.length - 1].verticalPos;
		}
	}

	AbstractEngraver.prototype.calcBeamDir = function (isSingleLineStaff, voice, elems) {
		if (this.stemdir) // If the user or voice is forcing the stem direction, we already know the answer.
			return this.stemdir;
		var beamelem = new BeamElem(this.stemHeight * this.voiceScale, this.stemdir, this.flatBeams);
		for (var i = 0; i < elems.length; i++) {
			beamelem.add({abcelem: elems[i]}); // This is a hack to call beam elem with just a minimum of processing: for our purposes, we don't need to construct the whole note.
		}

		var dir = beamelem.calcDir();
		return dir ? "up" : "down";
	};

	AbstractEngraver.prototype.createBeam = function (isSingleLineStaff, voice, elems) {
		var abselemset = [];

		var dir = this.calcBeamDir(isSingleLineStaff, voice, elems);
		var beamelem = new BeamElem(this.stemHeight * this.voiceScale, dir, this.flatBeams);
		if (hint) beamelem.setHint();
		var oldDir = this.stemdir;
		this.stemdir = dir;
		for (var i = 0; i < elems.length; i++) {
			var elem = elems[i];
			var abselem = this.createNote(elem, true, isSingleLineStaff, voice);
			abselemset.push(abselem);
			beamelem.add(abselem);
			if (this.triplet && this.triplet.isClosed()) {
				voice.addOther(this.triplet);
				this.triplet = null;
				this.tripletmultiplier = 1;
			}
		}
		this.stemdir = oldDir;
		voice.addBeam(beamelem);
		return abselemset;
	};

var sortPitch = function(elem) {
  var sorted;
  do {
    sorted = true;
    for (var p = 0; p<elem.pitches.length-1; p++) {
      if (elem.pitches[p].pitch>elem.pitches[p+1].pitch) {
        sorted = false;
        var tmp = elem.pitches[p];
        elem.pitches[p] = elem.pitches[p+1];
        elem.pitches[p+1] = tmp;
      }
    }
  } while (!sorted);
};

var ledgerLines = function(abselem, minPitch, maxPitch, isRest, symbolWidth, additionalLedgers, dir, dx, scale) {
	for (var i=maxPitch; i>11; i--) {
		if (i%2===0 && !isRest) {
			abselem.addChild(new RelativeElement(null, dx, (symbolWidth+4)*scale, i, {type:"ledger"}));
		}
	}

	for (i=minPitch; i<1; i++) {
		if (i%2===0 && !isRest) {
			abselem.addChild(new RelativeElement(null, dx, (symbolWidth+4)*scale, i, {type:"ledger"}));
		}
	}

	for (i = 0; i < additionalLedgers.length; i++) { // PER: draw additional ledgers
		var ofs = symbolWidth;
		if (dir === 'down') ofs = -ofs;
		abselem.addChild(new RelativeElement(null, ofs+dx, (symbolWidth+4)*scale, additionalLedgers[i], {type:"ledger"}));
	}
};

	AbstractEngraver.prototype.addGraceNotes = function (elem, voice, abselem, notehead, stemHeight, isBagpipes, roomtaken) {
		var gracescale = 3 / 5;
		var graceScaleStem = 3.5 / 5; // TODO-PER: empirically found constant.
		var gracebeam = null;
		var flag;

		if (elem.gracenotes.length > 1) {
			gracebeam = new BeamElem(stemHeight * graceScaleStem, "grace", isBagpipes);
			if (hint) gracebeam.setHint();
			gracebeam.mainNote = abselem;	// this gives us a reference back to the note this is attached to so that the stems can be attached somewhere.
		}

		var graceoffsets = [];
		for (i = elem.gracenotes.length - 1; i >= 0; i--) { // figure out where to place each gracenote
			roomtaken += 10;
			graceoffsets[i] = roomtaken;
			if (elem.gracenotes[i].accidental) {
				roomtaken += 7;
			}
		}

		var i;
		for (i = 0; i < elem.gracenotes.length; i++) {
			var gracepitch = elem.gracenotes[i].verticalPos;

			flag = (gracebeam) ? null : chartable.uflags[(isBagpipes) ? 5 : 3];
			var accidentalSlot = [];
			var ret = createNoteHead(abselem, "noteheads.quarter", elem.gracenotes[i], "up", -graceoffsets[i], -graceoffsets[i], flag, 0, 0, gracescale*this.voiceScale, accidentalSlot, false);
			ret.notehead.highestVert = ret.notehead.pitch + stemHeight * graceScaleStem;
			var grace = ret.notehead;
			this.addSlursAndTies(abselem, elem.gracenotes[i], grace, voice, "up", true);

			abselem.addExtra(grace);
			// PER: added acciaccatura slash
			if (elem.gracenotes[i].acciaccatura) {
				var pos = elem.gracenotes[i].verticalPos + 7 * gracescale;        // the same formula that determines the flag position.
				var dAcciaccatura = gracebeam ? 5 : 6;        // just an offset to make it line up correctly.
				abselem.addRight(new RelativeElement("flags.ugrace", -graceoffsets[i] + dAcciaccatura, 0, pos, {scalex: gracescale, scaley: gracescale}));
			}
			if (gracebeam) { // give the beam the necessary info
				var graceDuration = elem.gracenotes[i].duration / 2;
				if (isBagpipes) graceDuration /= 2;
				var pseudoabselem = {
					heads: [grace],
					abcelem: {averagepitch: gracepitch, minpitch: gracepitch, maxpitch: gracepitch, duration: graceDuration}
				};
				gracebeam.add(pseudoabselem);
			} else { // draw the stem
				var p1 = gracepitch + 1 / 3 * gracescale;
				var p2 = gracepitch + 7 * gracescale;
				var dx = grace.dx + grace.w;
				var width = -0.6;
				abselem.addExtra(new RelativeElement(null, dx, 0, p1, {"type": "stem", "pitch2": p2, linewidth: width}));
			}
			ledgerLines(abselem, gracepitch, gracepitch, false, glyphs.getSymbolWidth("noteheads.quarter"), [], true, grace.dx - 1, 0.6);

			if (i === 0 && !isBagpipes && !(elem.rest && (elem.rest.type === "spacer" || elem.rest.type === "invisible"))) {
				// This is the overall slur that is under the grace notes.
				var isTie = (elem.gracenotes.length === 1 && grace.pitch === notehead.pitch);
				voice.addOther(new TieElem({ anchor1: grace, anchor2: notehead, isGrace: true}));
			}
		}

		if (gracebeam) {
			voice.addBeam(gracebeam);
		}
		return roomtaken;
	};

	function addRestToAbsElement(abselem, elem, duration, dot, isMultiVoice, stemdir, isSingleLineStaff, durlog, voiceScale) {
		var c;
		var restpitch = 7;
		var noteHead;
		var roomTaken;
		var roomTakenRight;

		if (isMultiVoice) {
			if (stemdir === "down") restpitch = 3;
			if (stemdir === "up") restpitch = 11;
		}
		// There is special placement for the percussion staff. If there is one staff line, then move the rest position.
		if (isSingleLineStaff) {
			// The half and whole rests are attached to different lines normally, so we need to tweak their position to get them to both be attached to the same one.
			if (duration < 0.5)
				restpitch = 7;
			else if (duration < 1)
				restpitch = 7;	// half rest
			else
				restpitch = 5; // whole rest
		}
		switch (elem.rest.type) {
			case "whole":
				c = chartable.rest[0];
				elem.averagepitch = restpitch;
				elem.minpitch = restpitch;
				elem.maxpitch = restpitch;
				dot = 0;
				break;
			case "rest":
				if (elem.style === "rhythm") // special case for rhythm: rests are a handy way to express the rhythm.
					c = chartable.rhythm[-durlog];
				else
					c = chartable.rest[-durlog];
				elem.averagepitch = restpitch;
				elem.minpitch = restpitch;
				elem.maxpitch = restpitch;
				break;
			case "invisible":
			case "spacer":
				c = "";
				elem.averagepitch = restpitch;
				elem.minpitch = restpitch;
				elem.maxpitch = restpitch;
				break;
			case "multimeasure":
				c = chartable.rest['multi'];
				elem.averagepitch = restpitch;
				elem.minpitch = restpitch;
				elem.maxpitch = restpitch;
				dot = 0;
				var mmWidth = glyphs.getSymbolWidth(c);
				abselem.addHead(new RelativeElement(c, -mmWidth, mmWidth * 2, 7));
				var numMeasures = new RelativeElement("" + elem.duration, 0, mmWidth, 16, {type: "multimeasure-text"});
				abselem.addExtra(numMeasures);
		}
		if (elem.rest.type !== "multimeasure") {
			var ret = createNoteHead(abselem, c, {verticalPos: restpitch}, null, 0, 0, null, dot, 0, voiceScale, [], false);
			noteHead = ret.notehead;
			if (noteHead) {
				abselem.addHead(noteHead);
				roomTaken = ret.accidentalshiftx;
				roomTakenRight = ret.dotshiftx;
			}
		}
		return { noteHead: noteHead, roomTaken: roomTaken, roomTakenRight: roomTakenRight };
	}

	function addIfNotExist(arr, item) {
		for (var i = 0; i < arr.length; i++) {
			if (JSON.stringify(arr[i]) === JSON.stringify(item))
				return;
		}
		arr.push(item);
	}

	AbstractEngraver.prototype.addNoteToAbcElement = function(abselem, elem, dot, stemdir, style, zeroDuration, durlog, nostem, voice) {
		var dotshiftx = 0; // room taken by chords with displaced noteheads which cause dots to shift
		var noteHead;
		var roomTaken = 0;
		var roomTakenRight = 0;
		var min;
		var i;
		var additionalLedgers = [];
		// The accidentalSlot will hold a list of all the accidentals on this chord. Each element is a vertical place,
		// and contains a pitch, which is the last pitch that contains an accidental in that slot. The slots are numbered
		// from closest to the note to farther left. We only need to know the last accidental we placed because
		// we know that the pitches are sorted by now.
		var accidentalSlot = [];
		var symbolWidth = 0;

		var dir = (elem.averagepitch>=6) ? "down": "up";
		if (stemdir) dir=stemdir;

		style = elem.style ? elem.style : style; // get the style of note head.
		if (!style || style === "normal") style = "note";
		var noteSymbol;
		if (zeroDuration)
			noteSymbol = chartable[style].nostem;
		else
			noteSymbol = chartable[style][-durlog];
		if (!noteSymbol)
			console.log("noteSymbol:", style, durlog, zeroDuration);

		// determine elements of chords which should be shifted
		var p;
		for (p=(dir==="down")?elem.pitches.length-2:1; (dir==="down")?p>=0:p<elem.pitches.length; p=(dir==="down")?p-1:p+1) {
			var prev = elem.pitches[(dir==="down")?p+1:p-1];
			var curr = elem.pitches[p];
			var delta = (dir==="down")?prev.pitch-curr.pitch:curr.pitch-prev.pitch;
			if (delta<=1 && !prev.printer_shift) {
				curr.printer_shift=(delta)?"different":"same";
				if (curr.verticalPos > 11 || curr.verticalPos < 1) {        // PER: add extra ledger line
					additionalLedgers.push(curr.verticalPos - (curr.verticalPos%2));
				}
				if (dir==="down") {
					roomTaken = glyphs.getSymbolWidth(noteSymbol)+2;
				} else {
					dotshiftx = glyphs.getSymbolWidth(noteSymbol)+2;
				}
			}
		}

		var pp = elem.pitches.length;
		for (p=0; p<elem.pitches.length; p++) {

			if (!nostem) {
				var flag;
				if ((dir==="down" && p!==0) || (dir==="up" && p!==pp-1)) { // not the stemmed elem of the chord
					flag = null;
				} else {
					flag = chartable[(dir==="down")?"dflags":"uflags"][-durlog];
				}
			}
			var c;
			if (elem.pitches[p].style) { // There is a style for the whole group of pitches, but there could also be an override for a particular pitch.
				c = chartable[elem.pitches[p].style][-durlog];
			} else
				c = noteSymbol;
			// The highest position for the sake of placing slurs is itself if the slur is internal. It is the highest position possible if the slur is for the whole chord.
			// If the note is the only one in the chord, then any slur it has counts as if it were on the whole chord.
			elem.pitches[p].highestVert = elem.pitches[p].verticalPos;
			var isTopWhenStemIsDown = (stemdir==="up" || dir==="up") && p===0;
			var isBottomWhenStemIsUp = (stemdir==="down" || dir==="down") && p===pp-1;
			if (isTopWhenStemIsDown || isBottomWhenStemIsUp) { // place to put slurs if not already on pitches

				if (elem.startSlur || pp === 1) {
					elem.pitches[p].highestVert = elem.pitches[pp-1].verticalPos;
					if (getDuration(elem) < 1 && (stemdir==="up" || dir==="up"))
						elem.pitches[p].highestVert += 6;        // If the stem is up, then compensate for the length of the stem
				}
				if (elem.startSlur) {
					if (!elem.pitches[p].startSlur) elem.pitches[p].startSlur = []; //TODO possibly redundant, provided array is not optional
					for (i=0; i<elem.startSlur.length; i++) {
						addIfNotExist(elem.pitches[p].startSlur, elem.startSlur[i]);
					}
				}

				if (elem.endSlur) {
					elem.pitches[p].highestVert = elem.pitches[pp-1].verticalPos;
					if (getDuration(elem) < 1 && (stemdir==="up" || dir==="up"))
						elem.pitches[p].highestVert += 6;        // If the stem is up, then compensate for the length of the stem
					if (!elem.pitches[p].endSlur) elem.pitches[p].endSlur = []; //TODO possibly redundant, provided array is not optional
					for (i=0; i<elem.endSlur.length; i++) {
						addIfNotExist(elem.pitches[p].endSlur, elem.endSlur[i]);
					}
				}
			}

			var hasStem = !nostem && durlog<=-1;
			var ret = createNoteHead(abselem, c, elem.pitches[p], dir, 0, -roomTaken, flag, dot, dotshiftx, this.voiceScale, accidentalSlot, !stemdir);
			symbolWidth = Math.max(glyphs.getSymbolWidth(c), symbolWidth);
			abselem.extraw -= ret.extraLeft;
			noteHead = ret.notehead;
			if (noteHead) {
				this.addSlursAndTies(abselem, elem.pitches[p], noteHead, voice, hasStem ? dir : null, false);

				if (elem.gracenotes && elem.gracenotes.length > 0)
					noteHead.bottom = noteHead.bottom - 1;	 // If there is a tie to the grace notes, leave a little more room for the note to avoid collisions.
				abselem.addHead(noteHead);
			}
			roomTaken += ret.accidentalshiftx;
			roomTakenRight = Math.max(roomTakenRight,ret.dotshiftx);
		}

		// draw stem from the furthest note to a pitch above/below the stemmed note
		if (hasStem) {
			var stemHeight = 7 * this.voiceScale;
			var p1 = (dir==="down") ? elem.minpitch-stemHeight : elem.minpitch+1/3;
			// PER added stemdir test to make the line meet the note.
			if (p1>6 && !stemdir) p1=6;
			var p2 = (dir==="down") ? elem.maxpitch-1/3 : elem.maxpitch+stemHeight;
			// PER added stemdir test to make the line meet the note.
			if (p2<6 && !stemdir) p2=6;
			var dx = (dir==="down" || abselem.heads.length === 0)?0:abselem.heads[0].w;
			var width = (dir==="down")?1:-1;
			// TODO-PER-HACK: One type of note head has a different placement of the stem. This should be more generically calculated:
			if (noteHead.c === 'noteheads.slash.quarter') {
				if (dir === 'down')
					p2 -= 1;
				else
					p1 += 1;
			}
			abselem.addExtra(new RelativeElement(null, dx, 0, p1, {"type": "stem", "pitch2":p2, linewidth: width}));
			//var RelativeElement = function RelativeElement(c, dx, w, pitch, opt) {
			min = Math.min(p1, p2);
		}
		return { noteHead: noteHead, roomTaken: roomTaken, roomTakenRight: roomTakenRight, min: min, additionalLedgers: additionalLedgers, dir: dir, symbolWidth: symbolWidth };
	};

	AbstractEngraver.prototype.addLyric = function(abselem, elem) {
		var lyricStr = "";
		parseCommon.each(elem.lyric, function(ly) {
			var div = ly.divider === ' ' ? "" : ly.divider;
			lyricStr += ly.syllable + div + "\n";
		});
		var lyricDim = this.renderer.getTextSize(lyricStr, 'vocalfont', "lyric");
		var position = elem.positioning ? elem.positioning.vocalPosition : 'below';
		abselem.addCentered(new RelativeElement(lyricStr, 0, lyricDim.width, undefined, {type:"lyric", position: position, height: lyricDim.height / spacing.STEP }));
	};

	AbstractEngraver.prototype.addChord = function(abselem, elem, roomTaken, roomTakenRight) {
		var chordMargin = 8; // If there are chords next to each other, this is how close they can get.
		for (var i = 0; i < elem.chord.length; i++) {
			var x = 0;
			var y;
			var dim = this.renderer.getTextSize(elem.chord[i].name, 'annotationfont', "annotation");
			var chordWidth = dim.width;
			var chordHeight = dim.height / spacing.STEP;
			switch (elem.chord[i].position) {
				case "left":
					roomTaken+=chordWidth+7;
					x = -roomTaken;        // TODO-PER: This is just a guess from trial and error
					y = elem.averagepitch;
					abselem.addExtra(new RelativeElement(elem.chord[i].name, x, chordWidth+4, y, {type:"text", height: chordHeight}));
					break;
				case "right":
					roomTakenRight+=4;
					x = roomTakenRight;// TODO-PER: This is just a guess from trial and error
					y = elem.averagepitch;
					abselem.addRight(new RelativeElement(elem.chord[i].name, x, chordWidth+4, y, {type:"text", height: chordHeight}));
					break;
				case "below":
					// setting the y-coordinate to undefined for now: it will be overwritten later on, after we figure out what the highest element on the line is.
					abselem.addRight(new RelativeElement(elem.chord[i].name, 0, chordWidth+chordMargin, undefined, {type: "text", position: "below", height: chordHeight}));
					break;
				case "above":
					// setting the y-coordinate to undefined for now: it will be overwritten later on, after we figure out what the highest element on the line is.
					abselem.addRight(new RelativeElement(elem.chord[i].name, 0, chordWidth+chordMargin, undefined, {type: "text", height: chordHeight}));
					break;
				default:
					if (elem.chord[i].rel_position) {
						var relPositionY = elem.chord[i].rel_position.y + 3*spacing.STEP; // TODO-PER: this is a fudge factor to make it line up with abcm2ps
						abselem.addChild(new RelativeElement(elem.chord[i].name, x + elem.chord[i].rel_position.x, 0, elem.minpitch + relPositionY / spacing.STEP, {type: "text", height: chordHeight}));
					} else {
						// setting the y-coordinate to undefined for now: it will be overwritten later on, after we figure out what the highest element on the line is.
						var pos2 = 'above';
						if (elem.positioning && elem.positioning.chordPosition)
							pos2 = elem.positioning.chordPosition;

						dim = this.renderer.getTextSize(elem.chord[i].name, 'gchordfont', "chord");
						chordHeight = dim.height / spacing.STEP;
						chordWidth = dim.width; // Since the chord is centered, we only use half the width.
						abselem.addCentered(new RelativeElement(elem.chord[i].name, x, chordWidth, undefined, {type: "chord", position: pos2, height: chordHeight }));
					}
			}
		}
		return { roomTaken: roomTaken, roomTakenRight: roomTakenRight };
	};

AbstractEngraver.prototype.createNote = function(elem, nostem, isSingleLineStaff, voice) { //stem presence: true for drawing stemless notehead
  var notehead = null;
  var roomtaken = 0; // room needed to the left of the note
  var roomtakenright = 0; // room needed to the right of the note
  var symbolWidth = 0;
  var additionalLedgers = []; // PER: handle the case of [bc'], where the b doesn't have a ledger line

  var i;
  var dir;

	var duration = getDuration(elem);
	var zeroDuration = false;
  if (duration === 0) { zeroDuration = true; duration = 0.25; nostem = true; }        //PER: zero duration will draw a quarter note head.
  var durlog = Math.floor(Math.log(duration)/Math.log(2)); //TODO use getDurlog
  var dot=0;

  for (var tot = Math.pow(2,durlog), inc=tot/2; tot<duration; dot++,tot+=inc,inc/=2);


	if (elem.startTriplet) {
		this.tripletmultiplier = elem.tripletMultiplier;
	}

  var durationForSpacing = duration * this.tripletmultiplier;
  if (elem.rest && elem.rest.type === 'multimeasure')
  	durationForSpacing = 1;
  var absType = elem.rest ? "rest" : "note";
  var abselem = new AbsoluteElement(elem, durationForSpacing, 1, absType, this.tuneNumber, { durationClassOveride: elem.duration * this.tripletmultiplier});
  if (hint) abselem.setHint();

  if (elem.rest) {
  	if (this.measureLength === duration && elem.rest.type !== 'invisible' && elem.rest.type !== 'spacer')
	    elem.rest.type = 'whole'; // If the rest is exactly a measure, always use a whole rest
	  var ret1 = addRestToAbsElement(abselem, elem, duration, dot, voice.voicetotal > 1, this.stemdir, isSingleLineStaff, durlog, this.voiceScale);
	  notehead = ret1.noteHead;
	  roomtaken = ret1.roomTaken;
	  roomtakenright = ret1.roomTakenRight;
  } else {
	  var ret2 = this.addNoteToAbcElement(abselem, elem, dot, this.stemdir, this.style, zeroDuration, durlog, nostem, voice);
	  if (ret2.min !== undefined)
		  this.minY = Math.min(ret2.min, this.minY);
	  notehead = ret2.noteHead;
	  roomtaken = ret2.roomTaken;
	  roomtakenright = ret2.roomTakenRight;
	  additionalLedgers = ret2.additionalLedgers;
	  dir = ret2.dir;
	  symbolWidth = ret2.symbolWidth;
  }

  if (elem.lyric !== undefined) {
  	this.addLyric(abselem, elem);
  }

  if (elem.gracenotes !== undefined) {
	roomtaken += this.addGraceNotes(elem, voice, abselem, notehead, this.stemHeight * this.voiceScale, this.isBagpipes, roomtaken);
  }

  if (elem.decoration) {
	  this.decoration.createDecoration(voice, elem.decoration, abselem.top, (notehead)?notehead.w:0, abselem, roomtaken, dir, abselem.bottom, elem.positioning, this.hasVocals);
  }

  if (elem.barNumber) {
    abselem.addChild(new RelativeElement(elem.barNumber, -10, 0, 0, {type:"barNumber"}));
  }

  // ledger lines
	ledgerLines(abselem, elem.minpitch, elem.maxpitch, elem.rest, symbolWidth, additionalLedgers, dir, -2, 1);

  if (elem.chord !== undefined) {
  	var ret3 = this.addChord(abselem, elem, roomtaken, roomtakenright);
	  roomtaken = ret3.roomTaken;
	  roomtakenright = ret3.roomTakenRight;
  }


  if (elem.startTriplet) {
    this.triplet = new TripletElem(elem.startTriplet, notehead, { flatBeams: this.flatBeams }); // above is opposite from case of slurs
  }

  if (elem.endTriplet && this.triplet) {
    this.triplet.setCloseAnchor(notehead);
  }

  if (this.triplet && !elem.startTriplet && !elem.endTriplet) {
  	this.triplet.middleNote(notehead);
  }


  return abselem;
};




var createNoteHead = function(abselem, c, pitchelem, dir, headx, extrax, flag, dot, dotshiftx, scale, accidentalSlot, shouldExtendStem) {
  // TODO scale the dot as well
  var pitch = pitchelem.verticalPos;
  var notehead;
  var i;
  var accidentalshiftx = 0;
  var newDotShiftX = 0;
  var extraLeft = 0;
  if (c === undefined)
    abselem.addChild(new RelativeElement("pitch is undefined", 0, 0, 0, {type:"debug"}));
  else if (c==="") {
    notehead = new RelativeElement(null, 0, 0, pitch);
  } else {
    var shiftheadx = headx;
    if (pitchelem.printer_shift) {
      var adjust = (pitchelem.printer_shift==="same")?1:0;
      shiftheadx = (dir==="down")?-glyphs.getSymbolWidth(c)*scale+adjust:glyphs.getSymbolWidth(c)*scale-adjust;
    }
	  var opts = {scalex:scale, scaley: scale, thickness: glyphs.symbolHeightInPitches(c)*scale };
    notehead = new RelativeElement(c, shiftheadx, glyphs.getSymbolWidth(c)*scale, pitch, opts);
    notehead.stemDir = dir;
    if (flag) {
      var pos = pitch+((dir==="down")?-7:7)*scale;
      // if this is a regular note, (not grace or tempo indicator) then the stem will have been stretched to the middle line if it is far from the center.
	    if (shouldExtendStem) {
	    	if (dir==="down" && pos > 6)
	    		pos = 6;
	    	if (dir==="up" && pos < 6)
	    		pos = 6;
	    }
      //if (scale===1 && (dir==="down")?(pos>6):(pos<6)) pos=6;
      var xdelta = (dir==="down")?headx:headx+notehead.w-0.6;
      abselem.addRight(new RelativeElement(flag, xdelta, glyphs.getSymbolWidth(flag)*scale, pos, {scalex:scale, scaley: scale}));
    }
	  newDotShiftX = notehead.w+dotshiftx-2+5*dot;
    for (;dot>0;dot--) {
      var dotadjusty = (1-Math.abs(pitch)%2); //PER: take abs value of the pitch. And the shift still happens on ledger lines.
      abselem.addRight(new RelativeElement("dots.dot", notehead.w+dotshiftx-2+5*dot, glyphs.getSymbolWidth("dots.dot"), pitch+dotadjusty));
    }
  }
        if (notehead)
                notehead.highestVert = pitchelem.highestVert;

  if (pitchelem.accidental) {
    var symb;
    switch (pitchelem.accidental) {
    case "quartersharp":
      symb = "accidentals.halfsharp";
        break;
    case "dblsharp":
      symb = "accidentals.dblsharp";
      break;
    case "sharp":
      symb = "accidentals.sharp";
      break;
    case "quarterflat":
      symb = "accidentals.halfflat";
      break;
    case "flat":
      symb = "accidentals.flat";
      break;
    case "dblflat":
      symb = "accidentals.dblflat";
      break;
    case "natural":
      symb = "accidentals.nat";
    }
         // if a note is at least a sixth away, it can share a slot with another accidental
         var accSlotFound = false;
         var accPlace = extrax;
         for (var j = 0; j < accidentalSlot.length; j++) {
                 if (pitch - accidentalSlot[j][0] >= 6) {
                         accidentalSlot[j][0] = pitch;
                         accPlace = accidentalSlot[j][1];
                         accSlotFound = true;
                         break;
                 }
         }
         if (accSlotFound === false) {
                 accPlace -= (glyphs.getSymbolWidth(symb)*scale+2);
                 accidentalSlot.push([pitch,accPlace]);
                 accidentalshiftx = (glyphs.getSymbolWidth(symb)*scale+2);
         }
    abselem.addExtra(new RelativeElement(symb, accPlace, glyphs.getSymbolWidth(symb), pitch, {scalex:scale, scaley: scale}));
	  extraLeft = glyphs.getSymbolWidth(symb) / 2; // TODO-PER: We need a little extra width if there is an accidental, but I'm not sure why it isn't the full width of the accidental.
  }

  return { notehead: notehead, accidentalshiftx: accidentalshiftx, dotshiftx: newDotShiftX, extraLeft: extraLeft };

};

	AbstractEngraver.prototype.addSlursAndTies = function(abselem, pitchelem, notehead, voice, dir, isGrace) {
		if (pitchelem.endTie) {
			if (this.ties.length > 0) {
				// If there are multiple open ties, find the one that applies by matching the pitch, if possible.
				var found = false;
				for (var j = 0; j < this.ties.length; j++) {
					if (this.ties[j].anchor1 && this.ties[j].anchor1.pitch === notehead.pitch) {
						this.ties[j].setEndAnchor(notehead);
						this.ties.splice(j, 1);
						found = true;
						break;
					}
				}
				if (!found) {
					this.ties[0].setEndAnchor(notehead);
					this.ties.splice(0, 1);
				}
			}
		}

		var voiceNumber = voice.voicetotal < 2 ? -1 : voice.voicenumber;
		if (pitchelem.startTie) {
			var tie = new TieElem({ anchor1: notehead, force: (this.stemdir==="down" || this.stemdir==="up"), stemDir: this.stemdir, isGrace: isGrace, voiceNumber: voiceNumber});
			if (hint) tie.setHint();

			this.ties[this.ties.length]=tie;
			voice.addOther(tie);
			// HACK-PER: For the animation, we need to know if a note is tied to the next one, so here's a flag.
			// Unfortunately, only some of the notes in the current event might be tied, but this will consider it
			// tied if any one of them is. That will work for most cases.
			abselem.startTie = true;
		}

		if (pitchelem.endSlur) {
			for (var i=0; i<pitchelem.endSlur.length; i++) {
				var slurid = pitchelem.endSlur[i];
				var slur;
				if (this.slurs[slurid]) {
					slur = this.slurs[slurid];
					slur.setEndAnchor(notehead);
					delete this.slurs[slurid];
				} else {
					slur = new TieElem({ anchor2: notehead, stemDir: this.stemdir, voiceNumber: voiceNumber});
					if (hint) slur.setHint();
					voice.addOther(slur);
				}
				if (this.startlimitelem) {
					slur.setStartX(this.startlimitelem);
				}
			}
		} else if (!isGrace) {
			for (var s in this.slurs) {
				if (this.slurs.hasOwnProperty(s)) {
					this.slurs[s].addInternalNote(notehead);
				}
			}
		}

		if (pitchelem.startSlur) {
			for (i=0; i<pitchelem.startSlur.length; i++) {
				var slurid = pitchelem.startSlur[i].label;
				var slur = new TieElem({ anchor1: notehead, stemDir: this.stemdir, voiceNumber: voiceNumber});
				if (hint) slur.setHint();
				this.slurs[slurid]=slur;
				voice.addOther(slur);
			}
		}
	};

AbstractEngraver.prototype.addMeasureNumber = function (number, abselem) {
	var measureNumHeight = this.renderer.getTextSize(number, "measurefont", 'bar-number');
	abselem.addChild(new RelativeElement(number, 0, 0, 11+measureNumHeight.height / spacing.STEP, {type:"barNumber"}));
};

AbstractEngraver.prototype.createBarLine = function (voice, elem, isFirstStaff) {
// bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat

  var abselem = new AbsoluteElement(elem, 0, 10, 'bar', this.tuneNumber);
  var anchor = null; // place to attach part lines
  var dx = 0;

	if (elem.barNumber) {
		this.addMeasureNumber(elem.barNumber, abselem);
	}


  var firstdots = (elem.type==="bar_right_repeat" || elem.type==="bar_dbl_repeat");
  var firstthin = (elem.type!=="bar_left_repeat" && elem.type!=="bar_thick_thin" && elem.type!=="bar_invisible");
  var thick = (elem.type==="bar_right_repeat" || elem.type==="bar_dbl_repeat" || elem.type==="bar_left_repeat" ||
         elem.type==="bar_thin_thick" || elem.type==="bar_thick_thin");
  var secondthin = (elem.type==="bar_left_repeat" || elem.type==="bar_thick_thin" || elem.type==="bar_thin_thin" || elem.type==="bar_dbl_repeat");
  var seconddots = (elem.type==="bar_left_repeat" || elem.type==="bar_dbl_repeat");

  // limit positioning of slurs
  if (firstdots || seconddots) {
    for (var slur in this.slurs) {
      if (this.slurs.hasOwnProperty(slur)) {
        this.slurs[slur].setEndX(abselem);
      }
    }
    this.startlimitelem = abselem;
  }

  if (firstdots) {
    abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
    abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
    dx+=6; //2 hardcoded, twice;
  }

  if (firstthin) {
    anchor = new RelativeElement(null, dx, 1, 2, {"type": "bar", "pitch2":10, linewidth:0.6});
    abselem.addRight(anchor);
  }

  if (elem.type==="bar_invisible") {
    anchor = new RelativeElement(null, dx, 1, 2, {"type": "none", "pitch2":10, linewidth:0.6});
    abselem.addRight(anchor);
  }

  if (elem.decoration) {
    this.decoration.createDecoration(voice, elem.decoration, 12, (thick)?3:1, abselem, 0, "down", 2, elem.positioning, this.hasVocals);
  }

  if (thick) {
    dx+=4; //3 hardcoded;
    anchor = new RelativeElement(null, dx, 4, 2, {"type": "bar", "pitch2":10, linewidth:4});
    abselem.addRight(anchor);
    dx+=5;
  }

// if (this.partstartelem && (thick || (firstthin && secondthin))) { // means end of nth part
// this.partstartelem.anchor2=anchor;
// this.partstartelem = null;
// }

  if (this.partstartelem && elem.endEnding) {
    this.partstartelem.anchor2=anchor;
    this.partstartelem = null;
  }

  if (secondthin) {
    dx+=3; //3 hardcoded;
    anchor = new RelativeElement(null, dx, 1, 2, {"type": "bar", "pitch2":10, linewidth:0.6});
    abselem.addRight(anchor); // 3 is hardcoded
  }

  if (seconddots) {
    dx+=3; //3 hardcoded;
    abselem.addRight(new RelativeElement("dots.dot", dx, 1, 7));
    abselem.addRight(new RelativeElement("dots.dot", dx, 1, 5));
  } // 2 is hardcoded

  if (elem.startEnding && isFirstStaff) { // only put the first & second ending marks on the first staff
	  var textWidth = this.renderer.getTextSize(elem.startEnding, "repeatfont", '').width;
	  abselem.minspacing += textWidth + 10; // Give plenty of room for the ending number.
    this.partstartelem = new EndingElem(elem.startEnding, anchor, null);
	  voice.addOther(this.partstartelem);
  }

  // Add a little space to the left of the bar line so that nothing can crowd it.
	abselem.extraw -= 5;

	return abselem;

};


})();

module.exports = AbstractEngraver;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_beam_element.js":
/*!**********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_beam_element.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_beam_element.js: Definition of the BeamElem class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");
var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

var getDurlog = function(duration) {
        // TODO-PER: This is a hack to prevent a Chrome lockup. Duration should have been defined already,
        // but there's definitely a case where it isn't. [Probably something to do with triplets.]
        if (duration === undefined) {
                return 0;
        }
//        console.log("getDurlog: " + duration);
  return Math.floor(Math.log(duration)/Math.log(2));
};


// Most elements on the page are related to a particular absolute element -- notes, rests, bars, etc. Beams, however, span multiple elements.
// This means that beams can't be laid out until the absolute elements are placed. There is the further complication that the stems for beamed
// notes can't be laid out until the beams are because we don't know how long they will be until we know the slope of the beam and the horizontal
// spacing of the absolute elements.
//
// So, when a beam is detected, a BeamElem is created, then all notes belonging to that beam are added to it. These notes are not given stems at that time.
// Then, after the horizontal layout is complete, all of the BeamElem are iterated to set the beam position, then all of the notes that are beamed are given
// stems. After that, we are ready for the drawing step.

// There are three phases: the setup phase, when new elements are being discovered, the layout phase, when everything is calculated, and the drawing phase,
// when the object is not changed, but is used to put the elements on the page.

var BeamElem;

(function() {
	"use strict";

	//
	// Setup phase
	//
	BeamElem = function BeamElem(stemHeight, type, flat) {
		// type is "grace", "up", "down", or undefined. flat is used to force flat beams, as it commonly found in the grace notes of bagpipe music.
		this.isflat = flat;
		this.isgrace = (type && type === "grace");
		this.forceup = this.isgrace || (type && type === "up");
		this.forcedown = (type && type === "down");
		this.elems = []; // all the AbsoluteElements that this beam touches. It may include embedded rests.
		this.total = 0;
		this.allrests = true;
		this.stemHeight = stemHeight;
		this.beams = []; // During the layout phase, this will become a list of the beams that need to be drawn.
	};

	BeamElem.prototype.setHint = function () {
		this.hint = true;
	};

	BeamElem.prototype.add = function(abselem) {
		var pitch = abselem.abcelem.averagepitch;
		if (pitch === undefined) return; // don't include elements like spacers in beams
		this.allrests = this.allrests && abselem.abcelem.rest;
		abselem.beam = this;
		this.elems.push(abselem);
		//var pitch = abselem.abcelem.averagepitch;
		this.total += pitch; // TODO CHORD (get pitches from abselem.heads)
		if (this.min === undefined || abselem.abcelem.minpitch < this.min) {
			this.min = abselem.abcelem.minpitch;
		}
		if (this.max === undefined || abselem.abcelem.maxpitch > this.max) {
			this.max = abselem.abcelem.maxpitch;
		}
	};

	var middleLine = 6;	// hardcoded 6 is B

	BeamElem.prototype.calcDir = function() {
		if (this.forceup) return true;
		if (this.forcedown) return false;
		var average = calcAverage(this.total, this.elems.length);
		return average < middleLine;
	};

	//
	// layout phase
	//
	BeamElem.prototype.layout = function() {
		if (this.elems.length === 0 || this.allrests) return;

		this.stemsUp = this.calcDir(); // True means the stems are facing up.
		var dy = calcDy(this.stemsUp, this.isgrace); // This is the width of the beam line.

		// create the main beam
		var firstElement = this.elems[0];
		var lastElement = this.elems[this.elems.length - 1];
		var minStemHeight = 0; // The following is to leave space for "!///!" marks.
		var referencePitch = this.stemsUp ? firstElement.abcelem.maxpitch : firstElement.abcelem.minpitch;
		minStemHeight = minStem(firstElement, this.stemsUp, referencePitch, minStemHeight);
		minStemHeight = minStem(lastElement, this.stemsUp, referencePitch, minStemHeight);
		minStemHeight = Math.max(this.stemHeight, minStemHeight + 3); // TODO-PER: The 3 is the width of a 16th beam. The actual height of the beam should be used instead.
		var yPos = calcYPos(this.total, this.elems.length, minStemHeight, this.stemsUp, firstElement.abcelem.averagepitch, lastElement.abcelem.averagepitch, this.isflat, this.min, this.max, this.isgrace);
		var xPos = calcXPos(this.stemsUp, firstElement, lastElement);
		this.beams.push({ startX: xPos[0], endX: xPos[1], startY: yPos[0], endY: yPos[1], dy: dy });

		// create the rest of the beams (in the case of 1/16th notes, etc.
		var beams = createAdditionalBeams(this.elems, this.stemsUp, this.beams[0], this.isgrace, dy);
		for (var i = 0; i < beams.length; i++)
			this.beams.push(beams[i]);

		// Now that the main beam is defined, we know how tall the stems should be, so create them and attach them to the original notes.
		createStems(this.elems, this.stemsUp, this.beams[0], dy, this.mainNote);
	};

	BeamElem.prototype.isAbove = function() {
		return this.stemsUp;
	};

	// We can't just use the entire beam for the calculation. The range has to be passed in, because the beam might extend into some unrelated notes. for instance, (3_a'f'e'f'2 when L:16
	BeamElem.prototype.heightAtMidpoint = function(startX, endX) {
		if (this.beams.length === 0)
			return 0;
		var beam = this.beams[0];
		var midPoint = startX + (endX - startX) / 2;
		return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, midPoint);
	};

	BeamElem.prototype.yAtNote = function(element) {
		var beam = this.beams[0];
		return getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, element.x);
	};

	BeamElem.prototype.xAtMidpoint = function(startX, endX) {
		return startX + (endX - startX)/2;
	};

	//
	// Drawing phase
	//
	BeamElem.prototype.draw = function(renderer) {
		if (this.beams.length === 0) return;

		renderer.beginGroup();
		for (var i = 0; i < this.beams.length; i++) {
			var beam = this.beams[i];
			drawBeam(renderer, beam.startX, beam.startY, beam.endX, beam.endY, beam.dy, this.hint);
		}
		renderer.endGroup('beam-elem');
	};

	//
	// private functions
	//
	function minStem(element, stemsUp, referencePitch, minStemHeight) {
		if (!element.children)
			return minStemHeight;
		for (var i = 0; i < element.children.length; i++) {
			var elem = element.children[i];
			if (stemsUp && elem.top !== undefined && elem.c === "flags.ugrace")
				minStemHeight = Math.max(minStemHeight, elem.top - referencePitch);
			else if (!stemsUp && elem.bottom !== undefined && elem.c === "flags.ugrace")
				minStemHeight = Math.max(minStemHeight, referencePitch - elem.bottom + 7); // The extra 7 is because we are measuring the slash from the top.
		}
		return minStemHeight;
	}

	function calcSlant(leftAveragePitch, rightAveragePitch, numStems, isFlat) {
		if (isFlat)
			return 0;
		var slant = leftAveragePitch - rightAveragePitch;
		var maxSlant = numStems / 2;

		if (slant > maxSlant) slant = maxSlant;
		if (slant < -maxSlant) slant = -maxSlant;
		return slant;
	}

	function calcAverage(total, numElements) {
		if (!numElements)
			return 0;
		return total / numElements;
	}

	function getBarYAt(startx, starty, endx, endy, x) {
		return starty + (endy - starty) / (endx - startx) * (x - startx);
	}

	function calcDy(asc, isGrace) {
		var dy = (asc) ? spacing.STEP : -spacing.STEP;
		if (isGrace) dy = dy * 0.4;
		return dy;
	}

	function drawBeam(renderer, startX, startY, endX, endY, dy, isHint) {
		var klass = 'beam-elem';
		if (isHint)
			klass += " abcjs-hint";

		// the X coordinates are actual coordinates, but the Y coordinates are in pitches.
		startY = renderer.calcY(startY);
		endY = renderer.calcY(endY);
		var pathString = "M" + startX + " " + startY + " L" + endX + " " + endY +
			"L" + endX + " " + (endY + dy) + " L" + startX + " " + (startY + dy) + "z";
		renderer.printPath({
			path: pathString,
			stroke: "none",
			fill: "#000000",
			'class': renderer.addClasses(klass)
		});
	}

	function calcXPos(asc, firstElement, lastElement) {
		var starthead = firstElement.heads[asc ? 0 : firstElement.heads.length - 1];
		var endhead = lastElement.heads[asc ? 0 : lastElement.heads.length - 1];
		var startX = starthead.x;
		if (asc) startX += starthead.w - 0.6;
		var endX = endhead.x;
		if (asc) endX += endhead.w;
		return [ startX, endX ];
	}

	function calcYPos(total, numElements, stemHeight, asc, firstAveragePitch, lastAveragePitch, isFlat, minPitch, maxPitch, isGrace) {
		var average = calcAverage(total, numElements); // This is the average pitch for the all the notes that will be beamed.
		var barpos = stemHeight - 2; // (isGrace)? 5:7;
		var barminpos = stemHeight - 2;
		var pos = Math.round(asc ? Math.max(average + barpos, maxPitch + barminpos) : Math.min(average - barpos, minPitch - barminpos));

		var slant = calcSlant(firstAveragePitch, lastAveragePitch, numElements, isFlat);
		var startY = pos + Math.floor(slant / 2);
		var endY = pos + Math.floor(-slant / 2);

		// If the notes are too high or too low, make the beam go down to the middle
		if (!isGrace) {
			if (asc && pos < 6) {
				startY = 6;
				endY = 6;
			} else if (!asc && pos > 6) {
				startY = 6;
				endY = 6;
			}
		}

		return [ startY, endY];
	}

	function createStems(elems, asc, beam, dy, mainNote) {
		for (var i = 0; i < elems.length; i++) {
			var elem = elems[i];
			if (elem.abcelem.rest)
				continue;
			// TODO-PER: This is odd. If it is a regular beam then elems is an array of AbsoluteElements, if it is a grace beam then it is an array of objects , so we directly attach the element to the parent. We tell it if is a grace note because they are passed in as a generic object instead of an AbsoluteElement.
			var isGrace = elem.addExtra ? false : true;
			var parent = isGrace ? mainNote : elem;
			var furthestHead = elem.heads[(asc) ? 0 : elem.heads.length - 1];
			var ovalDelta = 1 / 5;//(isGrace)?1/3:1/5;
			var pitch = furthestHead.pitch + ((asc) ? ovalDelta : -ovalDelta);
			var dx = asc ? furthestHead.w : 0; // down-pointing stems start on the left side of the note, up-pointing stems start on the right side, so we offset by the note width.
			var x = furthestHead.x + dx; // this is now the actual x location in pixels.
			var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);
			var lineWidth = (asc) ? -0.6 : 0.6;
			if (!asc)
				bary -= (dy / 2) / spacing.STEP;	// TODO-PER: This is just a fudge factor so the down-pointing stems don't overlap.
			if (isGrace)
				dx += elem.heads[0].dx;
			// TODO-PER-HACK: One type of note head has a different placement of the stem. This should be more generically calculated:
			if (furthestHead.c === 'noteheads.slash.quarter') {
				if (asc)
					pitch += 1;
				else
					pitch -= 1;
			}
			var stem = new RelativeElement(null, dx, 0, pitch, {
				"type": "stem",
				"pitch2": bary,
				linewidth: lineWidth
			});
			stem.setX(parent.x); // This is after the x coordinates were set, so we have to set it directly.
			parent.addExtra(stem);
		}

	}

	function createAdditionalBeams(elems, asc, beam, isGrace, dy) {
		var beams = [];
		var auxBeams = [];  // auxbeam will be {x, y, durlog, single} auxbeam[0] should match with durlog=-4 (16th) (j=-4-durlog)
		for (var i = 0; i < elems.length; i++) {
			var elem = elems[i];
			if (elem.abcelem.rest)
				continue;
			var furthestHead = elem.heads[(asc) ? 0 : elem.heads.length - 1];
			var x = furthestHead.x + ((asc) ? furthestHead.w : 0);
			var bary = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, x);

			var sy = (asc) ? -1.5 : 1.5;
			if (isGrace) sy = sy * 2 / 3; // This makes the second beam on grace notes closer to the first one.
			var duration = elem.abcelem.duration; // get the duration via abcelem because of triplets
			if (duration === 0) duration = 0.25; // if this is stemless, then we use quarter note as the duration.
			for (var durlog = getDurlog(duration); durlog < -3; durlog++) {
				if (auxBeams[-4 - durlog]) {
					auxBeams[-4 - durlog].single = false;
				} else {
					auxBeams[-4 - durlog] = {
						x: x + ((asc) ? -0.6 : 0), y: bary + sy * (-4 - durlog + 1),
						durlog: durlog, single: true
					};
				}
			}

			for (var j = auxBeams.length - 1; j >= 0; j--) {
				if (i === elems.length - 1 || getDurlog(elems[i + 1].abcelem.duration) > (-j - 4)) {

					var auxBeamEndX = x;
					var auxBeamEndY = bary + sy * (j + 1);


					if (auxBeams[j].single) {
						auxBeamEndX = (i === 0) ? x + 5 : x - 5;
						auxBeamEndY = getBarYAt(beam.startX, beam.startY, beam.endX, beam.endY, auxBeamEndX) + sy * (j + 1);
					}
					beams.push({ startX: auxBeams[j].x, endX: auxBeamEndX, startY: auxBeams[j].y, endY: auxBeamEndY, dy: dy });
					auxBeams = auxBeams.slice(0, j);
				}
			}
		}
		return beams;
	}
})();

module.exports = BeamElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_brace_element.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_brace_element.js ***!
  \***********************************************************/
/***/ (function(module) {

//    abc_brace_element.js: Definition of the BraceElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var BraceElem = function BraceElem() {
    this.length = 1;
};

BraceElem.prototype.increaseStavesIncluded = function() {
    this.length++;
};

BraceElem.prototype.setLocation = function(x) {
	this.x = x;
};

BraceElem.prototype.getWidth = function() {
	return 10; // TODO-PER: right now the drawing function doesn't vary the width at all. If it does in the future then this will change.
};

BraceElem.prototype.layout = function (renderer, top, bottom) {
    this.startY = top;
    this.endY = bottom;
};

BraceElem.prototype.draw = function (renderer, top, bottom) {
    this.layout(renderer, top, bottom);
    renderer.drawBrace(this.x,this.startY, this.endY);

};

module.exports = BraceElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_create_clef.js":
/*!*********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_create_clef.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_create_clef.js
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");

var createClef;

(function() {
	"use strict";

	createClef = function(elem, tuneNumber) {
		var clef;
		var octave = 0;
		var abselem = new AbsoluteElement(elem,0,10, 'staff-extra', tuneNumber);
		abselem.isClef = true;
		switch (elem.type) {
			case "treble": clef = "clefs.G"; break;
			case "tenor": clef="clefs.C"; break;
			case "alto": clef="clefs.C"; break;
			case "bass": clef="clefs.F"; break;
			case 'treble+8': clef = "clefs.G"; octave = 1; break;
			case 'tenor+8':clef="clefs.C"; octave = 1; break;
			case 'bass+8': clef="clefs.F"; octave = 1; break;
			case 'alto+8': clef="clefs.C"; octave = 1; break;
			case 'treble-8': clef = "clefs.G"; octave = -1; break;
			case 'tenor-8':clef="clefs.C"; octave = -1; break;
			case 'bass-8': clef="clefs.F"; octave = -1; break;
			case 'alto-8': clef="clefs.C"; octave = -1; break;
			case 'none': return null;
			case 'perc': clef="clefs.perc"; break;
			default: abselem.addChild(new RelativeElement("clef="+elem.type, 0, 0, undefined, {type:"debug"}));
		}
		// if (elem.verticalPos) {
		// pitch = elem.verticalPos;
		// }
		var dx =5;
		if (clef) {
			abselem.addRight(new RelativeElement(clef, dx, glyphs.getSymbolWidth(clef), elem.clefPos));

			if (clef === 'clefs.G') {
				abselem.top = 13;
				abselem.bottom = -1;
			} else {
				abselem.top = 10;
				abselem.bottom = 2;
			}
			if (octave !== 0) {
				var scale = 2 / 3;
				var adjustspacing = (glyphs.getSymbolWidth(clef) - glyphs.getSymbolWidth("8") * scale) / 2;
				abselem.addRight(new RelativeElement("8", dx + adjustspacing, glyphs.getSymbolWidth("8") * scale, (octave > 0) ? abselem.top + 3 : abselem.bottom - 1, {
					scalex: scale,
					scaley: scale
				}));
				abselem.top += 2;
			}
		}
		return abselem;
	};

})();

module.exports = createClef;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_create_key_signature.js":
/*!******************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_create_key_signature.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_create_key_signature.js
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");

var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");

var createKeySignature;

(function() {
	"use strict";

	createKeySignature = function(elem, tuneNumber) {
		if (!elem.accidentals || elem.accidentals.length === 0)
			return null;
		var abselem = new AbsoluteElement(elem, 0, 10, 'staff-extra', tuneNumber);
		abselem.isKeySig = true;
		var dx = 0;
		parseCommon.each(elem.accidentals, function(acc) {
			var symbol;
			switch(acc.acc) {
				case "sharp": symbol = "accidentals.sharp"; break;
				case "natural": symbol = "accidentals.nat"; break;
				case "flat": symbol = "accidentals.flat"; break;
				case "quartersharp": symbol = "accidentals.halfsharp"; break;
				case "quarterflat": symbol = "accidentals.halfflat"; break;
				default: symbol = "accidentals.flat";
			}
			abselem.addRight(new RelativeElement(symbol, dx, glyphs.getSymbolWidth(symbol), acc.verticalPos, {thickness: glyphs.symbolHeightInPitches(symbol)}));
			dx += glyphs.getSymbolWidth(symbol) + 2;
		}, this);
		return abselem;
	};
})();

module.exports = createKeySignature;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_create_time_signature.js":
/*!*******************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_create_time_signature.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_create_time_signature.js
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");

var createTimeSignature;

(function() {
	"use strict";

	createTimeSignature = function(elem, tuneNumber) {
		var abselem = new AbsoluteElement(elem,0,10, 'staff-extra', tuneNumber);
		if (elem.type === "specified") {
			var x = 0;
			for (var i = 0; i < elem.value.length; i++) {
				if (i !== 0) {
					abselem.addRight(new RelativeElement('+', x+1, glyphs.getSymbolWidth("+"), 6, {thickness: glyphs.symbolHeightInPitches("+")}));
					x += glyphs.getSymbolWidth("+")+2;
				}
				if (elem.value[i].den) {
					var numWidth = 0;
					for (var i2 = 0; i2 < elem.value[i].num.length; i2++)
						numWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i2));
					var denWidth = 0;
					for (i2 = 0; i2 < elem.value[i].num.length; i2++)
						denWidth += glyphs.getSymbolWidth(elem.value[i].den.charAt(i2));
					var maxWidth = Math.max(numWidth, denWidth);
					abselem.addRight(new RelativeElement(elem.value[i].num, x+(maxWidth-numWidth)/2, numWidth, 8, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
					abselem.addRight(new RelativeElement(elem.value[i].den, x+(maxWidth-denWidth)/2, denWidth, 4, { thickness: glyphs.symbolHeightInPitches(elem.value[i].den.charAt(0)) }));
					x += maxWidth
				} else {
					var thisWidth = 0;
					for (var i3 = 0; i3 < elem.value[i].num.length; i3++)
						thisWidth += glyphs.getSymbolWidth(elem.value[i].num.charAt(i3));
					abselem.addRight(new RelativeElement(elem.value[i].num, x, thisWidth, 6, { thickness: glyphs.symbolHeightInPitches(elem.value[i].num.charAt(0)) }));
					x += thisWidth;
				}
			}
		} else if (elem.type === "common_time") {
			abselem.addRight(new RelativeElement("timesig.common", 0, glyphs.getSymbolWidth("timesig.common"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.common") }));

		} else if (elem.type === "cut_time") {
			abselem.addRight(new RelativeElement("timesig.cut", 0, glyphs.getSymbolWidth("timesig.cut"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.cut") }));
		} else if (elem.type === "tempus_imperfectum") {
			abselem.addRight(new RelativeElement("timesig.imperfectum", 0, glyphs.getSymbolWidth("timesig.imperfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum") }));
		} else if (elem.type === "tempus_imperfectum_prolatio") {
			abselem.addRight(new RelativeElement("timesig.imperfectum2", 0, glyphs.getSymbolWidth("timesig.imperfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.imperfectum2") }));
		} else if (elem.type === "tempus_perfectum") {
			abselem.addRight(new RelativeElement("timesig.perfectum", 0, glyphs.getSymbolWidth("timesig.perfectum"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum") }));
		} else if (elem.type === "tempus_perfectum_prolatio") {
			abselem.addRight(new RelativeElement("timesig.perfectum2", 0, glyphs.getSymbolWidth("timesig.perfectum2"), 6, { thickness: glyphs.symbolHeightInPitches("timesig.perfectum2") }));
		} else {
			console.log("time signature:",elem);
		}
		return abselem;
	};
})();

module.exports = createTimeSignature;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_crescendo_element.js":
/*!***************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_crescendo_element.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_crescendo_element.js: Definition of the CrescendoElem class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/abcjs/src/write/sprintf.js");

var CrescendoElem = function CrescendoElem(anchor1, anchor2, dir, positioning) {
	this.anchor1 = anchor1; // must have a .x and a .parent property or be null (means starts at the "beginning" of the line - after keysig)
	this.anchor2 = anchor2; // must have a .x property or be null (means ends at the end of the line)
	this.dir = dir; // either "<" or ">"
	if (positioning === 'above')
		this.dynamicHeightAbove = 4;
	else
		this.dynamicHeightBelow = 4;
	this.pitch = undefined; // This will be set later
};

CrescendoElem.prototype.setUpperAndLowerElements = function(positionY) {
	if (this.dynamicHeightAbove)
		this.pitch = positionY.dynamicHeightAbove;
	else
		this.pitch = positionY.dynamicHeightBelow;
};

CrescendoElem.prototype.draw = function (renderer) {
	if (this.pitch === undefined)
		window.console.error("Crescendo Element y-coordinate not set.");
	var y = renderer.calcY(this.pitch) + 4; // This is the top pixel to use (it is offset a little so that it looks good with the volume marks.)
	var height = 8;
	if (this.dir === "<") {
		this.drawLine(renderer, y+height/2, y);
		this.drawLine(renderer, y+height/2, y+height);
	} else {
		this.drawLine(renderer, y, y+height/2);
		this.drawLine(renderer, y+height, y+height/2);
	}
};

CrescendoElem.prototype.drawLine = function (renderer, y1, y2) {
	// TODO-PER: This is just a quick hack to make the dynamic marks not crash if they are mismatched. See the slur treatment for the way to get the beginning and end.
	var left = this.anchor1 ? this.anchor1.x : 0;
	var right = this.anchor2 ? this.anchor2.x : 800;
	var pathString = sprintf("M %f %f L %f %f",
		left, y1, right, y2);
	renderer.printPath({path:pathString, stroke:"#000000", 'class': renderer.addClasses('decoration')});
};

module.exports = CrescendoElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_decoration.js":
/*!********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_decoration.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// abc_decoration.js: Creates a data structure suitable for printing a line of abc
// Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) & Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global window */

var DynamicDecoration = __webpack_require__(/*! ./abc_dynamic_decoration */ "./node_modules/abcjs/src/write/abc_dynamic_decoration.js");
var CrescendoElem = __webpack_require__(/*! ./abc_crescendo_element */ "./node_modules/abcjs/src/write/abc_crescendo_element.js");
var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");
var TieElem = __webpack_require__(/*! ./abc_tie_element */ "./node_modules/abcjs/src/write/abc_tie_element.js");

var Decoration;

(function() {
	"use strict";

	Decoration = function Decoration() {
		this.startDiminuendoX = undefined;
		this.startCrescendoX = undefined;
		this.minTop = 12;	// TODO-PER: this is assuming a 5-line staff. Pass that info in.
		this.minBottom = 0;
	};

	var closeDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch) {
		var yPos;
		for (var i=0;i<decoration.length; i++) {
			if (decoration[i]==="staccato" || decoration[i]==="tenuto" || decoration[i] === "accent") {
				var symbol = "scripts." + decoration[i];
				if (decoration[i] === "accent") symbol = "scripts.sforzato";
				if (yPos === undefined)
					yPos = (dir==="down") ? pitch+2:minPitch-2;
				else
					yPos = (dir==="down") ? yPos+2:yPos-2;
				if (decoration[i] === "accent") {
					// Always place the accent three pitches away, no matter whether that is a line or space.
					if (dir === "up") yPos--;
					else yPos++;
				} else {
					// don't place on a stave line. The stave lines are 2,4,6,8,10
					switch (yPos) {
						case 2:
						case 4:
						case 6:
						case 8:
						case 10:
							if (dir === "up") yPos--;
							else yPos++;
							break;
					}
				}
				if (pitch>9) yPos++; // take up some room of those that are above
				var deltaX = width/2;
				if (glyphs.getSymbolAlign(symbol)!=="center") {
					deltaX -= (glyphs.getSymbolWidth(symbol)/2);
				}
				abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), yPos));
			}
			if (decoration[i]==="slide" && abselem.heads[0]) {
				var yPos2 = abselem.heads[0].pitch;
				yPos2 -= 2; // TODO-PER: not sure what this fudge factor is.
				var blank1 = new RelativeElement("", -roomtaken-15, 0, yPos2-1);
				var blank2 = new RelativeElement("", -roomtaken-5, 0, yPos2+1);
				abselem.addChild(blank1);
				abselem.addChild(blank2);
				voice.addOther(new TieElem({ anchor1: blank1, anchor2: blank2, fixedY: true}));
			}
		}
		if (yPos === undefined)
			yPos = pitch;

		return { above: yPos, below: abselem.bottom };
	};

	var volumeDecoration = function(voice, decoration, abselem, positioning) {
		for (var i=0;i<decoration.length; i++) {
			switch(decoration[i]) {
				case "p":
				case "mp":
				case "pp":
				case "ppp":
				case "pppp":
				case "f":
				case "ff":
				case "fff":
				case "ffff":
				case "sfz":
				case "mf":
					var elem = new DynamicDecoration(abselem, decoration[i], positioning);
					voice.addOther(elem);
			}
		}
	};

	var compoundDecoration = function(decoration, pitch, width, abselem, dir) {
		function highestPitch() {
			if (abselem.heads.length === 0)
				return 10;	// TODO-PER: I don't know if this can happen, but we'll return the top of the staff if so.
			var pitch = abselem.heads[0].pitch;
			for (var i = 1; i < abselem.heads.length; i++)
				pitch = Math.max(pitch, abselem.heads[i].pitch);
			return pitch;
		}
		function lowestPitch() {
			if (abselem.heads.length === 0)
				return 2;	// TODO-PER: I don't know if this can happen, but we'll return the bottom of the staff if so.
			var pitch = abselem.heads[0].pitch;
			for (var i = 1; i < abselem.heads.length; i++)
				pitch = Math.min(pitch, abselem.heads[i].pitch);
			return pitch;
		}
		function compoundDecoration(symbol, count) {
			var placement = (dir === 'down') ? lowestPitch()+1:highestPitch()+9;
			if (dir !== 'down' && count === 1)
				placement--;
			var deltaX = width/2;
			deltaX += (dir === 'down') ? -5 : 3;
			for (var i = 0; i < count; i++) {
				placement -= 1;
				abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), placement));
			}
		}

		for (var i=0;i<decoration.length; i++) {
			switch(decoration[i]) {
				case "/": compoundDecoration("flags.ugrace", 1); break;
				case "//": compoundDecoration("flags.ugrace", 2); break;
				case "///": compoundDecoration("flags.ugrace", 3); break;
				case "////": compoundDecoration("flags.ugrace", 4); break;
			}
		}
	};

	var stackedDecoration = function(decoration, width, abselem, yPos, positioning, minTop, minBottom) {
		function incrementPlacement(placement, height) {
			if (placement === 'above')
				yPos.above += height;
			else
				yPos.below -= height;
		}
		function getPlacement(placement) {
			var y;
			if (placement === 'above') {
				y = yPos.above;
				if (y < minTop)
					y = minTop;
			} else {
				y = yPos.below;
				if (y > minBottom)
					y = minBottom;
			}
			return y;
		}
		function textDecoration(text, placement) {
			var y = getPlacement(placement);
			var textFudge = 2;
			var textHeight = 5;
			// TODO-PER: Get the height of the current font and use that for the thickness.
			abselem.addChild(new RelativeElement(text, width/2, 0, y+textFudge, {type:"decoration", klass: 'ornament', thickness: 3}));

			incrementPlacement(placement, textHeight);
		}
		function symbolDecoration(symbol, placement) {
			var deltaX = width/2;
			if (glyphs.getSymbolAlign(symbol) !== "center") {
				deltaX -= (glyphs.getSymbolWidth(symbol) / 2);
			}
			var height = glyphs.symbolHeightInPitches(symbol) + 1; // adding a little padding so nothing touches.
			var y = getPlacement(placement);
			y = (placement === 'above') ? y + height/2 : y - height/2;// Center the element vertically.
			abselem.addChild(new RelativeElement(symbol, deltaX, glyphs.getSymbolWidth(symbol), y, { klass: 'ornament', thickness: glyphs.symbolHeightInPitches(symbol) }));

			incrementPlacement(placement, height);
		}

		var symbolList = {
			"+": "scripts.stopped",
			"open": "scripts.open",
			"snap": "scripts.snap",
			"wedge": "scripts.wedge",
			"thumb": "scripts.thumb",
			"shortphrase": "scripts.shortphrase",
			"mediumphrase": "scripts.mediumphrase",
			"longphrase": "scripts.longphrase",
			"trill": "scripts.trill",
			"roll": "scripts.roll",
			"irishroll": "scripts.roll",
			"marcato": "scripts.umarcato",
			"dmarcato": "scripts.dmarcato",
			"umarcato": "scripts.umarcato",
			"turn": "scripts.turn",
			"uppermordent": "scripts.prall",
			"pralltriller": "scripts.prall",
			"mordent": "scripts.mordent",
			"lowermordent": "scripts.mordent",
			"downbow": "scripts.downbow",
			"upbow": "scripts.upbow",
			"fermata": "scripts.ufermata",
			"invertedfermata": "scripts.dfermata",
			"breath": ",",
			"coda": "scripts.coda",
			"segno": "scripts.segno"
		};

		var hasOne = false;
		for (var i=0;i<decoration.length; i++) {
			switch(decoration[i]) {
				case "0":
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "D.C.":
				case "D.S.":
					textDecoration(decoration[i], positioning);
					hasOne = true;
					break;
				case "fine":
					textDecoration("FINE", positioning);
					hasOne = true;
					break;
				case "+":
				case "open":
				case "snap":
				case "wedge":
				case "thumb":
				case "shortphrase":
				case "mediumphrase":
				case "longphrase":
				case "trill":
				case "roll":
				case "irishroll":
				case "marcato":
				case "dmarcato":
				case "turn":
				case "uppermordent":
				case "pralltriller":
				case "mordent":
				case "lowermordent":
				case "downbow":
				case "upbow":
				case "fermata":
				case "breath":
				case "umarcato":
				case "coda":
				case "segno":
					symbolDecoration(symbolList[decoration[i]], positioning);
					hasOne = true;
					break;
				case "invertedfermata":
					symbolDecoration(symbolList[decoration[i]], 'below');
					hasOne = true;
					break;
				case "mark":
					abselem.klass = "mark";
					break;
			}
		}
		return hasOne;
	};

	function leftDecoration(decoration, abselem, roomtaken) {
		for (var i=0;i<decoration.length; i++) {
			switch (decoration[i]) {
				case "arpeggio":
					// The arpeggio symbol is the height of a note (that is, two Y units). This stacks as many as we need to go from the
					// top note to the bottom note. The arpeggio should also be a little taller than the stacked notes, so there is an extra
					// one drawn and it is offset by half of a note height (that is, one Y unit).
					for (var j = abselem.abcelem.minpitch - 1; j <= abselem.abcelem.maxpitch; j += 2) {
						abselem.addExtra(
							new RelativeElement(
								"scripts.arpeggio",
								-glyphs.getSymbolWidth("scripts.arpeggio")*2 - roomtaken,
								0,
								j+2,
								{klass: 'ornament', thickness: glyphs.symbolHeightInPitches("scripts.arpeggio")}
							)
						);
					}
					break;
			}
		}
	}

	Decoration.prototype.dynamicDecoration = function(voice, decoration, abselem, positioning) {
		var diminuendo;
		var crescendo;
		for (var i=0;i<decoration.length; i++) {
			switch(decoration[i]) {
				case "diminuendo(":
					this.startDiminuendoX = abselem;
					diminuendo = undefined;
					break;
				case "diminuendo)":
					diminuendo = { start: this.startDiminuendoX, stop: abselem};
					this.startDiminuendoX = undefined;
					break;
				case "crescendo(":
					this.startCrescendoX = abselem;
					crescendo = undefined;
					break;
				case "crescendo)":
					crescendo = { start: this.startCrescendoX, stop: abselem};
					this.startCrescendoX = undefined;
					break;
			}
		}
		if (diminuendo) {
			voice.addOther(new CrescendoElem(diminuendo.start, diminuendo.stop, ">", positioning));
		}
		if (crescendo) {
			voice.addOther(new CrescendoElem(crescendo.start, crescendo.stop, "<", positioning));
		}
	};

	Decoration.prototype.createDecoration = function(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch, positioning, hasVocals) {
		if (!positioning)
			positioning = { ornamentPosition: 'above', volumePosition: hasVocals ? 'above' :'below', dynamicPosition: hasVocals ? 'above' : 'below' };
		// These decorations don't affect the placement of other decorations
		volumeDecoration(voice, decoration, abselem, positioning.volumePosition);
		this.dynamicDecoration(voice, decoration, abselem, positioning.dynamicPosition);
		compoundDecoration(decoration, pitch, width, abselem, dir);

		// treat staccato, accent, and tenuto first (may need to shift other markers)
		var yPos = closeDecoration(voice, decoration, pitch, width, abselem, roomtaken, dir, minPitch);
		// yPos is an object containing 'above' and 'below'. That is the placement of the next symbol on either side.

		yPos.above = Math.max(yPos.above, this.minTop);
		var hasOne = stackedDecoration(decoration, width, abselem, yPos, positioning.ornamentPosition, this.minTop, this.minBottom);
		if (hasOne) {
//			abselem.top = Math.max(yPos.above + 3, abselem.top); // TODO-PER: Not sure why we need this fudge factor.
		}
		leftDecoration(decoration, abselem, roomtaken);
	};

})();

module.exports = Decoration;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_dynamic_decoration.js":
/*!****************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_dynamic_decoration.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_dynamic_decoration.js: Definition of the DynamicDecoration class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

var DynamicDecoration = function DynamicDecoration(anchor, dec, position) {
	this.anchor = anchor;
	this.dec = dec;
	if (position === 'below')
		this.volumeHeightBelow = 5;
	else
		this.volumeHeightAbove = 5;
	this.pitch = undefined; // This will be set later
};

DynamicDecoration.prototype.setUpperAndLowerElements = function(positionY) {
	if (this.volumeHeightAbove)
		this.pitch = positionY.volumeHeightAbove;
	else
		this.pitch = positionY.volumeHeightBelow;
};

DynamicDecoration.prototype.draw = function(renderer, linestartx, lineendx) {
	if (this.pitch === undefined)
		window.console.error("Dynamic Element y-coordinate not set.");
	var scalex = 1;
	var scaley = 1;
	renderer.printSymbol(this.anchor.x, this.pitch, this.dec, scalex, scaley, renderer.addClasses('decoration'));
};

module.exports = DynamicDecoration;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_ending_element.js":
/*!************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_ending_element.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_ending_element.js: Definition of the EndingElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/abcjs/src/write/sprintf.js");

var EndingElem = function EndingElem(text, anchor1, anchor2) {
	this.text = text; // text to be displayed top left
	this.anchor1 = anchor1; // must have a .x property or be null (means starts at the "beginning" of the line - after keysig)
	this.anchor2 = anchor2; // must have a .x property or be null (means ends at the end of the line)
	this.endingHeightAbove = 5;
	this.pitch = undefined; // This will be set later
};

EndingElem.prototype.setUpperAndLowerElements = function(positionY) {
	this.pitch = positionY.endingHeightAbove - 2;
};

EndingElem.prototype.draw = function (renderer, linestartx, lineendx) {
	if (this.pitch === undefined)
		window.console.error("Ending Element y-coordinate not set.");
	var y = renderer.calcY(this.pitch);
	var height = 20;
	var pathString;
	if (this.anchor1) {
		linestartx = this.anchor1.x+this.anchor1.w;
		pathString = sprintf("M %f %f L %f %f",
			linestartx, y, linestartx, y+height);
		renderer.printPath({path:pathString, stroke:"#000000", fill:"#000000", 'class': renderer.addClasses('ending')});
		renderer.renderText(linestartx+5, renderer.calcY(this.pitch-0.5), this.text, 'repeatfont', 'ending',"start");
	}

	if (this.anchor2) {
		lineendx = this.anchor2.x;
		pathString = sprintf("M %f %f L %f %f",
			lineendx, y, lineendx, y+height);
		renderer.printPath({path:pathString, stroke:"#000000", fill:"#000000", 'class': renderer.addClasses('ending')});
	}


	pathString = sprintf("M %f %f L %f %f",
		linestartx, y, lineendx, y);
	renderer.printPath({path:pathString, stroke:"#000000", fill:"#000000", 'class': renderer.addClasses('ending')});
};

module.exports = EndingElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_engraver_controller.js":
/*!*****************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_engraver_controller.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_engraver_controller.js: Controls the engraving process of an ABCJS abstract syntax tree as produced by ABCJS/parse
//    Copyright (C) 2014-2018 Gregory Dyke (gregdyke at gmail dot com)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


/*global Math */

var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");
var AbstractEngraver = __webpack_require__(/*! ./abc_abstract_engraver */ "./node_modules/abcjs/src/write/abc_abstract_engraver.js");
var Renderer = __webpack_require__(/*! ./abc_renderer */ "./node_modules/abcjs/src/write/abc_renderer.js");

/**
 * @class
 * Controls the engraving process, from ABCJS Abstract Syntax Tree (ABCJS AST) to rendered score sheet
 *
 * Call engraveABC to run the process. This creates a graphelems ABCJS Abstract Engraving Structure (ABCJS AES) that can be accessed through this.staffgroups
 * this data structure is first laid out (giving the graphelems x and y coordinates) and then drawn onto the renderer
 * each ABCJS AES represents a single staffgroup - all elements that are not in a staffgroup are rendered directly by the controller
 *
 * elements in ABCJS AES know their "source data" in the ABCJS AST, and their "target shape"
 * in the renderer for highlighting purposes
 *
 * @param {Object} paper div element that will wrap the SVG
 * @param {Object} params all the params -- documented on github //TODO-GD move some of that documentation here
 */
var EngraverController = function(paper, params) {
  params = params || {};
  this.responsive = params.responsive;
  this.space = 3*spacing.SPACE;
  this.scale = params.scale ? parseFloat(params.scale) : 0;
  if (!(this.scale > 0.1))
  	this.scale = undefined;

	if (params.staffwidth) {
		// Note: Normally all measurements to the engraver are in POINTS. However, if a person is formatting for the
		// screen and directly inputting the width, then it is more logical to have the measurement in pixels.
		this.staffwidthScreen = params.staffwidth;
		this.staffwidthPrint = params.staffwidth;
	} else {
		this.staffwidthScreen = 740; // TODO-PER: Not sure where this number comes from, but this is how it's always been.
		this.staffwidthPrint = 680; // The number of pixels in 8.5", after 1cm of margin has been removed.
	}
  this.editable = params.editable || false;
	this.listeners = [];
	if (params.clickListener)
		this.addSelectListener(params.clickListener);

  this.renderer=new Renderer(paper, params.regression, params.add_classes);
	this.renderer.setPaddingOverride(params);
  this.renderer.controller = this; // TODO-GD needed for highlighting

	this.reset();
};

EngraverController.prototype.reset = function() {
	this.selected = [];
	this.ingroup = false;
	this.staffgroups = [];
	this.lastStaffGroupIndex = -1;
	if (this.engraver)
		this.engraver.reset();
	this.engraver = null;
	this.renderer.reset();
};

/**
 * run the engraving process
 * @param {ABCJS.Tune|ABCJS.Tune[]} abctunes
 */
EngraverController.prototype.engraveABC = function(abctunes, tuneNumber) {
  if (abctunes[0]===undefined) {
    abctunes = [abctunes];
  }
	this.reset();

  for (var i = 0; i < abctunes.length; i++) {
  	if (tuneNumber === undefined)
  		tuneNumber = i;
    this.engraveTune(abctunes[i], tuneNumber);
  }
	if (this.renderer.doRegression)
		return this.renderer.regressionLines.join("\n");
};

/**
 * Some of the items on the page are not scaled, so adjust them in the opposite direction of scaling to cancel out the scaling.
 * @param {float} scale
 */
EngraverController.prototype.adjustNonScaledItems = function (scale) {
	this.width /= scale;
	this.renderer.adjustNonScaledItems(scale);
};

EngraverController.prototype.getMeasureWidths = function(abcTune) {
	this.reset();

	this.renderer.lineNumber = null;

	this.renderer.newTune(abcTune);
	this.engraver = new AbstractEngraver(this.renderer, 0, { bagpipes: abcTune.formatting.bagpipes, flatbeams: abcTune.formatting.flatbeams });
	this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
	if (abcTune.formatting.staffwidth) {
		this.width = abcTune.formatting.staffwidth * 1.33; // The width is expressed in pt; convert to px.
	} else {
		this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
	}

	var scale = abcTune.formatting.scale ? abcTune.formatting.scale : this.scale;
	if (this.responsive === "resize") // The resizing will mess with the scaling, so just don't do it explicitly.
		scale = undefined;
	if (scale === undefined) scale = this.renderer.isPrint ? 0.75 : 1;
	this.adjustNonScaledItems(scale);

	var ret = { left: 0, measureWidths: [], height: 0, total: 0 };
	// TODO-PER: need to add the height of the title block, too.
	ret.height = this.renderer.padding.top + this.renderer.spacing.music + this.renderer.padding.bottom + 24; // the 24 is the empirical value added to the bottom of all tunes.
	var debug = false;
	var hasPrintedTempo = false;
	for(var i=0; i<abcTune.lines.length; i++) {
		var abcLine = abcTune.lines[i];
		if (abcLine.staff) {
			abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abcTune.metaText.tempo: null);

			abcLine.staffGroup.layout(0, this.renderer, debug);
			// At this point, the voices are laid out so that the bar lines are even with each other. So we just need to get the placement of the first voice.
			if (abcLine.staffGroup.voices.length > 0) {
				var voice = abcLine.staffGroup.voices[0];
				var foundNotStaffExtra = false;
				var lastXPosition = 0;
				for (var k = 0; k < voice.children.length; k++) {
					var child = voice.children[k];
					if (!foundNotStaffExtra && !child.isClef && !child.isKeySig) {
						foundNotStaffExtra = true;
						ret.left = child.x;
						lastXPosition = child.x;
					}
					if (child.type === 'bar') {
						ret.measureWidths.push(child.x - lastXPosition);
						ret.total += (child.x - lastXPosition);
						lastXPosition = child.x;
					}
				}
			}
			hasPrintedTempo = true;
			ret.height += abcLine.staffGroup.calcHeight() * spacing.STEP;
		}
	}
	return ret;
};

/**
 * Run the engraving process on a single tune
 * @param {ABCJS.Tune} abctune
 */
EngraverController.prototype.engraveTune = function (abctune, tuneNumber) {
	this.renderer.lineNumber = null;

	this.renderer.newTune(abctune);
	this.engraver = new AbstractEngraver(this.renderer, tuneNumber, { bagpipes: abctune.formatting.bagpipes, flatbeams: abctune.formatting.flatbeams });
	this.engraver.setStemHeight(this.renderer.spacing.stemHeight);
	this.engraver.measureLength = abctune.getMeterFraction().num/abctune.getMeterFraction().den;
	if (abctune.formatting.staffwidth) {
		this.width = abctune.formatting.staffwidth * 1.33; // The width is expressed in pt; convert to px.
	} else {
		this.width = this.renderer.isPrint ? this.staffwidthPrint : this.staffwidthScreen;
	}

	var scale = abctune.formatting.scale ? abctune.formatting.scale : this.scale;
	if (this.responsive === "resize") // The resizing will mess with the scaling, so just don't do it explicitly.
		scale = undefined;
	if (scale === undefined) scale = this.renderer.isPrint ? 0.75 : 1;
	this.adjustNonScaledItems(scale);

	// Generate the raw staff line data
	var i;
	var abcLine;
	var hasPrintedTempo = false;
	for(i=0; i<abctune.lines.length; i++) {
		abcLine = abctune.lines[i];
		if (abcLine.staff) {
			abcLine.staffGroup = this.engraver.createABCLine(abcLine.staff, !hasPrintedTempo ? abctune.metaText.tempo: null);
			hasPrintedTempo = true;
		}
	}

	// Adjust the x-coordinates to their absolute positions
	var maxWidth = this.width;
	for(i=0; i<abctune.lines.length; i++) {
		abcLine = abctune.lines[i];
		if (abcLine.staff) {
			this.setXSpacing(abcLine.staffGroup, abctune.formatting, i === abctune.lines.length - 1, false);
			if (abcLine.staffGroup.w > maxWidth) maxWidth = abcLine.staffGroup.w;
		}
	}

	// Layout the beams and add the stems to the beamed notes.
	for(i=0; i<abctune.lines.length; i++) {
		abcLine = abctune.lines[i];
		if (abcLine.staffGroup && abcLine.staffGroup.voices) {
			for (var j = 0; j < abcLine.staffGroup.voices.length; j++)
				abcLine.staffGroup.voices[j].layoutBeams();
			abcLine.staffGroup.setUpperAndLowerElements(this.renderer);
		}
	}

	// Set the staff spacing
	// TODO-PER: we should have been able to do this by the time we called setUpperAndLowerElements, but for some reason the "bottom" element seems to be set as a side effect of setting the X spacing.
	for(i=0; i<abctune.lines.length; i++) {
		abcLine = abctune.lines[i];
		if (abcLine.staffGroup) {
			abcLine.staffGroup.height = abcLine.staffGroup.calcHeight();
		}
	}

	// Do all the writing to output
	this.renderer.topMargin(abctune);
	//this.renderer.printHorizontalLine(this.width + this.renderer.padding.left + this.renderer.padding.right);
	this.renderer.engraveTopText(this.width, abctune);
	this.renderer.addMusicPadding();

	this.staffgroups = [];
	this.lastStaffGroupIndex = -1;
	for (var line = 0; line < abctune.lines.length; line++) {
		this.renderer.lineNumber = line;
		abcLine = abctune.lines[line];
		if (abcLine.staff) {
			this.engraveStaffLine(abcLine.staffGroup);
		} else if (abcLine.subtitle && line !== 0) {
			this.renderer.outputSubtitle(this.width, abcLine.subtitle);
		} else if (abcLine.text !== undefined) {
			this.renderer.outputFreeText(abcLine.text, abcLine.vskip);
		} else if (abcLine.separator !== undefined) {
			this.renderer.outputSeparator(abcLine.separator);
		}
	}

	this.renderer.moveY(24); // TODO-PER: Empirically discovered. What variable should this be?
	this.renderer.engraveExtraText(this.width, abctune);
	this.renderer.setPaperSize(maxWidth, scale, this.responsive);
};

function calcHorizontalSpacing(isLastLine, stretchLast, targetWidth, lineWidth, spacing, spacingUnits, minSpace) {
	// TODO-PER: This used to stretch the first line when it is the only line, but I'm not sure why. abcm2ps doesn't do that
	if (isLastLine && lineWidth / targetWidth < 0.66 && !stretchLast) return null; // don't stretch last line too much
	if (Math.abs(targetWidth-lineWidth) < 2) return null; // if we are already near the target width, we're done.
	var relSpace = spacingUnits * spacing;
	var constSpace = lineWidth - relSpace;
	if (spacingUnits > 0) {
		spacing = (targetWidth - constSpace) / spacingUnits;
		if (spacing * minSpace > 50) {
			spacing = 50 / minSpace;
		}
		return spacing;
	}
	return null;
}

/**
 * Do the x-axis positioning for a single line (a group of related staffs)
 * @param {ABCJS.Tune} abctune an ABCJS AST
 * @param {Object} staffGroup an staffGroup
 * @param {Object} formatting an formatting
 * @param {boolean} isLastLine is this the last line to be printed?
 * @private
 */
EngraverController.prototype.setXSpacing = function (staffGroup, formatting, isLastLine, debug) {
   var newspace = this.space;
  for (var it = 0; it < 8; it++) { // TODO-PER: shouldn't need multiple passes, but each pass gets it closer to the right spacing. (Only affects long lines: normal lines break out of this loop quickly.)
	  var ret = staffGroup.layout(newspace, this.renderer, debug);
	  var stretchLast = formatting.stretchlast ? formatting.stretchlast : false;
		newspace = calcHorizontalSpacing(isLastLine, stretchLast, this.width+this.renderer.padding.left, staffGroup.w, newspace, ret.spacingUnits, ret.minSpace);
		if (debug)
			console.log("setXSpace", it, staffGroup.w, newspace, staffGroup.minspace);
		if (newspace === null) break;
  }
	centerWholeRests(staffGroup.voices);
	//this.renderer.printHorizontalLine(this.width);
};

/**
 * Engrave a single line (a group of related staffs)
 * @param {ABCJS.Tune} abctune an ABCJS AST
 * @param {Object} staffGroup an staffGroup
 * @private
 */
EngraverController.prototype.engraveStaffLine = function (staffGroup) {
	if (this.lastStaffGroupIndex > -1)
		this.renderer.addStaffPadding(this.staffgroups[this.lastStaffGroupIndex], staffGroup);
	this.renderer.voiceNumber = null;
	staffGroup.draw(this.renderer);
	var height = staffGroup.height * spacing.STEP;
	//this.renderer.printVerticalLine(this.width+this.renderer.padding.left, this.renderer.y, this.renderer.y+height);
  this.staffgroups[this.staffgroups.length] = staffGroup;
	this.lastStaffGroupIndex = this.staffgroups.length-1;
	this.renderer.y += height;
};

/**
 * Called by the Abstract Engraving Structure or any other (e.g. midi playback) to say it was selected (notehead clicked on)
 * @protected
 */
EngraverController.prototype.notifySelect = function (abselem, tuneNumber, classes) {
  this.clearSelection();
  if (abselem.highlight) {
    this.selected = [abselem];
    abselem.highlight();
  }
  var abcelem = abselem.abcelem || {};
  for (var i=0; i<this.listeners.length;i++) {
	  this.listeners[i](abcelem, tuneNumber, classes);
  }
};

/**
 * Called by the Abstract Engraving Structure to say it was modified (e.g. notehead dragged)
 * @protected
 */
// EngraverController.prototype.notifyChange = function (/*abselem*/) {
//   for (var i=0; i<this.listeners.length;i++) {
//     if (this.listeners[i].modelChanged)
//       this.listeners[i].modelChanged();
//   }
// };

/**
 *
 * @private
 */
EngraverController.prototype.clearSelection = function () {
  for (var i=0;i<this.selected.length;i++) {
    this.selected[i].unhighlight();
  }
  this.selected = [];
};

/**
 * @param {Object} listener
 * @param {Function} listener.modelChanged the model the listener passed to this controller has changed
 * @param {Function} listener.highlight the abcelem of the model the listener passed to this controller should be highlighted
 */
EngraverController.prototype.addSelectListener = function (clickListener) {
  this.listeners[this.listeners.length] = clickListener;
};

/**
 * Tell the controller to highlight some noteheads of its engraved score
 * @param {number} start the character in the source abc where highlighting should start
 * @param {number} end the character in the source abc where highlighting should end
 */
EngraverController.prototype.rangeHighlight = function(start,end)
{
    this.clearSelection();
    for (var line=0;line<this.staffgroups.length; line++) {
	var voices = this.staffgroups[line].voices;
	for (var voice=0;voice<voices.length;voice++) {
	    var elems = voices[voice].children;
	    for (var elem=0; elem<elems.length; elem++) {
		// Since the user can highlight more than an element, or part of an element, a hit is if any of the endpoints
		// is inside the other range.
		var elStart = elems[elem].abcelem.startChar;
		var elEnd = elems[elem].abcelem.endChar;
		if ((end>elStart && start<elEnd) || ((end===start) && end===elEnd)) {
		    //		if (elems[elem].abcelem.startChar>=start && elems[elem].abcelem.endChar<=end) {
		    this.selected[this.selected.length]=elems[elem];
		    elems[elem].highlight();
		}
	    }
	}
    }
};


function centerWholeRests(voices) {
	// whole rests are a special case: if they are by themselves in a measure, then they should be centered.
	// (If they are not by themselves, that is probably a user error, but we'll just center it between the two items to either side of it.)
	for (var i = 0; i < voices.length; i++) {
		var voice = voices[i];
		// Look through all of the elements except for the first and last. If the whole note appears there then there isn't anything to center it between anyway.
		for (var j = 1; j < voice.children.length-1; j++) {
			var absElem = voice.children[j];
			if (absElem.abcelem.rest && (absElem.abcelem.rest.type === 'whole' || absElem.abcelem.rest.type === 'multimeasure')) {
				var before = voice.children[j-1];
				var after = voice.children[j+1];
				var midpoint = (after.x - before.x) / 2 + before.x;
				absElem.x = midpoint - absElem.w / 2;
				for (var k = 0; k < absElem.children.length; k++)
					absElem.children[k].x = absElem.x;
			}
		}
	}
}

module.exports = EngraverController;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_glyphs.js":
/*!****************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_glyphs.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

/**
 * Glyphs and some methods to adjust for their x and y baseline
 */
	var glyphs =
	{'0':{d:[['M',4.83,-14.97],['c',0.33,-0.03,1.11,0.00,1.47,0.06],['c',1.68,0.36,2.97,1.59,3.78,3.60],['c',1.20,2.97,0.81,6.96,-0.90,9.27],['c',-0.78,1.08,-1.71,1.71,-2.91,1.95],['c',-0.45,0.09,-1.32,0.09,-1.77,0.00],['c',-0.81,-0.18,-1.47,-0.51,-2.07,-1.02],['c',-2.34,-2.07,-3.15,-6.72,-1.74,-10.20],['c',0.87,-2.16,2.28,-3.42,4.14,-3.66],['z'],['m',1.11,0.87],['c',-0.21,-0.06,-0.69,-0.09,-0.87,-0.06],['c',-0.54,0.12,-0.87,0.42,-1.17,0.99],['c',-0.36,0.66,-0.51,1.56,-0.60,3.00],['c',-0.03,0.75,-0.03,4.59,0.00,5.31],['c',0.09,1.50,0.27,2.40,0.60,3.06],['c',0.24,0.48,0.57,0.78,0.96,0.90],['c',0.27,0.09,0.78,0.09,1.05,0.00],['c',0.39,-0.12,0.72,-0.42,0.96,-0.90],['c',0.33,-0.66,0.51,-1.56,0.60,-3.06],['c',0.03,-0.72,0.03,-4.56,0.00,-5.31],['c',-0.09,-1.47,-0.27,-2.37,-0.60,-3.03],['c',-0.24,-0.48,-0.54,-0.78,-0.93,-0.90],['z']],w:10.78,h:14.959},
		'1':{d:[['M',3.30,-15.06],['c',0.06,-0.06,0.21,-0.03,0.66,0.15],['c',0.81,0.39,1.08,0.39,1.83,0.03],['c',0.21,-0.09,0.39,-0.15,0.42,-0.15],['c',0.12,0.00,0.21,0.09,0.27,0.21],['c',0.06,0.12,0.06,0.33,0.06,5.94],['c',0.00,3.93,0.00,5.85,0.03,6.03],['c',0.06,0.36,0.15,0.69,0.27,0.96],['c',0.36,0.75,0.93,1.17,1.68,1.26],['c',0.30,0.03,0.39,0.09,0.39,0.30],['c',0.00,0.15,-0.03,0.18,-0.09,0.24],['c',-0.06,0.06,-0.09,0.06,-0.48,0.06],['c',-0.42,0.00,-0.69,-0.03,-2.10,-0.24],['c',-0.90,-0.15,-1.77,-0.15,-2.67,0.00],['c',-1.41,0.21,-1.68,0.24,-2.10,0.24],['c',-0.39,0.00,-0.42,0.00,-0.48,-0.06],['c',-0.06,-0.06,-0.06,-0.09,-0.06,-0.24],['c',0.00,-0.21,0.06,-0.27,0.36,-0.30],['c',0.75,-0.09,1.32,-0.51,1.68,-1.26],['c',0.12,-0.27,0.21,-0.60,0.27,-0.96],['c',0.03,-0.18,0.03,-1.59,0.03,-4.29],['c',0.00,-3.87,0.00,-4.05,-0.06,-4.14],['c',-0.09,-0.15,-0.18,-0.24,-0.39,-0.24],['c',-0.12,0.00,-0.15,0.03,-0.21,0.06],['c',-0.03,0.06,-0.45,0.99,-0.96,2.13],['c',-0.48,1.14,-0.90,2.10,-0.93,2.16],['c',-0.06,0.15,-0.21,0.24,-0.33,0.24],['c',-0.24,0.00,-0.42,-0.18,-0.42,-0.39],['c',0.00,-0.06,3.27,-7.62,3.33,-7.74],['z']],w:8.94,h:15.058},
		'2':{d:[['M',4.23,-14.97],['c',0.57,-0.06,1.68,0.00,2.34,0.18],['c',0.69,0.18,1.50,0.54,2.01,0.90],['c',1.35,0.96,1.95,2.25,1.77,3.81],['c',-0.15,1.35,-0.66,2.34,-1.68,3.15],['c',-0.60,0.48,-1.44,0.93,-3.12,1.65],['c',-1.32,0.57,-1.80,0.81,-2.37,1.14],['c',-0.57,0.33,-0.57,0.33,-0.24,0.27],['c',0.39,-0.09,1.26,-0.09,1.68,0.00],['c',0.72,0.15,1.41,0.45,2.10,0.90],['c',0.99,0.63,1.86,0.87,2.55,0.75],['c',0.24,-0.06,0.42,-0.15,0.57,-0.30],['c',0.12,-0.09,0.30,-0.42,0.30,-0.51],['c',0.00,-0.09,0.12,-0.21,0.24,-0.24],['c',0.18,-0.03,0.39,0.12,0.39,0.30],['c',0.00,0.12,-0.15,0.57,-0.30,0.87],['c',-0.54,1.02,-1.56,1.74,-2.79,2.01],['c',-0.42,0.09,-1.23,0.09,-1.62,0.03],['c',-0.81,-0.18,-1.32,-0.45,-2.01,-1.11],['c',-0.45,-0.45,-0.63,-0.57,-0.96,-0.69],['c',-0.84,-0.27,-1.89,0.12,-2.25,0.90],['c',-0.12,0.21,-0.21,0.54,-0.21,0.72],['c',0.00,0.12,-0.12,0.21,-0.27,0.24],['c',-0.15,0.00,-0.27,-0.03,-0.33,-0.15],['c',-0.09,-0.21,0.09,-1.08,0.33,-1.71],['c',0.24,-0.66,0.66,-1.26,1.29,-1.89],['c',0.45,-0.45,0.90,-0.81,1.92,-1.56],['c',1.29,-0.93,1.89,-1.44,2.34,-1.98],['c',0.87,-1.05,1.26,-2.19,1.20,-3.63],['c',-0.06,-1.29,-0.39,-2.31,-0.96,-2.91],['c',-0.36,-0.33,-0.72,-0.51,-1.17,-0.54],['c',-0.84,-0.03,-1.53,0.42,-1.59,1.05],['c',-0.03,0.33,0.12,0.60,0.57,1.14],['c',0.45,0.54,0.54,0.87,0.42,1.41],['c',-0.15,0.63,-0.54,1.11,-1.08,1.38],['c',-0.63,0.33,-1.20,0.33,-1.83,0.00],['c',-0.24,-0.12,-0.33,-0.18,-0.54,-0.39],['c',-0.18,-0.18,-0.27,-0.30,-0.36,-0.51],['c',-0.24,-0.45,-0.27,-0.84,-0.21,-1.38],['c',0.12,-0.75,0.45,-1.41,1.02,-1.98],['c',0.72,-0.72,1.74,-1.17,2.85,-1.32],['z']],w:10.764,h:14.97},
		'3':{d:[['M',3.78,-14.97],['c',0.30,-0.03,1.41,0.00,1.83,0.06],['c',2.22,0.30,3.51,1.32,3.72,2.91],['c',0.03,0.33,0.03,1.26,-0.03,1.65],['c',-0.12,0.84,-0.48,1.47,-1.05,1.77],['c',-0.27,0.15,-0.36,0.24,-0.45,0.39],['c',-0.09,0.21,-0.09,0.36,0.00,0.57],['c',0.09,0.15,0.18,0.24,0.51,0.39],['c',0.75,0.42,1.23,1.14,1.41,2.13],['c',0.06,0.42,0.06,1.35,0.00,1.71],['c',-0.18,0.81,-0.48,1.38,-1.02,1.95],['c',-0.75,0.72,-1.80,1.20,-3.18,1.38],['c',-0.42,0.06,-1.56,0.06,-1.95,0.00],['c',-1.89,-0.33,-3.18,-1.29,-3.51,-2.64],['c',-0.03,-0.12,-0.03,-0.33,-0.03,-0.60],['c',0.00,-0.36,0.00,-0.42,0.06,-0.63],['c',0.12,-0.30,0.27,-0.51,0.51,-0.75],['c',0.24,-0.24,0.45,-0.39,0.75,-0.51],['c',0.21,-0.06,0.27,-0.06,0.60,-0.06],['c',0.33,0.00,0.39,0.00,0.60,0.06],['c',0.30,0.12,0.51,0.27,0.75,0.51],['c',0.36,0.33,0.57,0.75,0.60,1.20],['c',0.00,0.21,0.00,0.27,-0.06,0.42],['c',-0.09,0.18,-0.12,0.24,-0.54,0.54],['c',-0.51,0.36,-0.63,0.54,-0.60,0.87],['c',0.06,0.54,0.54,0.90,1.38,0.99],['c',0.36,0.06,0.72,0.03,0.96,-0.06],['c',0.81,-0.27,1.29,-1.23,1.44,-2.79],['c',0.03,-0.45,0.03,-1.95,-0.03,-2.37],['c',-0.09,-0.75,-0.33,-1.23,-0.75,-1.44],['c',-0.33,-0.18,-0.45,-0.18,-1.98,-0.18],['c',-1.35,0.00,-1.41,0.00,-1.50,-0.06],['c',-0.18,-0.12,-0.24,-0.39,-0.12,-0.60],['c',0.12,-0.15,0.15,-0.15,1.68,-0.15],['c',1.50,0.00,1.62,0.00,1.89,-0.15],['c',0.18,-0.09,0.42,-0.36,0.54,-0.57],['c',0.18,-0.42,0.27,-0.90,0.30,-1.95],['c',0.03,-1.20,-0.06,-1.80,-0.36,-2.37],['c',-0.24,-0.48,-0.63,-0.81,-1.14,-0.96],['c',-0.30,-0.06,-1.08,-0.06,-1.38,0.03],['c',-0.60,0.15,-0.90,0.42,-0.96,0.84],['c',-0.03,0.30,0.06,0.45,0.63,0.84],['c',0.33,0.24,0.42,0.39,0.45,0.63],['c',0.03,0.72,-0.57,1.50,-1.32,1.65],['c',-1.05,0.27,-2.10,-0.57,-2.10,-1.65],['c',0.00,-0.45,0.15,-0.96,0.39,-1.38],['c',0.12,-0.21,0.54,-0.63,0.81,-0.81],['c',0.57,-0.42,1.38,-0.69,2.25,-0.81],['z']],w:9.735,h:14.967},
		'4':{d:[['M',8.64,-14.94],['c',0.27,-0.09,0.42,-0.12,0.54,-0.03],['c',0.09,0.06,0.15,0.21,0.15,0.30],['c',-0.03,0.06,-1.92,2.31,-4.23,5.04],['c',-2.31,2.73,-4.23,4.98,-4.26,5.01],['c',-0.03,0.06,0.12,0.06,2.55,0.06],['l',2.61,0.00],['l',0.00,-2.37],['c',0.00,-2.19,0.03,-2.37,0.06,-2.46],['c',0.03,-0.06,0.21,-0.18,0.57,-0.42],['c',1.08,-0.72,1.38,-1.08,1.86,-2.16],['c',0.12,-0.30,0.24,-0.54,0.27,-0.57],['c',0.12,-0.12,0.39,-0.06,0.45,0.12],['c',0.06,0.09,0.06,0.57,0.06,3.96],['l',0.00,3.90],['l',1.08,0.00],['c',1.05,0.00,1.11,0.00,1.20,0.06],['c',0.24,0.15,0.24,0.54,0.00,0.69],['c',-0.09,0.06,-0.15,0.06,-1.20,0.06],['l',-1.08,0.00],['l',0.00,0.33],['c',0.00,0.57,0.09,1.11,0.30,1.53],['c',0.36,0.75,0.93,1.17,1.68,1.26],['c',0.30,0.03,0.39,0.09,0.39,0.30],['c',0.00,0.15,-0.03,0.18,-0.09,0.24],['c',-0.06,0.06,-0.09,0.06,-0.48,0.06],['c',-0.42,0.00,-0.69,-0.03,-2.10,-0.24],['c',-0.90,-0.15,-1.77,-0.15,-2.67,0.00],['c',-1.41,0.21,-1.68,0.24,-2.10,0.24],['c',-0.39,0.00,-0.42,0.00,-0.48,-0.06],['c',-0.06,-0.06,-0.06,-0.09,-0.06,-0.24],['c',0.00,-0.21,0.06,-0.27,0.36,-0.30],['c',0.75,-0.09,1.32,-0.51,1.68,-1.26],['c',0.21,-0.42,0.30,-0.96,0.30,-1.53],['l',0.00,-0.33],['l',-2.70,0.00],['c',-2.91,0.00,-2.85,0.00,-3.09,-0.15],['c',-0.18,-0.12,-0.30,-0.39,-0.27,-0.54],['c',0.03,-0.06,0.18,-0.24,0.33,-0.45],['c',0.75,-0.90,1.59,-2.07,2.13,-3.03],['c',0.33,-0.54,0.84,-1.62,1.05,-2.16],['c',0.57,-1.41,0.84,-2.64,0.90,-4.05],['c',0.03,-0.63,0.06,-0.72,0.24,-0.81],['l',0.12,-0.06],['l',0.45,0.12],['c',0.66,0.18,1.02,0.24,1.47,0.27],['c',0.60,0.03,1.23,-0.09,2.01,-0.33],['z']],w:11.795,h:14.994},
		'5':{d:[['M',1.02,-14.94],['c',0.12,-0.09,0.03,-0.09,1.08,0.06],['c',2.49,0.36,4.35,0.36,6.96,-0.06],['c',0.57,-0.09,0.66,-0.06,0.81,0.06],['c',0.15,0.18,0.12,0.24,-0.15,0.51],['c',-1.29,1.26,-3.24,2.04,-5.58,2.31],['c',-0.60,0.09,-1.20,0.12,-1.71,0.12],['c',-0.39,0.00,-0.45,0.00,-0.57,0.06],['c',-0.09,0.06,-0.15,0.12,-0.21,0.21],['l',-0.06,0.12],['l',0.00,1.65],['l',0.00,1.65],['l',0.21,-0.21],['c',0.66,-0.57,1.41,-0.96,2.19,-1.14],['c',0.33,-0.06,1.41,-0.06,1.95,0.00],['c',2.61,0.36,4.02,1.74,4.26,4.14],['c',0.03,0.45,0.03,1.08,-0.03,1.44],['c',-0.18,1.02,-0.78,2.01,-1.59,2.70],['c',-0.72,0.57,-1.62,1.02,-2.49,1.20],['c',-1.38,0.27,-3.03,0.06,-4.20,-0.54],['c',-1.08,-0.54,-1.71,-1.32,-1.86,-2.28],['c',-0.09,-0.69,0.09,-1.29,0.57,-1.74],['c',0.24,-0.24,0.45,-0.39,0.75,-0.51],['c',0.21,-0.06,0.27,-0.06,0.60,-0.06],['c',0.33,0.00,0.39,0.00,0.60,0.06],['c',0.30,0.12,0.51,0.27,0.75,0.51],['c',0.36,0.33,0.57,0.75,0.60,1.20],['c',0.00,0.21,0.00,0.27,-0.06,0.42],['c',-0.09,0.18,-0.12,0.24,-0.54,0.54],['c',-0.18,0.12,-0.36,0.30,-0.42,0.33],['c',-0.36,0.42,-0.18,0.99,0.36,1.26],['c',0.51,0.27,1.47,0.36,2.01,0.27],['c',0.93,-0.21,1.47,-1.17,1.65,-2.91],['c',0.06,-0.45,0.06,-1.89,0.00,-2.31],['c',-0.15,-1.20,-0.51,-2.10,-1.05,-2.55],['c',-0.21,-0.18,-0.54,-0.36,-0.81,-0.39],['c',-0.30,-0.06,-0.84,-0.03,-1.26,0.06],['c',-0.93,0.18,-1.65,0.60,-2.16,1.20],['c',-0.15,0.21,-0.27,0.30,-0.39,0.30],['c',-0.15,0.00,-0.30,-0.09,-0.36,-0.18],['c',-0.06,-0.09,-0.06,-0.15,-0.06,-3.66],['c',0.00,-3.39,0.00,-3.57,0.06,-3.66],['c',0.03,-0.06,0.09,-0.15,0.15,-0.18],['z']],w:10.212,h:14.997},
		'6':{d:[['M',4.98,-14.97],['c',0.36,-0.03,1.20,0.00,1.59,0.06],['c',0.90,0.15,1.68,0.51,2.25,1.05],['c',0.57,0.51,0.87,1.23,0.84,1.98],['c',-0.03,0.51,-0.21,0.90,-0.60,1.26],['c',-0.24,0.24,-0.45,0.39,-0.75,0.51],['c',-0.21,0.06,-0.27,0.06,-0.60,0.06],['c',-0.33,0.00,-0.39,0.00,-0.60,-0.06],['c',-0.30,-0.12,-0.51,-0.27,-0.75,-0.51],['c',-0.39,-0.36,-0.57,-0.78,-0.57,-1.26],['c',0.00,-0.27,0.00,-0.30,0.09,-0.42],['c',0.03,-0.09,0.18,-0.21,0.30,-0.30],['c',0.12,-0.09,0.30,-0.21,0.39,-0.27],['c',0.09,-0.06,0.21,-0.18,0.27,-0.24],['c',0.06,-0.12,0.09,-0.15,0.09,-0.33],['c',0.00,-0.18,-0.03,-0.24,-0.09,-0.36],['c',-0.24,-0.39,-0.75,-0.60,-1.38,-0.57],['c',-0.54,0.03,-0.90,0.18,-1.23,0.48],['c',-0.81,0.72,-1.08,2.16,-0.96,5.37],['l',0.00,0.63],['l',0.30,-0.12],['c',0.78,-0.27,1.29,-0.33,2.10,-0.27],['c',1.47,0.12,2.49,0.54,3.27,1.29],['c',0.48,0.51,0.81,1.11,0.96,1.89],['c',0.06,0.27,0.06,0.42,0.06,0.93],['c',0.00,0.54,0.00,0.69,-0.06,0.96],['c',-0.15,0.78,-0.48,1.38,-0.96,1.89],['c',-0.54,0.51,-1.17,0.87,-1.98,1.08],['c',-1.14,0.30,-2.40,0.33,-3.24,0.03],['c',-1.50,-0.48,-2.64,-1.89,-3.27,-4.02],['c',-0.36,-1.23,-0.51,-2.82,-0.42,-4.08],['c',0.30,-3.66,2.28,-6.30,4.95,-6.66],['z'],['m',0.66,7.41],['c',-0.27,-0.09,-0.81,-0.12,-1.08,-0.06],['c',-0.72,0.18,-1.08,0.69,-1.23,1.71],['c',-0.06,0.54,-0.06,3.00,0.00,3.54],['c',0.18,1.26,0.72,1.77,1.80,1.74],['c',0.39,-0.03,0.63,-0.09,0.90,-0.27],['c',0.66,-0.42,0.90,-1.32,0.90,-3.24],['c',0.00,-2.22,-0.36,-3.12,-1.29,-3.42],['z']],w:9.956,h:14.982},
		'7':{d:[['M',0.21,-14.97],['c',0.21,-0.06,0.45,0.00,0.54,0.15],['c',0.06,0.09,0.06,0.15,0.06,0.39],['c',0.00,0.24,0.00,0.33,0.06,0.42],['c',0.06,0.12,0.21,0.24,0.27,0.24],['c',0.03,0.00,0.12,-0.12,0.24,-0.21],['c',0.96,-1.20,2.58,-1.35,3.99,-0.42],['c',0.15,0.12,0.42,0.30,0.54,0.45],['c',0.48,0.39,0.81,0.57,1.29,0.60],['c',0.69,0.03,1.50,-0.30,2.13,-0.87],['c',0.09,-0.09,0.27,-0.30,0.39,-0.45],['c',0.12,-0.15,0.24,-0.27,0.30,-0.30],['c',0.18,-0.06,0.39,0.03,0.51,0.21],['c',0.06,0.18,0.06,0.24,-0.27,0.72],['c',-0.18,0.24,-0.54,0.78,-0.78,1.17],['c',-2.37,3.54,-3.54,6.27,-3.87,9.00],['c',-0.03,0.33,-0.03,0.66,-0.03,1.26],['c',0.00,0.90,0.00,1.08,0.15,1.89],['c',0.06,0.45,0.06,0.48,0.03,0.60],['c',-0.06,0.09,-0.21,0.21,-0.30,0.21],['c',-0.03,0.00,-0.27,-0.06,-0.54,-0.15],['c',-0.84,-0.27,-1.11,-0.30,-1.65,-0.30],['c',-0.57,0.00,-0.84,0.03,-1.56,0.27],['c',-0.60,0.18,-0.69,0.21,-0.81,0.15],['c',-0.12,-0.06,-0.21,-0.18,-0.21,-0.30],['c',0.00,-0.15,0.60,-1.44,1.20,-2.61],['c',1.14,-2.22,2.73,-4.68,5.10,-8.01],['c',0.21,-0.27,0.36,-0.48,0.33,-0.48],['c',0.00,0.00,-0.12,0.06,-0.27,0.12],['c',-0.54,0.30,-0.99,0.39,-1.56,0.39],['c',-0.75,0.03,-1.20,-0.18,-1.83,-0.75],['c',-0.99,-0.90,-1.83,-1.17,-2.31,-0.72],['c',-0.18,0.15,-0.36,0.51,-0.45,0.84],['c',-0.06,0.24,-0.06,0.33,-0.09,1.98],['c',0.00,1.62,-0.03,1.74,-0.06,1.80],['c',-0.15,0.24,-0.54,0.24,-0.69,0.00],['c',-0.06,-0.09,-0.06,-0.15,-0.06,-3.57],['c',0.00,-3.42,0.00,-3.48,0.06,-3.57],['c',0.03,-0.06,0.09,-0.12,0.15,-0.15],['z']],w:10.561,h:15.093},
		'8':{d:[['M',4.98,-14.97],['c',0.33,-0.03,1.02,-0.03,1.32,0.00],['c',1.32,0.12,2.49,0.60,3.21,1.32],['c',0.39,0.39,0.66,0.81,0.78,1.29],['c',0.09,0.36,0.09,1.08,0.00,1.44],['c',-0.21,0.84,-0.66,1.59,-1.59,2.55],['l',-0.30,0.30],['l',0.27,0.18],['c',1.47,0.93,2.31,2.31,2.25,3.75],['c',-0.03,0.75,-0.24,1.35,-0.63,1.95],['c',-0.45,0.66,-1.02,1.14,-1.83,1.53],['c',-1.80,0.87,-4.20,0.87,-6.00,0.03],['c',-1.62,-0.78,-2.52,-2.16,-2.46,-3.66],['c',0.06,-0.99,0.54,-1.77,1.80,-2.97],['c',0.54,-0.51,0.54,-0.54,0.48,-0.57],['c',-0.39,-0.27,-0.96,-0.78,-1.20,-1.14],['c',-0.75,-1.11,-0.87,-2.40,-0.30,-3.60],['c',0.69,-1.35,2.25,-2.25,4.20,-2.40],['z'],['m',1.53,0.69],['c',-0.42,-0.09,-1.11,-0.12,-1.38,-0.06],['c',-0.30,0.06,-0.60,0.18,-0.81,0.30],['c',-0.21,0.12,-0.60,0.51,-0.72,0.72],['c',-0.51,0.87,-0.42,1.89,0.21,2.52],['c',0.21,0.21,0.36,0.30,1.95,1.23],['c',0.96,0.54,1.74,0.99,1.77,1.02],['c',0.09,0.00,0.63,-0.60,0.99,-1.11],['c',0.21,-0.36,0.48,-0.87,0.57,-1.23],['c',0.06,-0.24,0.06,-0.36,0.06,-0.72],['c',0.00,-0.45,-0.03,-0.66,-0.15,-0.99],['c',-0.39,-0.81,-1.29,-1.44,-2.49,-1.68],['z'],['m',-1.44,8.07],['l',-1.89,-1.08],['c',-0.03,0.00,-0.18,0.15,-0.39,0.33],['c',-1.20,1.08,-1.65,1.95,-1.59,3.00],['c',0.09,1.59,1.35,2.85,3.21,3.24],['c',0.33,0.06,0.45,0.06,0.93,0.06],['c',0.63,0.00,0.81,-0.03,1.29,-0.27],['c',0.90,-0.42,1.47,-1.41,1.41,-2.40],['c',-0.06,-0.66,-0.39,-1.29,-0.90,-1.65],['c',-0.12,-0.09,-1.05,-0.63,-2.07,-1.23],['z']],w:10.926,h:14.989},
		'9':{d:[['M',4.23,-14.97],['c',0.42,-0.03,1.29,0.00,1.62,0.06],['c',0.51,0.12,0.93,0.30,1.38,0.57],['c',1.53,1.02,2.52,3.24,2.73,5.94],['c',0.18,2.55,-0.48,4.98,-1.83,6.57],['c',-1.05,1.26,-2.40,1.89,-3.93,1.83],['c',-1.23,-0.06,-2.31,-0.45,-3.03,-1.14],['c',-0.57,-0.51,-0.87,-1.23,-0.84,-1.98],['c',0.03,-0.51,0.21,-0.90,0.60,-1.26],['c',0.24,-0.24,0.45,-0.39,0.75,-0.51],['c',0.21,-0.06,0.27,-0.06,0.60,-0.06],['c',0.33,0.00,0.39,0.00,0.60,0.06],['c',0.30,0.12,0.51,0.27,0.75,0.51],['c',0.39,0.36,0.57,0.78,0.57,1.26],['c',0.00,0.27,0.00,0.30,-0.09,0.42],['c',-0.03,0.09,-0.18,0.21,-0.30,0.30],['c',-0.12,0.09,-0.30,0.21,-0.39,0.27],['c',-0.09,0.06,-0.21,0.18,-0.27,0.24],['c',-0.06,0.12,-0.06,0.15,-0.06,0.33],['c',0.00,0.18,0.00,0.24,0.06,0.36],['c',0.24,0.39,0.75,0.60,1.38,0.57],['c',0.54,-0.03,0.90,-0.18,1.23,-0.48],['c',0.81,-0.72,1.08,-2.16,0.96,-5.37],['l',0.00,-0.63],['l',-0.30,0.12],['c',-0.78,0.27,-1.29,0.33,-2.10,0.27],['c',-1.47,-0.12,-2.49,-0.54,-3.27,-1.29],['c',-0.48,-0.51,-0.81,-1.11,-0.96,-1.89],['c',-0.06,-0.27,-0.06,-0.42,-0.06,-0.96],['c',0.00,-0.51,0.00,-0.66,0.06,-0.93],['c',0.15,-0.78,0.48,-1.38,0.96,-1.89],['c',0.15,-0.12,0.33,-0.27,0.42,-0.36],['c',0.69,-0.51,1.62,-0.81,2.76,-0.93],['z'],['m',1.17,0.66],['c',-0.21,-0.06,-0.57,-0.06,-0.81,-0.03],['c',-0.78,0.12,-1.26,0.69,-1.41,1.74],['c',-0.12,0.63,-0.15,1.95,-0.09,2.79],['c',0.12,1.71,0.63,2.40,1.77,2.46],['c',1.08,0.03,1.62,-0.48,1.80,-1.74],['c',0.06,-0.54,0.06,-3.00,0.00,-3.54],['c',-0.15,-1.05,-0.51,-1.53,-1.26,-1.68],['z']],w:9.959,h:14.986},
		'rests.multimeasure':{d:[['M',0,-4],['l',0,16],['l',1,0],['l',0,-5],['l',40,0],['l',0,5],['l',1,0],['l',0,-16],['l',-1,0],['l',0,5],['l',-40,0],['l',0,-5],['z']],w:42,h:18},
		'rests.whole':{d:[['M',0.06,0.03],['l',0.09,-0.06],['l',5.46,0.00],['l',5.49,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,2.19],['l',0.00,2.19],['l',-0.06,0.09],['l',-0.09,0.06],['l',-5.49,0.00],['l',-5.46,0.00],['l',-0.09,-0.06],['l',-0.06,-0.09],['l',0.00,-2.19],['l',0.00,-2.19],['z']],w:11.25,h:4.68},
		'rests.half':{d:[['M',0.06,-4.62],['l',0.09,-0.06],['l',5.46,0.00],['l',5.49,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,2.19],['l',0.00,2.19],['l',-0.06,0.09],['l',-0.09,0.06],['l',-5.49,0.00],['l',-5.46,0.00],['l',-0.09,-0.06],['l',-0.06,-0.09],['l',0.00,-2.19],['l',0.00,-2.19],['z']],w:11.25,h:4.68},
		'rests.quarter':{d:[['M',1.89,-11.82],['c',0.12,-0.06,0.24,-0.06,0.36,-0.03],['c',0.09,0.06,4.74,5.58,4.86,5.82],['c',0.21,0.39,0.15,0.78,-0.15,1.26],['c',-0.24,0.33,-0.72,0.81,-1.62,1.56],['c',-0.45,0.36,-0.87,0.75,-0.96,0.84],['c',-0.93,0.99,-1.14,2.49,-0.60,3.63],['c',0.18,0.39,0.27,0.48,1.32,1.68],['c',1.92,2.25,1.83,2.16,1.83,2.34],['c',0.00,0.18,-0.18,0.36,-0.36,0.39],['c',-0.15,0.00,-0.27,-0.06,-0.48,-0.27],['c',-0.75,-0.75,-2.46,-1.29,-3.39,-1.08],['c',-0.45,0.09,-0.69,0.27,-0.90,0.69],['c',-0.12,0.30,-0.21,0.66,-0.24,1.14],['c',-0.03,0.66,0.09,1.35,0.30,2.01],['c',0.15,0.42,0.24,0.66,0.45,0.96],['c',0.18,0.24,0.18,0.33,0.03,0.42],['c',-0.12,0.06,-0.18,0.03,-0.45,-0.30],['c',-1.08,-1.38,-2.07,-3.36,-2.40,-4.83],['c',-0.27,-1.05,-0.15,-1.77,0.27,-2.07],['c',0.21,-0.12,0.42,-0.15,0.87,-0.15],['c',0.87,0.06,2.10,0.39,3.30,0.90],['l',0.39,0.18],['l',-1.65,-1.95],['c',-2.52,-2.97,-2.61,-3.09,-2.70,-3.27],['c',-0.09,-0.24,-0.12,-0.48,-0.03,-0.75],['c',0.15,-0.48,0.57,-0.96,1.83,-2.01],['c',0.45,-0.36,0.84,-0.72,0.93,-0.78],['c',0.69,-0.75,1.02,-1.80,0.90,-2.79],['c',-0.06,-0.33,-0.21,-0.84,-0.39,-1.11],['c',-0.09,-0.15,-0.45,-0.60,-0.81,-1.05],['c',-0.36,-0.42,-0.69,-0.81,-0.72,-0.87],['c',-0.09,-0.18,0.00,-0.42,0.21,-0.51],['z']],w:7.888,h:21.435},
		'rests.8th':{d:[['M',1.68,-6.12],['c',0.66,-0.09,1.23,0.09,1.68,0.51],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.12,0.27,0.33,0.45,0.60,0.48],['c',0.12,0.00,0.18,0.00,0.33,-0.09],['c',0.39,-0.18,1.32,-1.29,1.68,-1.98],['c',0.09,-0.21,0.24,-0.30,0.39,-0.30],['c',0.12,0.00,0.27,0.09,0.33,0.18],['c',0.03,0.06,-0.27,1.11,-1.86,6.42],['c',-1.02,3.48,-1.89,6.39,-1.92,6.42],['c',0.00,0.03,-0.12,0.12,-0.24,0.15],['c',-0.18,0.09,-0.21,0.09,-0.45,0.09],['c',-0.24,0.00,-0.30,0.00,-0.48,-0.06],['c',-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],['c',-0.06,-0.03,0.15,-0.57,1.68,-4.92],['c',0.96,-2.67,1.74,-4.89,1.71,-4.89],['l',-0.51,0.15],['c',-1.08,0.36,-1.74,0.48,-2.55,0.48],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.33,-0.45,0.84,-0.81,1.38,-0.90],['z']],w:7.534,h:13.883},
		'rests.16th':{d:[['M',3.33,-6.12],['c',0.66,-0.09,1.23,0.09,1.68,0.51],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.15,0.39,0.57,0.57,0.87,0.42],['c',0.39,-0.18,1.20,-1.23,1.62,-2.07],['c',0.06,-0.15,0.24,-0.24,0.36,-0.24],['c',0.12,0.00,0.27,0.09,0.33,0.18],['c',0.03,0.06,-0.45,1.86,-2.67,10.17],['c',-1.50,5.55,-2.73,10.14,-2.76,10.17],['c',-0.03,0.03,-0.12,0.12,-0.24,0.15],['c',-0.18,0.09,-0.21,0.09,-0.45,0.09],['c',-0.24,0.00,-0.30,0.00,-0.48,-0.06],['c',-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],['c',-0.06,-0.03,0.12,-0.57,1.44,-4.92],['c',0.81,-2.67,1.47,-4.86,1.47,-4.89],['c',-0.03,0.00,-0.27,0.06,-0.54,0.15],['c',-1.08,0.36,-1.77,0.48,-2.58,0.48],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.72,-1.05,2.22,-1.23,3.06,-0.42],['c',0.30,0.33,0.42,0.60,0.60,1.38],['c',0.09,0.45,0.21,0.78,0.33,0.90],['c',0.09,0.09,0.27,0.18,0.45,0.21],['c',0.12,0.00,0.18,0.00,0.33,-0.09],['c',0.33,-0.15,1.02,-0.93,1.41,-1.59],['c',0.12,-0.21,0.18,-0.39,0.39,-1.08],['c',0.66,-2.10,1.17,-3.84,1.17,-3.87],['c',0.00,0.00,-0.21,0.06,-0.42,0.15],['c',-0.51,0.15,-1.20,0.33,-1.68,0.42],['c',-0.33,0.06,-0.51,0.06,-0.96,0.06],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.33,-0.45,0.84,-0.81,1.38,-0.90],['z']],w:9.724,h:21.383},
		'rests.32nd':{d:[['M',4.23,-13.62],['c',0.66,-0.09,1.23,0.09,1.68,0.51],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.12,0.27,0.33,0.45,0.60,0.48],['c',0.12,0.00,0.18,0.00,0.27,-0.06],['c',0.33,-0.21,0.99,-1.11,1.44,-1.98],['c',0.09,-0.24,0.21,-0.33,0.39,-0.33],['c',0.12,0.00,0.27,0.09,0.33,0.18],['c',0.03,0.06,-0.57,2.67,-3.21,13.89],['c',-1.80,7.62,-3.30,13.89,-3.30,13.92],['c',-0.03,0.06,-0.12,0.12,-0.24,0.18],['c',-0.21,0.09,-0.24,0.09,-0.48,0.09],['c',-0.24,0.00,-0.30,0.00,-0.48,-0.06],['c',-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],['c',-0.06,-0.03,0.09,-0.57,1.23,-4.92],['c',0.69,-2.67,1.26,-4.86,1.29,-4.89],['c',0.00,-0.03,-0.12,-0.03,-0.48,0.12],['c',-1.17,0.39,-2.22,0.57,-3.00,0.54],['c',-0.42,-0.03,-0.75,-0.12,-1.11,-0.30],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.72,-1.05,2.22,-1.23,3.06,-0.42],['c',0.30,0.33,0.42,0.60,0.60,1.38],['c',0.09,0.45,0.21,0.78,0.33,0.90],['c',0.12,0.09,0.30,0.18,0.48,0.21],['c',0.12,0.00,0.18,0.00,0.30,-0.09],['c',0.42,-0.21,1.29,-1.29,1.56,-1.89],['c',0.03,-0.12,1.23,-4.59,1.23,-4.65],['c',0.00,-0.03,-0.18,0.03,-0.39,0.12],['c',-0.63,0.18,-1.20,0.36,-1.74,0.45],['c',-0.39,0.06,-0.54,0.06,-1.02,0.06],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.72,-1.05,2.22,-1.23,3.06,-0.42],['c',0.30,0.33,0.42,0.60,0.60,1.38],['c',0.09,0.45,0.21,0.78,0.33,0.90],['c',0.18,0.18,0.51,0.27,0.72,0.15],['c',0.30,-0.12,0.69,-0.57,1.08,-1.17],['c',0.42,-0.60,0.39,-0.51,1.05,-3.03],['c',0.33,-1.26,0.60,-2.31,0.60,-2.34],['c',0.00,0.00,-0.21,0.03,-0.45,0.12],['c',-0.57,0.18,-1.14,0.33,-1.62,0.42],['c',-0.33,0.06,-0.51,0.06,-0.96,0.06],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.33,-0.45,0.84,-0.81,1.38,-0.90],['z']],w:11.373,h:28.883},
		'rests.64th':{d:[['M',5.13,-13.62],['c',0.66,-0.09,1.23,0.09,1.68,0.51],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.15,0.63,0.21,0.81,0.33,0.96],['c',0.18,0.21,0.54,0.30,0.75,0.18],['c',0.24,-0.12,0.63,-0.66,1.08,-1.56],['c',0.33,-0.66,0.39,-0.72,0.60,-0.72],['c',0.12,0.00,0.27,0.09,0.33,0.18],['c',0.03,0.06,-0.69,3.66,-3.54,17.64],['c',-1.95,9.66,-3.57,17.61,-3.57,17.64],['c',-0.03,0.06,-0.12,0.12,-0.24,0.18],['c',-0.21,0.09,-0.24,0.09,-0.48,0.09],['c',-0.24,0.00,-0.30,0.00,-0.48,-0.06],['c',-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],['c',-0.06,-0.03,0.06,-0.57,1.05,-4.95],['c',0.60,-2.70,1.08,-4.89,1.08,-4.92],['c',0.00,0.00,-0.24,0.06,-0.51,0.15],['c',-0.66,0.24,-1.20,0.36,-1.77,0.48],['c',-0.42,0.06,-0.57,0.06,-1.05,0.06],['c',-0.69,0.00,-0.87,-0.03,-1.35,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.72,-1.05,2.22,-1.23,3.06,-0.42],['c',0.30,0.33,0.42,0.60,0.60,1.38],['c',0.09,0.45,0.21,0.78,0.33,0.90],['c',0.09,0.09,0.27,0.18,0.45,0.21],['c',0.21,0.03,0.39,-0.09,0.72,-0.42],['c',0.45,-0.45,1.02,-1.26,1.17,-1.65],['c',0.03,-0.09,0.27,-1.14,0.54,-2.34],['c',0.27,-1.20,0.48,-2.19,0.51,-2.22],['c',0.00,-0.03,-0.09,-0.03,-0.48,0.12],['c',-1.17,0.39,-2.22,0.57,-3.00,0.54],['c',-0.42,-0.03,-0.75,-0.12,-1.11,-0.30],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.15,0.39,0.57,0.57,0.90,0.42],['c',0.36,-0.18,1.20,-1.26,1.47,-1.89],['c',0.03,-0.09,0.30,-1.20,0.57,-2.43],['l',0.51,-2.28],['l',-0.54,0.18],['c',-1.11,0.36,-1.80,0.48,-2.61,0.48],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.15,0.63,0.21,0.81,0.33,0.96],['c',0.21,0.21,0.54,0.30,0.75,0.18],['c',0.36,-0.18,0.93,-0.93,1.29,-1.68],['c',0.12,-0.24,0.18,-0.48,0.63,-2.55],['l',0.51,-2.31],['c',0.00,-0.03,-0.18,0.03,-0.39,0.12],['c',-1.14,0.36,-2.10,0.54,-2.82,0.51],['c',-0.42,-0.03,-0.75,-0.12,-1.11,-0.30],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.33,-0.45,0.84,-0.81,1.38,-0.90],['z']],w:12.453,h:36.383},
		'rests.128th':{d:[['M',6.03,-21.12],['c',0.66,-0.09,1.23,0.09,1.68,0.51],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.12,0.27,0.33,0.45,0.60,0.48],['c',0.21,0.00,0.33,-0.06,0.54,-0.36],['c',0.15,-0.21,0.54,-0.93,0.78,-1.47],['c',0.15,-0.33,0.18,-0.39,0.30,-0.48],['c',0.18,-0.09,0.45,0.00,0.51,0.15],['c',0.03,0.09,-7.11,42.75,-7.17,42.84],['c',-0.03,0.03,-0.15,0.09,-0.24,0.15],['c',-0.18,0.06,-0.24,0.06,-0.45,0.06],['c',-0.24,0.00,-0.30,0.00,-0.48,-0.06],['c',-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],['c',-0.06,-0.03,0.03,-0.57,0.84,-4.98],['c',0.51,-2.70,0.93,-4.92,0.90,-4.92],['c',0.00,0.00,-0.15,0.06,-0.36,0.12],['c',-0.78,0.27,-1.62,0.48,-2.31,0.57],['c',-0.15,0.03,-0.54,0.03,-0.81,0.03],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.12,0.27,0.33,0.45,0.63,0.48],['c',0.12,0.00,0.18,0.00,0.30,-0.09],['c',0.42,-0.21,1.14,-1.11,1.50,-1.83],['c',0.12,-0.27,0.12,-0.27,0.54,-2.52],['c',0.24,-1.23,0.42,-2.25,0.39,-2.25],['c',0.00,0.00,-0.24,0.06,-0.51,0.18],['c',-1.26,0.39,-2.25,0.57,-3.06,0.54],['c',-0.42,-0.03,-0.75,-0.12,-1.11,-0.30],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.15,0.63,0.21,0.81,0.33,0.96],['c',0.18,0.21,0.51,0.30,0.75,0.18],['c',0.36,-0.15,1.05,-0.99,1.41,-1.77],['l',0.15,-0.30],['l',0.42,-2.25],['c',0.21,-1.26,0.42,-2.28,0.39,-2.28],['l',-0.51,0.15],['c',-1.11,0.39,-1.89,0.51,-2.70,0.51],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.15,0.63,0.21,0.81,0.33,0.96],['c',0.18,0.18,0.48,0.27,0.72,0.21],['c',0.33,-0.12,1.14,-1.26,1.41,-1.95],['c',0.00,-0.09,0.21,-1.11,0.45,-2.34],['c',0.21,-1.20,0.39,-2.22,0.39,-2.28],['c',0.03,-0.03,0.00,-0.03,-0.45,0.12],['c',-0.57,0.18,-1.20,0.33,-1.71,0.42],['c',-0.30,0.06,-0.51,0.06,-0.93,0.06],['c',-0.66,0.00,-0.84,-0.03,-1.32,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.36,-0.54,0.96,-0.87,1.65,-0.93],['c',0.54,-0.03,1.02,0.15,1.41,0.54],['c',0.27,0.30,0.39,0.54,0.57,1.26],['c',0.09,0.33,0.18,0.66,0.21,0.72],['c',0.12,0.27,0.33,0.45,0.60,0.48],['c',0.18,0.00,0.36,-0.09,0.57,-0.33],['c',0.33,-0.36,0.78,-1.14,0.93,-1.56],['c',0.03,-0.12,0.24,-1.20,0.45,-2.40],['c',0.24,-1.20,0.42,-2.22,0.42,-2.28],['c',0.03,-0.03,0.00,-0.03,-0.39,0.09],['c',-1.05,0.36,-1.80,0.48,-2.58,0.48],['c',-0.63,0.00,-0.84,-0.03,-1.29,-0.27],['c',-1.32,-0.63,-1.77,-2.16,-1.02,-3.30],['c',0.33,-0.45,0.84,-0.81,1.38,-0.90],['z']],w:12.992,h:43.883},
		'accidentals.sharp':{d:[['M',5.73,-11.19],['c',0.21,-0.12,0.54,-0.03,0.66,0.24],['c',0.06,0.12,0.06,0.21,0.06,2.31],['c',0.00,1.23,0.00,2.22,0.03,2.22],['c',0.00,0.00,0.27,-0.12,0.60,-0.24],['c',0.69,-0.27,0.78,-0.30,0.96,-0.15],['c',0.21,0.15,0.21,0.18,0.21,1.38],['c',0.00,1.02,0.00,1.11,-0.06,1.20],['c',-0.03,0.06,-0.09,0.12,-0.12,0.15],['c',-0.06,0.03,-0.42,0.21,-0.84,0.36],['l',-0.75,0.33],['l',-0.03,2.43],['c',0.00,1.32,0.00,2.43,0.03,2.43],['c',0.00,0.00,0.27,-0.12,0.60,-0.24],['c',0.69,-0.27,0.78,-0.30,0.96,-0.15],['c',0.21,0.15,0.21,0.18,0.21,1.38],['c',0.00,1.02,0.00,1.11,-0.06,1.20],['c',-0.03,0.06,-0.09,0.12,-0.12,0.15],['c',-0.06,0.03,-0.42,0.21,-0.84,0.36],['l',-0.75,0.33],['l',-0.03,2.52],['c',0.00,2.28,-0.03,2.55,-0.06,2.64],['c',-0.21,0.36,-0.72,0.36,-0.93,0.00],['c',-0.03,-0.09,-0.06,-0.33,-0.06,-2.43],['l',0.00,-2.31],['l',-1.29,0.51],['l',-1.26,0.51],['l',0.00,2.43],['c',0.00,2.58,0.00,2.52,-0.15,2.67],['c',-0.06,0.09,-0.27,0.18,-0.36,0.18],['c',-0.12,0.00,-0.33,-0.09,-0.39,-0.18],['c',-0.15,-0.15,-0.15,-0.09,-0.15,-2.43],['c',0.00,-1.23,0.00,-2.22,-0.03,-2.22],['c',0.00,0.00,-0.27,0.12,-0.60,0.24],['c',-0.69,0.27,-0.78,0.30,-0.96,0.15],['c',-0.21,-0.15,-0.21,-0.18,-0.21,-1.38],['c',0.00,-1.02,0.00,-1.11,0.06,-1.20],['c',0.03,-0.06,0.09,-0.12,0.12,-0.15],['c',0.06,-0.03,0.42,-0.21,0.84,-0.36],['l',0.78,-0.33],['l',0.00,-2.43],['c',0.00,-1.32,0.00,-2.43,-0.03,-2.43],['c',0.00,0.00,-0.27,0.12,-0.60,0.24],['c',-0.69,0.27,-0.78,0.30,-0.96,0.15],['c',-0.21,-0.15,-0.21,-0.18,-0.21,-1.38],['c',0.00,-1.02,0.00,-1.11,0.06,-1.20],['c',0.03,-0.06,0.09,-0.12,0.12,-0.15],['c',0.06,-0.03,0.42,-0.21,0.84,-0.36],['l',0.78,-0.33],['l',0.00,-2.52],['c',0.00,-2.28,0.03,-2.55,0.06,-2.64],['c',0.21,-0.36,0.72,-0.36,0.93,0.00],['c',0.03,0.09,0.06,0.33,0.06,2.43],['l',0.03,2.31],['l',1.26,-0.51],['l',1.26,-0.51],['l',0.00,-2.43],['c',0.00,-2.28,0.00,-2.43,0.06,-2.55],['c',0.06,-0.12,0.12,-0.18,0.27,-0.24],['z'],['m',-0.33,10.65],['l',0.00,-2.43],['l',-1.29,0.51],['l',-1.26,0.51],['l',0.00,2.46],['l',0.00,2.43],['l',0.09,-0.03],['c',0.06,-0.03,0.63,-0.27,1.29,-0.51],['l',1.17,-0.48],['l',0.00,-2.46],['z']],w:8.25,h:22.462},
		'accidentals.halfsharp':{d:[['M',2.43,-10.05],['c',0.21,-0.12,0.54,-0.03,0.66,0.24],['c',0.06,0.12,0.06,0.21,0.06,2.01],['c',0.00,1.05,0.00,1.89,0.03,1.89],['l',0.72,-0.48],['c',0.69,-0.48,0.69,-0.51,0.87,-0.51],['c',0.15,0.00,0.18,0.03,0.27,0.09],['c',0.21,0.15,0.21,0.18,0.21,1.41],['c',0.00,1.11,-0.03,1.14,-0.09,1.23],['c',-0.03,0.03,-0.48,0.39,-1.02,0.75],['l',-0.99,0.66],['l',0.00,2.37],['c',0.00,1.32,0.00,2.37,0.03,2.37],['l',0.72,-0.48],['c',0.69,-0.48,0.69,-0.51,0.87,-0.51],['c',0.15,0.00,0.18,0.03,0.27,0.09],['c',0.21,0.15,0.21,0.18,0.21,1.41],['c',0.00,1.11,-0.03,1.14,-0.09,1.23],['c',-0.03,0.03,-0.48,0.39,-1.02,0.75],['l',-0.99,0.66],['l',0.00,2.25],['c',0.00,1.95,0.00,2.28,-0.06,2.37],['c',-0.06,0.12,-0.12,0.21,-0.24,0.27],['c',-0.27,0.12,-0.54,0.03,-0.69,-0.24],['c',-0.06,-0.12,-0.06,-0.21,-0.06,-2.01],['c',0.00,-1.05,0.00,-1.89,-0.03,-1.89],['l',-0.72,0.48],['c',-0.69,0.48,-0.69,0.48,-0.87,0.48],['c',-0.15,0.00,-0.18,0.00,-0.27,-0.06],['c',-0.21,-0.15,-0.21,-0.18,-0.21,-1.41],['c',0.00,-1.11,0.03,-1.14,0.09,-1.23],['c',0.03,-0.03,0.48,-0.39,1.02,-0.75],['l',0.99,-0.66],['l',0.00,-2.37],['c',0.00,-1.32,0.00,-2.37,-0.03,-2.37],['l',-0.72,0.48],['c',-0.69,0.48,-0.69,0.48,-0.87,0.48],['c',-0.15,0.00,-0.18,0.00,-0.27,-0.06],['c',-0.21,-0.15,-0.21,-0.18,-0.21,-1.41],['c',0.00,-1.11,0.03,-1.14,0.09,-1.23],['c',0.03,-0.03,0.48,-0.39,1.02,-0.75],['l',0.99,-0.66],['l',0.00,-2.25],['c',0.00,-2.13,0.00,-2.28,0.06,-2.40],['c',0.06,-0.12,0.12,-0.18,0.27,-0.24],['z']],w:5.25,h:20.174},
		'accidentals.nat':{d:[['M',0.21,-11.40],['c',0.24,-0.06,0.78,0.00,0.99,0.15],['c',0.03,0.03,0.03,0.48,0.00,2.61],['c',-0.03,1.44,-0.03,2.61,-0.03,2.61],['c',0.00,0.03,0.75,-0.09,1.68,-0.24],['c',0.96,-0.18,1.71,-0.27,1.74,-0.27],['c',0.15,0.03,0.27,0.15,0.36,0.30],['l',0.06,0.12],['l',0.09,8.67],['c',0.09,6.96,0.12,8.67,0.09,8.67],['c',-0.03,0.03,-0.12,0.06,-0.21,0.09],['c',-0.24,0.09,-0.72,0.09,-0.96,0.00],['c',-0.09,-0.03,-0.18,-0.06,-0.21,-0.09],['c',-0.03,-0.03,-0.03,-0.48,0.00,-2.61],['c',0.03,-1.44,0.03,-2.61,0.03,-2.61],['c',0.00,-0.03,-0.75,0.09,-1.68,0.24],['c',-0.96,0.18,-1.71,0.27,-1.74,0.27],['c',-0.15,-0.03,-0.27,-0.15,-0.36,-0.30],['l',-0.06,-0.15],['l',-0.09,-7.53],['c',-0.06,-4.14,-0.09,-8.04,-0.12,-8.67],['l',0.00,-1.11],['l',0.15,-0.06],['c',0.09,-0.03,0.21,-0.06,0.27,-0.09],['z'],['m',3.75,8.40],['c',0.00,-0.33,0.00,-0.42,-0.03,-0.42],['c',-0.12,0.00,-2.79,0.45,-2.79,0.48],['c',-0.03,0.00,-0.09,6.30,-0.09,6.33],['c',0.03,0.00,2.79,-0.45,2.82,-0.48],['c',0.00,0.00,0.09,-4.53,0.09,-5.91],['z']],w:5.4,h:22.8},
		'accidentals.flat':{d:[['M',-0.36,-14.07],['c',0.33,-0.06,0.87,0.00,1.08,0.15],['c',0.06,0.03,0.06,0.36,-0.03,5.25],['c',-0.06,2.85,-0.09,5.19,-0.09,5.19],['c',0.00,0.03,0.12,-0.03,0.24,-0.12],['c',0.63,-0.42,1.41,-0.66,2.19,-0.72],['c',0.81,-0.03,1.47,0.21,2.04,0.78],['c',0.57,0.54,0.87,1.26,0.93,2.04],['c',0.03,0.57,-0.09,1.08,-0.36,1.62],['c',-0.42,0.81,-1.02,1.38,-2.82,2.61],['c',-1.14,0.78,-1.44,1.02,-1.80,1.44],['c',-0.18,0.18,-0.39,0.39,-0.45,0.42],['c',-0.27,0.18,-0.57,0.15,-0.81,-0.06],['c',-0.06,-0.09,-0.12,-0.18,-0.15,-0.27],['c',-0.03,-0.06,-0.09,-3.27,-0.18,-8.34],['c',-0.09,-4.53,-0.15,-8.58,-0.18,-9.03],['l',0.00,-0.78],['l',0.12,-0.06],['c',0.06,-0.03,0.18,-0.09,0.27,-0.12],['z'],['m',3.18,11.01],['c',-0.21,-0.12,-0.54,-0.15,-0.81,-0.06],['c',-0.54,0.15,-0.99,0.63,-1.17,1.26],['c',-0.06,0.30,-0.12,2.88,-0.06,3.87],['c',0.03,0.42,0.03,0.81,0.06,0.90],['l',0.03,0.12],['l',0.45,-0.39],['c',0.63,-0.54,1.26,-1.17,1.56,-1.59],['c',0.30,-0.42,0.60,-0.99,0.72,-1.41],['c',0.18,-0.69,0.09,-1.47,-0.18,-2.07],['c',-0.15,-0.30,-0.33,-0.51,-0.60,-0.63],['z']],w:6.75,h:18.801},
		'accidentals.halfflat':{d:[['M',4.83,-14.07],['c',0.33,-0.06,0.87,0.00,1.08,0.15],['c',0.06,0.03,0.06,0.60,-0.12,9.06],['c',-0.09,5.55,-0.15,9.06,-0.18,9.12],['c',-0.03,0.09,-0.09,0.18,-0.15,0.27],['c',-0.24,0.21,-0.54,0.24,-0.81,0.06],['c',-0.06,-0.03,-0.27,-0.24,-0.45,-0.42],['c',-0.36,-0.42,-0.66,-0.66,-1.80,-1.44],['c',-1.23,-0.84,-1.83,-1.32,-2.25,-1.77],['c',-0.66,-0.78,-0.96,-1.56,-0.93,-2.46],['c',0.09,-1.41,1.11,-2.58,2.40,-2.79],['c',0.30,-0.06,0.84,-0.03,1.23,0.06],['c',0.54,0.12,1.08,0.33,1.53,0.63],['c',0.12,0.09,0.24,0.15,0.24,0.12],['c',0.00,0.00,-0.12,-8.37,-0.18,-9.75],['l',0.00,-0.66],['l',0.12,-0.06],['c',0.06,-0.03,0.18,-0.09,0.27,-0.12],['z'],['m',-1.65,10.95],['c',-0.60,-0.18,-1.08,0.09,-1.38,0.69],['c',-0.27,0.60,-0.36,1.38,-0.18,2.07],['c',0.12,0.42,0.42,0.99,0.72,1.41],['c',0.30,0.42,0.93,1.05,1.56,1.59],['l',0.48,0.39],['l',0.00,-0.12],['c',0.03,-0.09,0.03,-0.48,0.06,-0.90],['c',0.03,-0.57,0.03,-1.08,0.00,-2.22],['c',-0.03,-1.62,-0.03,-1.62,-0.24,-2.07],['c',-0.21,-0.42,-0.60,-0.75,-1.02,-0.84],['z']],w:6.728,h:18.801},
		'accidentals.dblflat':{d:[['M',-0.36,-14.07],['c',0.33,-0.06,0.87,0.00,1.08,0.15],['c',0.06,0.03,0.06,0.33,-0.03,4.89],['c',-0.06,2.67,-0.09,5.01,-0.09,5.22],['l',0.00,0.36],['l',0.15,-0.15],['c',0.36,-0.30,0.75,-0.51,1.20,-0.63],['c',0.33,-0.09,0.96,-0.09,1.26,-0.03],['c',0.27,0.09,0.63,0.27,0.87,0.45],['l',0.21,0.15],['l',0.00,-0.27],['c',0.00,-0.15,-0.03,-2.43,-0.09,-5.10],['c',-0.09,-4.56,-0.09,-4.86,-0.03,-4.89],['c',0.15,-0.12,0.39,-0.15,0.72,-0.15],['c',0.30,0.00,0.54,0.03,0.69,0.15],['c',0.06,0.03,0.06,0.33,-0.03,4.95],['c',-0.06,2.70,-0.09,5.04,-0.09,5.22],['l',0.03,0.30],['l',0.21,-0.15],['c',0.69,-0.48,1.44,-0.69,2.28,-0.69],['c',0.51,0.00,0.78,0.03,1.20,0.21],['c',1.32,0.63,2.01,2.28,1.53,3.69],['c',-0.21,0.57,-0.51,1.02,-1.05,1.56],['c',-0.42,0.42,-0.81,0.72,-1.92,1.50],['c',-1.26,0.87,-1.50,1.08,-1.86,1.50],['c',-0.39,0.45,-0.54,0.54,-0.81,0.51],['c',-0.18,0.00,-0.21,0.00,-0.33,-0.06],['l',-0.21,-0.21],['l',-0.06,-0.12],['l',-0.03,-0.99],['c',-0.03,-0.54,-0.03,-1.29,-0.06,-1.68],['l',0.00,-0.69],['l',-0.21,0.24],['c',-0.36,0.42,-0.75,0.75,-1.80,1.62],['c',-1.02,0.84,-1.20,0.99,-1.44,1.38],['c',-0.36,0.51,-0.54,0.60,-0.90,0.51],['c',-0.15,-0.03,-0.39,-0.27,-0.42,-0.42],['c',-0.03,-0.06,-0.09,-3.27,-0.18,-8.34],['c',-0.09,-4.53,-0.15,-8.58,-0.18,-9.03],['l',0.00,-0.78],['l',0.12,-0.06],['c',0.06,-0.03,0.18,-0.09,0.27,-0.12],['z'],['m',2.52,10.98],['c',-0.18,-0.09,-0.48,-0.12,-0.66,-0.06],['c',-0.39,0.15,-0.69,0.54,-0.84,1.14],['c',-0.06,0.24,-0.06,0.39,-0.09,1.74],['c',-0.03,1.44,0.00,2.73,0.06,3.18],['l',0.03,0.15],['l',0.27,-0.27],['c',0.93,-0.96,1.50,-1.95,1.74,-3.06],['c',0.06,-0.27,0.06,-0.39,0.06,-0.96],['c',0.00,-0.54,0.00,-0.69,-0.06,-0.93],['c',-0.09,-0.51,-0.27,-0.81,-0.51,-0.93],['z'],['m',5.43,0.00],['c',-0.18,-0.09,-0.51,-0.12,-0.72,-0.06],['c',-0.54,0.12,-0.96,0.63,-1.17,1.26],['c',-0.06,0.30,-0.12,2.88,-0.06,3.90],['c',0.03,0.42,0.03,0.81,0.06,0.90],['l',0.03,0.12],['l',0.36,-0.30],['c',0.42,-0.36,1.02,-0.96,1.29,-1.29],['c',0.36,-0.45,0.66,-0.99,0.81,-1.41],['c',0.42,-1.23,0.15,-2.76,-0.60,-3.12],['z']],w:11.613,h:18.804},
		'accidentals.dblsharp':{d:[['M',-0.18,-3.96],['c',0.06,-0.03,0.12,-0.06,0.15,-0.06],['c',0.09,0.00,2.76,0.27,2.79,0.30],['c',0.12,0.03,0.15,0.12,0.15,0.51],['c',0.06,0.96,0.24,1.59,0.57,2.10],['c',0.06,0.09,0.15,0.21,0.18,0.24],['l',0.09,0.06],['l',0.09,-0.06],['c',0.03,-0.03,0.12,-0.15,0.18,-0.24],['c',0.33,-0.51,0.51,-1.14,0.57,-2.10],['c',0.00,-0.39,0.03,-0.45,0.12,-0.51],['c',0.03,0.00,0.66,-0.09,1.44,-0.15],['c',1.47,-0.15,1.50,-0.15,1.56,-0.03],['c',0.03,0.06,0.00,0.42,-0.09,1.44],['c',-0.09,0.72,-0.15,1.35,-0.15,1.38],['c',0.00,0.03,-0.03,0.09,-0.06,0.12],['c',-0.06,0.06,-0.12,0.09,-0.51,0.09],['c',-1.08,0.06,-1.80,0.30,-2.28,0.75],['l',-0.12,0.09],['l',0.09,0.09],['c',0.12,0.15,0.39,0.33,0.63,0.45],['c',0.42,0.18,0.96,0.27,1.68,0.33],['c',0.39,0.00,0.45,0.03,0.51,0.09],['c',0.03,0.03,0.06,0.09,0.06,0.12],['c',0.00,0.03,0.06,0.66,0.15,1.38],['c',0.09,1.02,0.12,1.38,0.09,1.44],['c',-0.06,0.12,-0.09,0.12,-1.56,-0.03],['c',-0.78,-0.06,-1.41,-0.15,-1.44,-0.15],['c',-0.09,-0.06,-0.12,-0.12,-0.12,-0.54],['c',-0.06,-0.93,-0.24,-1.56,-0.57,-2.07],['c',-0.06,-0.09,-0.15,-0.21,-0.18,-0.24],['l',-0.09,-0.06],['l',-0.09,0.06],['c',-0.03,0.03,-0.12,0.15,-0.18,0.24],['c',-0.33,0.51,-0.51,1.14,-0.57,2.07],['c',0.00,0.42,-0.03,0.48,-0.12,0.54],['c',-0.03,0.00,-0.66,0.09,-1.44,0.15],['c',-1.47,0.15,-1.50,0.15,-1.56,0.03],['c',-0.03,-0.06,0.00,-0.42,0.09,-1.44],['c',0.09,-0.72,0.15,-1.35,0.15,-1.38],['c',0.00,-0.03,0.03,-0.09,0.06,-0.12],['c',0.06,-0.06,0.12,-0.09,0.51,-0.09],['c',0.72,-0.06,1.26,-0.15,1.68,-0.33],['c',0.24,-0.12,0.51,-0.30,0.63,-0.45],['l',0.09,-0.09],['l',-0.12,-0.09],['c',-0.48,-0.45,-1.20,-0.69,-2.28,-0.75],['c',-0.39,0.00,-0.45,-0.03,-0.51,-0.09],['c',-0.03,-0.03,-0.06,-0.09,-0.06,-0.12],['c',0.00,-0.03,-0.06,-0.63,-0.12,-1.38],['c',-0.09,-0.72,-0.15,-1.35,-0.15,-1.38],['z']],w:7.95,h:7.977},
		'dots.dot':{d:[['M',1.32,-1.68],['c',0.09,-0.03,0.27,-0.06,0.39,-0.06],['c',0.96,0.00,1.74,0.78,1.74,1.71],['c',0.00,0.96,-0.78,1.74,-1.71,1.74],['c',-0.96,0.00,-1.74,-0.78,-1.74,-1.71],['c',0.00,-0.78,0.54,-1.50,1.32,-1.68],['z']],w:3.45,h:3.45},
		'noteheads.dbl':{d:[['M',-0.69,-4.02],['c',0.18,-0.09,0.36,-0.09,0.54,0.00],['c',0.18,0.09,0.24,0.15,0.33,0.30],['c',0.06,0.15,0.06,0.18,0.06,1.41],['l',0.00,1.23],['l',0.12,-0.18],['c',0.72,-1.26,2.64,-2.31,4.86,-2.64],['c',0.81,-0.15,1.11,-0.15,2.13,-0.15],['c',0.99,0.00,1.29,0.00,2.10,0.15],['c',0.75,0.12,1.38,0.27,2.04,0.54],['c',1.35,0.51,2.34,1.26,2.82,2.10],['l',0.12,0.18],['l',0.00,-1.23],['c',0.00,-1.20,0.00,-1.26,0.06,-1.38],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['c',0.18,-0.09,0.36,-0.09,0.54,0.00],['c',0.18,0.09,0.24,0.15,0.33,0.30],['l',0.06,0.15],['l',0.00,3.54],['l',0.00,3.54],['l',-0.06,0.15],['c',-0.09,0.18,-0.15,0.24,-0.33,0.33],['c',-0.18,0.09,-0.36,0.09,-0.54,0.00],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['c',-0.06,-0.12,-0.06,-0.18,-0.06,-1.38],['l',0.00,-1.23],['l',-0.12,0.18],['c',-0.48,0.84,-1.47,1.59,-2.82,2.10],['c',-0.84,0.33,-1.71,0.54,-2.85,0.66],['c',-0.45,0.06,-2.16,0.06,-2.61,0.00],['c',-1.14,-0.12,-2.01,-0.33,-2.85,-0.66],['c',-1.35,-0.51,-2.34,-1.26,-2.82,-2.10],['l',-0.12,-0.18],['l',0.00,1.23],['c',0.00,1.23,0.00,1.26,-0.06,1.38],['c',-0.09,0.18,-0.15,0.24,-0.33,0.33],['c',-0.18,0.09,-0.36,0.09,-0.54,0.00],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['l',-0.06,-0.15],['l',0.00,-3.54],['c',0.00,-3.48,0.00,-3.54,0.06,-3.66],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['z'],['m',7.71,0.63],['c',-0.36,-0.06,-0.90,-0.06,-1.14,0.00],['c',-0.30,0.03,-0.66,0.24,-0.87,0.42],['c',-0.60,0.54,-0.90,1.62,-0.75,2.82],['c',0.12,0.93,0.51,1.68,1.11,2.31],['c',0.75,0.72,1.83,1.20,2.85,1.26],['c',1.05,0.06,1.83,-0.54,2.10,-1.65],['c',0.21,-0.90,0.12,-1.95,-0.24,-2.82],['c',-0.36,-0.81,-1.08,-1.53,-1.95,-1.95],['c',-0.30,-0.15,-0.78,-0.30,-1.11,-0.39],['z']],w:16.83,h:8.145},
		'noteheads.whole':{d:[['M',6.51,-4.05],['c',0.51,-0.03,2.01,0.00,2.52,0.03],['c',1.41,0.18,2.64,0.51,3.72,1.08],['c',1.20,0.63,1.95,1.41,2.19,2.31],['c',0.09,0.33,0.09,0.90,0.00,1.23],['c',-0.24,0.90,-0.99,1.68,-2.19,2.31],['c',-1.08,0.57,-2.28,0.90,-3.75,1.08],['c',-0.66,0.06,-2.31,0.06,-2.97,0.00],['c',-1.47,-0.18,-2.67,-0.51,-3.75,-1.08],['c',-1.20,-0.63,-1.95,-1.41,-2.19,-2.31],['c',-0.09,-0.33,-0.09,-0.90,0.00,-1.23],['c',0.24,-0.90,0.99,-1.68,2.19,-2.31],['c',1.20,-0.63,2.61,-0.99,4.23,-1.11],['z'],['m',0.57,0.66],['c',-0.87,-0.15,-1.53,0.00,-2.04,0.51],['c',-0.15,0.15,-0.24,0.27,-0.33,0.48],['c',-0.24,0.51,-0.36,1.08,-0.33,1.77],['c',0.03,0.69,0.18,1.26,0.42,1.77],['c',0.60,1.17,1.74,1.98,3.18,2.22],['c',1.11,0.21,1.95,-0.15,2.34,-0.99],['c',0.24,-0.51,0.36,-1.08,0.33,-1.80],['c',-0.06,-1.11,-0.45,-2.04,-1.17,-2.76],['c',-0.63,-0.63,-1.47,-1.05,-2.40,-1.20],['z']],w:14.985,h:8.097},
		'noteheads.half':{d:[['M',7.44,-4.05],['c',0.06,-0.03,0.27,-0.03,0.48,-0.03],['c',1.05,0.00,1.71,0.24,2.10,0.81],['c',0.42,0.60,0.45,1.35,0.18,2.40],['c',-0.42,1.59,-1.14,2.73,-2.16,3.39],['c',-1.41,0.93,-3.18,1.44,-5.40,1.53],['c',-1.17,0.03,-1.89,-0.21,-2.28,-0.81],['c',-0.42,-0.60,-0.45,-1.35,-0.18,-2.40],['c',0.42,-1.59,1.14,-2.73,2.16,-3.39],['c',0.63,-0.42,1.23,-0.72,1.98,-0.96],['c',0.90,-0.30,1.65,-0.42,3.12,-0.54],['z'],['m',1.29,0.87],['c',-0.27,-0.09,-0.63,-0.12,-0.90,-0.03],['c',-0.72,0.24,-1.53,0.69,-3.27,1.80],['c',-2.34,1.50,-3.30,2.25,-3.57,2.79],['c',-0.36,0.72,-0.06,1.50,0.66,1.77],['c',0.24,0.12,0.69,0.09,0.99,0.00],['c',0.84,-0.30,1.92,-0.93,4.14,-2.37],['c',1.62,-1.08,2.37,-1.71,2.61,-2.19],['c',0.36,-0.72,0.06,-1.50,-0.66,-1.77],['z']],w:10.37,h:8.132},
		'noteheads.quarter':{d:[['M',6.09,-4.05],['c',0.36,-0.03,1.20,0.00,1.53,0.06],['c',1.17,0.24,1.89,0.84,2.16,1.83],['c',0.06,0.18,0.06,0.30,0.06,0.66],['c',0.00,0.45,0.00,0.63,-0.15,1.08],['c',-0.66,2.04,-3.06,3.93,-5.52,4.38],['c',-0.54,0.09,-1.44,0.09,-1.83,0.03],['c',-1.23,-0.27,-1.98,-0.87,-2.25,-1.86],['c',-0.06,-0.18,-0.06,-0.30,-0.06,-0.66],['c',0.00,-0.45,0.00,-0.63,0.15,-1.08],['c',0.24,-0.78,0.75,-1.53,1.44,-2.22],['c',1.20,-1.20,2.85,-2.01,4.47,-2.22],['z']],w:9.81,h:8.094},
		'noteheads.slash.nostem':{d:[['M',9.30,-7.77],['c',0.06,-0.06,0.18,-0.06,1.71,-0.06],['l',1.65,0.00],['l',0.09,0.09],['c',0.06,0.06,0.06,0.09,0.06,0.15],['c',-0.03,0.12,-9.21,15.24,-9.30,15.33],['c',-0.06,0.06,-0.18,0.06,-1.71,0.06],['l',-1.65,0.00],['l',-0.09,-0.09],['c',-0.06,-0.06,-0.06,-0.09,-0.06,-0.15],['c',0.03,-0.12,9.21,-15.24,9.30,-15.33],['z']],w:12.81,h:15.63},
		'noteheads.indeterminate':{d:[['M',0.78,-4.05],['c',0.12,-0.03,0.24,-0.03,0.36,0.03],['c',0.03,0.03,0.93,0.72,1.95,1.56],['l',1.86,1.50],['l',1.86,-1.50],['c',1.02,-0.84,1.92,-1.53,1.95,-1.56],['c',0.21,-0.12,0.33,-0.09,0.75,0.24],['c',0.30,0.27,0.36,0.36,0.36,0.54],['c',0.00,0.03,-0.03,0.12,-0.06,0.18],['c',-0.03,0.06,-0.90,0.75,-1.89,1.56],['l',-1.80,1.47],['c',0.00,0.03,0.81,0.69,1.80,1.50],['c',0.99,0.81,1.86,1.50,1.89,1.56],['c',0.03,0.06,0.06,0.15,0.06,0.18],['c',0.00,0.18,-0.06,0.27,-0.36,0.54],['c',-0.42,0.33,-0.54,0.36,-0.75,0.24],['c',-0.03,-0.03,-0.93,-0.72,-1.95,-1.56],['l',-1.86,-1.50],['l',-1.86,1.50],['c',-1.02,0.84,-1.92,1.53,-1.95,1.56],['c',-0.21,0.12,-0.33,0.09,-0.75,-0.24],['c',-0.30,-0.27,-0.36,-0.36,-0.36,-0.54],['c',0.00,-0.03,0.03,-0.12,0.06,-0.18],['c',0.03,-0.06,0.90,-0.75,1.89,-1.56],['l',1.80,-1.47],['c',0.00,-0.03,-0.81,-0.69,-1.80,-1.50],['c',-0.99,-0.81,-1.86,-1.50,-1.89,-1.56],['c',-0.06,-0.12,-0.09,-0.21,-0.03,-0.36],['c',0.03,-0.09,0.57,-0.57,0.72,-0.63],['z']],w:9.843,h:8.139},
		'scripts.ufermata':{d:[['M',-0.75,-10.77],['c',0.12,0.00,0.45,-0.03,0.69,-0.03],['c',2.91,-0.03,5.55,1.53,7.41,4.35],['c',1.17,1.71,1.95,3.72,2.43,6.03],['c',0.12,0.51,0.12,0.57,0.03,0.69],['c',-0.12,0.21,-0.48,0.27,-0.69,0.12],['c',-0.12,-0.09,-0.18,-0.24,-0.27,-0.69],['c',-0.78,-3.63,-3.42,-6.54,-6.78,-7.38],['c',-0.78,-0.21,-1.20,-0.24,-2.07,-0.24],['c',-0.63,0.00,-0.84,0.00,-1.20,0.06],['c',-1.83,0.27,-3.42,1.08,-4.80,2.37],['c',-1.41,1.35,-2.40,3.21,-2.85,5.19],['c',-0.09,0.45,-0.15,0.60,-0.27,0.69],['c',-0.21,0.15,-0.57,0.09,-0.69,-0.12],['c',-0.09,-0.12,-0.09,-0.18,0.03,-0.69],['c',0.33,-1.62,0.78,-3.00,1.47,-4.38],['c',1.77,-3.54,4.44,-5.67,7.56,-5.97],['z'],['m',0.33,7.47],['c',1.38,-0.30,2.58,0.90,2.31,2.25],['c',-0.15,0.72,-0.78,1.35,-1.47,1.50],['c',-1.38,0.27,-2.58,-0.93,-2.31,-2.31],['c',0.15,-0.69,0.78,-1.29,1.47,-1.44],['z']],w:19.748,h:11.289},
		'scripts.dfermata':{d:[['M',-9.63,-0.42],['c',0.15,-0.09,0.36,-0.06,0.51,0.03],['c',0.12,0.09,0.18,0.24,0.27,0.66],['c',0.78,3.66,3.42,6.57,6.78,7.41],['c',0.78,0.21,1.20,0.24,2.07,0.24],['c',0.63,0.00,0.84,0.00,1.20,-0.06],['c',1.83,-0.27,3.42,-1.08,4.80,-2.37],['c',1.41,-1.35,2.40,-3.21,2.85,-5.22],['c',0.09,-0.42,0.15,-0.57,0.27,-0.66],['c',0.21,-0.15,0.57,-0.09,0.69,0.12],['c',0.09,0.12,0.09,0.18,-0.03,0.69],['c',-0.33,1.62,-0.78,3.00,-1.47,4.38],['c',-1.92,3.84,-4.89,6.00,-8.31,6.00],['c',-3.42,0.00,-6.39,-2.16,-8.31,-6.00],['c',-0.48,-0.96,-0.84,-1.92,-1.14,-2.97],['c',-0.18,-0.69,-0.42,-1.74,-0.42,-1.92],['c',0.00,-0.12,0.09,-0.27,0.24,-0.33],['z'],['m',9.21,0.00],['c',1.20,-0.27,2.34,0.63,2.34,1.86],['c',0.00,0.90,-0.66,1.68,-1.50,1.89],['c',-1.38,0.27,-2.58,-0.93,-2.31,-2.31],['c',0.15,-0.69,0.78,-1.29,1.47,-1.44],['z']],w:19.744,h:11.274},
		'scripts.sforzato':{d:[['M',-6.45,-3.69],['c',0.06,-0.03,0.15,-0.06,0.18,-0.06],['c',0.06,0.00,2.85,0.72,6.24,1.59],['l',6.33,1.65],['c',0.33,0.06,0.45,0.21,0.45,0.51],['c',0.00,0.30,-0.12,0.45,-0.45,0.51],['l',-6.33,1.65],['c',-3.39,0.87,-6.18,1.59,-6.21,1.59],['c',-0.21,0.00,-0.48,-0.24,-0.51,-0.45],['c',0.00,-0.15,0.06,-0.36,0.18,-0.45],['c',0.09,-0.06,0.87,-0.27,3.84,-1.05],['c',2.04,-0.54,3.84,-0.99,4.02,-1.02],['c',0.15,-0.06,1.14,-0.24,2.22,-0.42],['c',1.05,-0.18,1.92,-0.36,1.92,-0.36],['c',0.00,0.00,-0.87,-0.18,-1.92,-0.36],['c',-1.08,-0.18,-2.07,-0.36,-2.22,-0.42],['c',-0.18,-0.03,-1.98,-0.48,-4.02,-1.02],['c',-2.97,-0.78,-3.75,-0.99,-3.84,-1.05],['c',-0.12,-0.09,-0.18,-0.30,-0.18,-0.45],['c',0.03,-0.15,0.15,-0.30,0.30,-0.39],['z']],w:13.5,h:7.5},
		'scripts.staccato':{d:[['M',-0.36,-1.47],['c',0.93,-0.21,1.86,0.51,1.86,1.47],['c',0.00,0.93,-0.87,1.65,-1.80,1.47],['c',-0.54,-0.12,-1.02,-0.57,-1.14,-1.08],['c',-0.21,-0.81,0.27,-1.65,1.08,-1.86],['z']],w:2.989,h:3.004},
		'scripts.tenuto':{d:[['M',-4.20,-0.48],['l',0.12,-0.06],['l',4.08,0.00],['l',4.08,0.00],['l',0.12,0.06],['c',0.39,0.21,0.39,0.75,0.00,0.96],['l',-0.12,0.06],['l',-4.08,0.00],['l',-4.08,0.00],['l',-0.12,-0.06],['c',-0.39,-0.21,-0.39,-0.75,0.00,-0.96],['z']],w:8.985,h:1.08},
		'scripts.umarcato':{d:[['M',-0.15,-8.19],['c',0.15,-0.12,0.36,-0.03,0.45,0.15],['c',0.21,0.42,3.45,7.65,3.45,7.71],['c',0.00,0.12,-0.12,0.27,-0.21,0.30],['c',-0.03,0.03,-0.51,0.03,-1.14,0.03],['c',-1.05,0.00,-1.08,0.00,-1.17,-0.06],['c',-0.09,-0.06,-0.24,-0.36,-1.17,-2.40],['c',-0.57,-1.29,-1.05,-2.34,-1.08,-2.34],['c',0.00,-0.03,-0.51,1.02,-1.08,2.34],['c',-0.93,2.07,-1.08,2.34,-1.14,2.40],['c',-0.06,0.03,-0.15,0.06,-0.18,0.06],['c',-0.15,0.00,-0.33,-0.18,-0.33,-0.33],['c',0.00,-0.06,3.24,-7.32,3.45,-7.71],['c',0.03,-0.06,0.09,-0.15,0.15,-0.15],['z']],w:7.5,h:8.245},
		'scripts.dmarcato':{d:[['M',-3.57,0.03],['c',0.03,0.00,0.57,-0.03,1.17,-0.03],['c',1.05,0.00,1.08,0.00,1.17,0.06],['c',0.09,0.06,0.24,0.36,1.17,2.40],['c',0.57,1.29,1.05,2.34,1.08,2.34],['c',0.00,0.03,0.51,-1.02,1.08,-2.34],['c',0.93,-2.07,1.08,-2.34,1.14,-2.40],['c',0.06,-0.03,0.15,-0.06,0.18,-0.06],['c',0.15,0.00,0.33,0.18,0.33,0.33],['c',0.00,0.09,-3.45,7.74,-3.54,7.83],['c',-0.12,0.12,-0.30,0.12,-0.42,0.00],['c',-0.09,-0.09,-3.54,-7.74,-3.54,-7.83],['c',0.00,-0.09,0.12,-0.27,0.18,-0.30],['z']],w:7.5,h:8.25},
		'scripts.stopped':{d:[['M',-0.27,-4.08],['c',0.18,-0.09,0.36,-0.09,0.54,0.00],['c',0.18,0.09,0.24,0.15,0.33,0.30],['l',0.06,0.15],['l',0.00,1.50],['l',0.00,1.47],['l',1.47,0.00],['l',1.50,0.00],['l',0.15,0.06],['c',0.15,0.09,0.21,0.15,0.30,0.33],['c',0.09,0.18,0.09,0.36,0.00,0.54],['c',-0.09,0.18,-0.15,0.24,-0.33,0.33],['c',-0.12,0.06,-0.18,0.06,-1.62,0.06],['l',-1.47,0.00],['l',0.00,1.47],['l',0.00,1.47],['l',-0.06,0.15],['c',-0.09,0.18,-0.15,0.24,-0.33,0.33],['c',-0.18,0.09,-0.36,0.09,-0.54,0.00],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['l',-0.06,-0.15],['l',0.00,-1.47],['l',0.00,-1.47],['l',-1.47,0.00],['c',-1.44,0.00,-1.50,0.00,-1.62,-0.06],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['c',-0.09,-0.18,-0.09,-0.36,0.00,-0.54],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['l',0.15,-0.06],['l',1.47,0.00],['l',1.47,0.00],['l',0.00,-1.47],['c',0.00,-1.44,0.00,-1.50,0.06,-1.62],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['z']],w:8.295,h:8.295},
		'scripts.upbow':{d:[['M',-4.65,-15.54],['c',0.12,-0.09,0.36,-0.06,0.48,0.03],['c',0.03,0.03,0.09,0.09,0.12,0.15],['c',0.03,0.06,0.66,2.13,1.41,4.62],['c',1.35,4.41,1.38,4.56,2.01,6.96],['l',0.63,2.46],['l',0.63,-2.46],['c',0.63,-2.40,0.66,-2.55,2.01,-6.96],['c',0.75,-2.49,1.38,-4.56,1.41,-4.62],['c',0.06,-0.15,0.18,-0.21,0.36,-0.24],['c',0.15,0.00,0.30,0.06,0.39,0.18],['c',0.15,0.21,0.24,-0.18,-2.10,7.56],['c',-1.20,3.96,-2.22,7.32,-2.25,7.41],['c',0.00,0.12,-0.06,0.27,-0.09,0.30],['c',-0.12,0.21,-0.60,0.21,-0.72,0.00],['c',-0.03,-0.03,-0.09,-0.18,-0.09,-0.30],['c',-0.03,-0.09,-1.05,-3.45,-2.25,-7.41],['c',-2.34,-7.74,-2.25,-7.35,-2.10,-7.56],['c',0.03,-0.03,0.09,-0.09,0.15,-0.12],['z']],w:9.73,h:15.608},
		'scripts.downbow':{d:[['M',-5.55,-9.93],['l',0.09,-0.06],['l',5.46,0.00],['l',5.46,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,4.77],['c',0.00,5.28,0.00,4.89,-0.18,5.01],['c',-0.18,0.12,-0.42,0.06,-0.54,-0.12],['c',-0.06,-0.09,-0.06,-0.18,-0.06,-2.97],['l',0.00,-2.85],['l',-4.83,0.00],['l',-4.83,0.00],['l',0.00,2.85],['c',0.00,2.79,0.00,2.88,-0.06,2.97],['c',-0.15,0.24,-0.51,0.24,-0.66,0.00],['c',-0.06,-0.09,-0.06,-0.21,-0.06,-4.89],['l',0.00,-4.77],['z']],w:11.22,h:9.992},
		'scripts.turn':{d:[['M',-4.77,-3.90],['c',0.36,-0.06,1.05,-0.06,1.44,0.03],['c',0.78,0.15,1.50,0.51,2.34,1.14],['c',0.60,0.45,1.05,0.87,2.22,2.01],['c',1.11,1.08,1.62,1.50,2.22,1.86],['c',0.60,0.36,1.32,0.57,1.92,0.57],['c',0.90,0.00,1.71,-0.57,1.89,-1.35],['c',0.24,-0.93,-0.39,-1.89,-1.35,-2.10],['l',-0.15,-0.06],['l',-0.09,0.15],['c',-0.03,0.09,-0.15,0.24,-0.24,0.33],['c',-0.72,0.72,-2.04,0.54,-2.49,-0.36],['c',-0.48,-0.93,0.03,-1.86,1.17,-2.19],['c',0.30,-0.09,1.02,-0.09,1.35,0.00],['c',0.99,0.27,1.74,0.87,2.25,1.83],['c',0.69,1.41,0.63,3.00,-0.21,4.26],['c',-0.21,0.30,-0.69,0.81,-0.99,1.02],['c',-0.30,0.21,-0.84,0.45,-1.17,0.54],['c',-1.23,0.36,-2.49,0.15,-3.72,-0.60],['c',-0.75,-0.48,-1.41,-1.02,-2.85,-2.46],['c',-1.11,-1.08,-1.62,-1.50,-2.22,-1.86],['c',-0.60,-0.36,-1.32,-0.57,-1.92,-0.57],['c',-0.90,0.00,-1.71,0.57,-1.89,1.35],['c',-0.24,0.93,0.39,1.89,1.35,2.10],['l',0.15,0.06],['l',0.09,-0.15],['c',0.03,-0.09,0.15,-0.24,0.24,-0.33],['c',0.72,-0.72,2.04,-0.54,2.49,0.36],['c',0.48,0.93,-0.03,1.86,-1.17,2.19],['c',-0.30,0.09,-1.02,0.09,-1.35,0.00],['c',-0.99,-0.27,-1.74,-0.87,-2.25,-1.83],['c',-0.69,-1.41,-0.63,-3.00,0.21,-4.26],['c',0.21,-0.30,0.69,-0.81,0.99,-1.02],['c',0.48,-0.33,1.11,-0.57,1.74,-0.66],['z']],w:16.366,h:7.893},
		'scripts.trill':{d:[['M',-0.51,-16.02],['c',0.12,-0.09,0.21,-0.18,0.21,-0.18],['l',-0.81,4.02],['l',-0.81,4.02],['c',0.03,0.00,0.51,-0.27,1.08,-0.60],['c',0.60,-0.30,1.14,-0.63,1.26,-0.66],['c',1.14,-0.54,2.31,-0.60,3.09,-0.18],['c',0.27,0.15,0.54,0.36,0.60,0.51],['l',0.06,0.12],['l',0.21,-0.21],['c',0.90,-0.81,2.22,-0.99,3.12,-0.42],['c',0.60,0.42,0.90,1.14,0.78,2.07],['c',-0.15,1.29,-1.05,2.31,-1.95,2.25],['c',-0.48,-0.03,-0.78,-0.30,-0.96,-0.81],['c',-0.09,-0.27,-0.09,-0.90,-0.03,-1.20],['c',0.21,-0.75,0.81,-1.23,1.59,-1.32],['l',0.24,-0.03],['l',-0.09,-0.12],['c',-0.51,-0.66,-1.62,-0.63,-2.31,0.03],['c',-0.39,0.42,-0.30,0.09,-1.23,4.77],['l',-0.81,4.14],['c',-0.03,0.00,-0.12,-0.03,-0.21,-0.09],['c',-0.33,-0.15,-0.54,-0.18,-0.99,-0.18],['c',-0.42,0.00,-0.66,0.03,-1.05,0.18],['c',-0.12,0.06,-0.21,0.09,-0.21,0.09],['c',0.00,-0.03,0.36,-1.86,0.81,-4.11],['c',0.90,-4.47,0.87,-4.26,0.69,-4.53],['c',-0.21,-0.36,-0.66,-0.51,-1.17,-0.36],['c',-0.15,0.06,-2.22,1.14,-2.58,1.38],['c',-0.12,0.09,-0.12,0.09,-0.21,0.60],['l',-0.09,0.51],['l',0.21,0.24],['c',0.63,0.75,1.02,1.47,1.20,2.19],['c',0.06,0.27,0.06,0.36,0.06,0.81],['c',0.00,0.42,0.00,0.54,-0.06,0.78],['c',-0.15,0.54,-0.33,0.93,-0.63,1.35],['c',-0.18,0.24,-0.57,0.63,-0.81,0.78],['c',-0.24,0.15,-0.63,0.36,-0.84,0.42],['c',-0.27,0.06,-0.66,0.06,-0.87,0.03],['c',-0.81,-0.18,-1.32,-1.05,-1.38,-2.46],['c',-0.03,-0.60,0.03,-0.99,0.33,-2.46],['c',0.21,-1.08,0.24,-1.32,0.21,-1.29],['c',-1.20,0.48,-2.40,0.75,-3.21,0.72],['c',-0.69,-0.06,-1.17,-0.30,-1.41,-0.72],['c',-0.39,-0.75,-0.12,-1.80,0.66,-2.46],['c',0.24,-0.18,0.69,-0.42,1.02,-0.51],['c',0.69,-0.18,1.53,-0.15,2.31,0.09],['c',0.30,0.09,0.75,0.30,0.99,0.45],['c',0.12,0.09,0.15,0.09,0.15,0.03],['c',0.03,-0.03,0.33,-1.59,0.72,-3.45],['c',0.36,-1.86,0.66,-3.42,0.69,-3.45],['c',0.00,-0.03,0.03,-0.03,0.21,0.03],['c',0.21,0.06,0.27,0.06,0.48,0.06],['c',0.42,-0.03,0.78,-0.18,1.26,-0.48],['c',0.15,-0.12,0.36,-0.27,0.48,-0.39],['z'],['m',-5.73,7.68],['c',-0.27,-0.03,-0.96,-0.06,-1.20,-0.03],['c',-0.81,0.12,-1.35,0.57,-1.50,1.20],['c',-0.18,0.66,0.12,1.14,0.75,1.29],['c',0.66,0.12,1.92,-0.12,3.18,-0.66],['l',0.33,-0.15],['l',0.09,-0.39],['c',0.06,-0.21,0.09,-0.42,0.09,-0.45],['c',0.00,-0.03,-0.45,-0.30,-0.75,-0.45],['c',-0.27,-0.15,-0.66,-0.27,-0.99,-0.36],['z'],['m',4.29,3.63],['c',-0.24,-0.39,-0.51,-0.75,-0.51,-0.69],['c',-0.06,0.12,-0.39,1.92,-0.45,2.28],['c',-0.09,0.54,-0.12,1.14,-0.06,1.38],['c',0.06,0.42,0.21,0.60,0.51,0.57],['c',0.39,-0.06,0.75,-0.48,0.93,-1.14],['c',0.09,-0.33,0.09,-1.05,0.00,-1.38],['c',-0.09,-0.39,-0.24,-0.69,-0.42,-1.02],['z']],w:17.963,h:16.49},
		'scripts.segno':{d:[['M',-3.72,-11.22],['c',0.78,-0.09,1.59,0.03,2.31,0.42],['c',1.20,0.60,2.01,1.71,2.31,3.09],['c',0.09,0.42,0.09,1.20,0.03,1.50],['c',-0.15,0.45,-0.39,0.81,-0.66,0.93],['c',-0.33,0.18,-0.84,0.21,-1.23,0.15],['c',-0.81,-0.18,-1.32,-0.93,-1.26,-1.89],['c',0.03,-0.36,0.09,-0.57,0.24,-0.90],['c',0.15,-0.33,0.45,-0.60,0.72,-0.75],['c',0.12,-0.06,0.18,-0.09,0.18,-0.12],['c',0.00,-0.03,-0.03,-0.15,-0.09,-0.24],['c',-0.18,-0.45,-0.54,-0.87,-0.96,-1.08],['c',-1.11,-0.57,-2.34,-0.18,-2.88,0.90],['c',-0.24,0.51,-0.33,1.11,-0.24,1.83],['c',0.27,1.92,1.50,3.54,3.93,5.13],['c',0.48,0.33,1.26,0.78,1.29,0.78],['c',0.03,0.00,1.35,-2.19,2.94,-4.89],['l',2.88,-4.89],['l',0.84,0.00],['l',0.87,0.00],['l',-0.03,0.06],['c',-0.15,0.21,-6.15,10.41,-6.15,10.44],['c',0.00,0.00,0.21,0.15,0.48,0.27],['c',2.61,1.47,4.35,3.03,5.13,4.65],['c',1.14,2.34,0.51,5.07,-1.44,6.39],['c',-0.66,0.42,-1.32,0.63,-2.13,0.69],['c',-2.01,0.09,-3.81,-1.41,-4.26,-3.54],['c',-0.09,-0.42,-0.09,-1.20,-0.03,-1.50],['c',0.15,-0.45,0.39,-0.81,0.66,-0.93],['c',0.33,-0.18,0.84,-0.21,1.23,-0.15],['c',0.81,0.18,1.32,0.93,1.26,1.89],['c',-0.03,0.36,-0.09,0.57,-0.24,0.90],['c',-0.15,0.33,-0.45,0.60,-0.72,0.75],['c',-0.12,0.06,-0.18,0.09,-0.18,0.12],['c',0.00,0.03,0.03,0.15,0.09,0.24],['c',0.18,0.45,0.54,0.87,0.96,1.08],['c',1.11,0.57,2.34,0.18,2.88,-0.90],['c',0.24,-0.51,0.33,-1.11,0.24,-1.83],['c',-0.27,-1.92,-1.50,-3.54,-3.93,-5.13],['c',-0.48,-0.33,-1.26,-0.78,-1.29,-0.78],['c',-0.03,0.00,-1.35,2.19,-2.91,4.89],['l',-2.88,4.89],['l',-0.87,0.00],['l',-0.87,0.00],['l',0.03,-0.06],['c',0.15,-0.21,6.15,-10.41,6.15,-10.44],['c',0.00,0.00,-0.21,-0.15,-0.48,-0.30],['c',-2.61,-1.44,-4.35,-3.00,-5.13,-4.62],['c',-0.90,-1.89,-0.72,-4.02,0.48,-5.52],['c',0.69,-0.84,1.68,-1.41,2.73,-1.53],['z'],['m',8.76,9.09],['c',0.03,-0.03,0.15,-0.03,0.27,-0.03],['c',0.33,0.03,0.57,0.18,0.72,0.48],['c',0.09,0.18,0.09,0.57,0.00,0.75],['c',-0.09,0.18,-0.21,0.30,-0.36,0.39],['c',-0.15,0.06,-0.21,0.06,-0.39,0.06],['c',-0.21,0.00,-0.27,0.00,-0.39,-0.06],['c',-0.30,-0.15,-0.48,-0.45,-0.48,-0.75],['c',0.00,-0.39,0.24,-0.72,0.63,-0.84],['z'],['m',-10.53,2.61],['c',0.03,-0.03,0.15,-0.03,0.27,-0.03],['c',0.33,0.03,0.57,0.18,0.72,0.48],['c',0.09,0.18,0.09,0.57,0.00,0.75],['c',-0.09,0.18,-0.21,0.30,-0.36,0.39],['c',-0.15,0.06,-0.21,0.06,-0.39,0.06],['c',-0.21,0.00,-0.27,0.00,-0.39,-0.06],['c',-0.30,-0.15,-0.48,-0.45,-0.48,-0.75],['c',0.00,-0.39,0.24,-0.72,0.63,-0.84],['z']],w:15,h:22.504},
		'scripts.coda':{d:[['M',-0.21,-10.47],['c',0.18,-0.12,0.42,-0.06,0.54,0.12],['c',0.06,0.09,0.06,0.18,0.06,1.50],['l',0.00,1.38],['l',0.18,0.00],['c',0.39,0.06,0.96,0.24,1.38,0.48],['c',1.68,0.93,2.82,3.24,3.03,6.12],['c',0.03,0.24,0.03,0.45,0.03,0.45],['c',0.00,0.03,0.60,0.03,1.35,0.03],['c',1.50,0.00,1.47,0.00,1.59,0.18],['c',0.09,0.12,0.09,0.30,0.00,0.42],['c',-0.12,0.18,-0.09,0.18,-1.59,0.18],['c',-0.75,0.00,-1.35,0.00,-1.35,0.03],['c',0.00,0.00,0.00,0.21,-0.03,0.42],['c',-0.24,3.15,-1.53,5.58,-3.45,6.36],['c',-0.27,0.12,-0.72,0.24,-0.96,0.27],['l',-0.18,0.00],['l',0.00,1.38],['c',0.00,1.32,0.00,1.41,-0.06,1.50],['c',-0.15,0.24,-0.51,0.24,-0.66,0.00],['c',-0.06,-0.09,-0.06,-0.18,-0.06,-1.50],['l',0.00,-1.38],['l',-0.18,0.00],['c',-0.39,-0.06,-0.96,-0.24,-1.38,-0.48],['c',-1.68,-0.93,-2.82,-3.24,-3.03,-6.15],['c',-0.03,-0.21,-0.03,-0.42,-0.03,-0.42],['c',0.00,-0.03,-0.60,-0.03,-1.35,-0.03],['c',-1.50,0.00,-1.47,0.00,-1.59,-0.18],['c',-0.09,-0.12,-0.09,-0.30,0.00,-0.42],['c',0.12,-0.18,0.09,-0.18,1.59,-0.18],['c',0.75,0.00,1.35,0.00,1.35,-0.03],['c',0.00,0.00,0.00,-0.21,0.03,-0.45],['c',0.24,-3.12,1.53,-5.55,3.45,-6.33],['c',0.27,-0.12,0.72,-0.24,0.96,-0.27],['l',0.18,0.00],['l',0.00,-1.38],['c',0.00,-1.53,0.00,-1.50,0.18,-1.62],['z'],['m',-0.18,6.93],['c',0.00,-2.97,0.00,-3.15,-0.06,-3.15],['c',-0.09,0.00,-0.51,0.15,-0.66,0.21],['c',-0.87,0.51,-1.38,1.62,-1.56,3.51],['c',-0.06,0.54,-0.12,1.59,-0.12,2.16],['l',0.00,0.42],['l',1.20,0.00],['l',1.20,0.00],['l',0.00,-3.15],['z'],['m',1.17,-3.06],['c',-0.09,-0.03,-0.21,-0.06,-0.27,-0.09],['l',-0.12,0.00],['l',0.00,3.15],['l',0.00,3.15],['l',1.20,0.00],['l',1.20,0.00],['l',0.00,-0.81],['c',-0.06,-2.40,-0.33,-3.69,-0.93,-4.59],['c',-0.27,-0.39,-0.66,-0.69,-1.08,-0.81],['z'],['m',-1.17,10.14],['l',0.00,-3.15],['l',-1.20,0.00],['l',-1.20,0.00],['l',0.00,0.81],['c',0.03,0.96,0.06,1.47,0.15,2.13],['c',0.24,2.04,0.96,3.12,2.13,3.36],['l',0.12,0.00],['l',0.00,-3.15],['z'],['m',3.18,-2.34],['l',0.00,-0.81],['l',-1.20,0.00],['l',-1.20,0.00],['l',0.00,3.15],['l',0.00,3.15],['l',0.12,0.00],['c',1.17,-0.24,1.89,-1.32,2.13,-3.36],['c',0.09,-0.66,0.12,-1.17,0.15,-2.13],['z']],w:16.035,h:21.062},
		'scripts.comma':{d:[['M',1.14,-4.62],['c',0.30,-0.12,0.69,-0.03,0.93,0.15],['c',0.12,0.12,0.36,0.45,0.51,0.78],['c',0.90,1.77,0.54,4.05,-1.08,6.75],['c',-0.36,0.63,-0.87,1.38,-0.96,1.44],['c',-0.18,0.12,-0.42,0.06,-0.54,-0.12],['c',-0.09,-0.18,-0.09,-0.30,0.12,-0.60],['c',0.96,-1.44,1.44,-2.97,1.38,-4.35],['c',-0.06,-0.93,-0.30,-1.68,-0.78,-2.46],['c',-0.27,-0.39,-0.33,-0.63,-0.24,-0.96],['c',0.09,-0.27,0.36,-0.54,0.66,-0.63],['z']],w:3.042,h:9.237},
		'scripts.roll':{d:[['M',1.95,-6.00],['c',0.21,-0.09,0.36,-0.09,0.57,0.00],['c',0.39,0.15,0.63,0.39,1.47,1.35],['c',0.66,0.75,0.78,0.87,1.08,1.05],['c',0.75,0.45,1.65,0.42,2.40,-0.06],['c',0.12,-0.09,0.27,-0.27,0.54,-0.60],['c',0.42,-0.54,0.51,-0.63,0.69,-0.63],['c',0.09,0.00,0.30,0.12,0.36,0.21],['c',0.09,0.12,0.12,0.30,0.03,0.42],['c',-0.06,0.12,-3.15,3.90,-3.30,4.08],['c',-0.06,0.06,-0.18,0.12,-0.27,0.18],['c',-0.27,0.12,-0.60,0.06,-0.99,-0.27],['c',-0.27,-0.21,-0.42,-0.39,-1.08,-1.14],['c',-0.63,-0.72,-0.81,-0.90,-1.17,-1.08],['c',-0.36,-0.18,-0.57,-0.21,-0.99,-0.21],['c',-0.39,0.00,-0.63,0.03,-0.93,0.18],['c',-0.36,0.15,-0.51,0.27,-0.90,0.81],['c',-0.24,0.27,-0.45,0.51,-0.48,0.54],['c',-0.12,0.09,-0.27,0.06,-0.39,0.00],['c',-0.24,-0.15,-0.33,-0.39,-0.21,-0.60],['c',0.09,-0.12,3.18,-3.87,3.33,-4.02],['c',0.06,-0.06,0.18,-0.15,0.24,-0.21],['z']],w:10.817,h:6.125},
		'scripts.prall':{d:[['M',-4.38,-3.69],['c',0.06,-0.03,0.18,-0.06,0.24,-0.06],['c',0.30,0.00,0.27,-0.03,1.89,1.95],['l',1.53,1.83],['c',0.03,0.00,0.57,-0.84,1.23,-1.83],['c',1.14,-1.68,1.23,-1.83,1.35,-1.89],['c',0.06,-0.03,0.18,-0.06,0.24,-0.06],['c',0.30,0.00,0.27,-0.03,1.89,1.95],['l',1.53,1.83],['l',0.48,-0.69],['c',0.51,-0.78,0.54,-0.84,0.69,-0.90],['c',0.42,-0.18,0.87,0.15,0.81,0.60],['c',-0.03,0.12,-0.30,0.51,-1.50,2.37],['c',-1.38,2.07,-1.50,2.22,-1.62,2.28],['c',-0.06,0.03,-0.18,0.06,-0.24,0.06],['c',-0.30,0.00,-0.27,0.03,-1.89,-1.95],['l',-1.53,-1.83],['c',-0.03,0.00,-0.57,0.84,-1.23,1.83],['c',-1.14,1.68,-1.23,1.83,-1.35,1.89],['c',-0.06,0.03,-0.18,0.06,-0.24,0.06],['c',-0.30,0.00,-0.27,0.03,-1.89,-1.95],['l',-1.53,-1.83],['l',-0.48,0.69],['c',-0.51,0.78,-0.54,0.84,-0.69,0.90],['c',-0.42,0.18,-0.87,-0.15,-0.81,-0.60],['c',0.03,-0.12,0.30,-0.51,1.50,-2.37],['c',1.38,-2.07,1.50,-2.22,1.62,-2.28],['z']],w:15.011,h:7.5},
		'scripts.arpeggio':{d:[['M',1.5,0],['c',1.5,2,1.5,3,1.5,3],['s',0,1,-2,1.5],['s',-0.5,3,1,5.5],['l',1.5,0],['s',-1.75,-2,-1.9,-3.25],['s',2.15,-0.6,2.95,-1.6],['s',0.45,-1,0.5,-1.25],['s',0,-1,-2,-3.9],['l',-1.5,0],['z']],w:5,h:10},
		'scripts.mordent':{d:[['M',-0.21,-4.95],['c',0.27,-0.15,0.63,0.00,0.75,0.27],['c',0.06,0.12,0.06,0.24,0.06,1.44],['l',0.00,1.29],['l',0.57,-0.84],['c',0.51,-0.75,0.57,-0.84,0.69,-0.90],['c',0.06,-0.03,0.18,-0.06,0.24,-0.06],['c',0.30,0.00,0.27,-0.03,1.89,1.95],['l',1.53,1.83],['l',0.48,-0.69],['c',0.51,-0.78,0.54,-0.84,0.69,-0.90],['c',0.42,-0.18,0.87,0.15,0.81,0.60],['c',-0.03,0.12,-0.30,0.51,-1.50,2.37],['c',-1.38,2.07,-1.50,2.22,-1.62,2.28],['c',-0.06,0.03,-0.18,0.06,-0.24,0.06],['c',-0.30,0.00,-0.27,0.03,-1.83,-1.89],['c',-0.81,-0.99,-1.50,-1.80,-1.53,-1.86],['c',-0.06,-0.03,-0.06,-0.03,-0.12,0.03],['c',-0.06,0.06,-0.06,0.15,-0.06,2.28],['c',0.00,1.95,0.00,2.25,-0.06,2.34],['c',-0.18,0.45,-0.81,0.48,-1.05,0.03],['c',-0.03,-0.06,-0.06,-0.24,-0.06,-1.41],['l',0.00,-1.35],['l',-0.57,0.84],['c',-0.54,0.78,-0.60,0.87,-0.72,0.93],['c',-0.06,0.03,-0.18,0.06,-0.24,0.06],['c',-0.30,0.00,-0.27,0.03,-1.89,-1.95],['l',-1.53,-1.83],['l',-0.48,0.69],['c',-0.51,0.78,-0.54,0.84,-0.69,0.90],['c',-0.42,0.18,-0.87,-0.15,-0.81,-0.60],['c',0.03,-0.12,0.30,-0.51,1.50,-2.37],['c',1.38,-2.07,1.50,-2.22,1.62,-2.28],['c',0.06,-0.03,0.18,-0.06,0.24,-0.06],['c',0.30,0.00,0.27,-0.03,1.89,1.95],['l',1.53,1.83],['c',0.03,0.00,0.06,-0.06,0.09,-0.09],['c',0.06,-0.12,0.06,-0.15,0.06,-2.28],['c',0.00,-1.92,0.00,-2.22,0.06,-2.31],['c',0.06,-0.15,0.15,-0.24,0.30,-0.30],['z']],w:15.011,h:10.012},
		'flags.u8th':{d:[['M',-0.42,3.75],['l',0.00,-3.75],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,0.18],['c',0.00,0.30,0.06,0.84,0.12,1.23],['c',0.24,1.53,0.90,3.12,2.13,5.16],['l',0.99,1.59],['c',0.87,1.44,1.38,2.34,1.77,3.09],['c',0.81,1.68,1.20,3.06,1.26,4.53],['c',0.03,1.53,-0.21,3.27,-0.75,5.01],['c',-0.21,0.69,-0.51,1.50,-0.60,1.59],['c',-0.09,0.12,-0.27,0.21,-0.42,0.21],['c',-0.15,0.00,-0.42,-0.12,-0.51,-0.21],['c',-0.15,-0.18,-0.18,-0.42,-0.09,-0.66],['c',0.15,-0.33,0.45,-1.20,0.57,-1.62],['c',0.42,-1.38,0.60,-2.58,0.60,-3.90],['c',0.00,-0.66,0.00,-0.81,-0.06,-1.11],['c',-0.39,-2.07,-1.80,-4.26,-4.59,-7.14],['l',-0.42,-0.45],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-3.75],['z']],w:6.692,h:22.59},
		'flags.u16th':{d:[['M',-0.42,7.50],['l',0.00,-7.50],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,0.39],['c',0.06,1.08,0.39,2.19,0.99,3.39],['c',0.45,0.90,0.87,1.59,1.95,3.12],['c',1.29,1.86,1.77,2.64,2.22,3.57],['c',0.45,0.93,0.72,1.80,0.87,2.64],['c',0.06,0.51,0.06,1.50,0.00,1.92],['c',-0.12,0.60,-0.30,1.20,-0.54,1.71],['l',-0.09,0.24],['l',0.18,0.45],['c',0.51,1.20,0.72,2.22,0.69,3.42],['c',-0.06,1.53,-0.39,3.03,-0.99,4.53],['c',-0.30,0.75,-0.36,0.81,-0.57,0.90],['c',-0.15,0.09,-0.33,0.06,-0.48,0.00],['c',-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],['c',-0.09,-0.18,-0.06,-0.30,0.12,-0.75],['c',0.66,-1.41,1.02,-2.88,1.08,-4.32],['c',0.00,-0.60,-0.03,-1.05,-0.18,-1.59],['c',-0.30,-1.20,-0.99,-2.40,-2.25,-3.87],['c',-0.42,-0.48,-1.53,-1.62,-2.19,-2.22],['l',-0.45,-0.42],['l',-0.03,1.11],['l',0.00,1.11],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-7.50],['z'],['m',1.65,0.09],['c',-0.30,-0.30,-0.69,-0.72,-0.90,-0.87],['l',-0.33,-0.33],['l',0.00,0.15],['c',0.00,0.30,0.06,0.81,0.15,1.26],['c',0.27,1.29,0.87,2.61,2.04,4.29],['c',0.15,0.24,0.60,0.87,0.96,1.38],['l',1.08,1.53],['l',0.42,0.63],['c',0.03,0.00,0.12,-0.36,0.21,-0.72],['c',0.06,-0.33,0.06,-1.20,0.00,-1.62],['c',-0.33,-1.71,-1.44,-3.48,-3.63,-5.70],['z']],w:6.693,h:26.337},
		'flags.u32nd':{d:[['M',-0.42,11.25],['l',0.00,-11.25],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,0.36],['c',0.09,1.68,0.69,3.27,2.07,5.46],['l',0.87,1.35],['c',1.02,1.62,1.47,2.37,1.86,3.18],['c',0.48,1.02,0.78,1.92,0.93,2.88],['c',0.06,0.48,0.06,1.50,0.00,1.89],['c',-0.09,0.42,-0.21,0.87,-0.36,1.26],['l',-0.12,0.30],['l',0.15,0.39],['c',0.69,1.56,0.84,2.88,0.54,4.38],['c',-0.09,0.45,-0.27,1.08,-0.45,1.47],['l',-0.12,0.24],['l',0.18,0.36],['c',0.33,0.72,0.57,1.56,0.69,2.34],['c',0.12,1.02,-0.06,2.52,-0.42,3.84],['c',-0.27,0.93,-0.75,2.13,-0.93,2.31],['c',-0.18,0.15,-0.45,0.18,-0.66,0.09],['c',-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],['c',-0.09,-0.18,-0.06,-0.30,0.06,-0.60],['c',0.21,-0.36,0.42,-0.90,0.57,-1.38],['c',0.51,-1.41,0.69,-3.06,0.48,-4.08],['c',-0.15,-0.81,-0.57,-1.68,-1.20,-2.55],['c',-0.72,-0.99,-1.83,-2.13,-3.30,-3.33],['l',-0.48,-0.42],['l',-0.03,1.53],['l',0.00,1.56],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-11.25],['z'],['m',1.26,-3.96],['c',-0.27,-0.30,-0.54,-0.60,-0.66,-0.72],['l',-0.18,-0.21],['l',0.00,0.42],['c',0.06,0.87,0.24,1.74,0.66,2.67],['c',0.36,0.87,0.96,1.86,1.92,3.18],['c',0.21,0.33,0.63,0.87,0.87,1.23],['c',0.27,0.39,0.60,0.84,0.75,1.08],['l',0.27,0.39],['l',0.03,-0.12],['c',0.12,-0.45,0.15,-1.05,0.09,-1.59],['c',-0.27,-1.86,-1.38,-3.78,-3.75,-6.33],['z'],['m',-0.27,6.09],['c',-0.27,-0.21,-0.48,-0.42,-0.51,-0.45],['c',-0.06,-0.03,-0.06,-0.03,-0.06,0.21],['c',0.00,0.90,0.30,2.04,0.81,3.09],['c',0.48,1.02,0.96,1.77,2.37,3.63],['c',0.60,0.78,1.05,1.44,1.29,1.77],['c',0.06,0.12,0.15,0.21,0.15,0.18],['c',0.03,-0.03,0.18,-0.57,0.24,-0.87],['c',0.06,-0.45,0.06,-1.32,-0.03,-1.74],['c',-0.09,-0.48,-0.24,-0.90,-0.51,-1.44],['c',-0.66,-1.35,-1.83,-2.70,-3.75,-4.38],['z']],w:6.697,h:32.145},
		'flags.u64th':{d:[['M',-0.42,15.00],['l',0.00,-15.00],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,0.36],['c',0.06,1.20,0.39,2.37,1.02,3.66],['c',0.39,0.81,0.84,1.56,1.80,3.09],['c',0.81,1.26,1.05,1.68,1.35,2.22],['c',0.87,1.50,1.35,2.79,1.56,4.08],['c',0.06,0.54,0.06,1.56,-0.03,2.04],['c',-0.09,0.48,-0.21,0.99,-0.36,1.35],['l',-0.12,0.27],['l',0.12,0.27],['c',0.09,0.15,0.21,0.45,0.27,0.66],['c',0.69,1.89,0.63,3.66,-0.18,5.46],['l',-0.18,0.39],['l',0.15,0.33],['c',0.30,0.66,0.51,1.44,0.63,2.10],['c',0.06,0.48,0.06,1.35,0.00,1.71],['c',-0.15,0.57,-0.42,1.20,-0.78,1.68],['l',-0.21,0.27],['l',0.18,0.33],['c',0.57,1.05,0.93,2.13,1.02,3.18],['c',0.06,0.72,0.00,1.83,-0.21,2.79],['c',-0.18,1.02,-0.63,2.34,-1.02,3.09],['c',-0.15,0.33,-0.48,0.45,-0.78,0.30],['c',-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],['c',-0.09,-0.18,-0.06,-0.30,0.03,-0.54],['c',0.75,-1.50,1.23,-3.45,1.17,-4.89],['c',-0.06,-1.02,-0.42,-2.01,-1.17,-3.15],['c',-0.48,-0.72,-1.02,-1.35,-1.89,-2.22],['c',-0.57,-0.57,-1.56,-1.50,-1.92,-1.77],['l',-0.12,-0.09],['l',0.00,1.68],['l',0.00,1.68],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-15.00],['z'],['m',0.93,-8.07],['c',-0.27,-0.30,-0.48,-0.54,-0.51,-0.54],['c',0.00,0.00,0.00,0.69,0.03,1.02],['c',0.15,1.47,0.75,2.94,2.04,4.83],['l',1.08,1.53],['c',0.39,0.57,0.84,1.20,0.99,1.44],['c',0.15,0.24,0.30,0.45,0.30,0.45],['c',0.00,0.00,0.03,-0.09,0.06,-0.21],['c',0.36,-1.59,-0.15,-3.33,-1.47,-5.40],['c',-0.63,-0.93,-1.35,-1.83,-2.52,-3.12],['z'],['m',0.06,6.72],['c',-0.24,-0.21,-0.48,-0.42,-0.51,-0.45],['l',-0.06,-0.06],['l',0.00,0.33],['c',0.00,1.20,0.30,2.34,0.93,3.60],['c',0.45,0.90,0.96,1.68,2.25,3.51],['c',0.39,0.54,0.84,1.17,1.02,1.44],['c',0.21,0.33,0.33,0.51,0.33,0.48],['c',0.06,-0.09,0.21,-0.63,0.30,-0.99],['c',0.06,-0.33,0.06,-0.45,0.06,-0.96],['c',0.00,-0.60,-0.03,-0.84,-0.18,-1.35],['c',-0.30,-1.08,-1.02,-2.28,-2.13,-3.57],['c',-0.39,-0.45,-1.44,-1.47,-2.01,-1.98],['z'],['m',0.00,6.72],['c',-0.24,-0.21,-0.48,-0.39,-0.51,-0.42],['l',-0.06,-0.06],['l',0.00,0.33],['c',0.00,1.41,0.45,2.82,1.38,4.35],['c',0.42,0.72,0.72,1.14,1.86,2.73],['c',0.36,0.45,0.75,0.99,0.87,1.20],['c',0.15,0.21,0.30,0.36,0.30,0.36],['c',0.06,0.00,0.30,-0.48,0.39,-0.75],['c',0.09,-0.36,0.12,-0.63,0.12,-1.05],['c',-0.06,-1.05,-0.45,-2.04,-1.20,-3.18],['c',-0.57,-0.87,-1.11,-1.53,-2.07,-2.49],['c',-0.36,-0.33,-0.84,-0.78,-1.08,-1.02],['z']],w:6.682,h:39.694},
		'flags.d8th':{d:[['M',5.67,-21.63],['c',0.24,-0.12,0.54,-0.06,0.69,0.15],['c',0.06,0.06,0.21,0.36,0.39,0.66],['c',0.84,1.77,1.26,3.36,1.32,5.10],['c',0.03,1.29,-0.21,2.37,-0.81,3.63],['c',-0.60,1.23,-1.26,2.13,-3.21,4.38],['c',-1.35,1.53,-1.86,2.19,-2.40,2.97],['c',-0.63,0.93,-1.11,1.92,-1.38,2.79],['c',-0.15,0.54,-0.27,1.35,-0.27,1.80],['l',0.00,0.15],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-3.75],['l',0.00,-3.75],['l',0.21,0.00],['l',0.21,0.00],['l',0.48,-0.30],['c',1.83,-1.11,3.12,-2.10,4.17,-3.12],['c',0.78,-0.81,1.32,-1.53,1.71,-2.31],['c',0.45,-0.93,0.60,-1.74,0.51,-2.88],['c',-0.12,-1.56,-0.63,-3.18,-1.47,-4.68],['c',-0.12,-0.21,-0.15,-0.33,-0.06,-0.51],['c',0.06,-0.15,0.15,-0.24,0.33,-0.33],['z']],w:8.492,h:21.691},
		'flags.ugrace':{d:[['M',6.03,6.93],['c',0.15,-0.09,0.33,-0.06,0.51,0.00],['c',0.15,0.09,0.21,0.15,0.30,0.33],['c',0.09,0.18,0.06,0.39,-0.03,0.54],['c',-0.06,0.15,-10.89,8.88,-11.07,8.97],['c',-0.15,0.09,-0.33,0.06,-0.48,0.00],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['c',-0.09,-0.18,-0.06,-0.39,0.03,-0.54],['c',0.06,-0.15,10.89,-8.88,11.07,-8.97],['z']],w:12.019,h:9.954},
		'flags.dgrace':{d:[['M',-6.06,-15.93],['c',0.18,-0.09,0.33,-0.12,0.48,-0.06],['c',0.18,0.09,14.01,8.04,14.10,8.10],['c',0.12,0.12,0.18,0.33,0.18,0.51],['c',-0.03,0.21,-0.15,0.39,-0.36,0.48],['c',-0.18,0.09,-0.33,0.12,-0.48,0.06],['c',-0.18,-0.09,-14.01,-8.04,-14.10,-8.10],['c',-0.12,-0.12,-0.18,-0.33,-0.18,-0.51],['c',0.03,-0.21,0.15,-0.39,0.36,-0.48],['z']],w:15.12,h:9.212},
		'flags.d16th':{d:[['M',6.84,-22.53],['c',0.27,-0.12,0.57,-0.06,0.72,0.15],['c',0.15,0.15,0.33,0.87,0.45,1.56],['c',0.06,0.33,0.06,1.35,0.00,1.65],['c',-0.06,0.33,-0.15,0.78,-0.27,1.11],['c',-0.12,0.33,-0.45,0.96,-0.66,1.32],['l',-0.18,0.27],['l',0.09,0.18],['c',0.48,1.02,0.72,2.25,0.69,3.30],['c',-0.06,1.23,-0.42,2.28,-1.26,3.45],['c',-0.57,0.87,-0.99,1.32,-3.00,3.39],['c',-1.56,1.56,-2.22,2.40,-2.76,3.45],['c',-0.42,0.84,-0.66,1.80,-0.66,2.55],['l',0.00,0.15],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-7.50],['l',0.00,-7.50],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,1.14],['l',0.00,1.11],['l',0.27,-0.15],['c',1.11,-0.57,1.77,-0.99,2.52,-1.47],['c',2.37,-1.56,3.69,-3.15,4.05,-4.83],['c',0.03,-0.18,0.03,-0.39,0.03,-0.78],['c',0.00,-0.60,-0.03,-0.93,-0.24,-1.50],['c',-0.06,-0.18,-0.12,-0.39,-0.15,-0.45],['c',-0.03,-0.24,0.12,-0.48,0.36,-0.60],['z'],['m',-0.63,7.50],['c',-0.06,-0.18,-0.15,-0.36,-0.15,-0.36],['c',-0.03,0.00,-0.03,0.03,-0.06,0.06],['c',-0.06,0.12,-0.96,1.02,-1.95,1.98],['c',-0.63,0.57,-1.26,1.17,-1.44,1.35],['c',-1.53,1.62,-2.28,2.85,-2.55,4.32],['c',-0.03,0.18,-0.03,0.54,-0.06,0.99],['l',0.00,0.69],['l',0.18,-0.09],['c',0.93,-0.54,2.10,-1.29,2.82,-1.83],['c',0.69,-0.51,1.02,-0.81,1.53,-1.29],['c',1.86,-1.89,2.37,-3.66,1.68,-5.82],['z']],w:8.475,h:22.591},
		'flags.d32nd':{d:[['M',6.84,-29.13],['c',0.27,-0.12,0.57,-0.06,0.72,0.15],['c',0.12,0.12,0.27,0.63,0.36,1.11],['c',0.33,1.59,0.06,3.06,-0.81,4.47],['l',-0.18,0.27],['l',0.09,0.15],['c',0.12,0.24,0.33,0.69,0.45,1.05],['c',0.63,1.83,0.45,3.57,-0.57,5.22],['l',-0.18,0.30],['l',0.15,0.27],['c',0.42,0.87,0.60,1.71,0.57,2.61],['c',-0.06,1.29,-0.48,2.46,-1.35,3.78],['c',-0.54,0.81,-0.93,1.29,-2.46,3.00],['c',-0.51,0.54,-1.05,1.17,-1.26,1.41],['c',-1.56,1.86,-2.25,3.36,-2.37,5.01],['l',0.00,0.33],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-11.25],['l',0.00,-11.25],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,1.35],['l',0.03,1.35],['l',0.78,-0.39],['c',1.38,-0.69,2.34,-1.26,3.24,-1.92],['c',1.38,-1.02,2.28,-2.13,2.64,-3.21],['c',0.15,-0.48,0.18,-0.72,0.18,-1.29],['c',0.00,-0.57,-0.06,-0.90,-0.24,-1.47],['c',-0.06,-0.18,-0.12,-0.39,-0.15,-0.45],['c',-0.03,-0.24,0.12,-0.48,0.36,-0.60],['z'],['m',-0.63,7.20],['c',-0.09,-0.18,-0.12,-0.21,-0.12,-0.15],['c',-0.03,0.09,-1.02,1.08,-2.04,2.04],['c',-1.17,1.08,-1.65,1.56,-2.07,2.04],['c',-0.84,0.96,-1.38,1.86,-1.68,2.76],['c',-0.21,0.57,-0.27,0.99,-0.30,1.65],['l',0.00,0.54],['l',0.66,-0.33],['c',3.57,-1.86,5.49,-3.69,5.94,-5.70],['c',0.06,-0.39,0.06,-1.20,-0.03,-1.65],['c',-0.06,-0.39,-0.24,-0.90,-0.36,-1.20],['z'],['m',-0.06,7.20],['c',-0.06,-0.15,-0.12,-0.33,-0.15,-0.45],['l',-0.06,-0.18],['l',-0.18,0.21],['l',-1.83,1.83],['c',-0.87,0.90,-1.77,1.80,-1.95,2.01],['c',-1.08,1.29,-1.62,2.31,-1.89,3.51],['c',-0.06,0.30,-0.06,0.51,-0.09,0.93],['l',0.00,0.57],['l',0.09,-0.06],['c',0.75,-0.45,1.89,-1.26,2.52,-1.74],['c',0.81,-0.66,1.74,-1.53,2.22,-2.16],['c',1.26,-1.53,1.68,-3.06,1.32,-4.47],['z']],w:8.385,h:29.191},
		'flags.d64th':{d:[['M',7.08,-32.88],['c',0.30,-0.12,0.66,-0.03,0.78,0.24],['c',0.18,0.33,0.27,2.10,0.15,2.64],['c',-0.09,0.39,-0.21,0.78,-0.39,1.08],['l',-0.15,0.30],['l',0.09,0.27],['c',0.03,0.12,0.09,0.45,0.12,0.69],['c',0.27,1.44,0.18,2.55,-0.30,3.60],['l',-0.12,0.33],['l',0.06,0.42],['c',0.27,1.35,0.33,2.82,0.21,3.63],['c',-0.12,0.60,-0.30,1.23,-0.57,1.80],['l',-0.15,0.27],['l',0.03,0.42],['c',0.06,1.02,0.06,2.70,0.03,3.06],['c',-0.15,1.47,-0.66,2.76,-1.74,4.41],['c',-0.45,0.69,-0.75,1.11,-1.74,2.37],['c',-1.05,1.38,-1.50,1.98,-1.95,2.73],['c',-0.93,1.50,-1.38,2.82,-1.44,4.20],['l',0.00,0.42],['l',-0.21,0.00],['l',-0.21,0.00],['l',0.00,-15.00],['l',0.00,-15.00],['l',0.21,0.00],['l',0.21,0.00],['l',0.00,1.86],['l',0.00,1.89],['c',0.00,0.00,0.21,-0.03,0.45,-0.09],['c',2.22,-0.39,4.08,-1.11,5.19,-2.01],['c',0.63,-0.54,1.02,-1.14,1.20,-1.80],['c',0.06,-0.30,0.06,-1.14,-0.03,-1.65],['c',-0.03,-0.18,-0.06,-0.39,-0.09,-0.48],['c',-0.03,-0.24,0.12,-0.48,0.36,-0.60],['z'],['m',-0.45,6.15],['c',-0.03,-0.18,-0.06,-0.42,-0.06,-0.54],['l',-0.03,-0.18],['l',-0.33,0.30],['c',-0.42,0.36,-0.87,0.72,-1.68,1.29],['c',-1.98,1.38,-2.25,1.59,-2.85,2.16],['c',-0.75,0.69,-1.23,1.44,-1.47,2.19],['c',-0.15,0.45,-0.18,0.63,-0.21,1.35],['l',0.00,0.66],['l',0.39,-0.18],['c',1.83,-0.90,3.45,-1.95,4.47,-2.91],['c',0.93,-0.90,1.53,-1.83,1.74,-2.82],['c',0.06,-0.33,0.06,-0.87,0.03,-1.32],['z'],['m',-0.27,4.86],['c',-0.03,-0.21,-0.06,-0.36,-0.06,-0.36],['c',0.00,-0.03,-0.12,0.09,-0.24,0.24],['c',-0.39,0.48,-0.99,1.08,-2.16,2.19],['c',-1.47,1.38,-1.92,1.83,-2.46,2.49],['c',-0.66,0.87,-1.08,1.74,-1.29,2.58],['c',-0.09,0.42,-0.15,0.87,-0.15,1.44],['l',0.00,0.54],['l',0.48,-0.33],['c',1.50,-1.02,2.58,-1.89,3.51,-2.82],['c',1.47,-1.47,2.25,-2.85,2.40,-4.26],['c',0.03,-0.39,0.03,-1.17,-0.03,-1.71],['z'],['m',-0.66,7.68],['c',0.03,-0.15,0.03,-0.60,0.03,-0.99],['l',0.00,-0.72],['l',-0.27,0.33],['l',-1.74,1.98],['c',-1.77,1.92,-2.43,2.76,-2.97,3.90],['c',-0.51,1.02,-0.72,1.77,-0.75,2.91],['c',0.00,0.63,0.00,0.63,0.06,0.60],['c',0.03,-0.03,0.30,-0.27,0.63,-0.54],['c',0.66,-0.60,1.86,-1.80,2.31,-2.31],['c',1.65,-1.89,2.52,-3.54,2.70,-5.16],['z']],w:8.485,h:32.932},
		'clefs.C':{d:[['M',0.06,-14.94],['l',0.09,-0.06],['l',1.92,0.00],['l',1.92,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,14.85],['l',0.00,14.82],['l',-0.06,0.09],['l',-0.09,0.06],['l',-1.92,0.00],['l',-1.92,0.00],['l',-0.09,-0.06],['l',-0.06,-0.09],['l',0.00,-14.82],['l',0.00,-14.85],['z'],['m',5.37,0.00],['c',0.09,-0.06,0.09,-0.06,0.57,-0.06],['c',0.45,0.00,0.45,0.00,0.54,0.06],['l',0.06,0.09],['l',0.00,7.14],['l',0.00,7.11],['l',0.09,-0.06],['c',0.18,-0.18,0.72,-0.84,0.96,-1.20],['c',0.30,-0.45,0.66,-1.17,0.84,-1.65],['c',0.36,-0.90,0.57,-1.83,0.60,-2.79],['c',0.03,-0.48,0.03,-0.54,0.09,-0.63],['c',0.12,-0.18,0.36,-0.21,0.54,-0.12],['c',0.18,0.09,0.21,0.15,0.24,0.66],['c',0.06,0.87,0.21,1.56,0.57,2.22],['c',0.51,1.02,1.26,1.68,2.22,1.92],['c',0.21,0.06,0.33,0.06,0.78,0.06],['c',0.45,0.00,0.57,0.00,0.84,-0.06],['c',0.45,-0.12,0.81,-0.33,1.08,-0.60],['c',0.57,-0.57,0.87,-1.41,0.99,-2.88],['c',0.06,-0.54,0.06,-3.00,0.00,-3.57],['c',-0.21,-2.58,-0.84,-3.87,-2.16,-4.50],['c',-0.48,-0.21,-1.17,-0.36,-1.77,-0.36],['c',-0.69,0.00,-1.29,0.27,-1.50,0.72],['c',-0.06,0.15,-0.06,0.21,-0.06,0.42],['c',0.00,0.24,0.00,0.30,0.06,0.45],['c',0.12,0.24,0.24,0.39,0.63,0.66],['c',0.42,0.30,0.57,0.48,0.69,0.72],['c',0.06,0.15,0.06,0.21,0.06,0.48],['c',0.00,0.39,-0.03,0.63,-0.21,0.96],['c',-0.30,0.60,-0.87,1.08,-1.50,1.26],['c',-0.27,0.06,-0.87,0.06,-1.14,0.00],['c',-0.78,-0.24,-1.44,-0.87,-1.65,-1.68],['c',-0.12,-0.42,-0.09,-1.17,0.09,-1.71],['c',0.51,-1.65,1.98,-2.82,3.81,-3.09],['c',0.84,-0.09,2.46,0.03,3.51,0.27],['c',2.22,0.57,3.69,1.80,4.44,3.75],['c',0.36,0.93,0.57,2.13,0.57,3.36],['c',0.00,1.44,-0.48,2.73,-1.38,3.81],['c',-1.26,1.50,-3.27,2.43,-5.28,2.43],['c',-0.48,0.00,-0.51,0.00,-0.75,-0.09],['c',-0.15,-0.03,-0.48,-0.21,-0.78,-0.36],['c',-0.69,-0.36,-0.87,-0.42,-1.26,-0.42],['c',-0.27,0.00,-0.30,0.00,-0.51,0.09],['c',-0.57,0.30,-0.81,0.90,-0.81,2.10],['c',0.00,1.23,0.24,1.83,0.81,2.13],['c',0.21,0.09,0.24,0.09,0.51,0.09],['c',0.39,0.00,0.57,-0.06,1.26,-0.42],['c',0.30,-0.15,0.63,-0.33,0.78,-0.36],['c',0.24,-0.09,0.27,-0.09,0.75,-0.09],['c',2.01,0.00,4.02,0.93,5.28,2.40],['c',0.90,1.11,1.38,2.40,1.38,3.84],['c',0.00,1.50,-0.30,2.88,-0.84,3.96],['c',-0.78,1.59,-2.19,2.64,-4.17,3.15],['c',-1.05,0.24,-2.67,0.36,-3.51,0.27],['c',-1.83,-0.27,-3.30,-1.44,-3.81,-3.09],['c',-0.18,-0.54,-0.21,-1.29,-0.09,-1.74],['c',0.15,-0.60,0.63,-1.20,1.23,-1.47],['c',0.36,-0.18,0.57,-0.21,0.99,-0.21],['c',0.42,0.00,0.63,0.03,1.02,0.21],['c',0.42,0.21,0.84,0.63,1.05,1.05],['c',0.18,0.36,0.21,0.60,0.21,0.96],['c',0.00,0.30,0.00,0.36,-0.06,0.51],['c',-0.12,0.24,-0.27,0.42,-0.69,0.72],['c',-0.57,0.42,-0.69,0.63,-0.69,1.08],['c',0.00,0.24,0.00,0.30,0.06,0.45],['c',0.12,0.21,0.30,0.39,0.57,0.54],['c',0.42,0.18,0.87,0.21,1.53,0.15],['c',1.08,-0.15,1.80,-0.57,2.34,-1.32],['c',0.54,-0.75,0.84,-1.83,0.99,-3.51],['c',0.06,-0.57,0.06,-3.03,0.00,-3.57],['c',-0.12,-1.47,-0.42,-2.31,-0.99,-2.88],['c',-0.27,-0.27,-0.63,-0.48,-1.08,-0.60],['c',-0.27,-0.06,-0.39,-0.06,-0.84,-0.06],['c',-0.45,0.00,-0.57,0.00,-0.78,0.06],['c',-1.14,0.27,-2.01,1.17,-2.46,2.49],['c',-0.21,0.57,-0.30,0.99,-0.33,1.65],['c',-0.03,0.51,-0.06,0.57,-0.24,0.66],['c',-0.12,0.06,-0.27,0.06,-0.39,0.00],['c',-0.21,-0.09,-0.21,-0.15,-0.24,-0.75],['c',-0.09,-1.92,-0.78,-3.72,-2.01,-5.19],['c',-0.18,-0.21,-0.36,-0.42,-0.39,-0.45],['l',-0.09,-0.06],['l',0.00,7.11],['l',0.00,7.14],['l',-0.06,0.09],['c',-0.09,0.06,-0.09,0.06,-0.54,0.06],['c',-0.48,0.00,-0.48,0.00,-0.57,-0.06],['l',-0.06,-0.09],['l',0.00,-14.82],['l',0.00,-14.85],['z']],w:20.31,h:29.97},
		'clefs.F':{d:[['M',6.30,-7.80],['c',0.36,-0.03,1.65,0.00,2.13,0.03],['c',3.60,0.42,6.03,2.10,6.93,4.86],['c',0.27,0.84,0.36,1.50,0.36,2.58],['c',0.00,0.90,-0.03,1.35,-0.18,2.16],['c',-0.78,3.78,-3.54,7.08,-8.37,9.96],['c',-1.74,1.05,-3.87,2.13,-6.18,3.12],['c',-0.39,0.18,-0.75,0.33,-0.81,0.36],['c',-0.06,0.03,-0.15,0.06,-0.18,0.06],['c',-0.15,0.00,-0.33,-0.18,-0.33,-0.33],['c',0.00,-0.15,0.06,-0.21,0.51,-0.48],['c',3.00,-1.77,5.13,-3.21,6.84,-4.74],['c',0.51,-0.45,1.59,-1.50,1.95,-1.95],['c',1.89,-2.19,2.88,-4.32,3.15,-6.78],['c',0.06,-0.42,0.06,-1.77,0.00,-2.19],['c',-0.24,-2.01,-0.93,-3.63,-2.04,-4.71],['c',-0.63,-0.63,-1.29,-1.02,-2.07,-1.20],['c',-1.62,-0.39,-3.36,0.15,-4.56,1.44],['c',-0.54,0.60,-1.05,1.47,-1.32,2.22],['l',-0.09,0.21],['l',0.24,-0.12],['c',0.39,-0.21,0.63,-0.24,1.11,-0.24],['c',0.30,0.00,0.45,0.00,0.66,0.06],['c',1.92,0.48,2.85,2.55,1.95,4.38],['c',-0.45,0.99,-1.41,1.62,-2.46,1.71],['c',-1.47,0.09,-2.91,-0.87,-3.39,-2.25],['c',-0.18,-0.57,-0.21,-1.32,-0.03,-2.28],['c',0.39,-2.25,1.83,-4.20,3.81,-5.19],['c',0.69,-0.36,1.59,-0.60,2.37,-0.69],['z'],['m',11.58,2.52],['c',0.84,-0.21,1.71,0.30,1.89,1.14],['c',0.30,1.17,-0.72,2.19,-1.89,1.89],['c',-0.99,-0.21,-1.50,-1.32,-1.02,-2.25],['c',0.18,-0.39,0.60,-0.69,1.02,-0.78],['z'],['m',0.00,7.50],['c',0.84,-0.21,1.71,0.30,1.89,1.14],['c',0.21,0.87,-0.30,1.71,-1.14,1.89],['c',-0.87,0.21,-1.71,-0.30,-1.89,-1.14],['c',-0.21,-0.84,0.30,-1.71,1.14,-1.89],['z']],w:20.153,h:23.142},
		'clefs.G':{d:[['M',9.69,-37.41],['c',0.09,-0.09,0.24,-0.06,0.36,0.00],['c',0.12,0.09,0.57,0.60,0.96,1.11],['c',1.77,2.34,3.21,5.85,3.57,8.73],['c',0.21,1.56,0.03,3.27,-0.45,4.86],['c',-0.69,2.31,-1.92,4.47,-4.23,7.44],['c',-0.30,0.39,-0.57,0.72,-0.60,0.75],['c',-0.03,0.06,0.00,0.15,0.18,0.78],['c',0.54,1.68,1.38,4.44,1.68,5.49],['l',0.09,0.42],['l',0.39,0.00],['c',1.47,0.09,2.76,0.51,3.96,1.29],['c',1.83,1.23,3.06,3.21,3.39,5.52],['c',0.09,0.45,0.12,1.29,0.06,1.74],['c',-0.09,1.02,-0.33,1.83,-0.75,2.73],['c',-0.84,1.71,-2.28,3.06,-4.02,3.72],['l',-0.33,0.12],['l',0.03,1.26],['c',0.00,1.74,-0.06,3.63,-0.21,4.62],['c',-0.45,3.06,-2.19,5.49,-4.47,6.21],['c',-0.57,0.18,-0.90,0.21,-1.59,0.21],['c',-0.69,0.00,-1.02,-0.03,-1.65,-0.21],['c',-1.14,-0.27,-2.13,-0.84,-2.94,-1.65],['c',-0.99,-0.99,-1.56,-2.16,-1.71,-3.54],['c',-0.09,-0.81,0.06,-1.53,0.45,-2.13],['c',0.63,-0.99,1.83,-1.56,3.00,-1.53],['c',1.50,0.09,2.64,1.32,2.73,2.94],['c',0.06,1.47,-0.93,2.70,-2.37,2.97],['c',-0.45,0.06,-0.84,0.03,-1.29,-0.09],['l',-0.21,-0.09],['l',0.09,0.12],['c',0.39,0.54,0.78,0.93,1.32,1.26],['c',1.35,0.87,3.06,1.02,4.35,0.36],['c',1.44,-0.72,2.52,-2.28,2.97,-4.35],['c',0.15,-0.66,0.24,-1.50,0.30,-3.03],['c',0.03,-0.84,0.03,-2.94,0.00,-3.00],['c',-0.03,0.00,-0.18,0.00,-0.36,0.03],['c',-0.66,0.12,-0.99,0.12,-1.83,0.12],['c',-1.05,0.00,-1.71,-0.06,-2.61,-0.30],['c',-4.02,-0.99,-7.11,-4.35,-7.80,-8.46],['c',-0.12,-0.66,-0.12,-0.99,-0.12,-1.83],['c',0.00,-0.84,0.00,-1.14,0.15,-1.92],['c',0.36,-2.28,1.41,-4.62,3.30,-7.29],['l',2.79,-3.60],['c',0.54,-0.66,0.96,-1.20,0.96,-1.23],['c',0.00,-0.03,-0.09,-0.33,-0.18,-0.69],['c',-0.96,-3.21,-1.41,-5.28,-1.59,-7.68],['c',-0.12,-1.38,-0.15,-3.09,-0.06,-3.96],['c',0.33,-2.67,1.38,-5.07,3.12,-7.08],['c',0.36,-0.42,0.99,-1.05,1.17,-1.14],['z'],['m',2.01,4.71],['c',-0.15,-0.30,-0.30,-0.54,-0.30,-0.54],['c',-0.03,0.00,-0.18,0.09,-0.30,0.21],['c',-2.40,1.74,-3.87,4.20,-4.26,7.11],['c',-0.06,0.54,-0.06,1.41,-0.03,1.89],['c',0.09,1.29,0.48,3.12,1.08,5.22],['c',0.15,0.42,0.24,0.78,0.24,0.81],['c',0.00,0.03,0.84,-1.11,1.23,-1.68],['c',1.89,-2.73,2.88,-5.07,3.15,-7.53],['c',0.09,-0.57,0.12,-1.74,0.06,-2.37],['c',-0.09,-1.23,-0.27,-1.92,-0.87,-3.12],['z'],['m',-2.94,20.70],['c',-0.21,-0.72,-0.39,-1.32,-0.42,-1.32],['c',0.00,0.00,-1.20,1.47,-1.86,2.37],['c',-2.79,3.63,-4.02,6.30,-4.35,9.30],['c',-0.03,0.21,-0.03,0.69,-0.03,1.08],['c',0.00,0.69,0.00,0.75,0.06,1.11],['c',0.12,0.54,0.27,0.99,0.51,1.47],['c',0.69,1.38,1.83,2.55,3.42,3.42],['c',0.96,0.54,2.07,0.90,3.21,1.08],['c',0.78,0.12,2.04,0.12,2.94,-0.03],['c',0.51,-0.06,0.45,-0.03,0.42,-0.30],['c',-0.24,-3.33,-0.72,-6.33,-1.62,-10.08],['c',-0.09,-0.39,-0.18,-0.75,-0.18,-0.78],['c',-0.03,-0.03,-0.42,0.00,-0.81,0.09],['c',-0.90,0.18,-1.65,0.57,-2.22,1.14],['c',-0.72,0.72,-1.08,1.65,-1.05,2.64],['c',0.06,0.96,0.48,1.83,1.23,2.58],['c',0.36,0.36,0.72,0.63,1.17,0.90],['c',0.33,0.18,0.36,0.21,0.42,0.33],['c',0.18,0.42,-0.18,0.90,-0.60,0.87],['c',-0.18,-0.03,-0.84,-0.36,-1.26,-0.63],['c',-0.78,-0.51,-1.38,-1.11,-1.86,-1.83],['c',-1.77,-2.70,-0.99,-6.42,1.71,-8.19],['c',0.30,-0.21,0.81,-0.48,1.17,-0.63],['c',0.30,-0.09,1.02,-0.30,1.14,-0.30],['c',0.06,0.00,0.09,0.00,0.09,-0.03],['c',0.03,-0.03,-0.51,-1.92,-1.23,-4.26],['z'],['m',3.78,7.41],['c',-0.18,-0.03,-0.36,-0.06,-0.39,-0.06],['c',-0.03,0.00,0.00,0.21,0.18,1.02],['c',0.75,3.18,1.26,6.30,1.50,9.09],['c',0.06,0.72,0.00,0.69,0.51,0.42],['c',0.78,-0.36,1.44,-0.96,1.98,-1.77],['c',1.08,-1.62,1.20,-3.69,0.30,-5.55],['c',-0.81,-1.62,-2.31,-2.79,-4.08,-3.15],['z']],w:19.051,h:57.057},
		'clefs.perc':{d:[['M',5.07,-7.44],['l',0.09,-0.06],['l',1.53,0.00],['l',1.53,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,7.35],['l',0.00,7.32],['l',-0.06,0.09],['l',-0.09,0.06],['l',-1.53,0.00],['l',-1.53,0.00],['l',-0.09,-0.06],['l',-0.06,-0.09],['l',0.00,-7.32],['l',0.00,-7.35],['z'],['m',6.63,0.00],['l',0.09,-0.06],['l',1.53,0.00],['l',1.53,0.00],['l',0.09,0.06],['l',0.06,0.09],['l',0.00,7.35],['l',0.00,7.32],['l',-0.06,0.09],['l',-0.09,0.06],['l',-1.53,0.00],['l',-1.53,0.00],['l',-0.09,-0.06],['l',-0.06,-0.09],['l',0.00,-7.32],['l',0.00,-7.35],['z']],w:9.99,h:14.97},
		'timesig.common':{d:[['M',6.66,-7.83],['c',0.72,-0.06,1.41,-0.03,1.98,0.09],['c',1.20,0.27,2.34,0.96,3.09,1.92],['c',0.63,0.81,1.08,1.86,1.14,2.73],['c',0.06,1.02,-0.51,1.92,-1.44,2.22],['c',-0.24,0.09,-0.30,0.09,-0.63,0.09],['c',-0.33,0.00,-0.42,0.00,-0.63,-0.06],['c',-0.66,-0.24,-1.14,-0.63,-1.41,-1.20],['c',-0.15,-0.30,-0.21,-0.51,-0.24,-0.90],['c',-0.06,-1.08,0.57,-2.04,1.56,-2.37],['c',0.18,-0.06,0.27,-0.06,0.63,-0.06],['l',0.45,0.00],['c',0.06,0.03,0.09,0.03,0.09,0.00],['c',0.00,0.00,-0.09,-0.12,-0.24,-0.27],['c',-1.02,-1.11,-2.55,-1.68,-4.08,-1.50],['c',-1.29,0.15,-2.04,0.69,-2.40,1.74],['c',-0.36,0.93,-0.42,1.89,-0.42,5.37],['c',0.00,2.97,0.06,3.96,0.24,4.77],['c',0.24,1.08,0.63,1.68,1.41,2.07],['c',0.81,0.39,2.16,0.45,3.18,0.09],['c',1.29,-0.45,2.37,-1.53,3.03,-2.97],['c',0.15,-0.33,0.33,-0.87,0.39,-1.17],['c',0.09,-0.24,0.15,-0.36,0.30,-0.39],['c',0.21,-0.03,0.42,0.15,0.39,0.36],['c',-0.06,0.39,-0.42,1.38,-0.69,1.89],['c',-0.96,1.80,-2.49,2.94,-4.23,3.18],['c',-0.99,0.12,-2.58,-0.06,-3.63,-0.45],['c',-0.96,-0.36,-1.71,-0.84,-2.40,-1.50],['c',-1.11,-1.11,-1.80,-2.61,-2.04,-4.56],['c',-0.06,-0.60,-0.06,-2.01,0.00,-2.61],['c',0.24,-1.95,0.90,-3.45,2.01,-4.56],['c',0.69,-0.66,1.44,-1.11,2.37,-1.47],['c',0.63,-0.24,1.47,-0.42,2.22,-0.48],['z']],w:13.038,h:15.689},
		'timesig.cut':{d:[['M',6.24,-10.44],['c',0.09,-0.06,0.09,-0.06,0.48,-0.06],['c',0.36,0.00,0.36,0.00,0.45,0.06],['l',0.06,0.09],['l',0.00,1.23],['l',0.00,1.26],['l',0.27,0.00],['c',1.26,0.00,2.49,0.45,3.48,1.29],['c',1.05,0.87,1.80,2.28,1.89,3.48],['c',0.06,1.02,-0.51,1.92,-1.44,2.22],['c',-0.24,0.09,-0.30,0.09,-0.63,0.09],['c',-0.33,0.00,-0.42,0.00,-0.63,-0.06],['c',-0.66,-0.24,-1.14,-0.63,-1.41,-1.20],['c',-0.15,-0.30,-0.21,-0.51,-0.24,-0.90],['c',-0.06,-1.08,0.57,-2.04,1.56,-2.37],['c',0.18,-0.06,0.27,-0.06,0.63,-0.06],['l',0.45,0.00],['c',0.06,0.03,0.09,0.03,0.09,0.00],['c',0.00,-0.03,-0.45,-0.51,-0.66,-0.69],['c',-0.87,-0.69,-1.83,-1.05,-2.94,-1.11],['l',-0.42,0.00],['l',0.00,7.17],['l',0.00,7.14],['l',0.42,0.00],['c',0.69,-0.03,1.23,-0.18,1.86,-0.51],['c',1.05,-0.51,1.89,-1.47,2.46,-2.70],['c',0.15,-0.33,0.33,-0.87,0.39,-1.17],['c',0.09,-0.24,0.15,-0.36,0.30,-0.39],['c',0.21,-0.03,0.42,0.15,0.39,0.36],['c',-0.03,0.24,-0.21,0.78,-0.39,1.20],['c',-0.96,2.37,-2.94,3.90,-5.13,3.90],['l',-0.30,0.00],['l',0.00,1.26],['l',0.00,1.23],['l',-0.06,0.09],['c',-0.09,0.06,-0.09,0.06,-0.45,0.06],['c',-0.39,0.00,-0.39,0.00,-0.48,-0.06],['l',-0.06,-0.09],['l',0.00,-1.29],['l',0.00,-1.29],['l',-0.21,-0.03],['c',-1.23,-0.21,-2.31,-0.63,-3.21,-1.29],['c',-0.15,-0.09,-0.45,-0.36,-0.66,-0.57],['c',-1.11,-1.11,-1.80,-2.61,-2.04,-4.56],['c',-0.06,-0.60,-0.06,-2.01,0.00,-2.61],['c',0.24,-1.95,0.93,-3.45,2.04,-4.59],['c',0.42,-0.39,0.78,-0.66,1.26,-0.93],['c',0.75,-0.45,1.65,-0.75,2.61,-0.90],['l',0.21,-0.03],['l',0.00,-1.29],['l',0.00,-1.29],['z'],['m',-0.06,10.44],['c',0.00,-5.58,0.00,-6.99,-0.03,-6.99],['c',-0.15,0.00,-0.63,0.27,-0.87,0.45],['c',-0.45,0.36,-0.75,0.93,-0.93,1.77],['c',-0.18,0.81,-0.24,1.80,-0.24,4.74],['c',0.00,2.97,0.06,3.96,0.24,4.77],['c',0.24,1.08,0.66,1.68,1.41,2.07],['c',0.12,0.06,0.30,0.12,0.33,0.15],['l',0.09,0.00],['l',0.00,-6.96],['z']],w:13.038,h:20.97},
		'timesig.imperfectum':{d:[['M',13,-5],['a',8,8,0,1,0,0,10]],w:13.038,h:20.97},
		'timesig.imperfectum2':{d:[['M',13,-5],['a',8,8,0,1,0,0,10]],w:13.038,h:20.97},
		'timesig.perfectum':{d:[['M',13,-5],['a',8,8,0,1,0,0,10]],w:13.038,h:20.97},
		'timesig.perfectum2':{d:[['M',13,-5],['a',8,8,0,1,0,0,10]],w:13.038,h:20.97},
		'f':{d:[['M',9.93,-14.28],['c',1.53,-0.18,2.88,0.45,3.12,1.50],['c',0.12,0.51,0.00,1.32,-0.27,1.86],['c',-0.15,0.30,-0.42,0.57,-0.63,0.69],['c',-0.69,0.36,-1.56,0.03,-1.83,-0.69],['c',-0.09,-0.24,-0.09,-0.69,0.00,-0.87],['c',0.06,-0.12,0.21,-0.24,0.45,-0.42],['c',0.42,-0.24,0.57,-0.45,0.60,-0.72],['c',0.03,-0.33,-0.09,-0.39,-0.63,-0.42],['c',-0.30,0.00,-0.45,0.00,-0.60,0.03],['c',-0.81,0.21,-1.35,0.93,-1.74,2.46],['c',-0.06,0.27,-0.48,2.25,-0.48,2.31],['c',0.00,0.03,0.39,0.03,0.90,0.03],['c',0.72,0.00,0.90,0.00,0.99,0.06],['c',0.42,0.15,0.45,0.72,0.03,0.90],['c',-0.12,0.06,-0.24,0.06,-1.17,0.06],['l',-1.05,0.00],['l',-0.78,2.55],['c',-0.45,1.41,-0.87,2.79,-0.96,3.06],['c',-0.87,2.37,-2.37,4.74,-3.78,5.91],['c',-1.05,0.90,-2.04,1.23,-3.09,1.08],['c',-1.11,-0.18,-1.89,-0.78,-2.04,-1.59],['c',-0.12,-0.66,0.15,-1.71,0.54,-2.19],['c',0.69,-0.75,1.86,-0.54,2.22,0.39],['c',0.06,0.15,0.09,0.27,0.09,0.48],['c',0.00,0.24,-0.03,0.27,-0.12,0.42],['c',-0.03,0.09,-0.15,0.18,-0.27,0.27],['c',-0.09,0.06,-0.27,0.21,-0.36,0.27],['c',-0.24,0.18,-0.36,0.36,-0.39,0.60],['c',-0.03,0.33,0.09,0.39,0.63,0.42],['c',0.42,0.00,0.63,-0.03,0.90,-0.15],['c',0.60,-0.30,0.96,-0.96,1.38,-2.64],['c',0.09,-0.42,0.63,-2.55,1.17,-4.77],['l',1.02,-4.08],['c',0.00,-0.03,-0.36,-0.03,-0.81,-0.03],['c',-0.72,0.00,-0.81,0.00,-0.93,-0.06],['c',-0.42,-0.18,-0.39,-0.75,0.03,-0.90],['c',0.09,-0.06,0.27,-0.06,1.05,-0.06],['l',0.96,0.00],['l',0.00,-0.09],['c',0.06,-0.18,0.30,-0.72,0.51,-1.17],['c',1.20,-2.46,3.30,-4.23,5.34,-4.50],['z']],w:16.155,h:19.445},
		'm':{d:[['M',2.79,-8.91],['c',0.09,0.00,0.30,-0.03,0.45,-0.03],['c',0.24,0.03,0.30,0.03,0.45,0.12],['c',0.36,0.15,0.63,0.54,0.75,1.02],['l',0.03,0.21],['l',0.33,-0.30],['c',0.69,-0.69,1.38,-1.02,2.07,-1.02],['c',0.27,0.00,0.33,0.00,0.48,0.06],['c',0.21,0.09,0.48,0.36,0.63,0.60],['c',0.03,0.09,0.12,0.27,0.18,0.42],['c',0.03,0.15,0.09,0.27,0.12,0.27],['c',0.00,0.00,0.09,-0.09,0.18,-0.21],['c',0.33,-0.39,0.87,-0.81,1.29,-0.99],['c',0.78,-0.33,1.47,-0.21,2.01,0.33],['c',0.30,0.33,0.48,0.69,0.60,1.14],['c',0.09,0.42,0.06,0.54,-0.54,3.06],['c',-0.33,1.29,-0.57,2.40,-0.57,2.43],['c',0.00,0.12,0.09,0.21,0.21,0.21],['c',0.24,0.00,0.75,-0.30,1.20,-0.72],['c',0.45,-0.39,0.60,-0.45,0.78,-0.27],['c',0.18,0.18,0.09,0.36,-0.45,0.87],['c',-1.05,0.96,-1.83,1.47,-2.58,1.71],['c',-0.93,0.33,-1.53,0.21,-1.80,-0.33],['c',-0.06,-0.15,-0.06,-0.21,-0.06,-0.45],['c',0.00,-0.24,0.03,-0.48,0.60,-2.82],['c',0.42,-1.71,0.60,-2.64,0.63,-2.79],['c',0.03,-0.57,-0.30,-0.75,-0.84,-0.48],['c',-0.24,0.12,-0.54,0.39,-0.66,0.63],['c',-0.03,0.09,-0.42,1.38,-0.90,3.00],['c',-0.90,3.15,-0.84,3.00,-1.14,3.15],['l',-0.15,0.09],['l',-0.78,0.00],['c',-0.60,0.00,-0.78,0.00,-0.84,-0.06],['c',-0.09,-0.03,-0.18,-0.18,-0.18,-0.27],['c',0.00,-0.03,0.36,-1.38,0.84,-2.97],['c',0.57,-2.04,0.81,-2.97,0.84,-3.12],['c',0.03,-0.54,-0.30,-0.72,-0.84,-0.45],['c',-0.24,0.12,-0.57,0.42,-0.66,0.63],['c',-0.06,0.09,-0.51,1.44,-1.05,2.97],['c',-0.51,1.56,-0.99,2.85,-0.99,2.91],['c',-0.06,0.12,-0.21,0.24,-0.36,0.30],['c',-0.12,0.06,-0.21,0.06,-0.90,0.06],['c',-0.60,0.00,-0.78,0.00,-0.84,-0.06],['c',-0.09,-0.03,-0.18,-0.18,-0.18,-0.27],['c',0.00,-0.03,0.45,-1.38,0.99,-2.97],['c',1.05,-3.18,1.05,-3.18,0.93,-3.45],['c',-0.12,-0.27,-0.39,-0.30,-0.72,-0.15],['c',-0.54,0.27,-1.14,1.17,-1.56,2.40],['c',-0.06,0.15,-0.15,0.30,-0.18,0.36],['c',-0.21,0.21,-0.57,0.27,-0.72,0.09],['c',-0.09,-0.09,-0.06,-0.21,0.06,-0.63],['c',0.48,-1.26,1.26,-2.46,2.01,-3.21],['c',0.57,-0.54,1.20,-0.87,1.83,-1.02],['z']],w:14.687,h:9.126},
		'p':{d:[['M',1.92,-8.70],['c',0.27,-0.09,0.81,-0.06,1.11,0.03],['c',0.54,0.18,0.93,0.51,1.17,0.99],['c',0.09,0.15,0.15,0.33,0.18,0.36],['l',0.00,0.12],['l',0.30,-0.27],['c',0.66,-0.60,1.35,-1.02,2.13,-1.20],['c',0.21,-0.06,0.33,-0.06,0.78,-0.06],['c',0.45,0.00,0.51,0.00,0.84,0.09],['c',1.29,0.33,2.07,1.32,2.25,2.79],['c',0.09,0.81,-0.09,2.01,-0.45,2.79],['c',-0.54,1.26,-1.86,2.55,-3.18,3.03],['c',-0.45,0.18,-0.81,0.24,-1.29,0.24],['c',-0.69,-0.03,-1.35,-0.18,-1.86,-0.45],['c',-0.30,-0.15,-0.51,-0.18,-0.69,-0.09],['c',-0.09,0.03,-0.18,0.09,-0.18,0.12],['c',-0.09,0.12,-1.05,2.94,-1.05,3.06],['c',0.00,0.24,0.18,0.48,0.51,0.63],['c',0.18,0.06,0.54,0.15,0.75,0.15],['c',0.21,0.00,0.36,0.06,0.42,0.18],['c',0.12,0.18,0.06,0.42,-0.12,0.54],['c',-0.09,0.03,-0.15,0.03,-0.78,0.00],['c',-1.98,-0.15,-3.81,-0.15,-5.79,0.00],['c',-0.63,0.03,-0.69,0.03,-0.78,0.00],['c',-0.24,-0.15,-0.24,-0.57,0.03,-0.66],['c',0.06,-0.03,0.48,-0.09,0.99,-0.12],['c',0.87,-0.06,1.11,-0.09,1.35,-0.21],['c',0.18,-0.06,0.33,-0.18,0.39,-0.30],['c',0.06,-0.12,3.24,-9.42,3.27,-9.60],['c',0.06,-0.33,0.03,-0.57,-0.15,-0.69],['c',-0.09,-0.06,-0.12,-0.06,-0.30,-0.06],['c',-0.69,0.06,-1.53,1.02,-2.28,2.61],['c',-0.09,0.21,-0.21,0.45,-0.27,0.51],['c',-0.09,0.12,-0.33,0.24,-0.48,0.24],['c',-0.18,0.00,-0.36,-0.15,-0.36,-0.30],['c',0.00,-0.24,0.78,-1.83,1.26,-2.55],['c',0.72,-1.11,1.47,-1.74,2.28,-1.92],['z'],['m',5.37,1.47],['c',-0.27,-0.12,-0.75,-0.03,-1.14,0.21],['c',-0.75,0.48,-1.47,1.68,-1.89,3.15],['c',-0.45,1.47,-0.42,2.34,0.00,2.70],['c',0.45,0.39,1.26,0.21,1.83,-0.36],['c',0.51,-0.51,0.99,-1.68,1.38,-3.27],['c',0.30,-1.17,0.33,-1.74,0.15,-2.13],['c',-0.09,-0.15,-0.15,-0.21,-0.33,-0.30],['z']],w:14.689,h:13.127},
		'r':{d:[['M',6.33,-9.12],['c',0.27,-0.03,0.93,0.00,1.20,0.06],['c',0.84,0.21,1.23,0.81,1.02,1.53],['c',-0.24,0.75,-0.90,1.17,-1.56,0.96],['c',-0.33,-0.09,-0.51,-0.30,-0.66,-0.75],['c',-0.03,-0.12,-0.09,-0.24,-0.12,-0.30],['c',-0.09,-0.15,-0.30,-0.24,-0.48,-0.24],['c',-0.57,0.00,-1.38,0.54,-1.65,1.08],['c',-0.06,0.15,-0.33,1.17,-0.90,3.27],['c',-0.57,2.31,-0.81,3.12,-0.87,3.21],['c',-0.03,0.06,-0.12,0.15,-0.18,0.21],['l',-0.12,0.06],['l',-0.81,0.03],['c',-0.69,0.00,-0.81,0.00,-0.90,-0.03],['c',-0.09,-0.06,-0.18,-0.21,-0.18,-0.30],['c',0.00,-0.06,0.39,-1.62,0.90,-3.51],['c',0.84,-3.24,0.87,-3.45,0.87,-3.72],['c',0.00,-0.21,0.00,-0.27,-0.03,-0.36],['c',-0.12,-0.15,-0.21,-0.24,-0.42,-0.24],['c',-0.24,0.00,-0.45,0.15,-0.78,0.42],['c',-0.33,0.36,-0.45,0.54,-0.72,1.14],['c',-0.03,0.12,-0.21,0.24,-0.36,0.27],['c',-0.12,0.00,-0.15,0.00,-0.24,-0.06],['c',-0.18,-0.12,-0.18,-0.21,-0.06,-0.54],['c',0.21,-0.57,0.42,-0.93,0.78,-1.32],['c',0.54,-0.51,1.20,-0.81,1.95,-0.87],['c',0.81,-0.03,1.53,0.30,1.92,0.87],['l',0.12,0.18],['l',0.09,-0.09],['c',0.57,-0.45,1.41,-0.84,2.19,-0.96],['z']],w:9.41,h:9.132},
		's':{d:[['M',4.47,-8.73],['c',0.09,0.00,0.36,-0.03,0.57,-0.03],['c',0.75,0.03,1.29,0.24,1.71,0.63],['c',0.51,0.54,0.66,1.26,0.36,1.83],['c',-0.24,0.42,-0.63,0.57,-1.11,0.42],['c',-0.33,-0.09,-0.60,-0.36,-0.60,-0.57],['c',0.00,-0.03,0.06,-0.21,0.15,-0.39],['c',0.12,-0.21,0.15,-0.33,0.18,-0.48],['c',0.00,-0.24,-0.06,-0.48,-0.15,-0.60],['c',-0.15,-0.21,-0.42,-0.24,-0.75,-0.15],['c',-0.27,0.06,-0.48,0.18,-0.69,0.36],['c',-0.39,0.39,-0.51,0.96,-0.33,1.38],['c',0.09,0.21,0.42,0.51,0.78,0.72],['c',1.11,0.69,1.59,1.11,1.89,1.68],['c',0.21,0.39,0.24,0.78,0.15,1.29],['c',-0.18,1.20,-1.17,2.16,-2.52,2.52],['c',-1.02,0.24,-1.95,0.12,-2.70,-0.42],['c',-0.72,-0.51,-0.99,-1.47,-0.60,-2.19],['c',0.24,-0.48,0.72,-0.63,1.17,-0.42],['c',0.33,0.18,0.54,0.45,0.57,0.81],['c',0.00,0.21,-0.03,0.30,-0.33,0.51],['c',-0.33,0.24,-0.39,0.42,-0.27,0.69],['c',0.06,0.15,0.21,0.27,0.45,0.33],['c',0.30,0.09,0.87,0.09,1.20,0.00],['c',0.75,-0.21,1.23,-0.72,1.29,-1.35],['c',0.03,-0.42,-0.15,-0.81,-0.54,-1.20],['c',-0.24,-0.24,-0.48,-0.42,-1.41,-1.02],['c',-0.69,-0.42,-1.05,-0.93,-1.05,-1.47],['c',0.00,-0.39,0.12,-0.87,0.30,-1.23],['c',0.27,-0.57,0.78,-1.05,1.38,-1.35],['c',0.24,-0.12,0.63,-0.27,0.90,-0.30],['z']],w:6.632,h:8.758},
		'z':{d:[['M',2.64,-7.95],['c',0.36,-0.09,0.81,-0.03,1.71,0.27],['c',0.78,0.21,0.96,0.27,1.74,0.30],['c',0.87,0.06,1.02,0.03,1.38,-0.21],['c',0.21,-0.15,0.33,-0.15,0.48,-0.06],['c',0.15,0.09,0.21,0.30,0.15,0.45],['c',-0.03,0.06,-1.26,1.26,-2.76,2.67],['l',-2.73,2.55],['l',0.54,0.03],['c',0.54,0.03,0.72,0.03,2.01,0.15],['c',0.36,0.03,0.90,0.06,1.20,0.09],['c',0.66,0.00,0.81,-0.03,1.02,-0.24],['c',0.30,-0.30,0.39,-0.72,0.27,-1.23],['c',-0.06,-0.27,-0.06,-0.27,-0.03,-0.39],['c',0.15,-0.30,0.54,-0.27,0.69,0.03],['c',0.15,0.33,0.27,1.02,0.27,1.50],['c',0.00,1.47,-1.11,2.70,-2.52,2.79],['c',-0.57,0.03,-1.02,-0.09,-2.01,-0.51],['c',-1.02,-0.42,-1.23,-0.48,-2.13,-0.54],['c',-0.81,-0.06,-0.96,-0.03,-1.26,0.18],['c',-0.12,0.06,-0.24,0.12,-0.27,0.12],['c',-0.27,0.00,-0.45,-0.30,-0.36,-0.51],['c',0.03,-0.06,1.32,-1.32,2.91,-2.79],['l',2.88,-2.73],['c',-0.03,0.00,-0.21,0.03,-0.42,0.06],['c',-0.21,0.03,-0.78,0.09,-1.23,0.12],['c',-1.11,0.12,-1.23,0.15,-1.95,0.27],['c',-0.72,0.15,-1.17,0.18,-1.29,0.09],['c',-0.27,-0.18,-0.21,-0.75,0.12,-1.26],['c',0.39,-0.60,0.93,-1.02,1.59,-1.20],['z']],w:8.573,h:8.743},
		'+':{d:[['M',3.48,-9.3],['c',0.18,-0.09,0.36,-0.09,0.54,0.00],['c',0.18,0.09,0.24,0.15,0.33,0.30],['l',0.06,0.15],['l',0.00,1.29],['l',0.00,1.29],['l',1.29,0.00],['c',1.23,0.00,1.29,0.00,1.41,0.06],['c',0.06,0.03,0.15,0.09,0.18,0.12],['c',0.12,0.09,0.21,0.33,0.21,0.48],['c',0.00,0.15,-0.09,0.39,-0.21,0.48],['c',-0.03,0.03,-0.12,0.09,-0.18,0.12],['c',-0.12,0.06,-0.18,0.06,-1.41,0.06],['l',-1.29,0.00],['l',0.00,1.29],['c',0.00,1.23,0.00,1.29,-0.06,1.41],['c',-0.09,0.18,-0.15,0.24,-0.30,0.33],['c',-0.21,0.09,-0.39,0.09,-0.57,0.00],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['c',-0.06,-0.12,-0.06,-0.18,-0.06,-1.41],['l',0.00,-1.29],['l',-1.29,0.00],['c',-1.23,0.00,-1.29,0.00,-1.41,-0.06],['c',-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],['c',-0.09,-0.18,-0.09,-0.36,0.00,-0.54],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['l',0.15,-0.06],['l',1.26,0.00],['l',1.29,0.00],['l',0.00,-1.29],['c',0.00,-1.23,0.00,-1.29,0.06,-1.41],['c',0.09,-0.18,0.15,-0.24,0.33,-0.33],['z']],w:7.507,h:7.515},
		',':{d:[['M',1.32,-3.36],['c',0.57,-0.15,1.17,0.03,1.59,0.45],['c',0.45,0.45,0.60,0.96,0.51,1.89],['c',-0.09,1.23,-0.42,2.46,-0.99,3.93],['c',-0.30,0.72,-0.72,1.62,-0.78,1.68],['c',-0.18,0.21,-0.51,0.18,-0.66,-0.06],['c',-0.03,-0.06,-0.06,-0.15,-0.06,-0.18],['c',0.00,-0.06,0.12,-0.33,0.24,-0.63],['c',0.84,-1.80,1.02,-2.61,0.69,-3.24],['c',-0.12,-0.24,-0.27,-0.36,-0.75,-0.60],['c',-0.36,-0.15,-0.42,-0.21,-0.60,-0.39],['c',-0.69,-0.69,-0.69,-1.71,0.00,-2.40],['c',0.21,-0.21,0.51,-0.39,0.81,-0.45],['z']],w:3.452,h:8.143},
		'-':{d:[['M',0.18,-5.34],['c',0.09,-0.06,0.15,-0.06,2.31,-0.06],['c',2.46,0.00,2.37,0.00,2.46,0.21],['c',0.12,0.21,0.03,0.42,-0.15,0.54],['c',-0.09,0.06,-0.15,0.06,-2.28,0.06],['c',-2.16,0.00,-2.22,0.00,-2.31,-0.06],['c',-0.27,-0.15,-0.27,-0.54,-0.03,-0.69],['z']],w:5.001,h:0.81},
		'.':{d:[['M',1.32,-3.36],['c',1.05,-0.27,2.10,0.57,2.10,1.65],['c',0.00,1.08,-1.05,1.92,-2.10,1.65],['c',-0.90,-0.21,-1.50,-1.14,-1.26,-2.04],['c',0.12,-0.63,0.63,-1.11,1.26,-1.26],['z']],w:3.413,h:3.402},
		'scripts.wedge':{d:[['M',-3.66,-7.44],['c',0.06,-0.09,0.00,-0.09,0.81,0.03],['c',1.86,0.30,3.84,0.30,5.73,0.00],['c',0.78,-0.12,0.72,-0.12,0.78,-0.03],['c',0.15,0.15,0.12,0.24,-0.24,0.60],['c',-0.93,0.93,-1.98,2.76,-2.67,4.62],['c',-0.30,0.78,-0.51,1.71,-0.51,2.13],['c',0.00,0.15,0.00,0.18,-0.06,0.27],['c',-0.12,0.09,-0.24,0.09,-0.36,0.00],['c',-0.06,-0.09,-0.06,-0.12,-0.06,-0.27],['c',0.00,-0.42,-0.21,-1.35,-0.51,-2.13],['c',-0.69,-1.86,-1.74,-3.69,-2.67,-4.62],['c',-0.36,-0.36,-0.39,-0.45,-0.24,-0.60],['z']],w:7.49,h:7.752},
		'scripts.thumb':{d:[['M',-0.54,-3.69],['c',0.15,-0.03,0.36,-0.06,0.51,-0.06],['c',1.44,0.00,2.58,1.11,2.94,2.85],['c',0.09,0.48,0.09,1.32,0.00,1.80],['c',-0.27,1.41,-1.08,2.43,-2.16,2.73],['l',-0.18,0.06],['l',0.00,0.12],['c',0.03,0.06,0.06,0.45,0.09,0.87],['c',0.03,0.57,0.03,0.78,0.00,0.84],['c',-0.09,0.27,-0.39,0.48,-0.66,0.48],['c',-0.27,0.00,-0.57,-0.21,-0.66,-0.48],['c',-0.03,-0.06,-0.03,-0.27,0.00,-0.84],['c',0.03,-0.42,0.06,-0.81,0.09,-0.87],['l',0.00,-0.12],['l',-0.18,-0.06],['c',-1.08,-0.30,-1.89,-1.32,-2.16,-2.73],['c',-0.09,-0.48,-0.09,-1.32,0.00,-1.80],['c',0.15,-0.84,0.51,-1.53,1.02,-2.04],['c',0.39,-0.39,0.84,-0.63,1.35,-0.75],['z'],['m',1.05,0.90],['c',-0.15,-0.09,-0.21,-0.09,-0.45,-0.12],['c',-0.15,0.00,-0.30,0.03,-0.39,0.03],['c',-0.57,0.18,-0.90,0.72,-1.08,1.74],['c',-0.06,0.48,-0.06,1.80,0.00,2.28],['c',0.15,0.90,0.42,1.44,0.90,1.65],['c',0.18,0.09,0.21,0.09,0.51,0.09],['c',0.30,0.00,0.33,0.00,0.51,-0.09],['c',0.48,-0.21,0.75,-0.75,0.90,-1.65],['c',0.03,-0.27,0.03,-0.54,0.03,-1.14],['c',0.00,-0.60,0.00,-0.87,-0.03,-1.14],['c',-0.15,-0.90,-0.45,-1.44,-0.90,-1.65],['z']],w:5.955,h:9.75},
		'scripts.open':{d:[['M',-0.54,-3.69],['c',0.15,-0.03,0.36,-0.06,0.51,-0.06],['c',1.44,0.00,2.58,1.11,2.94,2.85],['c',0.09,0.48,0.09,1.32,0.00,1.80],['c',-0.33,1.74,-1.47,2.85,-2.91,2.85],['c',-1.44,0.00,-2.58,-1.11,-2.91,-2.85],['c',-0.09,-0.48,-0.09,-1.32,0.00,-1.80],['c',0.15,-0.84,0.51,-1.53,1.02,-2.04],['c',0.39,-0.39,0.84,-0.63,1.35,-0.75],['z'],['m',1.11,0.90],['c',-0.21,-0.09,-0.27,-0.09,-0.51,-0.12],['c',-0.30,0.00,-0.42,0.03,-0.66,0.15],['c',-0.24,0.12,-0.51,0.39,-0.66,0.63],['c',-0.54,0.93,-0.63,2.64,-0.21,3.81],['c',0.21,0.54,0.51,0.90,0.93,1.11],['c',0.21,0.09,0.24,0.09,0.54,0.09],['c',0.30,0.00,0.33,0.00,0.54,-0.09],['c',0.42,-0.21,0.72,-0.57,0.93,-1.11],['c',0.36,-0.99,0.36,-2.37,0.00,-3.36],['c',-0.21,-0.54,-0.51,-0.90,-0.90,-1.11],['z']],w:5.955,h:7.5},
		'scripts.longphrase':{d:[['M',1.47,-15.09],['c',0.36,-0.09,0.66,-0.18,0.69,-0.18],['c',0.06,0.00,0.06,0.54,0.06,11.25],['l',0.00,11.25],['l',-0.63,0.15],['c',-0.66,0.18,-1.44,0.39,-1.50,0.39],['c',-0.03,0.00,-0.03,-3.39,-0.03,-11.25],['l',0.00,-11.25],['l',0.36,-0.09],['c',0.21,-0.06,0.66,-0.18,1.05,-0.27],['z']],w:2.16,h:23.04},
		'scripts.mediumphrase':{d:[['M',1.47,-7.59],['c',0.36,-0.09,0.66,-0.18,0.69,-0.18],['c',0.06,0.00,0.06,0.39,0.06,7.50],['l',0.00,7.50],['l',-0.63,0.15],['c',-0.66,0.18,-1.44,0.39,-1.50,0.39],['c',-0.03,0.00,-0.03,-2.28,-0.03,-7.50],['l',0.00,-7.50],['l',0.36,-0.09],['c',0.21,-0.06,0.66,-0.18,1.05,-0.27],['z']],w:2.16,h:15.54},
		'scripts.shortphrase':{d:[['M',1.47,-7.59],['c',0.36,-0.09,0.66,-0.18,0.69,-0.18],['c',0.06,0.00,0.06,0.21,0.06,3.75],['l',0.00,3.75],['l',-0.42,0.09],['c',-0.57,0.18,-1.65,0.45,-1.71,0.45],['c',-0.03,0.00,-0.03,-0.72,-0.03,-3.75],['l',0.00,-3.75],['l',0.36,-0.09],['c',0.21,-0.06,0.66,-0.18,1.05,-0.27],['z']],w:2.16,h:8.04},
		'scripts.snap':{d:[['M',4.50,-3.39],['c',0.36,-0.03,0.96,-0.03,1.35,0.00],['c',1.56,0.15,3.15,0.90,4.20,2.01],['c',0.24,0.27,0.33,0.42,0.33,0.60],['c',0.00,0.27,0.03,0.24,-2.46,2.22],['c',-1.29,1.02,-2.40,1.86,-2.49,1.92],['c',-0.18,0.09,-0.30,0.09,-0.48,0.00],['c',-0.09,-0.06,-1.20,-0.90,-2.49,-1.92],['c',-2.49,-1.98,-2.46,-1.95,-2.46,-2.22],['c',0.00,-0.18,0.09,-0.33,0.33,-0.60],['c',1.05,-1.08,2.64,-1.86,4.17,-2.01],['z'],['m',1.29,1.17],['c',-1.47,-0.15,-2.97,0.30,-4.14,1.20],['l',-0.18,0.15],['l',0.06,0.09],['c',0.15,0.12,3.63,2.85,3.66,2.85],['c',0.03,0.00,3.51,-2.73,3.66,-2.85],['l',0.06,-0.09],['l',-0.18,-0.15],['c',-0.84,-0.66,-1.89,-1.08,-2.94,-1.20],['z']],w:10.38,h:6.84}};

	// Custom characters that weren't generated from the font:
	glyphs['noteheads.slash.whole'] = {d:[['M',5,-5],['l',1,1],['l',-5,5],['l',-1,-1],['z'],['m',4,6],['l',-5,-5],['l',2,-2],['l',5,5],['z'],['m',0,-2],['l',1,1],['l',-5,5],['l',-1,-1],['z'],['m',-4,6],['l',-5,-5],['l',2,-2],['l',5,5],['z']],w:10.81,h:15.63};

	glyphs['noteheads.slash.quarter'] = {d:[['M',9,-6],['l',0,4],['l',-9,9],['l',0,-4],['z']],w:9,h:9};

	glyphs['noteheads.harmonic.quarter'] = {d:[['M',3.63,-4.02],['c',0.09,-0.06,0.18,-0.09,0.24,-0.03],['c',0.03,0.03,0.87,0.93,1.83,2.01],['c',1.50,1.65,1.80,1.98,1.80,2.04],['c',0.00,0.06,-0.30,0.39,-1.80,2.04],['c',-0.96,1.08,-1.80,1.98,-1.83,2.01],['c',-0.06,0.06,-0.15,0.03,-0.24,-0.03],['c',-0.12,-0.09,-3.54,-3.84,-3.60,-3.93],['c',-0.03,-0.03,-0.03,-0.09,-0.03,-0.15],['c',0.03,-0.06,3.45,-3.84,3.63,-3.96],['z']],w:7.5,h:8.165};

var pathClone = function (pathArray) {
	var res = [];
	for (var i = 0, ii = pathArray.length; i < ii; i++) {
		res[i] = [];
		for (var j = 0, jj = pathArray[i].length; j < jj; j++) {
			res[i][j] = pathArray[i][j];
		}
	}
	return res;
};

var pathScale = function (pathArray, kx, ky) {
	for (var i = 0, ii = pathArray.length; i < ii; i++) {
		var p = pathArray[i];
		var j, jj;
		for (j = 1, jj = p.length; j < jj; j++) {
			p[j] *= (j % 2) ? kx : ky;
		}
	}
};

var Glyphs = {
	printSymbol: function (x,y,symb,paper, klass) {
    if (!glyphs[symb]) return null;
    var pathArray = pathClone(glyphs[symb].d);
    pathArray[0][1] +=x;
    pathArray[0][2] +=y;
    var path = "";
    for (var i = 0; i < pathArray.length; i++)
    	path += pathArray[i].join(" ");
    return paper.path({path:path, stroke:"none", fill:"#000000", 'class': klass });
   },

  getPathForSymbol: function (x,y,symb,scalex, scaley) {
    scalex = scalex || 1;
    scaley = scaley || 1;
    if (!glyphs[symb]) return null;
    var pathArray = pathClone(glyphs[symb].d);
    if (scalex!==1 || scaley!==1) pathScale(pathArray,scalex,scaley);
    pathArray[0][1] +=x;
    pathArray[0][2] +=y;

    return pathArray;
  },

  getSymbolWidth: function (symbol) {
    if (glyphs[symbol]) return glyphs[symbol].w;
    return 0;
  },

	symbolHeightInPitches: function(symbol) {
		var height = glyphs[symbol] ? glyphs[symbol].h : 0;
		return height / spacing.STEP;
	},

  getSymbolAlign: function (symbol) {
    if (symbol.substring(0,7)==="scripts" &&
	symbol!=="scripts.roll") {
      return "center";
    }
    return "left";
  },

  getYCorr: function (symbol) {
    switch(symbol) {
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
    case "+": return -2;
    case "timesig.common":
    case "timesig.cut": return 0;
    case "flags.d32nd": return -1;
    case "flags.d64th": return -2;
    case "flags.u32nd": return 1;
    case "flags.u64th": return 3;
    case "rests.whole": return 1;
    case "rests.half": return -1;
    case "rests.8th": return -1;
    case "rests.quarter": return -1;
    case "rests.16th": return -1;
    case "rests.32nd": return -1;
    case "rests.64th": return -1;
		case "f":
		case "m":
		case "p":
		case "s":
		case "z":
			return -4;
		case "scripts.trill":
		case "scripts.upbow":
		case "scripts.downbow":
			return -2;
		case "scripts.ufermata":
		case "scripts.wedge":
		case "scripts.roll":
		case "scripts.shortphrase":
		case "scripts.longphrase":
			return -1;
		case "scripts.dfermata":
			return 1;
    default: return 0;
    }
  },
	setSymbol: function(name, path) {
		glyphs[name] = path;
	}
};

module.exports = Glyphs; // we need the glyphs for layout information


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_relative_element.js":
/*!**************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_relative_element.js ***!
  \**************************************************************/
/***/ (function(module) {

//    abc_relative_element.js: Definition of the RelativeElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var RelativeElement = function RelativeElement(c, dx, w, pitch, opt) {
	opt = opt || {};
	this.x = 0;
	this.c = c;      // character or path or string
	this.dx = dx;    // relative x position
	this.w = w;      // minimum width taken up by this element (can include gratuitous space)
	this.pitch = pitch; // relative y position by pitch
	this.scalex = opt.scalex || 1; // should the character/path be scaled?
	this.scaley = opt.scaley || 1; // should the character/path be scaled?
	this.type = opt.type || "symbol"; // cheap types.
	this.pitch2 = opt.pitch2;
	this.linewidth = opt.linewidth;
	this.klass = opt.klass;
	this.top = pitch;
	if (this.pitch2 !== undefined && this.pitch2 > this.top) this.top = this.pitch2;
	this.bottom = pitch;
	if (this.pitch2 !== undefined && this.pitch2 < this.bottom) this.bottom = this.pitch2;
	if (opt.thickness) {
		this.top += opt.thickness/2;
		this.bottom -= opt.thickness/2;
	}
	if (opt.stemHeight) {
		if (opt.stemHeight > 0)
			this.top += opt.stemHeight;
		else
			this.bottom += opt.stemHeight;
	}
	//if (this.type === "symbol") {
	//	var offset = glyphs.getYCorr(this.c);
	//	this.top += offset;
	//	this.bottom += offset;
	//}
	this.height = opt.height ? opt.height : 4; // The +1 is to give a little bit of padding.
	this.centerVertically = false;
	switch (this.type) {
		case "debug":
			this.chordHeightAbove = this.height;
			break;
		case "lyric":
			if (opt.position && opt.position === 'below')
				this.lyricHeightBelow = this.height;
			else
				this.lyricHeightAbove = this.height;
			break;
		case "chord":
			if (opt.position && opt.position === 'below')
				this.chordHeightBelow = this.height;
			else
				this.chordHeightAbove = this.height;
			break;
		case "text":
			if (this.pitch === undefined) {
				if (opt.position && opt.position === 'below')
					this.chordHeightBelow = this.height;
				else
					this.chordHeightAbove = this.height;
			} else
				this.centerVertically = true;
			break;
		case "part": this.partHeightAbove = this.height; break;
	}
};

RelativeElement.prototype.setX = function (x) {
	this.x = x+this.dx;
};

RelativeElement.prototype.setUpperAndLowerElements = function(positionY) {
	switch(this.type) {
		case "part":
			this.top = positionY.partHeightAbove + this.height;
			this.bottom = positionY.partHeightAbove;
			break;
		case "text":
		case "chord":
			if (this.chordHeightAbove) {
				this.top = positionY.chordHeightAbove;
				this.bottom = positionY.chordHeightAbove;
			} else {
				this.top = positionY.chordHeightBelow;
				this.bottom = positionY.chordHeightBelow;
			}
			break;
		case "lyric":
			if (this.lyricHeightAbove) {
				this.top = positionY.lyricHeightAbove;
				this.bottom = positionY.lyricHeightAbove;
			} else {
				this.top = positionY.lyricHeightBelow;
				this.bottom = positionY.lyricHeightBelow;
			}
			break;
		case "debug":
			this.top = positionY.chordHeightAbove;
			this.bottom = positionY.chordHeightAbove;
			break;
	}
	if (this.pitch === undefined || this.top === undefined)
		window.console.error("RelativeElement position not set.", this.type, this.pitch, this.top, positionY);
};

RelativeElement.prototype.draw = function (renderer, bartop) {
	if (this.pitch === undefined)
		window.console.error(this.type + " Relative Element y-coordinate not set.");
	var y = renderer.calcY(this.pitch);
	switch(this.type) {
		case "symbol":
			if (this.c===null) return null;
			var klass = "symbol";
			if (this.klass) klass += " " + this.klass;
			this.graphelem = renderer.printSymbol(this.x, this.pitch, this.c, this.scalex, this.scaley, renderer.addClasses(klass)); break;
		case "debug":
			this.graphelem = renderer.renderText(this.x, renderer.calcY(15), ""+this.c, "debugfont", 'debug-msg', 'start'); break;
		case "barNumber":
			this.graphelem = renderer.renderText(this.x, y, ""+this.c, "measurefont", 'bar-number', "middle");
			break;
		case "lyric":
			this.graphelem = renderer.renderText(this.x, y, this.c, "vocalfont", 'lyric', "middle");
			break;
		case "chord":
			this.graphelem = renderer.renderText(this.x, y, this.c, 'gchordfont', "chord", "middle");
			break;
		case "decoration":
			this.graphelem = renderer.renderText(this.x, y, this.c, 'annotationfont', "annotation", "middle", true);
			break;
		case "text":
			this.graphelem = renderer.renderText(this.x, y, this.c, 'annotationfont', "annotation", "start", this.centerVertically);
			break;
		case "multimeasure-text":
			this.graphelem = renderer.renderText(this.x+this.w/2, y, this.c, 'tempofont', "rest", "middle", false);
			break;
		case "part":
			this.graphelem = renderer.renderText(this.x, y, this.c, 'partsfont', "part", "start");
			break;
		case "bar":
			this.graphelem = renderer.printStem(this.x, this.linewidth, y, (bartop)?bartop:renderer.calcY(this.pitch2)); break; // bartop can't be 0
		case "stem":
			this.graphelem = renderer.printStem(this.x, this.linewidth, y, renderer.calcY(this.pitch2)); break;
		case "ledger":
			this.graphelem = renderer.printStaveLine(this.x, this.x+this.w, this.pitch); break;
	}
	if (this.scalex!==1 && this.graphelem) {
		renderer.scaleExistingElem(this.graphelem, this.scalex, this.scaley, this.x, y);
	}
	return this.graphelem;
};

module.exports = RelativeElement;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_renderer.js":
/*!******************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_renderer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_renderer.js: API to render to SVG/Raphael/whatever rendering engine
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


/*global Math, console */

var glyphs = __webpack_require__(/*! ./abc_glyphs */ "./node_modules/abcjs/src/write/abc_glyphs.js");
var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");
var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/abcjs/src/write/sprintf.js");
var Svg = __webpack_require__(/*! ./svg */ "./node_modules/abcjs/src/write/svg.js");

/**
 * Implements the API for rendering ABCJS Abstract Rendering Structure to a canvas/paper (e.g. SVG, Raphael, etc)
 * @param {Object} paper
 * @param {bool} doRegression
 */
var Renderer = function(paper, doRegression, shouldAddClasses) {
  this.paper = new Svg(paper);
  this.controller = null; //TODO-GD only used when drawing the ABCJS ARS to connect the controller with the elements for highlighting

	this.space = 3*spacing.SPACE;
  this.padding = {}; // renderer's padding is managed by the controller
  this.doRegression = doRegression;
  this.shouldAddClasses = shouldAddClasses;
  if (this.doRegression)
    this.regressionLines = [];
	this.reset();
};

Renderer.prototype.reset = function() {

	this.paper.clear();
	this.y = 0;
	this.abctune = null;
	this.lastM = null;
	this.ingroup = false;
	this.path = null;
	this.isPrint = false;
	this.initVerticalSpace();
	if (this.doRegression)
		this.regressionLines = [];
	// HACK-PER: There was a problem in Raphael where every path string that was sent to it was cached.
	// That was causing the browser's memory to steadily grow until the browser went slower and slower until
	// it crashed. The fix to that was a patch to Raphael, so it is only patched on the versions of this library that
	// bundle Raphael with it. Also, if Raphael gets an update, then that patch will be lost. On version 2.1.2 of Raphael,
	// the patch is on line 1542 and 1545 and it is:
	//             p[ps].sleep = 1;
};

Renderer.prototype.newTune = function(abcTune) {
	this.abctune = abcTune; // TODO-PER: this is just to get the font info.
	this.setVerticalSpace(abcTune.formatting);
	this.measureNumber = null;
	this.noteNumber = null;
	this.setPrintMode(abcTune.media === 'print');
	this.setPadding(abcTune);
};

Renderer.prototype.createElemSet = function() {
	return this.paper.openGroup();
};

Renderer.prototype.closeElemSet = function() {
	return this.paper.closeGroup();
};

/**
 * Set whether we are formatting this for the screen, or as a preview for creating a PDF version.
 * @param {bool} isPrint
 */
Renderer.prototype.setPrintMode = function (isPrint) {
	this.isPrint = isPrint;
};

/**
 * Set the size of the canvas.
 * @param {object} maxwidth
 * @param {object} scale
 */
Renderer.prototype.setPaperSize = function (maxwidth, scale, responsive) {
	var w = (maxwidth+this.padding.right)*scale;
	var h = (this.y+this.padding.bottom)*scale;
	if (this.isPrint)
		h = Math.max(h, 1056); // 11in x 72pt/in x 1.33px/pt
	// TODO-PER: We are letting the page get as long as it needs now, but eventually that should go to a second page.
	if (this.doRegression)
		this.regressionLines.push("PAPER SIZE: ("+w+","+h+")");

	// for accessibility
	var text = "Sheet Music";
	if (this.abctune && this.abctune.metaText && this.abctune.metaText.title)
		text += " for \"" + this.abctune.metaText.title + '"';
	this.paper.setTitle(text);

	var parentStyles = { overflow: "hidden" };
	if (responsive === 'resize') {
		this.paper.setResponsiveWidth(w, h);
	} else {
		parentStyles.width = "";
		parentStyles.height = h + "px";
		if (scale < 1) {
			parentStyles.width = w + "px";
			this.paper.setSize(w / scale, h / scale);
		} else
			this.paper.setSize(w, h);
	}
	this.paper.setScale(scale);
	this.paper.setParentStyles(parentStyles);
};

/**
 * Set the padding
 * @param {object} params
 */
Renderer.prototype.setPaddingOverride = function(params) {
	this.paddingOverride = { top: params.paddingtop, bottom: params.paddingbottom,
		right: params.paddingright, left: params.paddingleft };
};

/**
 * Set the padding
 * @param {object} params
 */
Renderer.prototype.setPadding = function(abctune) {
	// If the padding is set in the tune, then use that.
	// Otherwise, if the padding is set in the override, use that.
	// Otherwise, use the defaults (there are a different set of defaults for screen and print.)
	function setPaddingVariable(self, paddingKey, formattingKey, printDefault, screenDefault) {
		if (abctune.formatting[formattingKey] !== undefined)
			self.padding[paddingKey] = abctune.formatting[formattingKey];
		else if (self.paddingOverride[paddingKey] !== undefined)
			self.padding[paddingKey] = self.paddingOverride[paddingKey];
		else if (self.isPrint)
			self.padding[paddingKey] = printDefault;
		else
			self.padding[paddingKey] = screenDefault;
	}
	// 1cm x 0.393701in/cm x 72pt/in x 1.33px/pt = 38px
	// 1.8cm x 0.393701in/cm x 72pt/in x 1.33px/pt = 68px
	setPaddingVariable(this, 'top', 'topmargin', 38, 15);
	setPaddingVariable(this, 'bottom', 'botmargin', 38, 15);
	setPaddingVariable(this, 'left', 'leftmargin', 68, 15);
	setPaddingVariable(this, 'right', 'rightmargin', 68, 15);
};

/**
 * Some of the items on the page are not scaled, so adjust them in the opposite direction of scaling to cancel out the scaling.
 * @param {float} scale
 */
Renderer.prototype.adjustNonScaledItems = function (scale) {
	this.padding.top /= scale;
	this.padding.bottom /= scale;
	this.padding.left /= scale;
	this.padding.right /= scale;
	this.abctune.formatting.headerfont.size /= scale;
	this.abctune.formatting.footerfont.size /= scale;
};

/**
 * Set the the values for all the configurable vertical space options.
 */
Renderer.prototype.initVerticalSpace = function() {
	// conversion: 37.7953 = conversion factor for cm to px.
	// All of the following values are in px.
	this.spacing = {
		composer: 7.56, // Set the vertical space above the composer.
		graceBefore: 8.67, // Define the space before, inside and after the grace notes.
		graceInside: 10.67,
		graceAfter: 16,
		info: 0, // Set the vertical space above the infoline.
		lineSkipFactor: 1.1, // Set the factor for spacing between lines of text. (multiply this by the font size)
		music: 7.56, // Set the vertical space above the first staff.
		paragraphSkipFactor: 0.4, // Set the factor for spacing between text paragraphs. (multiply this by the font size)
		parts: 11.33, // Set the vertical space above a new part.
		slurHeight: 1.0, // Set the slur height factor.
		staffSeparation: 61.33, // Do not put a staff system closer than <unit> from the previous system.
		stemHeight: 26.67+10, // Set the stem height.
		subtitle: 3.78, // Set the vertical space above the subtitle.
		systemStaffSeparation: 48, // Do not place the staves closer than <unit> inside a system. * This values applies to all staves when in the tune header. Otherwise, it applies to the next staff
		text: 18.9, // Set the vertical space above the history.
		title: 7.56, // Set the vertical space above the title.
		top: 30.24, //Set the vertical space above the tunes and on the top of the continuation pages.
		vocal: 30.67, // Set the vertical space above the lyrics under the staves.
		words: 0 // Set the vertical space above the lyrics at the end of the tune.
	};
	/*
	TODO-PER: Handle the x-coordinate spacing items, too.
maxshrink <float>Default: 0.65
Set how much to compress horizontally when music line breaks
are automatic.
<float> must be between 0 (natural spacing)
and 1 (max shrinking).

// This next value is used to compute the natural spacing of
// the notes. The base spacing of the crotchet is always
// 40 pts. When the duration of a note type is twice the
// duration of an other note type, its spacing is multiplied
// by this factor.
// The default value causes the note spacing to be multiplied
// by 2 when its duration is multiplied by 4, i.e. the
// space of the semibreve is 80 pts and the space of the
// semiquaver is 20 pts.
// Setting this value to 1 sets all note spacing to 40 pts.
noteSpacingFactor: 1.414, // Set the note spacing factor to <float> (range 1..2).

scale <float> Default: 0.75 Set the page scale factor. Note that the header and footer are not scaled.

stretchlast <float>Default: 0.8
Stretch the last music line of a tune when it exceeds
the <float> fraction of the page width.
<float> range is 0.0 to 1.0.
	 */
};

Renderer.prototype.setVerticalSpace = function(formatting) {
	// conversion from pts to px 4/3
	if (formatting.staffsep !== undefined)
		this.spacing.staffSeparation = formatting.staffsep *4/3;
	if (formatting.composerspace !== undefined)
		this.spacing.composer = formatting.composerspace *4/3;
	if (formatting.partsspace !== undefined)
		this.spacing.parts = formatting.partsspace *4/3;
	if (formatting.textspace !== undefined)
		this.spacing.text = formatting.textspace *4/3;
	if (formatting.musicspace !== undefined)
		this.spacing.music = formatting.musicspace *4/3;
	if (formatting.titlespace !== undefined)
		this.spacing.title = formatting.titlespace *4/3;
	if (formatting.sysstaffsep !== undefined)
		this.spacing.systemStaffSeparation = formatting.sysstaffsep *4/3;
	if (formatting.subtitlespace !== undefined)
		this.spacing.subtitle = formatting.subtitlespace *4/3;
	if (formatting.topspace !== undefined)
		this.spacing.top = formatting.topspace *4/3;
	if (formatting.vocalspace !== undefined)
		this.spacing.vocal = formatting.vocalspace *4/3;
	if (formatting.wordsspace !== undefined)
		this.spacing.words = formatting.wordsspace *4/3;
};

/**
 * Leave space at the top of the paper
 * @param {object} abctune
 */
Renderer.prototype.topMargin = function(abctune) {
		this.moveY(this.padding.top);
};

/**
 * Leave space before printing the music
 */
Renderer.prototype.addMusicPadding = function() {
		this.moveY(this.spacing.music);
};

/**
 * Leave space before printing a staff system
 */
Renderer.prototype.addStaffPadding = function(lastStaffGroup, thisStaffGroup) {
	var lastStaff = lastStaffGroup.staffs[lastStaffGroup.staffs.length-1];
	var lastBottomLine = -(lastStaff.bottom - 2); // The 2 is because the scale goes to 2 below the last line.
	var nextTopLine = thisStaffGroup.staffs[0].top - 10; // Because 10 represents the top line.
	var naturalSeparation = nextTopLine + lastBottomLine; // This is how far apart they'd be without extra spacing
	var separationInPixels = naturalSeparation * spacing.STEP;
	if (separationInPixels < this.spacing.staffSeparation)
		this.moveY(this.spacing.staffSeparation-separationInPixels);
};

/**
 * Text that goes above the score
 * @param {number} width
 * @param {object} abctune
 */
Renderer.prototype.engraveTopText = function(width, abctune) {
	if (abctune.metaText.header && this.isPrint) {
		// Note: whether there is a header or not doesn't change any other positioning, so this doesn't change the Y-coordinate.
		// This text goes above the margin, so we'll temporarily move up.
		var headerTextHeight = this.getTextSize("XXXX", "headerfont", 'abcjs-header abcjs-meta-top').height;
		this.y -=headerTextHeight;
		this.outputTextIf(this.padding.left, abctune.metaText.header.left, 'headerfont', 'header meta-top', 0, null, 'start');
		this.outputTextIf(this.padding.left + width / 2, abctune.metaText.header.center, 'headerfont', 'header meta-top', 0, null, 'middle');
		this.outputTextIf(this.padding.left + width, abctune.metaText.header.right, 'headerfont', 'header meta-top', 0, null, 'end');
		this.y += headerTextHeight;
	}
	if (this.isPrint)
		this.moveY(this.spacing.top);
	this.outputTextIf(this.padding.left + width / 2, abctune.metaText.title, 'titlefont', 'title meta-top', this.spacing.title, 0, 'middle');
	if (abctune.lines[0])
		this.outputTextIf(this.padding.left + width / 2, abctune.lines[0].subtitle, 'subtitlefont', 'text meta-top', this.spacing.subtitle, 0, 'middle');

	if (abctune.metaText.rhythm || abctune.metaText.origin || abctune.metaText.composer) {
		this.moveY(this.spacing.composer);
		var rSpace = this.outputTextIf(this.padding.left, abctune.metaText.rhythm, 'infofont', 'meta-top', 0, null, "start");

		var composerLine = "";
		if (abctune.metaText.composer) composerLine += abctune.metaText.composer;
		if (abctune.metaText.origin) composerLine += ' (' + abctune.metaText.origin + ')';
		if (composerLine.length > 0) {
			var space = this.outputTextIf(this.padding.left + width, composerLine, 'composerfont', 'meta-top', 0, null, "end");
			this.moveY(space[1]);
		} else {
			this.moveY(rSpace[1]);
		}
		// TODO-PER: The following is a hack to make the elements line up with abcm2ps. Don't know where the extra space is coming from.
		this.moveY(-6);
	//} else if (this.isPrint) {
	//	// abcm2ps adds this space whether there is anything to write or not.
	//	this.moveY(this.spacing.composer);
	//	var space2 = this.getTextSize("M", 'composerfont', 'meta-top');
	//	this.moveY(space2.height);
	}

	this.outputTextIf(this.padding.left + width, abctune.metaText.author, 'composerfont', 'meta-top', 0, 0, "end");
	//this.skipSpaceY();

	this.outputTextIf(this.padding.left, abctune.metaText.partOrder, 'partsfont', 'meta-bottom', 0, 0, "start");
};

/**
 * Text that goes below the score
 * @param {number} width
 * @param {object} abctune
 */
Renderer.prototype.engraveExtraText = function(width, abctune) {
	this.lineNumber = null;
	this.measureNumber = null;
	this.noteNumber = null;
	this.voiceNumber = null;

	if (abctune.metaText.unalignedWords) {
		var hash = this.getFontAndAttr("wordsfont", 'meta-bottom');
		var space = this.getTextSize("i", 'wordsfont', 'meta-bottom');

		if (abctune.metaText.unalignedWords.length > 0)
			this.moveY(this.spacing.words, 1);
		for (var j = 0; j < abctune.metaText.unalignedWords.length; j++) {
			if (abctune.metaText.unalignedWords[j] === '')
				this.moveY(hash.font.size, 1);
			else if (typeof abctune.metaText.unalignedWords[j] === 'string') {
				this.outputTextIf(this.padding.left + spacing.INDENT, abctune.metaText.unalignedWords[j], 'wordsfont', 'meta-bottom', 0, 0, "start");
			} else {
				var largestY = 0;
				var offsetX = 0;
				for (var k = 0; k < abctune.metaText.unalignedWords[j].length; k++) {
					var thisWord = abctune.metaText.unalignedWords[j][k];
					var type = (thisWord.font) ? thisWord.font : "wordsfont";
					var el = this.renderText(this.padding.left + spacing.INDENT + offsetX, this.y, thisWord.text, type, 'meta-bottom', false);
					var size = this.getTextSize(thisWord.text, type, 'meta-bottom');
					largestY = Math.max(largestY, size.height);
					offsetX += size.width;
					// If the phrase ends in a space, then that is not counted in the width, so we need to add that in ourselves.
					if (thisWord.text[thisWord.text.length-1] === ' ') {
						offsetX += space.width;
					}
				}
				this.moveY(largestY, 1);
			}
		}
		if (abctune.metaText.unalignedWords.length > 0)
			this.moveY(hash.font.size, 2);
	}

	var extraText = "";
	if (abctune.metaText.book) extraText += "Book: " + abctune.metaText.book + "\n";
	if (abctune.metaText.source) extraText += "Source: " + abctune.metaText.source + "\n";
	if (abctune.metaText.discography) extraText += "Discography: " + abctune.metaText.discography + "\n";
	if (abctune.metaText.notes) extraText += "Notes: " + abctune.metaText.notes + "\n";
	if (abctune.metaText.transcription) extraText += "Transcription: " + abctune.metaText.transcription + "\n";
	if (abctune.metaText.history) extraText += "History: " + abctune.metaText.history + "\n";
	if (abctune.metaText['abc-copyright']) extraText += "Copyright: " + abctune.metaText['abc-copyright'] + "\n";
	if (abctune.metaText['abc-creator']) extraText += "Creator: " + abctune.metaText['abc-creator'] + "\n";
	if (abctune.metaText['abc-edited-by']) extraText += "Edited By: " + abctune.metaText['abc-edited-by'] + "\n";
	this.outputTextIf(this.padding.left, extraText, 'historyfont', 'meta-bottom', this.spacing.info, 0, "start");

	if (abctune.metaText.footer && this.isPrint) {
		// Note: whether there is a footer or not doesn't change any other positioning, so this doesn't change the Y-coordinate.
		this.outputTextIf(this.padding.left, abctune.metaText.footer.left, 'footerfont', 'header meta-bottom', 0, null, 'start');
		this.outputTextIf(this.padding.left + width / 2, abctune.metaText.footer.center, 'footerfont', 'header meta-bottom', 0, null, 'middle');
		this.outputTextIf(this.padding.left + width, abctune.metaText.footer.right, 'footerfont', 'header meta-bottom', 0, null, 'end');
	}
};

/**
 * Output text defined with %%text.
 * @param {array or string} text
 */
Renderer.prototype.outputFreeText = function (text, vskip) {
	if (vskip)
		this.moveY(vskip);
	var hash = this.getFontAndAttr('textfont', 'defined-text');
	if (text === "") {	// we do want to print out blank lines if they have been specified.
		this.moveY(hash.attr['font-size'] * 2); // move the distance of the line, plus the distance of the margin, which is also one line.
	} else if (typeof text === 'string') {
		this.moveY(hash.attr['font-size']/2); // TODO-PER: move down some - the y location should be the top of the text, but we output text specifying the center line.
		this.outputTextIf(this.padding.left, text, 'textfont', 'defined-text', 0, 0, "start");
	} else {
		var str = "";
		var isCentered = false; // The structure is wrong here: it requires an array to do centering, but it shouldn't have.
		for (var i = 0; i < text.length; i++) {
			if (text[i].font)
				str += "FONT(" + text[i].font + ")";
			str += text[i].text;
			if (text[i].center)
				isCentered = true;
		}
		var alignment = isCentered ? 'middle' : 'start';
		var x = isCentered ? this.controller.width / 2 : this.padding.left;
		this.outputTextIf(x, str, 'textfont', 'defined-text', 0, 1, alignment);
	}
};

Renderer.prototype.outputSeparator = function (separator) {
	if (!separator.lineLength)
		return;
	this.moveY(separator.spaceAbove);
	this.printSeparator(separator.lineLength);
	this.moveY(separator.spaceBelow);
};

/**
 * Output an extra subtitle that is defined later in the tune.
 */
Renderer.prototype.outputSubtitle = function (width, subtitle) {
	this.outputTextIf(this.padding.left + width / 2, subtitle, 'subtitlefont', 'text meta-top', this.spacing.subtitle, 0, 'middle');
};

/**
 * Begin a group of glyphs that will always be moved, scaled and highlighted together
 */
Renderer.prototype.beginGroup = function () {
  this.path = [];
  this.lastM = [0,0];
  this.ingroup = true;
};

/**
 * Add a path to the current group
 * @param {Array} path
 * @private
 */
Renderer.prototype.addPath = function (path) {
  path = path || [];
  if (path.length===0) return;
  path[0][0]="m";
  path[0][1]-=this.lastM[0];
  path[0][2]-=this.lastM[1];
  this.lastM[0]+=path[0][1];
  this.lastM[1]+=path[0][2];
  this.path.push(path[0]);
  for (var i=1,ii=path.length;i<ii;i++) {
    if (path[i][0]==="m") {
      this.lastM[0]+=path[i][1];
      this.lastM[1]+=path[i][2];
    }
    this.path.push(path[i]);
  }
};

/**
 * End a group of glyphs that will always be moved, scaled and highlighted together
 */
Renderer.prototype.endGroup = function (klass) {
  this.ingroup = false;
  if (this.path.length===0) return null;
  var path = "";
	for (var i = 0; i < this.path.length; i++)
		path += this.path[i].join(" ");
	var ret = this.paper.path({path: path, stroke:"none", fill:"#000000", 'class': this.addClasses(klass)});
	this.path = [];
  if (this.doRegression) this.addToRegression(ret);

  return ret;
};

/**
 * gets scaled
 * @param {number} x1 start x
 * @param {number} x2 end x
 * @param {number} pitch pitch the stave line is drawn at
 */
Renderer.prototype.printStaveLine = function (x1,x2, pitch, klass) {
	var extraClass = "staff";
	if (klass !== undefined)
		extraClass += " " + klass;
  var isIE=/*@cc_on!@*/false;//IE detector
  var dy = 0.35;
  var fill = "#000000";
  if (isIE) {
    dy = 1;
    fill = "#666666";
  }
  var y = this.calcY(pitch);
  var pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x1, y-dy, x2, y-dy,
     x2, y+dy, x1, y+dy);
  var ret = this.paper.pathToBack({path:pathString, stroke:"none", fill:fill, 'class': this.addClasses(extraClass)});
  if (this.doRegression) this.addToRegression(ret);

  return ret;
};

/**
 * gets scaled if not in a group
 * @param {number} x x coordinate of the stem
 * @param {number} dx stem width
 * @param {number} y1 y coordinate of the stem bottom
 * @param {number} y2 y coordinate of the stem top
 */
Renderer.prototype.printStem = function (x, dx, y1, y2) {
  if (dx<0) { // correct path "handedness" for intersection with other elements
    var tmp = y2;
    y2 = y1;
    y1 = tmp;
  }
  var isIE=/*@cc_on!@*/false;//IE detector
  var fill = "#000000";
  if (isIE && dx<1) {
    dx = 1;
    fill = "#666666";
  }
  if (~~x === x) x+=0.05; // raphael does weird rounding (for VML)
  var pathArray = [["M",x,y1],["L", x, y2],["L", x+dx, y2],["L",x+dx,y1],["z"]];
  if (!isIE && this.ingroup) {
    this.addPath(pathArray);
  } else {
  	var path = "";
  	for (var i = 0; i < pathArray.length; i++)
  		path += pathArray[i].join(" ");
    var ret = this.paper.pathToBack({path:path, stroke:"none", fill:fill, 'class': this.addClasses('stem')});
    if (this.doRegression) this.addToRegression(ret);

    return ret;
  }
};

function kernSymbols(lastSymbol, thisSymbol, lastSymbolWidth) {
	// This is just some adjustments to make it look better.
	var width = lastSymbolWidth;
	if (lastSymbol === 'f' && thisSymbol === 'f')
		width = width*2/3;
	if (lastSymbol === 'p' && thisSymbol === 'p')
		width = width*5/6;
	if (lastSymbol === 'f' && thisSymbol === 'z')
		width = width*5/8;
	return width;
}

/**
 * assumes this.y is set appropriately
 * if symbol is a multichar string without a . (as in scripts.staccato) 1 symbol per char is assumed
 * not scaled if not in printgroup
 */
Renderer.prototype.printSymbol = function (x, offset, symbol, scalex, scaley, klass) {
	var el;
	var ycorr;
	if (!symbol) return null;
	if (symbol.length > 1 && symbol.indexOf(".") < 0) {
		this.paper.openGroup();
		var dx = 0;
		for (var i = 0; i < symbol.length; i++) {
			var s = symbol.charAt(i);
			ycorr = glyphs.getYCorr(s);
			el = glyphs.printSymbol(x + dx, this.calcY(offset + ycorr), s, this.paper, klass);
			if (el) {
				if (this.doRegression) this.addToRegression(el);
				//elemset.push(el);
				if (i < symbol.length - 1)
					dx += kernSymbols(s, symbol.charAt(i + 1), glyphs.getSymbolWidth(s));
			} else {
				this.renderText(x, this.y, "no symbol:" + symbol, "debugfont", 'debug-msg', 'start');
			}
		}
		return this.paper.closeGroup();
	} else {
		ycorr = glyphs.getYCorr(symbol);
		if (this.ingroup) {
			this.addPath(glyphs.getPathForSymbol(x, this.calcY(offset + ycorr), symbol, scalex, scaley));
		} else {
			el = glyphs.printSymbol(x, this.calcY(offset + ycorr), symbol, this.paper, klass);
			if (el) {
				if (this.doRegression) this.addToRegression(el);
				return el;
			} else
				this.renderText(x, this.y, "no symbol:" + symbol, "debugfont", 'debug-msg', 'start');
		}
		return null;
	}
};

Renderer.prototype.scaleExistingElem = function (elem, scaleX, scaleY, x, y) {
	this.paper.setAttributeOnElement(elem, { style: "transform:scale("+scaleX+","+scaleY + ");transform-origin:" + x + "px " + y + "px;"});
};

Renderer.prototype.printPath = function (attrs) {
  var ret = this.paper.path(attrs);
  if (this.doRegression) this.addToRegression(ret);
  return ret;
};

Renderer.prototype.drawBrace = function(xLeft, yTop, yBottom) {//Tony
	var yHeight = yBottom - yTop;

	var xCurve = [7.5, -8, 21, 0, 18.5, -10.5, 7.5];
	var yCurve = [0, yHeight/5.5, yHeight/3.14, yHeight/2, yHeight/2.93, yHeight/4.88, 0];

	var pathString = sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
		xLeft+xCurve[0], yTop+yCurve[0],
		xLeft+xCurve[1], yTop+yCurve[1],
		xLeft+xCurve[2], yTop+yCurve[2],
		xLeft+xCurve[3], yTop+yCurve[3],
		xLeft+xCurve[4], yTop+yCurve[4],
		xLeft+xCurve[5], yTop+yCurve[5],
		xLeft+xCurve[6], yTop+yCurve[6]);
	var ret1 = this.paper.path({path:pathString, stroke:"#000000", fill:"#000000", 'class': this.addClasses('brace')});

	xCurve = [0, 17.5, -7.5, 6.6, -5, 20, 0];
	yCurve = [yHeight/2, yHeight/1.46, yHeight/1.22, yHeight, yHeight/1.19, yHeight/1.42, yHeight/2];

	pathString = sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",
		xLeft+xCurve[ 0], yTop+yCurve[0],
		xLeft+xCurve[1], yTop+yCurve[1],
		xLeft+xCurve[2], yTop+yCurve[2],
		xLeft+xCurve[3], yTop+yCurve[3],
		xLeft+xCurve[4], yTop+yCurve[4],
		xLeft+xCurve[5], yTop+yCurve[5],
		xLeft+xCurve[6], yTop+yCurve[6]);
	var ret2 = this.paper.path({path:pathString, stroke:"#000000", fill:"#000000", 'class': this.addClasses('brace')});

	if (this.doRegression){
		this.addToRegression(ret1);
		this.addToRegression(ret2);
	}
	return ret1 + ret2;
};

Renderer.prototype.drawArc = function(x1, x2, pitch1, pitch2, above, klass, isTie) {
	// If it is a tie vs. a slur, draw it shallower.
	var spacing = isTie ? 1.2 : 1.5;

  x1 = x1 + 6;
  x2 = x2 + 4;
  pitch1 = pitch1 + ((above)?spacing:-spacing);
  pitch2 = pitch2 + ((above)?spacing:-spacing);
  var y1 = this.calcY(pitch1);
  var y2 = this.calcY(pitch2);

  //unit direction vector
  var dx = x2-x1;
  var dy = y2-y1;
  var norm= Math.sqrt(dx*dx+dy*dy);
  var ux = dx/norm;
  var uy = dy/norm;

  var flatten = norm/3.5;
  var maxFlatten = isTie ? 10 : 25;  // If it is a tie vs. a slur, draw it shallower.
  var curve = ((above)?-1:1)*Math.min(maxFlatten, Math.max(4, flatten));

  var controlx1 = x1+flatten*ux-curve*uy;
  var controly1 = y1+flatten*uy+curve*ux;
  var controlx2 = x2-flatten*ux-curve*uy;
  var controly2 = y2-flatten*uy+curve*ux;
  var thickness = 2;
  var pathString = sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z", x1, y1,
     controlx1, controly1, controlx2, controly2, x2, y2,
     controlx2-thickness*uy, controly2+thickness*ux, controlx1-thickness*uy, controly1+thickness*ux, x1, y1);
	if (klass)
		klass += ' slur';
	else
		klass = 'slur';
  var ret = this.paper.path({path:pathString, stroke:"none", fill:"#000000", 'class': this.addClasses(klass)});
  if (this.doRegression) this.addToRegression(ret);

  return ret;
};
/**
 * Calculates the y for a given pitch value (relative to the stave the renderer is currently printing)
 * @param {number} ofs pitch value (bottom C on a G clef = 0, D=1, etc.)
 */
Renderer.prototype.calcY = function(ofs) {
  return this.y - ofs*spacing.STEP;
};

/**
 * Print @param {number} numLines. If there is 1 line it is the B line. Otherwise the bottom line is the E line.
 */
Renderer.prototype.printStave = function (startx, endx, numLines) {
	var klass = "top-line";
	this.paper.openGroup({ prepend: true });
	// If there is one line, it is the B line. Otherwise, the bottom line is the E line.
	if (numLines === 1) {
		this.printStaveLine(startx,endx,6, klass);
		return;
	}
	for (var i = numLines-1; i >= 0; i--) {
		this.printStaveLine(startx,endx,(i+1)*2, klass);
		klass = undefined;
	}
	this.paper.closeGroup();
};

/**
 *
 * @private
 */
Renderer.prototype.addClasses = function (c, isNote) {
	if (!this.shouldAddClasses)
		return "";
	var ret = [];
	if (c.length > 0) ret.push(c);
	if (this.lineNumber !== null && this.lineNumber !== undefined) ret.push("l"+this.lineNumber);
	if (this.measureNumber !== null && this.measureNumber !== undefined) ret.push("m"+this.measureNumber);
	if (this.voiceNumber !== null && this.voiceNumber !== undefined) ret.push("v"+this.voiceNumber);
	if ((c.indexOf('note') >= 0 || c.indexOf('rest') >= 0 || c.indexOf('lyric') >= 0 ) && this.noteNumber !== null && this.noteNumber !== undefined) ret.push("n"+this.noteNumber);
	// add a prefix to all classes that abcjs adds.
	if (ret.length > 0) {
		ret = ret.join(' '); // Some strings are compound classes - that is, specify more than one class in a string.
		ret = ret.split(' ');
		for (var i = 0; i < ret.length; i++) {
			if (ret[i].indexOf('abcjs-') !== 0 && ret[i].length > 0) // if the prefix doesn't already exist and the class is not blank.
				ret[i] = 'abcjs-' + ret[i];
		}
	}
	return ret.join(' ');
};

Renderer.prototype.getFontAndAttr = function(type, klass) {
	var font;
	if (typeof type === 'string') {
		font = this.abctune.formatting[type];
		// Raphael deliberately changes the font units to pixels for some reason, so we need to change points to pixels here.
		if (font)
			font = {face: font.face, size: font.size * 4 / 3, decoration: font.decoration, style: font.style, weight: font.weight, box: font.box};
		else
			font = {face: "Arial", size: 12 * 4 / 3, decoration: "underline", style: "normal", weight: "normal"};
	} else
		font = {face: type.face, size: type.size * 4 / 3, decoration: type.decoration, style: type.style, weight: type.weight, box: type.box};

	var attr = {"font-size": font.size, 'font-style': font.style,
		"font-family": font.face, 'font-weight': font.weight, 'text-decoration': font.decoration,
		'class': this.addClasses(klass) };
	attr.font = "";	// There is a spurious font definition that is put on all text elements. This overwrites it.
	return { font: font, attr: attr };
};

Renderer.prototype.getTextSize = function(text, type, klass, el) {
	var hash = this.getFontAndAttr(type, klass);
	var size = this.paper.getTextSize(text, hash.attr, el);
	if (hash.font.box) {
		size.height += 8;
		size.width += 8;
	}
	return size;
};

Renderer.prototype.renderText = function(x, y, text, type, klass, anchor, centerVertically) {
	var hash = this.getFontAndAttr(type, klass);
	if (anchor)
		hash.attr["text-anchor"] = anchor;
	hash.attr.x = x;
	hash.attr.y = y + 7; // TODO-PER: Not sure why the text appears to be 7 pixels off.
	if (!centerVertically)
		hash.attr.dy = "0.5em";
	if (type === 'debugfont') {
		console.log("Debug msg: " + text);
		hash.attr.stroke = "#ff0000";
	}

	text = text.replace(/\n\n/g, "\n \n");
	text = text.replace(/^\n/, "\xA0\n");

	if (hash.font.box) {
		hash.attr.x += 2;
		hash.attr.y += 4;
	}
	var el = this.paper.text(text, hash.attr);

	if (hash.font.box) {
		var size = this.getTextSize(text, type, klass);
		var padding = 2;
		var margin = 2;
		this.paper.rect({ x: x - padding, y: y, width: size.width + padding*2, height: size.height + padding*2 - margin,  stroke: "#888888", fill: "transparent"});
		//size.height += 8;
	}
	if (this.doRegression) this.addToRegression(el);
	return el;
};

Renderer.prototype.moveY = function (em, numLines) {
	if (numLines === undefined) numLines = 1;
	this.y += em*numLines;
};

Renderer.prototype.skipSpaceY = function () {
	this.y += this.space;
};

// Call with 'kind' being the font type to use,
// if marginBottom === null then don't increment the Y after printing, otherwise that is the extra number of em's to leave below the line.
// and alignment being "start", "middle", or "end".
Renderer.prototype.outputTextIf = function(x, str, kind, klass, marginTop, marginBottom, alignment) {
	if (str) {
		if (marginTop)
			this.moveY(marginTop);
		var el = this.renderText(x, this.y, str, kind, klass, alignment);
		var bb = this.getTextSize(str, kind, klass);
		var width = isNaN(bb.width) ? 0 : bb.width;
		var height = isNaN(bb.height) ? 0 : bb.height;
		var hash = this.getFontAndAttr(kind, klass);
		if (hash.font.box) {
			width += 8;
			height += 8;
		}
		if (marginBottom !== null) {
			var numLines = str.split("\n").length;
			if (!isNaN(bb.height))
				this.moveY(height/numLines, (numLines + marginBottom));
		}
		return [width, height];
	}
	return [0,0];
};

Renderer.prototype.addInvisibleMarker = function (className) {
	var dy = 0.35;
	var fill = "rgba(0,0,0,0)";
	var y = this.y;
	y = Math.round(y);
	var x1 = 0;
	var x2 = 100;
	var pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x1, y-dy, x1+x2, y-dy,
		x2, y+dy, x1, y+dy);
	this.paper.pathToBack({path:pathString, stroke:"none", fill:fill, "fill-opacity": 0, 'class': this.addClasses(className), 'data-vertical': y });
};

Renderer.prototype.printSeparator = function(width) {
	var fill = "rgba(0,0,0,255)";
	var stroke = "rgba(0,0,0,0)";
	var y = Math.round(this.y);
	var staffWidth = this.controller.width;
	var x1 = (staffWidth - width)/2;
	var x2 = x1 + width;
	var pathString = 'M ' + x1 + ' ' + y +
		' L ' + x2 + ' ' + y +
		' L ' + x2 + ' ' + (y+1) +
		' L ' + x1 + ' ' + (y+1) +
		' L ' + x1 + ' ' + y + ' z';
	this.paper.pathToBack({path:pathString, stroke:stroke, fill:fill, 'class': this.addClasses('defined-text')});
};

// For debugging, it is sometimes useful to know where you are vertically.
Renderer.prototype.printHorizontalLine = function (width, vertical, comment) {
	var dy = 0.35;
	var fill = "rgba(0,0,255,.4)";
	var y = this.y;
	if (vertical) y = vertical;
	y = Math.round(y);
	this.paper.text(""+Math.round(y), {x: 10, y: y, "text-anchor": "start", "font-size":"18px", fill: fill, stroke: fill });
	var x1 = 50;
	var x2 = width;
	var pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x1, y-dy, x1+x2, y-dy,
		x2, y+dy, x1, y+dy);
	this.paper.pathToBack({path:pathString, stroke:"none", fill:fill, 'class': this.addClasses('staff')});
	for (var i = 1; i < width/100; i++) {
		pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", i*100-dy, y-5, i*100-dy, y+5,
			i*100+dy, y-5, i*100+dy, y+5);
		this.paper.pathToBack({path:pathString, stroke:"none", fill:fill, 'class': this.addClasses('staff')});
	}
	if (comment)
		this.paper.text(comment, {x: width+70, y: y, "text-anchor": "start", "font-size":"18px", fill: fill, stroke: fill });
};

Renderer.prototype.printShadedBox = function (x, y, width, height, color, opacity, comment) {
	var box = this.paper.rect({ x: x, y: y, width: width, height: height, fill: color, stroke: color, "fill-opacity": opacity, "stroke-opacity": opacity });
	if (comment)
		this.paper.text(comment, {x: 0, y: y+7, "text-anchor": "start", "font-size":"14px", fill: "rgba(0,0,255,.4)", stroke: "rgba(0,0,255,.4)" });
	return box;
};

Renderer.prototype.printVerticalLine = function (x, y1, y2) {
	var dy = 0.35;
	var fill = "#00aaaa";
	var pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x - dy, y1, x - dy, y2,
			x + dy, y1, x + dy, y2);
	this.paper.pathToBack({path: pathString, stroke: "none", fill: fill, 'class': this.addClasses('staff')});
	pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x - 20, y1, x - 20, y1+3,
		x, y1, x, y1+3);
	this.paper.pathToBack({path: pathString, stroke: "none", fill: fill, 'class': this.addClasses('staff')});
	pathString = sprintf("M %f %f L %f %f L %f %f L %f %f z", x + 20, y2, x + 20, y2+3,
		x, y2, x, y2+3);
	this.paper.pathToBack({path: pathString, stroke: "none", fill: fill, 'class': this.addClasses('staff')});

};

/**
 * @private
 */
Renderer.prototype.addToRegression = function (el) {
	var box;
	try {
		box = el.getBBox();
	} catch(e) {
		box = { width: 0, height: 0 };
	}
	//var str = "("+box.x+","+box.y+")["+box.width+","+box.height+"] "
	var str = el.type + ' ' + box.toString() + ' ';
	var attrs = [];
	for (var key in el.attrs) {
		if (el.attrs.hasOwnProperty(key)) {
			if (key === 'class')
				str = el.attrs[key] + " " + str;
			else
				attrs.push(key+": "+el.attrs[key]);
		}
	}
	attrs.sort();
	str += "{ " +attrs.join(" ") + " }";
	this.regressionLines.push(str);
};

module.exports = Renderer;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_spacing.js":
/*!*****************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_spacing.js ***!
  \*****************************************************/
/***/ (function(module) {

//    Copyright (C) 2014-2018 Gregory Dyke (gregdyke at gmail dot com)
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var spacing = {};

spacing.FONTEM = 360;
spacing.FONTSIZE = 30;
spacing.STEP = spacing.FONTSIZE*93/720;
spacing.SPACE = 10;
spacing.TOPNOTE = 15;
spacing.STAVEHEIGHT = 100;
spacing.INDENT = 50;

module.exports = spacing;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_staff_group_element.js":
/*!*****************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_staff_group_element.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_staff_group_element.js: Definition of the StaffGroupElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*globals console */

var spacing = __webpack_require__(/*! ./abc_spacing */ "./node_modules/abcjs/src/write/abc_spacing.js");

// StaffGroupElement contains all the elements that go together to make one line of music.
// That might be multiple staves that are tied together, and it might be multiple voices on one staff.
//
// Methods:
// constructor: some basic initialization
// addVoice(): Called once for each voice. May add a new staff if needed.
// finished(): Called only internally by layout()
// layout(): This does all the layout. It sets the following: spacingunits, startx, minspace, w, and the x-coordinate of each element in each voice.
// draw(): Calls the underlying methods on the voice objects to do the drawing. Sets y and height.
//
// Members:
// staffs: an array of all the staves in this group. Each staff contains the following elements:
//    { top, bottom, highest, lowest, y }
// voices: array of VoiceElement objects. This is mostly passed in, but the VoiceElement objects are modified here.
//
// spacingunits: number of relative x-units in the line. Used by the calling function to pass back in as the "spacing" input parameter.
// TODO-PER: This should actually be passed back as a return value.
// minspace: smallest space between two notes. Used by the calling function to pass back in as the "spacing" input parameter.
// TODO-PER: This should actually be passed back as a return value.
// startx: The left edge, taking the margin and the optional voice name. Used by the draw() method.
// w: The width of the line. Used by calling function to pass back in as the "spacing" input parameter, and the draw() method.
// TODO-PER: This should actually be passed back as a return value.  (TODO-PER: in pixels or spacing units?)
// y: The top of the staff group, in pixels. This is set in the draw method.
// TODO-PER: Where is that used? It looks like it might not be needed.
// height: Set in the draw() method to the height actually used. Used by the calling function to know where to start the next staff group.
// TODO-PER: This should actually be set in the layout method and passed back as a return value.

var StaffGroupElement = function() {
	this.voices = [];
	this.staffs = [];
	this.brace = undefined; //tony
};

StaffGroupElement.prototype.setLimit = function(member, voice) {
	if (!voice.specialY[member]) return;
	if (!voice.staff.specialY[member])
		voice.staff.specialY[member] = voice.specialY[member];
	else
		voice.staff.specialY[member] = Math.max(voice.staff.specialY[member], voice.specialY[member]);
};

StaffGroupElement.prototype.addVoice = function (voice, staffnumber, stafflines) {
	var voiceNum = this.voices.length;
	this.voices[voiceNum] = voice;
	if (this.staffs[staffnumber])
		this.staffs[staffnumber].voices.push(voiceNum);
	else {
		// TODO-PER: how does the min/max change when stafflines is not 5?
		this.staffs[this.staffs.length] = {
			top: 10,
			bottom: 2,
			lines: stafflines,
			voices: [voiceNum],
			specialY: {
				tempoHeightAbove: 0,
				partHeightAbove: 0,
				volumeHeightAbove: 0,
				dynamicHeightAbove: 0,
				endingHeightAbove: 0,
				chordHeightAbove: 0,
				lyricHeightAbove: 0,

				lyricHeightBelow: 0,
				chordHeightBelow: 0,
				volumeHeightBelow: 0,
				dynamicHeightBelow: 0
			}
		};
	}
	voice.staff = this.staffs[staffnumber];
};

StaffGroupElement.prototype.setStaffLimits = function (voice) {
	voice.staff.top = Math.max(voice.staff.top, voice.top);
	voice.staff.bottom = Math.min(voice.staff.bottom, voice.bottom);
	this.setLimit('tempoHeightAbove', voice);
	this.setLimit('partHeightAbove', voice);
	this.setLimit('volumeHeightAbove', voice);
	this.setLimit('dynamicHeightAbove', voice);
	this.setLimit('endingHeightAbove', voice);
	this.setLimit('chordHeightAbove', voice);
	this.setLimit('lyricHeightAbove', voice);
	this.setLimit('lyricHeightBelow', voice);
	this.setLimit('chordHeightBelow', voice);
	this.setLimit('volumeHeightBelow', voice);
	this.setLimit('dynamicHeightBelow', voice);
};

StaffGroupElement.prototype.setUpperAndLowerElements = function(renderer) {
	// Each staff already has the top and bottom set, now we see if there are elements that are always on top and bottom, and resolve their pitch.
	// Also, get the overall height of all the staves in this group.
	var lastStaffBottom;
	for (var i = 0; i < this.staffs.length; i++) {
		var staff = this.staffs[i];
		// the vertical order of elements that are above is: tempo, part, volume/dynamic, ending/chord, lyric
		// the vertical order of elements that are below is: lyric, chord, volume/dynamic
		var positionY = {
			tempoHeightAbove: 0,
			partHeightAbove: 0,
			volumeHeightAbove: 0,
			dynamicHeightAbove: 0,
			endingHeightAbove: 0,
			chordHeightAbove: 0,
			lyricHeightAbove: 0,

			lyricHeightBelow: 0,
			chordHeightBelow: 0,
			volumeHeightBelow: 0,
			dynamicHeightBelow: 0
		};

		if (/*ABCJS.write.debugPlacement*/false) {}

		if (staff.specialY.lyricHeightAbove) { staff.top += staff.specialY.lyricHeightAbove; positionY.lyricHeightAbove = staff.top; }
		if (staff.specialY.chordHeightAbove) { staff.top += staff.specialY.chordHeightAbove; positionY.chordHeightAbove = staff.top; }
		if (staff.specialY.endingHeightAbove) {
			if (staff.specialY.chordHeightAbove)
				staff.top += 2;
			else
				staff.top += staff.specialY.endingHeightAbove;
			positionY.endingHeightAbove = staff.top;
		}
		if (staff.specialY.dynamicHeightAbove && staff.specialY.volumeHeightAbove) {
			staff.top += Math.max(staff.specialY.dynamicHeightAbove, staff.specialY.volumeHeightAbove);
			positionY.dynamicHeightAbove = staff.top;
			positionY.volumeHeightAbove = staff.top;
		} else if (staff.specialY.dynamicHeightAbove) {
			staff.top += staff.specialY.dynamicHeightAbove; positionY.dynamicHeightAbove = staff.top;
		} else if (staff.specialY.volumeHeightAbove) { staff.top += staff.specialY.volumeHeightAbove; positionY.volumeHeightAbove = staff.top; }
		if (staff.specialY.partHeightAbove) { staff.top += staff.specialY.partHeightAbove; positionY.partHeightAbove = staff.top; }
		if (staff.specialY.tempoHeightAbove) { staff.top += staff.specialY.tempoHeightAbove; positionY.tempoHeightAbove = staff.top; }

		if (staff.specialY.lyricHeightBelow) { positionY.lyricHeightBelow = staff.bottom; staff.bottom -= staff.specialY.lyricHeightBelow; }
		if (staff.specialY.chordHeightBelow) { positionY.chordHeightBelow = staff.bottom; staff.bottom -= staff.specialY.chordHeightBelow; }
		if (staff.specialY.volumeHeightBelow && staff.specialY.dynamicHeightBelow) {
			positionY.volumeHeightBelow = staff.bottom;
			positionY.dynamicHeightBelow = staff.bottom;
			staff.bottom -= Math.max(staff.specialY.volumeHeightBelow, staff.specialY.dynamicHeightBelow);
		} else if (staff.specialY.volumeHeightBelow) {
			positionY.volumeHeightBelow = staff.bottom; staff.bottom -= staff.specialY.volumeHeightBelow;
		} else if (staff.specialY.dynamicHeightBelow) {
			positionY.dynamicHeightBelow = staff.bottom; staff.bottom -= staff.specialY.dynamicHeightBelow;
		}

		if (/*ABCJS.write.debugPlacement*/false)
			{} // This is just being stored for debugging purposes.

		for (var j = 0; j < staff.voices.length; j++) {
			var voice = this.voices[staff.voices[j]];
			voice.setUpperAndLowerElements(positionY);
		}
		// We might need a little space in between staves if the staves haven't been pushed far enough apart by notes or extra vertical stuff.
		// Only try to put in extra space if this isn't the top staff.
		if (lastStaffBottom !== undefined) {
			var thisStaffTop = staff.top - 10;
			var forcedSpacingBetween = lastStaffBottom + thisStaffTop;
			var minSpacingInPitches = renderer.spacing.systemStaffSeparation/spacing.STEP;
			var addedSpace = minSpacingInPitches - forcedSpacingBetween;
			if (addedSpace > 0)
				staff.top += addedSpace;
		}
		lastStaffBottom = 2 - staff.bottom; // the staff starts at position 2 and the bottom variable is negative. Therefore to find out how large the bottom is, we reverse the sign of the bottom, and add the 2 in.

		// Now we need a little margin on the top, so we'll just throw that in.
		//staff.top += 4;
		//console.log("Staff Y: ",i,heightInPitches,staff.top,staff.bottom);
	}
	//console.log("Staff Height: ",heightInPitches,this.height);
};

StaffGroupElement.prototype.finished = function() {
	for (var i=0;i<this.voices.length;i++) {
		if (!this.voices[i].layoutEnded()) return false;
	}
	return true;
};

function getLeftEdgeOfStaff(renderer, voices, brace) {
	var x = renderer.padding.left;

	// find out how much space will be taken up by voice headers
	var voiceheaderw = 0;
	for (var i=0;i<voices.length;i++) {
		if(voices[i].header) {
			var size = renderer.getTextSize(voices[i].header, 'voicefont', '');
			voiceheaderw = Math.max(voiceheaderw,size.width);
		}
	}
	if (voiceheaderw) {
		// Give enough spacing to the right - we use the width of an A for the amount of spacing.
		var sizeW = renderer.getTextSize("A", 'voicefont', '');
		voiceheaderw += sizeW.width;
	}
	x += voiceheaderw;

	if (brace) {
		brace.setLocation(x);
		x += brace.getWidth();
	}
	return x;
}

StaffGroupElement.prototype.layout = function(spacing, renderer, debug) {
	var epsilon = 0.0000001; // Fudging for inexactness of floating point math.
	var spacingunits = 0; // number of times we will have ended up using the spacing distance (as opposed to fixed width distances)
	var minspace = 1000; // a big number to start off with - used to find out what the smallest space between two notes is -- GD 2014.1.7

	var x = getLeftEdgeOfStaff(renderer, this.voices, this.brace);
	this.startx=x;
	var i;

	var currentduration = 0;
	if (debug) console.log("init layout", spacing);
	for (i=0;i<this.voices.length;i++) {
		this.voices[i].beginLayout(x);
	}

	var spacingunit = 0; // number of spacingunits coming from the previously laid out element to this one
	while (!this.finished()) {
		// find first duration level to be laid out among candidates across voices
		currentduration= null; // candidate smallest duration level
		for (i=0;i<this.voices.length;i++) {
			if (!this.voices[i].layoutEnded() && (!currentduration || this.voices[i].getDurationIndex()<currentduration))
				currentduration=this.voices[i].getDurationIndex();
		}


		// isolate voices at current duration level
		var currentvoices = [];
		var othervoices = [];
		for (i=0;i<this.voices.length;i++) {
			var durationIndex = this.voices[i].getDurationIndex();
			// PER: Because of the inexactness of JS floating point math, we just get close.
			if (durationIndex - currentduration > epsilon) {
				othervoices.push(this.voices[i]);
				//console.log("out: voice ",i);
			} else {
				currentvoices.push(this.voices[i]);
				//if (debug) console.log("in: voice ",i);
			}
		}

		// among the current duration level find the one which needs starting furthest right
		spacingunit = 0; // number of spacingunits coming from the previously laid out element to this one
		var spacingduration = 0;
		for (i=0;i<currentvoices.length;i++) {
			//console.log("greatest spacing unit", x, currentvoices[i].getNextX(), currentvoices[i].getSpacingUnits(), currentvoices[i].spacingduration);
			if (currentvoices[i].getNextX()>x) {
				x=currentvoices[i].getNextX();
				spacingunit=currentvoices[i].getSpacingUnits();
				spacingduration = currentvoices[i].spacingduration;
			}
		}
		spacingunits+=spacingunit;
		minspace = Math.min(minspace,spacingunit);
		if (debug) console.log("currentduration: ",currentduration, spacingunits, minspace);

		for (i=0;i<currentvoices.length;i++) {
			var voicechildx = currentvoices[i].layoutOneItem(x,spacing);
			var dx = voicechildx-x;
			if (dx>0) {
				x = voicechildx; //update x
				for (var j=0;j<i;j++) { // shift over all previously laid out elements
					currentvoices[j].shiftRight(dx);
				}
			}
		}

		// remove the value of already counted spacing units in other voices (e.g. if a voice had planned to use up 5 spacing units but is not in line to be laid out at this duration level - where we've used 2 spacing units - then we must use up 3 spacing units, not 5)
		for (i=0;i<othervoices.length;i++) {
			othervoices[i].spacingduration-=spacingduration;
			othervoices[i].updateNextX(x,spacing); // adjust other voices expectations
		}

		// update indexes of currently laid out elems
		for (i=0;i<currentvoices.length;i++) {
			var voice = currentvoices[i];
			voice.updateIndices();
		}
	} // finished laying out


	// find the greatest remaining x as a base for the width
	for (i=0;i<this.voices.length;i++) {
		if (this.voices[i].getNextX()>x) {
			x=this.voices[i].getNextX();
			spacingunit=this.voices[i].getSpacingUnits();
		}
	}
	//console.log("greatest remaining",spacingunit,x);
	spacingunits+=spacingunit;
	this.w = x;

	for (i=0;i<this.voices.length;i++) {
		this.voices[i].w=this.w;
	}
	return { spacingUnits: spacingunits, minSpace: minspace };
};

StaffGroupElement.prototype.calcHeight = function () {
	// the height is calculated here in a parallel way to the drawing below in hopes that both of these functions will be modified together.
	// TODO-PER: also add the space between staves. (That's systemStaffSeparation, which is the minimum distance between the staff LINES.)
	var height = 0;
	for (var i=0;i<this.voices.length;i++) {
		var staff = this.voices[i].staff;
		if (!this.voices[i].duplicate) {
			height += staff.top;
			if (staff.bottom < 0)
				height += -staff.bottom;
		}
	}
	return height;
};

StaffGroupElement.prototype.draw = function (renderer) {
	// We enter this method with renderer.y pointing to the topmost coordinate that we're allowed to draw.
	// All of the children that will be drawn have a relative "pitch" set, where zero is the first ledger line below the staff.
	// renderer.y will be offset at the beginning of each staff by the amount required to make the relative pitch work.
	// If there are multiple staves, then renderer.y will be incremented for each new staff.

	var debugPrint;
	var colorIndex;
	if (/*ABCJS.write.debugPlacement*/false) { var colors; }

	// An invisible marker is useful to be able to find where each system starts.
	renderer.addInvisibleMarker("abcjs-top-of-system");

	var startY = renderer.y; // So that it can be restored after we're done.
	// Set the absolute Y position for each staff here, so the voice drawing below can just use if.
	for (var j = 0; j < this.staffs.length; j++) {
		var staff1 = this.staffs[j];
		//renderer.printHorizontalLine(50, renderer.y, "start");
		renderer.moveY(spacing.STEP, staff1.top);
		staff1.absoluteY = renderer.y;
		if (/*ABCJS.write.debugPlacement*/false) {}
		if (staff1.bottom < 0)
			renderer.moveY(spacing.STEP, -staff1.bottom);
	}
	var topLine; // these are to connect multiple staves. We need to remember where they are.
	var bottomLine;

	var bartop = 0;
	renderer.measureNumber = null;
	renderer.noteNumber = null;
	for (var i=0;i<this.voices.length;i++) {
		var staff = this.voices[i].staff;
		renderer.y = staff.absoluteY;
		renderer.voiceNumber = i;
		//renderer.y = staff.y;
		// offset for starting the counting at middle C
		if (!this.voices[i].duplicate) {
//			renderer.moveY(spacing.STEP, staff.top);
			if (!topLine) topLine  = renderer.calcY(10);
			bottomLine  = renderer.calcY(2);
			if (staff.lines !== 0) {
				renderer.measureNumber = null;
				renderer.noteNumber = null;
				renderer.printStave(this.startx, this.w, staff.lines);
			}
		}
		this.voices[i].draw(renderer, bartop);
		renderer.measureNumber = null;
		renderer.noteNumber = null;
		if (!this.voices[i].duplicate) {
			bartop = renderer.calcY(2); // This connects the bar lines between two different staves.
//			if (staff.bottom < 0)
//				renderer.moveY(spacing.STEP, -staff.bottom);
		}
		if(this.brace) {//Tony
			if (i === this.brace.length - 1) {
				if (this.brace) {
					this.brace.draw(renderer, topLine, bottomLine); //tony
				}
			}
		}
	}
	renderer.measureNumber = null;
	renderer.noteNumber = null;

	// connect all the staves together with a vertical line
	if (this.staffs.length>1) {
		renderer.printStem(this.startx, 0.6, topLine, bottomLine);
	}
	renderer.y = startY;
};

module.exports = StaffGroupElement;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_tempo_element.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_tempo_element.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_tempo_element.js: Definition of the TempoElement class.
//    Copyright (C) 2014-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var AbsoluteElement = __webpack_require__(/*! ./abc_absolute_element */ "./node_modules/abcjs/src/write/abc_absolute_element.js");
var RelativeElement = __webpack_require__(/*! ./abc_relative_element */ "./node_modules/abcjs/src/write/abc_relative_element.js");

var TempoElement;
(function() {
	"use strict";
	var totalHeightInPitches = 5;

	TempoElement = function TempoElement(tempo, tuneNumber, createNoteHead) {
		this.tempo = tempo;
		this.tuneNumber = tuneNumber;
		this.tempoHeightAbove = totalHeightInPitches;
		this.pitch = undefined; // This will be set later
		if (this.tempo.duration && !this.tempo.suppressBpm) {
			this.note = this.createNote(createNoteHead, tempo, tuneNumber);
		}
	};

	TempoElement.prototype.setUpperAndLowerElements = function(positionY) { // TODO-PER: This might not be called.
		this.pitch = positionY.tempoHeightAbove;
		this.top = positionY.tempoHeightAbove;
		this.bottom = positionY.tempoHeightAbove;
		if (this.note) {
			var tempoPitch = this.pitch - totalHeightInPitches + 1; // The pitch we receive is the top of the allotted area: change that to practically the bottom.
			this.note.top = tempoPitch;
			this.note.bottom = tempoPitch;
			for (var i = 0; i < this.note.children.length; i++) {
				var child = this.note.children[i];
				child.top += tempoPitch;
				child.bottom += tempoPitch;
				child.pitch += tempoPitch;
				if (child.pitch2 !== undefined)
					child.pitch2 += tempoPitch;
			}
		}
	};

	TempoElement.prototype.setX = function (x) {
		this.x = x;
	};

	TempoElement.prototype.createNote = function(createNoteHead, tempo, tuneNumber) {
		var temposcale = 0.75;
		var duration = tempo.duration[0]; // TODO when multiple durations
		var absElem = new AbsoluteElement(tempo, duration, 1, 'tempo', tuneNumber);
		// There aren't an infinite number of note values, but we are passed a float, so just in case something is off upstream,
		// merge all of the in between points.
		var dot;
		var flag;
		var note;
		if (duration <= 1/32) { note = "noteheads.quarter"; flag = "flags.u32nd"; dot = 0; }
		else if (duration <= 1/16) { note = "noteheads.quarter"; flag = "flags.u16th"; dot = 0; }
		else if (duration <= 3/32) { note = "noteheads.quarter"; flag = "flags.u16nd"; dot = 1; }
		else if (duration <= 1/8) { note = "noteheads.quarter"; flag = "flags.u8th"; dot = 0; }
		else if (duration <= 3/16) { note = "noteheads.quarter"; flag = "flags.u8th"; dot = 1; }
		else if (duration <= 1/4) { note = "noteheads.quarter"; dot = 0; }
		else if (duration <= 3/8) { note = "noteheads.quarter"; dot = 1; }
		else if (duration <= 1/2) { note = "noteheads.half"; dot = 0; }
		else if (duration <= 3/4) { note = "noteheads.half"; dot = 1; }
		else if (duration <= 1) { note = "noteheads.whole"; dot = 0; }
		else if (duration <= 1.5) { note = "noteheads.whole"; dot = 1; }
		else if (duration <= 2) { note = "noteheads.dbl"; dot = 0; }
		else { note = "noteheads.dbl"; dot = 1; }

		var ret = createNoteHead(absElem,
			note,
			{ verticalPos: 0}, // This is just temporary: we'll offset the vertical positioning when we get the actual vertical spot.
			"up",
			0,
			0,
			flag,
			dot,
			0,
			temposcale,
			[],
			false
		);
		var tempoNote = ret.notehead;
		absElem.addHead(tempoNote);
		var stem;
		if (note !== "noteheads.whole" && note !== "noteheads.dbl") {
			var p1 = 1 / 3 * temposcale;
			var p2 = 7 * temposcale;
			var dx = tempoNote.dx + tempoNote.w;
			var width = -0.6;
			stem = new RelativeElement(null, dx, 0, p1, {"type": "stem", "pitch2": p2, linewidth: width});
			absElem.addExtra(stem);
		}
		return absElem;
	};

	TempoElement.prototype.draw = function(renderer) {
		var x = this.x;
		if (this.pitch === undefined)
			window.console.error("Tempo Element y-coordinate not set.");

		var y = renderer.calcY(this.pitch);
		var text;
		if (this.tempo.preString) {
			text = renderer.renderText(x, y, this.tempo.preString, 'tempofont', 'tempo', "start");
			var size = renderer.getTextSize(this.tempo.preString, 'tempofont', 'tempo', text);
			var preWidth = size.width;
			var charWidth = preWidth / this.tempo.preString.length; // Just get some average number to increase the spacing.
			x += preWidth + charWidth;
		}
		if (this.note) {
			if (this.note)
				this.note.setX(x);
			for (var i = 0; i < this.note.children.length; i++)
				this.note.children[i].draw(renderer, x);
			x += (this.note.w + 5);
			var str = "= " + this.tempo.bpm;
			text = renderer.renderText(x, y, str, 'tempofont', 'tempo', "start");
			size = renderer.getTextSize(str, 'tempofont', 'tempo', text);
			var postWidth = size.width;
			var charWidth2 = postWidth / str.length; // Just get some average number to increase the spacing.
			x += postWidth + charWidth2;
		}
		if (this.tempo.postString) {
			renderer.renderText(x, y, this.tempo.postString, 'tempofont', 'tempo', "start");
		}
	};
})();

module.exports = TempoElement;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_tie_element.js":
/*!*********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_tie_element.js ***!
  \*********************************************************/
/***/ (function(module) {

//    abc_tie_element.js: Definition of the TieElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var TieElem = function TieElem(options) {
//	console.log("constructor", options.anchor1 ? options.anchor1.pitch : "N/A", options.anchor2 ? options.anchor2.pitch : "N/A", options.isTie, options.isGrace);
	this.anchor1 = options.anchor1; // must have a .x and a .pitch, and a .parent property or be null (means starts at the "beginning" of the line - after keysig)
	this.anchor2 = options.anchor2; // must have a .x and a .pitch property or be null (means ends at the end of the line)
	if (options.isGrace)
		this.isGrace = true;
	if (options.fixedY)
		this.fixedY = true;
	if (options.stemDir)
		this.stemDir = options.stemDir;
	if (options.voiceNumber !== undefined)
		this.voiceNumber = options.voiceNumber;
	this.internalNotes = [];
};

TieElem.prototype.addInternalNote = function(note) {
	this.internalNotes.push(note);
};

TieElem.prototype.setEndAnchor = function(anchor2) {
//	console.log("end", this.anchor1 ? this.anchor1.pitch : "N/A", anchor2 ? anchor2.pitch : "N/A", this.isTie, this.isGrace);
	this.anchor2 = anchor2; // must have a .x and a .pitch property or be null (means ends at the end of the line)
};

// If we encounter a repeat sign, then we don't want to extend either a tie or a slur past it, so these are called to be a limit.
TieElem.prototype.setStartX = function(startLimitElem) {
	this.startLimitX = startLimitElem;
};

TieElem.prototype.setEndX = function(endLimitElem) {
	this.endLimitX = endLimitElem;
};

TieElem.prototype.setHint = function () {
	this.hint = true;
};

TieElem.prototype.setUpperAndLowerElements = function(positionY) {
	// Doesn't depend on the highest and lowest, so there's nothing to do here.
};

TieElem.prototype.calcTieDirection = function () {
	// The rules:
	// 1) If it is in a grace note group, then the direction is always BELOW.
	// 2) If it is in a single voice, then the direction is always OPPOSITE of the stem (or where the stem would have been in the case of whole notes.)
	// 3) If the stem direction is forced (probably because there are two voices on the same line), then the direction is the SAME as the stem direction.

	if (this.isGrace)
		this.above = false;
	else if (this.voiceNumber === 0)
		this.above = true;
	else if (this.voiceNumber > 0)
		this.above = false;
	else {
		var referencePitch;
		if (this.anchor1)
			referencePitch = this.anchor1.pitch;
		else if (this.anchor2)
			referencePitch = this.anchor2.pitch;
		else
			referencePitch = 14; // TODO-PER: this can't really happen normally. This would imply that a tie crossed over three lines, something like "C-\nz\nC"
		// Put the arc in the opposite direction of the stem. That isn't always the pitch if one or both of the notes are beamed with something that affects its stem.
		if ((this.anchor1 && this.anchor1.stemDir === 'down') && (this.anchor2 && this.anchor2.stemDir === "down"))
			this.above = true;
		else if ((this.anchor1 && this.anchor1.stemDir === 'up') && (this.anchor2 && this.anchor2.stemDir === "up"))
			this.above = false;
		else if (this.anchor1 && this.anchor2)
			this.above = referencePitch >= 6;
		else if (this.anchor1)
			this.above = this.anchor1.stemDir === "down";
		else if (this.anchor2)
			this.above = this.anchor2.stemDir === "down";
		else
			this.above = referencePitch >= 6;
	}
};

// From "standard music notation practice" by Music Publishers Association:
// 1) Slurs are placed under the note heads if all stems go up.
// 2) Slurs are placed over the note heads if all stems go down.
// 3) If there are both up stems and down stems, prefer placing the slur over.
// 4) When the staff has opposite stemmed voices, all slurs should be on the stemmed side.

TieElem.prototype.calcSlurDirection = function () {
	if (this.isGrace)
		this.above = false;
	else if (this.voiceNumber === 0)
		this.above = true;
	else if (this.voiceNumber > 0)
		this.above = false;
	else {
		var hasDownStem = false;
		if (this.anchor1 && this.anchor1.stemDir === "down")
			hasDownStem = true;
		if (this.anchor2 && this.anchor2.stemDir === "down")
			hasDownStem = true;
		for (var i = 0; i < this.internalNotes.length; i++) {
			var n = this.internalNotes[i];
			if (n.stemDir === "down")
				hasDownStem = true;
		}
		this.above = hasDownStem;
	}
};

TieElem.prototype.calcX = function (lineStartX, lineEndX) {
	if (this.anchor1) {
		this.startX = this.anchor1.x; // The normal case where there is a starting element to attach to.
		if (this.anchor1.scalex < 1) // this is a grace note - don't offset the tie as much.
			this.startX -= 3;
	} else if (this.startLimitX)
		this.startX = this.startLimitX.x+this.startLimitX.w; // if there is no start element, but there is a repeat mark before the start of the line.
	else
		this.startX = lineStartX; // There is no element and no repeat mark: extend to the beginning of the line.

	if (this.anchor2)
		this.endX = this.anchor2.x; // The normal case where there is a starting element to attach to.
	else if (this.endLimitX)
		this.endX = this.endLimitX.x; // if there is no start element, but there is a repeat mark before the start of the line.
	else
		this.endX = lineEndX; // There is no element and no repeat mark: extend to the beginning of the line.
};

TieElem.prototype.calcTieY = function () {
	// If the tie comes from another line, then one or both anchors will be missing.
	if (this.anchor1)
		this.startY = this.anchor1.pitch;
	else if (this.anchor2)
		this.startY = this.anchor2.pitch;
	else
		this.startY = this.above ? 14 : 0;

	if (this.anchor2)
		this.endY = this.anchor2.pitch;
	else if (this.anchor1)
		this.endY = this.anchor1.pitch;
	else
		this.endY = this.above ? 14 : 0;
};

// From "standard music notation practice" by Music Publishers Association:
// 1) If the anchor note is down stem, the slur points to the note head.
// 2) If the anchor note is up stem, and the slur is over, then point to middle of stem.

TieElem.prototype.calcSlurY = function () {
	if (this.anchor1 && this.anchor2) {
		if (this.above && this.anchor1.stemDir === "up" && !this.fixedY) {
			this.startY = (this.anchor1.highestVert + this.anchor1.pitch) / 2;
			this.startX += this.anchor1.w/2; // When going to the middle of the stem, bump the line to the right a little bit to make it look right.
		} else
			this.startY = this.anchor1.pitch;

		// If the closing note has an up stem, and it is beamed, and it isn't the first note in the beam, then the beam will get in the way.
		var beamInterferes = this.anchor2.parent.beam && this.anchor2.parent.beam.stemsUp && this.anchor2.parent.beam.elems[0] !== this.anchor2.parent;
		var midPoint = (this.anchor2.highestVert + this.anchor2.pitch) / 2;
		if (this.above && this.anchor2.stemDir === "up" && !this.fixedY && !beamInterferes && (midPoint < this.startY)) {
			this.endY = midPoint;
			this.endX += this.anchor2.w/2; // When going to the middle of the stem, bump the line to the right a little bit to make it look right.
		} else
			this.endY = this.above && beamInterferes ? this.anchor2.highestVert : this.anchor2.pitch;

	} else if (this.anchor1) {
		this.startY = this.endY = this.anchor1.pitch;
	} else if (this.anchor2) {
		this.startY = this.endY = this.anchor2.pitch;
	} else {
		// This is the case where the slur covers the entire line.
		// TODO-PER: figure out where the real top and bottom of the line are.
		this.startY = this.above ? 14 : 0;
		this.endY = this.above ? 14 : 0;
	}
};

TieElem.prototype.avoidCollisionAbove = function () {
	// Double check that an interior note in the slur isn't so high that it interferes.
	if (this.above) {
		var maxInnerHeight = -50;
		for (var i = 0; i < this.internalNotes.length; i++) {
			if (this.internalNotes[i].highestVert > maxInnerHeight)
				maxInnerHeight = this.internalNotes[i].highestVert;
		}
		if (maxInnerHeight > this.startY && maxInnerHeight > this.endY)
			this.startY = this.endY = maxInnerHeight - 1;
	}
};

TieElem.prototype.layout = function (lineStartX, lineEndX) {
	// We now have all of the input variables set, so we can figure out the start and ending x,y coordinates, and finalize the direction of the arc.

	// Ties and slurs are handled a little differently, so do calculations for them separately.
	if (!this.anchor1 || !this.anchor2)
		this.isTie = true; // if the slur goes off the end of the line, then draw it like a tie
	else if (this.anchor1.pitch === this.anchor2.pitch && this.internalNotes.length === 0)
		this.isTie = true;
	else
		this.isTie = false;

	// TODO-PER: Not sure why this would be needed, but it would be better to figure out a way to have the anchors be immutable here anyway.
	// if (this.isTie) {
	// 	if (this.anchor1) // this can happen if the tie comes from the previous line.
	// 		this.anchor1.isTie = true;
	// 	if (this.anchor2) // this can happen if the tie does not go to the next line.
	// 		this.anchor2.isTie = true;
	// }

	if (this.isTie) {
		this.calcTieDirection();
		// TODO-PER: Not sure why this would be needed, but it would be better to figure out a way to have the anchors be immutable here anyway.
		// if (this.anchor1) // this can happen if the tie comes from the previous line.
		// 	this.anchor1.tieAbove = this.above;
		// if (this.anchor2) // this can happen if the tie goes to the next line.
		// 	this.anchor2.tieAbove = this.above;
		this.calcX(lineStartX, lineEndX);
		this.calcTieY();

	} else {
		this.calcSlurDirection();
		this.calcX(lineStartX, lineEndX);
		this.calcSlurY();
	}
	this.avoidCollisionAbove();
};

TieElem.prototype.draw = function (renderer, linestartx, lineendx) {
	this.layout(linestartx, lineendx);

	var klass;
	if (this.hint)
			klass = "abcjs-hint";
	var fudgeY =  this.fixedY ? 1.5 : 0; // TODO-PER: This just compensates for drawArc, which contains too much knowledge of ties and slurs.
	renderer.drawArc(this.startX, this.endX, this.startY+fudgeY, this.endY+fudgeY,  this.above, klass, this.isTie);

};

module.exports = TieElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_triplet_element.js":
/*!*************************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_triplet_element.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_triplet_element.js: Definition of the TripletElem class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var sprintf = __webpack_require__(/*! ./sprintf */ "./node_modules/abcjs/src/write/sprintf.js");

var TripletElem;

(function() {
	"use strict";

	TripletElem = function TripletElem(number, anchor1, options) {
		this.anchor1 = anchor1; // must have a .x and a .parent property or be null (means starts at the "beginning" of the line - after key signature)
		this.number = number;
		this.duration = (''+anchor1.parent.durationClass).replace(/\./, '-');
		this.middleElems = []; // This is to calculate the highest interior pitch. It is used to make sure that the drawn bracket never crosses a really high middle note.
		this.flatBeams = options.flatBeams;
	};

	TripletElem.prototype.isClosed = function() {
		return this.anchor2;
	};

	TripletElem.prototype.middleNote = function(elem) {
		this.middleElems.push(elem);
	};

	TripletElem.prototype.setCloseAnchor = function(anchor2) {
		this.anchor2 = anchor2;
		// TODO-PER: Unfortunately, I don't know if there is a beam above until after the vertical positioning is done,
		// so I don't know whether to leave room for the number above. Therefore, If there is a beam on the first note, I'll leave room just in case.
		if (this.anchor1.parent.beam)
			this.endingHeightAbove = 4;
	};

	TripletElem.prototype.setUpperAndLowerElements = function(/*positionY*/) {
	};

	TripletElem.prototype.layout = function() {
		// TODO end and beginning of line (PER: P.S. I'm not sure this can happen: I think the parser will always specify both the start and end points.)
		if (this.anchor1 && this.anchor2) {
			this.hasBeam = this.anchor1.parent.beam && this.anchor1.parent.beam === this.anchor2.parent.beam;

			if (this.hasBeam) {
				// If there is a beam then we don't need to draw anything except the text. The beam could either be above or below.
				var beam = this.anchor1.parent.beam;
				var left = beam.isAbove() ? this.anchor1.x + this.anchor1.w : this.anchor1.x;
				this.yTextPos = beam.heightAtMidpoint(left,  this.anchor2.x);
				this.yTextPos += beam.isAbove() ? 3 : -2; // This creates some space between the beam and the number.
				this.top = this.yTextPos + 1;
				this.bottom = this.yTextPos - 2;
				if (beam.isAbove())
					this.endingHeightAbove = 4;
			} else {
				// If there isn't a beam, then we need to draw the bracket and the text. The bracket is always above.
				// The bracket is never lower than the 'a' line, but is 4 pitches above the first and last notes. If there is
				// a tall note in the middle, the bracket is horizontal and above the highest note.
				this.startNote = Math.max(this.anchor1.parent.top, 9) + 4;
				this.endNote = Math.max(this.anchor2.parent.top, 9) + 4;
				// If it starts or ends on a rest, make the beam horizontal
				if (this.anchor1.parent.type === "rest" && this.anchor2.parent.type !== "rest")
					this.startNote = this.endNote;
				else if (this.anchor2.parent.type === "rest" && this.anchor1.parent.type !== "rest")
					this.endNote = this.startNote;
				// See if the middle note is really high.
				var max = 0;
				for (var i = 0; i < this.middleElems.length; i++) {
					max = Math.max(max, this.middleElems[i].top);
				}
				max += 4;
				if (max > this.startNote || max > this.endNote) {
					this.startNote = max;
					this.endNote = max;
				}
				if (this.flatBeams) {
					this.startNote = Math.max(this.startNote, this.endNote);
					this.endNote = Math.max(this.startNote, this.endNote);
				}

				this.yTextPos = this.startNote + (this.endNote - this.startNote) / 2;
				this.top = this.yTextPos + 1;
			}
		}
		delete this.middleElems;
		delete this.flatBeams;
	};

	TripletElem.prototype.draw = function(renderer) {
		var xTextPos;
		if (this.hasBeam) {
			var left = this.anchor1.parent.beam.isAbove() ? this.anchor1.x + this.anchor1.w : this.anchor1.x;
			xTextPos = this.anchor1.parent.beam.xAtMidpoint(left, this.anchor2.x);
		} else {
			xTextPos = this.anchor1.x + (this.anchor2.x + this.anchor2.w - this.anchor1.x) / 2;
			drawBracket(renderer, this.anchor1.x, this.startNote, this.anchor2.x + this.anchor2.w, this.endNote, this.duration);
		}
		renderer.renderText(xTextPos, renderer.calcY(this.yTextPos), "" + this.number, 'tripletfont', renderer.addClasses('triplet d'+this.duration), "middle", true);
	};

	function drawLine(renderer, l, t, r, b, duration) {
		var pathString = sprintf("M %f %f L %f %f",
			l, t, r, b);
		renderer.printPath({path: pathString, stroke: "#000000", 'class': renderer.addClasses('triplet d'+duration)});
	}

	function drawBracket(renderer, x1, y1, x2, y2, duration) {
		y1 = renderer.calcY(y1);
		y2 = renderer.calcY(y2);
		var bracketHeight = 5;

		// Draw vertical lines at the beginning and end
		drawLine(renderer, x1, y1, x1, y1 + bracketHeight, duration);
		drawLine(renderer, x2, y2, x2, y2 + bracketHeight, duration);

		// figure out midpoints to draw the broken line.
		var midX = x1 + (x2-x1)/2;
		//var midY = y1 + (y2-y1)/2;
		var gapWidth = 8;
		var slope = (y2 - y1) / (x2 - x1);
		var leftEndX = midX - gapWidth;
		var leftEndY = y1 + (leftEndX - x1) * slope;
		drawLine(renderer, x1, y1, leftEndX, leftEndY, duration);
		var rightStartX = midX + gapWidth;
		var rightStartY = y1 + (rightStartX - x1) * slope;
		drawLine(renderer, rightStartX, rightStartY, x2, y2, duration);
	}
})();

module.exports = TripletElem;


/***/ }),

/***/ "./node_modules/abcjs/src/write/abc_voice_element.js":
/*!***********************************************************!*\
  !*** ./node_modules/abcjs/src/write/abc_voice_element.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

//    abc_voice_element.js: Definition of the VoiceElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var parseCommon = __webpack_require__(/*! ../parse/abc_common */ "./node_modules/abcjs/src/parse/abc_common.js");

var VoiceElement = function VoiceElement(voicenumber, voicetotal) {
	this.children = [];
	this.beams = [];
	this.otherchildren = []; // ties, slurs, triplets
	this.w = 0;
	this.duplicate = false;
	this.voicenumber = voicenumber; //number of the voice on a given stave (not staffgroup)
	this.voicetotal = voicetotal;
	this.bottom = 7;
	this.top = 7;
	this.specialY = {
		tempoHeightAbove: 0,
		partHeightAbove: 0,
		volumeHeightAbove: 0,
		dynamicHeightAbove: 0,
		endingHeightAbove: 0,
		chordHeightAbove: 0,
		lyricHeightAbove: 0,

		lyricHeightBelow: 0,
		chordHeightBelow: 0,
		volumeHeightBelow: 0,
		dynamicHeightBelow: 0
	};
};

VoiceElement.prototype.addChild = function (child) {
	if (child.type === 'bar') {
		var firstItem = true;
		for (var i = 0; firstItem && i < this.children.length; i++) {
			if (this.children[i].type !== "staff-extra" && this.children[i].type !== "tempo")
				firstItem = false;
		}
		if (!firstItem) {
			this.beams.push("bar");
			this.otherchildren.push("bar");
		}
	}
	this.children[this.children.length] = child;
	this.setRange(child);
};

VoiceElement.prototype.setLimit = function(member, child) {
	// Sometimes we get an absolute element in here and sometimes we get some type of relative element.
	// If there is a "specialY" element, then assume it is an absolute element. If that doesn't exist, look for the
	// same members at the top level, because that's where they are in relative elements.
	var specialY = child.specialY;
	if (!specialY) specialY = child;
	if (!specialY[member]) return;
	if (!this.specialY[member])
		this.specialY[member] = specialY[member];
	else
		this.specialY[member] = Math.max(this.specialY[member], specialY[member]);
};

VoiceElement.prototype.moveDecorations = function(beam) {
	var padding = 1.5; // This is the vertical padding between elements, in pitches.
	for (var ch = 0; ch < beam.elems.length; ch++) {
		var child = beam.elems[ch];
		if (child.top) {
			// We now know where the ornaments should have been placed, so move them if they would overlap.
			var top = beam.yAtNote(child);
			for (var i = 0; i < child.children.length; i++) {
				var el = child.children[i];
				if (el.klass === 'ornament') {
					if (el.bottom - padding < top) {
						var distance = top - el.bottom + padding; // Find the distance that it needs to move and add a little margin so the element doesn't touch the beam.
						el.bottom += distance;
						el.top += distance;
						el.pitch += distance;
						top = child.top = el.top;
					}
				}
			}
		}
	}
};

VoiceElement.prototype.adjustRange = function(child) {
	if (child.bottom !== undefined)
		this.bottom = Math.min(this.bottom, child.bottom);
	if (child.top !== undefined)
		this.top = Math.max(this.top, child.top);
};

VoiceElement.prototype.setRange = function(child) {
	this.adjustRange(child);
	this.setLimit('tempoHeightAbove', child);
	this.setLimit('partHeightAbove', child);
	this.setLimit('volumeHeightAbove', child);
	this.setLimit('dynamicHeightAbove', child);
	this.setLimit('endingHeightAbove', child);
	this.setLimit('chordHeightAbove', child);
	this.setLimit('lyricHeightAbove', child);
	this.setLimit('lyricHeightBelow', child);
	this.setLimit('chordHeightBelow', child);
	this.setLimit('volumeHeightBelow', child);
	this.setLimit('dynamicHeightBelow', child);
};

VoiceElement.prototype.setUpperAndLowerElements = function(positionY) {
	var i;
	for (i = 0; i < this.children.length; i++) {
		var abselem = this.children[i];
		abselem.setUpperAndLowerElements(positionY);
	}
	for (i = 0; i < this.otherchildren.length; i++) {
		var abselem = this.otherchildren[i];
		if (typeof abselem !== 'string')
			abselem.setUpperAndLowerElements(positionY);
	}
};

VoiceElement.prototype.addOther = function (child) {
	this.otherchildren.push(child);
	this.setRange(child);
};

VoiceElement.prototype.addBeam = function (child) {
	this.beams.push(child);
};

VoiceElement.prototype.updateIndices = function () {
	if (!this.layoutEnded()) {
		this.durationindex += this.children[this.i].duration;
		if (this.children[this.i].type === 'bar') this.durationindex = Math.round(this.durationindex*64)/64; // everytime we meet a barline, do rounding to nearest 64th
		this.i++;
	}
};

VoiceElement.prototype.layoutEnded = function () {
	return (this.i>=this.children.length);
};

VoiceElement.prototype.getDurationIndex = function () {
	return this.durationindex - (this.children[this.i] && (this.children[this.i].duration>0)?0:0.0000005); // if the ith element doesn't have a duration (is not a note), its duration index is fractionally before. This enables CLEF KEYSIG TIMESIG PART, etc. to be laid out before we get to the first note of other voices
};

// number of spacing units expected for next positioning
VoiceElement.prototype.getSpacingUnits = function () {
	return Math.sqrt(this.spacingduration*8);
	// TODO-PER: On short lines, this would never trigger, so the spacing was wrong. I just changed this line empirically, though, so I don't know if there are other ramifications.
	//return (this.minx<this.nextx) ? Math.sqrt(this.spacingduration*8) : 0; // we haven't used any spacing units if we end up using minx
};

//
VoiceElement.prototype.getNextX = function () {
	return Math.max(this.minx, this.nextx);
};

VoiceElement.prototype.beginLayout = function (startx) {
	this.i=0;
	this.durationindex=0;
	//this.ii=this.children.length;
	this.startx=startx;
	this.minx=startx; // furthest left to where negatively positioned elements are allowed to go
	this.nextx=startx; // x position where the next element of this voice should be placed assuming no other voices and no fixed width constraints
	this.spacingduration=0; // duration left to be laid out in current iteration (omitting additional spacing due to other aspects, such as bars, dots, sharps and flats)
};

// Try to layout the element at index this.i
// x - position to try to layout the element at
// spacing - base spacing
// can't call this function more than once per iteration
VoiceElement.prototype.layoutOneItem = function (x, spacing) {
	var child = this.children[this.i];
	if (!child) return 0;
	var er = x - this.minx; // available extrawidth to the left
	var extraWidth = child.getExtraWidth();
	if (er<extraWidth) { // shift right by needed amount
		// There's an exception if a bar element is after a Part element, there is no shift.
		if (this.i === 0 || child.type !== 'bar' || (this.children[this.i-1].type !== 'part' && this.children[this.i-1].type !== 'tempo') )
			x+=extraWidth-er;
	}
	child.setX(x);

	this.spacingduration = child.duration;
	//update minx
	this.minx = x+child.getMinWidth(); // add necessary layout space
	if (this.i!==this.children.length-1) this.minx+=child.minspacing; // add minimumspacing except on last elem

	this.updateNextX(x, spacing);

	// contribute to staff y position
	//this.staff.top = Math.max(child.top,this.staff.top);
	//this.staff.bottom = Math.min(child.bottom,this.staff.bottom);

	return x; // where we end up having placed the child
};

// call when spacingduration has been updated
VoiceElement.prototype.updateNextX = function (x, spacing) {
	this.nextx= x + (spacing*Math.sqrt(this.spacingduration*8));
};

VoiceElement.prototype.shiftRight = function (dx) {
	var child = this.children[this.i];
	if (!child) return;
	child.setX(child.x+dx);
	this.minx+=dx;
	this.nextx+=dx;
};

function isNonSpacerRest(elem) {
	if (elem.type !== 'rest')
		return false;
	if (elem.abcelem && elem.abcelem.rest && elem.abcelem.rest.type !== 'spacer')
		return true;
	return false;
}
VoiceElement.prototype.draw = function (renderer, bartop) {
	var width = this.w-1;
	renderer.staffbottom = this.staff.bottom;
	//this.barbottom = renderer.calcY(2);

	renderer.measureNumber = null;
	renderer.noteNumber = null;
	if (this.header) { // print voice name
		var textpitch = 14 - (this.voicenumber+1)*(12/(this.voicetotal+1));
		renderer.renderText(renderer.padding.left, renderer.calcY(textpitch), this.header, 'voicefont', 'staff-extra voice-name', 'start');
	}

	for (var i=0, ii=this.children.length; i<ii; i++) {
		var child = this.children[i];
		var justInitializedMeasureNumber = false;
		if (child.type !== 'staff-extra' && renderer.measureNumber === null) {
			renderer.measureNumber = 0;
			renderer.noteNumber = 0;
			justInitializedMeasureNumber = true;
		}
		child.draw(renderer, (this.barto || i===ii-1)?bartop:0);
		if (child.type === 'note' || isNonSpacerRest(child))
			renderer.noteNumber++;
		if (child.type === 'bar' && !justInitializedMeasureNumber) {
			renderer.measureNumber++;
			renderer.noteNumber = 0;
		}
	}

	renderer.measureNumber = 0;
	renderer.noteNumber = 0;
	parseCommon.each(this.beams, function(beam) {
		if (beam === 'bar') {
			renderer.measureNumber++;
			renderer.noteNumber = 0;
		} else
			beam.draw(renderer); // beams must be drawn first for proper printing of triplets, slurs and ties.
	});

	renderer.measureNumber = 0;
	renderer.noteNumber = 0;
	var self = this;
	parseCommon.each(this.otherchildren, function(child) {
		if (child === 'bar') {
			renderer.measureNumber++;
			renderer.noteNumber = 0;
		} else
			child.draw(renderer,self.startx+10,width);
	});

};

VoiceElement.prototype.layoutBeams = function() {
	for (var i = 0; i < this.beams.length; i++) {
		if (this.beams[i].layout) {
			this.beams[i].layout();
			this.moveDecorations(this.beams[i]);
			// The above will change the top and bottom of the abselem children, so see if we need to expand our range.
			for (var j = 0; j < this.beams[i].elems.length; j++) {
				this.adjustRange(this.beams[i].elems[j]);
			}
		}
	}
	// Now we can layout the triplets
	for (i = 0; i < this.otherchildren.length; i++) {
		var child = this.otherchildren[i];
		if (child.layout) {
			child.layout();
			this.adjustRange(child);
		}
	}
	this.staff.top = Math.max(this.staff.top, this.top);
	this.staff.bottom = Math.min(this.staff.bottom, this.bottom);
};

module.exports = VoiceElement;


/***/ }),

/***/ "./node_modules/abcjs/src/write/sprintf.js":
/*!*************************************************!*\
  !*** ./node_modules/abcjs/src/write/sprintf.js ***!
  \*************************************************/
/***/ (function(module) {

/**
 * sprintf() for JavaScript v.0.4
 *
 Copyright (c) 2007-present, Alexandru Mrteanu <hello@alexei.ro>
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 * Neither the name of this software nor the names of its contributors may be
 used to endorse or promote products derived from this software without
 specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

//function str_repeat(i, m) { for (var o = []; m > 0; o[--m] = i); return(o.join('')); }

var sprintf = function() {
  var i = 0, a, f = arguments[i++], o = [], m, p, c, x;
  while (f) {
    if (m = /^[^\x25]+/.exec(f)) o.push(m[0]);
    else if (m = /^\x25{2}/.exec(f)) o.push('%');
    else if (m = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(f)) {
      if (((a = arguments[m[1] || i++]) == null) || (a == undefined)) throw("Too few arguments.");
      if (/[^s]/.test(m[7]) && (typeof(a) != 'number'))
        throw("Expecting number but found " + typeof(a));
      switch (m[7]) {
        case 'b': a = a.toString(2); break;
        case 'c': a = String.fromCharCode(a); break;
        case 'd': a = parseInt(a); break;
        case 'e': a = m[6] ? a.toExponential(m[6]) : a.toExponential(); break;
        case 'f': a = m[6] ? parseFloat(a).toFixed(m[6]) : parseFloat(a); break;
        case 'o': a = a.toString(8); break;
        case 's': a = ((a = String(a)) && m[6] ? a.substring(0, m[6]) : a); break;
        case 'u': a = Math.abs(a); break;
        case 'x': a = a.toString(16); break;
        case 'X': a = a.toString(16).toUpperCase(); break;
      }
      a = (/[def]/.test(m[7]) && m[2] && a > 0 ? '+' + a : a);
      c = m[3] ? m[3] == '0' ? '0' : m[3].charAt(1) : ' ';
      x = m[5] - String(a).length;
      p = m[5] ? str_repeat(c, x) : '';
      o.push(m[4] ? a + p : p + a);
    }
    else throw ("Huh ?!");
    f = f.substring(m[0].length);
  }
  return o.join('');
};

module.exports = sprintf;


/***/ }),

/***/ "./node_modules/abcjs/src/write/svg.js":
/*!*********************************************!*\
  !*** ./node_modules/abcjs/src/write/svg.js ***!
  \*********************************************/
/***/ (function(module) {

//    abc_voice_element.js: Definition of the VoiceElement class.
//    Copyright (C) 2010-2018 Gregory Dyke (gregdyke at gmail dot com) and Paul Rosen
//
//    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
//    documentation files (the "Software"), to deal in the Software without restriction, including without limitation
//    the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
//    to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
//    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
//    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//    BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//    NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global module */

var svgNS = "http://www.w3.org/2000/svg";

function Svg(wrapper) {
	this.svg = createSvg();
	wrapper.appendChild(this.svg);
}

Svg.prototype.clear = function() {
	if (this.svg) {
		var wrapper = this.svg.parentNode;
		this.svg = createSvg();
		if (wrapper) {
			// TODO-PER: If the wrapper is not present, then the underlying div was pulled out from under this instance. It's possible that is still useful (for creating the music off page?)
			wrapper.innerHTML = "";
			wrapper.appendChild(this.svg);
		}
	}
};

Svg.prototype.setTitle = function(title) {
	var titleEl = document.createElement("title");
	var titleNode = document.createTextNode(title);
	titleEl.appendChild(titleNode);
	this.svg.insertBefore(titleEl, this.svg.firstChild);
};

Svg.prototype.setResponsiveWidth = function(w, h) {
	// this technique is from: http://thenewcode.com/744/Make-SVG-Responsive, thx to https://github.com/iantresman
	this.svg.setAttribute("viewBox", "0 0 " + w + " " + h);
	this.svg.setAttribute("preserveAspectRatio", "xMinYMin meet");
	this.svg.removeAttribute("height");
	this.svg.removeAttribute("width");
	this.svg.style['display'] = "inline-block";
	this.svg.style['position'] = "absolute";
	this.svg.style['top'] = "0";
	this.svg.style['left'] = "0";

	if (this.svg.parentNode) {
		var cls = this.svg.parentNode.getAttribute("class");
		if (!cls)
			this.svg.parentNode.setAttribute("class", "abcjs-container");
		else if (cls.indexOf("abcjs-container") < 0)
			this.svg.parentNode.setAttribute("class", cls + " abcjs-container");
		this.svg.parentNode.style['display'] = "inline-block";
		this.svg.parentNode.style['position'] = "relative";
		this.svg.parentNode.style['width'] = "100%";
		// PER: I changed the padding from 100% to this through trial and error.
		// The example was using a square image, but this music might be either wider or taller.
		var padding = h / w * 100;
		this.svg.parentNode.style['padding-bottom'] = padding + "%";
		this.svg.parentNode.style['vertical-align'] = "middle";
		this.svg.parentNode.style['overflow'] = "hidden";
	}
};

Svg.prototype.setSize = function(w, h) {
	this.svg.setAttribute('width', w);
	this.svg.setAttribute('height', h);
	// TODO-PER: Is this hack still needed?
	// Correct for IE problem in calculating height
	// var isIE = /*@cc_on!@*/false;//IE detector
	// if (isIE) {
	// 	this.paper.canvas.parentNode.style.width = w + "px";
	// 	this.paper.canvas.parentNode.style.height = "" + h + "px";
	// } else
	// 	this.paper.canvas.parentNode.setAttribute("style", "width:" + w + "px");
};

Svg.prototype.setScale = function(scale) {
	if (scale !== 1) {
		this.svg.style.transform = "scale("+scale+","+scale+")";
		this.svg.style['-ms-transform'] = "scale("+scale+","+scale+")";
		this.svg.style['-webkit-transform'] = "scale("+scale+","+scale+")";
		this.svg.style['transform-origin'] = "0 0";
		this.svg.style['-ms-transform-origin-x'] = "0";
		this.svg.style['-ms-transform-origin-y'] = "0";
		this.svg.style['-webkit-transform-origin-x'] = "0";
		this.svg.style['-webkit-transform-origin-y'] = "0";
	} else {
		this.svg.style.transform = "";
		this.svg.style['-ms-transform'] = "";
		this.svg.style['-webkit-transform'] = "";
	}
};

Svg.prototype.setParentStyles = function(attr) {
	// This is needed to get the size right when there is scaling involved.
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			if (this.svg.parentNode)
				this.svg.parentNode.style[key] = attr[key];
		}
	}
	// This is the last thing that gets called, so delete the temporary SVG if one was created
	if (this.dummySvg) {
		var body = document.querySelector('body');
		body.removeChild(this.dummySvg);
		this.dummySvg = null;
	}

};

Svg.prototype.rect = function(attr) {
	var el = document.createElementNS(svgNS, "rect");
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			var tmp = "" + attr[key];
			if (tmp.indexOf("NaN") >= 0)
				debugger;
			el.setAttributeNS(null, key, attr[key]);
		}
	}
	this.append(el);
	return el;
};

Svg.prototype.text = function(text, attr, target) {
	var el = document.createElementNS(svgNS, 'text');
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			el.setAttribute(key, attr[key]);
		}
	}
	var lines = (""+text).split("\n");
	for (var i = 0; i < lines.length; i++) {
		var line = document.createElementNS(svgNS, 'tspan');
		line.textContent = lines[i];
		line.setAttribute("x", attr.x ? attr.x : 0);
		if (i !== 0)
			line.setAttribute("dy", "1.2em");
		el.appendChild(line);
	}
	if (target)
		target.appendChild(el);
	else
		this.append(el);
	return el;
};

Svg.prototype.guessWidth = function(text, attr) {
	var svg = this.createDummySvg();
	var el = this.text(text, attr, svg);
	var size;
	try {
		size  = el.getBBox();
		if (isNaN(size.height) || !size.height) // TODO-PER: I don't think this can happen unless there isn't a browser at all.
			size = { width: attr['font-size']/2, height: attr['font-size'] + 2 }; // Just a wild guess.
		else
			size = {width: size.width, height: size.height};
	} catch (ex) {
		size = { width: attr['font-size']/2, height: attr['font-size'] + 2 }; // Just a wild guess.
	}
	svg.removeChild(el);
	return size;
};

Svg.prototype.createDummySvg = function() {
	if (!this.dummySvg) {
		this.dummySvg = createSvg();
		var styles = [
			"display: block !important;",
			"height: 1px;",
			"width: 1px;",
			"position: absolute;"
		];
		this.dummySvg.setAttribute('style', styles.join(""));
		var body = document.querySelector('body');
		body.appendChild(this.dummySvg);
	}

	return this.dummySvg;
};

Svg.prototype.getTextSize = function(text, attr, el) {
	if (typeof text === 'number')
		text = ''+text;
	if (!text || text.match(/^\s+$/))
		return { width: 0, height: 0 };
	var removeLater = !el;
	if (!el)
		el = this.text(text, attr);
	var size;
	try {
		size  = el.getBBox();
		if (isNaN(size.height) || !size.height)
			size = this.guessWidth(text, attr);
		else
			size = {width: size.width, height: size.height};
	} catch (ex) {
		size = this.guessWidth(text, attr);
	}
	if (removeLater) {
		if (this.currentGroup)
			this.currentGroup.removeChild(el);
		else
			this.svg.removeChild(el);
	}
	return size;
};

Svg.prototype.openGroup = function(options) {
	options = options ? options : {};
	var el = document.createElementNS(svgNS, "g");
	if (options.prepend)
		this.svg.insertBefore(el, this.svg.firstChild);
	else
		this.svg.appendChild(el);
	this.currentGroup = el;
	return el;
};

Svg.prototype.closeGroup = function() {
	var g = this.currentGroup;
	this.currentGroup = null;
	return g;
};

Svg.prototype.path = function(attr) {
	var el = document.createElementNS(svgNS, "path");
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			if (key === 'path')
				el.setAttributeNS(null, 'd', attr.path);
			else
				el.setAttributeNS(null, key, attr[key]);
		}
	}
	this.append(el);
	return el;
};

Svg.prototype.pathToBack = function(attr) {
	var el = document.createElementNS(svgNS, "path");
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			if (key === 'path')
				el.setAttributeNS(null, 'd', attr.path);
			else
				el.setAttributeNS(null, key, attr[key]);
		}
	}
	this.prepend(el);
	return el;
};

Svg.prototype.append = function(el) {
	if (this.currentGroup)
		this.currentGroup.appendChild(el);
	else
		this.svg.appendChild(el);
};

Svg.prototype.prepend = function(el) {
	// The entire group is prepended, so don't prepend the individual elements.
	if (this.currentGroup)
		this.currentGroup.appendChild(el);
	else
		this.svg.insertBefore(el, this.svg.firstChild);
};

Svg.prototype.setAttributeOnElement = function(el, attr) {
	for (var key in attr) {
		if (attr.hasOwnProperty(key)) {
			el.setAttributeNS(null, key, attr[key]);
		}
	}
};

function createSvg() {
	var svg = document.createElementNS(svgNS, "svg");
	svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
	svg.setAttribute('role', 'img');    // for accessibility
	return svg;
}


module.exports = Svg;


/***/ }),

/***/ "./node_modules/abcjs/version.js":
/*!***************************************!*\
  !*** ./node_modules/abcjs/version.js ***!
  \***************************************/
/***/ (function(module) {

var version = '5.12.0';

module.exports = version;


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module) {

"use strict";

var assign = Object.assign.bind(Object);
module.exports = assign;
module.exports.default = module.exports;

//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CUsers%5CSherwin%5CDesktop%5CTheGitStuff%5CSonatina-Alpha%5Cpages%5Cindex.js!":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CUsers%5CSherwin%5CDesktop%5CTheGitStuff%5CSonatina-Alpha%5Cpages%5Cindex.js! ***!
  \************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/",
      function () {
        return __webpack_require__(/*! ./pages/index.js */ "./pages/index.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/prop-types/node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/prop-types/node_modules/react-is/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/prop-types/node_modules/react-is/index.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-abcjs/es/index.js":
/*!**********************************************!*\
  !*** ./node_modules/react-abcjs/es/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var abcjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abcjs */ "./node_modules/abcjs/index.js");
/* harmony import */ var abcjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(abcjs__WEBPACK_IMPORTED_MODULE_2__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var Abcjs = function (_PureComponent) {
  _inherits(Abcjs, _PureComponent);

  function Abcjs() {
    var _temp, _this, _ret;

    _classCallCheck(this, Abcjs);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.uniqueNumber = Date.now() + Math.random(), _temp), _possibleConstructorReturn(_this, _ret);
  }

  Abcjs.prototype.renderAbcNotation = function renderAbcNotation(abcNotation, parserParams, engraverParams, renderParams) {
    var res = abcjs__WEBPACK_IMPORTED_MODULE_2___default().renderAbc('abcjs-result-' + this.uniqueNumber, abcNotation, parserParams, engraverParams, renderParams);
  };

  Abcjs.prototype.componentDidMount = function componentDidMount() {
    var _props = this.props,
        abcNotation = _props.abcNotation,
        parserParams = _props.parserParams,
        engraverParams = _props.engraverParams,
        renderParams = _props.renderParams;

    this.renderAbcNotation(abcNotation, parserParams, engraverParams, renderParams);
  };

  Abcjs.prototype.componentDidUpdate = function componentDidUpdate() {
    var _props2 = this.props,
        abcNotation = _props2.abcNotation,
        parserParams = _props2.parserParams,
        engraverParams = _props2.engraverParams,
        renderParams = _props2.renderParams;

    this.renderAbcNotation(abcNotation, parserParams, engraverParams, renderParams);
  };

  Abcjs.prototype.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(
      'div',
      { style: { width: '100%' } },
      react__WEBPACK_IMPORTED_MODULE_0___default().createElement('div', { id: 'abcjs-result-' + this.uniqueNumber, style: { width: '100%' } })
    );
  };

  return Abcjs;
}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);

Abcjs.propTypes =  true ? {
  abcNotation: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),
  parserParams: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object),
  engraverParams: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object),
  renderParams: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)
} : 0;

Abcjs.defaultProps = {
  abcNotation: '',
  parserParams: {},
  engraverParams: { responsive: 'resize' },
  renderParams: { viewportHorizontal: true }
};

/* harmony default export */ __webpack_exports__["default"] = (Abcjs);

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _assertThisInitialized; }
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _classCallCheck; }
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _createClass; }
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _getPrototypeOf; }
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _inherits; }
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.default)(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _possibleConstructorReturn; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__.default)(self);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _setPrototypeOf; }
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _typeof; }
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=C%3A%5CUsers%5CSherwin%5CDesktop%5CTheGitStuff%5CSonatina-Alpha%5Cpages%5Cindex.js!"));
/******/ _N_E = __webpack_exports__;
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9wYWdlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7OztJQUVNRTs7Ozs7Ozs7Ozs7OztXQUNGLDZCQUFvQixDQUNoQjtBQUVIOzs7V0FFSixrQkFBUztBQUNSLDBCQUFPO0FBQUEsZ0NBQ0c7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBREgsZUFFRztBQUFBLGlDQUNJLDhEQUFDLGdEQUFEO0FBQ0ksdUJBQVcsRUFDUCxpRkFGUjtBQUlJLHdCQUFZLEVBQUUsRUFKbEI7QUFLSSwwQkFBYyxFQUFFO0FBQUVDLGNBQUFBLFVBQVUsRUFBRTtBQUFkLGFBTHBCO0FBTUksd0JBQVksRUFBRTtBQUFFQyxjQUFBQSxrQkFBa0IsRUFBRTtBQUF0QjtBQU5sQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREo7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFGSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBUDtBQWFBOzs7O0VBcEJrQko7O0FBdUJwQiwrREFBZUUsS0FBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBLGNBQWMsbUJBQU8sQ0FBQyxrREFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBeUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLDRFQUF3Qjs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsa0JBQWtCLG1CQUFPLENBQUMsb0ZBQTRCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLDRGQUFnQzs7QUFFaEUsYUFBYSxtQkFBTyxDQUFDLDRFQUF3QjtBQUM3Qzs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBMEI7QUFDcEQsNEJBQTRCLG1CQUFPLENBQUMsd0dBQXNDO0FBQzFFLHNCQUFzQixtQkFBTyxDQUFDLDRGQUFnQztBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyxvRkFBNEI7QUFDeEQseUJBQXlCLG1CQUFPLENBQUMsZ0dBQWtDO0FBQ25FLDJCQUEyQixtQkFBTyxDQUFDLG9HQUFvQztBQUN2RSx5QkFBeUIsbUJBQU8sQ0FBQyxnR0FBa0M7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQTRCO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLDRFQUF3QjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBOEI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEVBQXVCO0FBQzVDOztBQUVBOzs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDJFQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXdCOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsa0RBQWtEO0FBQ2xELHlHQUF5RztBQUN6Ryw4RkFBOEY7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTtBQUNuRSwyQkFBMkI7QUFDM0I7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUNBQW1DO0FBQ25DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsMkZBQTJGO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx5Q0FBeUM7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QUNBOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsQ0FBTTtBQUM3STtBQUNBOztBQUVBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxrQkFB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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7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O0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsR0FBRztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQiwwREFBMEQ7QUFDMUQsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixZQUFZO0FBQ1osbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzV4RWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVIQUFzRDtBQUN4RDs7Ozs7Ozs7Ozs7O0FDTmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVKQUFzRTtBQUN4RTs7Ozs7Ozs7Ozs7Ozs7OztBQ05lO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05lO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNkZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMaUQ7QUFDbEM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiwyREFBYztBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkb0Q7QUFDVztBQUNoRDtBQUNmLGVBQWUsc0VBQU87QUFDdEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxTQUFTLGtFQUFxQjtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7O0FDVmU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNQZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9hcGkvYWJjX2FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9hcGkvYWJjX3RpbWluZ19jYWxsYmFja3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvYXBpL2FiY190dW5lYm9vay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9hcGkvYWJjX3R1bmVib29rX3N2Zy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9kYXRhL2FiY190dW5lLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL2VkaXQvYWJjX2VkaXRvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9taWRpL2FiY19taWRpX2ZsYXR0ZW5lci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9taWRpL2FiY19taWRpX3NlcXVlbmNlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9wYXJzZS9hYmNfY29tbW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3BhcnNlL2FiY19wYXJzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9wYXJzZS9hYmNfcGFyc2VfZGlyZWN0aXZlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3BhcnNlL2FiY19wYXJzZV9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvcGFyc2UvYWJjX3BhcnNlX2tleV92b2ljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9wYXJzZS9hYmNfdG9rZW5pemVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3BhcnNlL2FiY190cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvcGFyc2Uvd3JhcF9saW5lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9zeW50aC9hY3RpdmUtYXVkaW8tY29udGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9zeW50aC9jcmVhdGUtbm90ZS1tYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvc3ludGgvY3JlYXRlLXN5bnRoLWNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvc3ludGgvY3JlYXRlLXN5bnRoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3N5bnRoL2Rvd25sb2FkLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9zeW50aC9pbnN0cnVtZW50LWluZGV4LXRvLW5hbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvc3ludGgvbG9hZC1ub3RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3N5bnRoL3BpdGNoLXRvLW5vdGUtbmFtZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy9zeW50aC9wbGF5LWV2ZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3N5bnRoL3JlZ2lzdGVyLWF1ZGlvLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvc3ludGgvc291bmRzLWNhY2hlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3N5bnRoL3N1cHBvcnRzLWF1ZGlvLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3N5bnRoL3N5bnRoLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvc3ludGgvc3ludGgtc2VxdWVuY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvdHJhbnNmb3JtL2FiYzJhYmNfd3JpdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvd3JpdGUvYWJjX2Fic29sdXRlX2VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvd3JpdGUvYWJjX2Fic3RyYWN0X2VuZ3JhdmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19iZWFtX2VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvd3JpdGUvYWJjX2JyYWNlX2VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvd3JpdGUvYWJjX2NyZWF0ZV9jbGVmLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19jcmVhdGVfa2V5X3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfY3JlYXRlX3RpbWVfc2lnbmF0dXJlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19jcmVzY2VuZG9fZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfZGVjb3JhdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfZHluYW1pY19kZWNvcmF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19lbmRpbmdfZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfZW5ncmF2ZXJfY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfZ2x5cGhzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19yZWxhdGl2ZV9lbGVtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL2FiY19yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfc3BhY2luZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfc3RhZmZfZ3JvdXBfZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfdGVtcG9fZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfdGllX2VsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmNqcy9zcmMvd3JpdGUvYWJjX3RyaXBsZXRfZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9hYmNfdm9pY2VfZWxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3NyYy93cml0ZS9zcHJpbnRmLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWJjanMvc3JjL3dyaXRlL3N2Zy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FiY2pzL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8iLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWJjanMvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCBBYmNqcyBmcm9tICdyZWFjdC1hYmNqcydcclxuXHJcbmNsYXNzIEluZGV4IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vdmFyIHJlYWN0QWJjanMgPSByZXF1aXJlKFwicmVhY3QtYWJjanNcIilcclxuXHJcbiAgICB9XHJcblxyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiA8ZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PiBUaGlzIGlzIG15IHdlYnNpdGUgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8QWJjanNcclxuICAgICAgICAgICAgICAgICAgICBhYmNOb3RhdGlvbj17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdYOjFcXG5UOkV4YW1wbGVcXG5NOjQvNFxcbkM6VHJhZC5cXG5LOkdcXG58OkdjY2MgZGVkQnxkZWRCIGRlZEJ8YzJlYyBCMmRCfGMyQTIgQTJCQXwnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlclBhcmFtcz17e319XHJcbiAgICAgICAgICAgICAgICAgICAgZW5ncmF2ZXJQYXJhbXM9e3sgcmVzcG9uc2l2ZTogJ3Jlc2l6ZScgfX1cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQYXJhbXM9e3sgdmlld3BvcnRIb3Jpem9udGFsOiB0cnVlIH19XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEluZGV4XHJcbiIsInZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG52YXIgYW5pbWF0aW9uID0gcmVxdWlyZSgnLi9zcmMvYXBpL2FiY19hbmltYXRpb24nKTtcbnZhciB0dW5lQm9vayA9IHJlcXVpcmUoJy4vc3JjL2FwaS9hYmNfdHVuZWJvb2snKTtcblxudmFyIGFiY2pzID0ge307XG5cbmFiY2pzLnNpZ25hdHVyZSA9IFwiYWJjanMtYmFzaWMgdlwiICsgdmVyc2lvbjtcblxuT2JqZWN0LmtleXMoYW5pbWF0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0YWJjanNba2V5XSA9IGFuaW1hdGlvbltrZXldO1xufSk7XG5cbk9iamVjdC5rZXlzKHR1bmVCb29rKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0YWJjanNba2V5XSA9IHR1bmVCb29rW2tleV07XG59KTtcblxuYWJjanMucmVuZGVyQWJjID0gcmVxdWlyZSgnLi9zcmMvYXBpL2FiY190dW5lYm9va19zdmcnKTtcbmFiY2pzLlRpbWluZ0NhbGxiYWNrcyA9IHJlcXVpcmUoJy4vc3JjL2FwaS9hYmNfdGltaW5nX2NhbGxiYWNrcycpO1xuXG52YXIgZ2x5cGhzID0gcmVxdWlyZSgnLi9zcmMvd3JpdGUvYWJjX2dseXBocycpO1xuYWJjanMuc2V0R2x5cGggPSBnbHlwaHMuc2V0U3ltYm9sO1xuXG52YXIgQ3JlYXRlU3ludGggPSByZXF1aXJlKCcuL3NyYy9zeW50aC9jcmVhdGUtc3ludGgnKTtcbnZhciBpbnN0cnVtZW50SW5kZXhUb05hbWUgPSByZXF1aXJlKCcuL3NyYy9zeW50aC9pbnN0cnVtZW50LWluZGV4LXRvLW5hbWUnKTtcbnZhciBwaXRjaFRvTm90ZU5hbWUgPSByZXF1aXJlKCcuL3NyYy9zeW50aC9waXRjaC10by1ub3RlLW5hbWUnKTtcbnZhciBTeW50aFNlcXVlbmNlID0gcmVxdWlyZSgnLi9zcmMvc3ludGgvc3ludGgtc2VxdWVuY2UnKTtcbnZhciBDcmVhdGVTeW50aENvbnRyb2wgPSByZXF1aXJlKCcuL3NyYy9zeW50aC9jcmVhdGUtc3ludGgtY29udHJvbCcpO1xudmFyIHJlZ2lzdGVyQXVkaW9Db250ZXh0ID0gcmVxdWlyZSgnLi9zcmMvc3ludGgvcmVnaXN0ZXItYXVkaW8tY29udGV4dCcpO1xudmFyIGFjdGl2ZUF1ZGlvQ29udGV4dCA9IHJlcXVpcmUoJy4vc3JjL3N5bnRoL2FjdGl2ZS1hdWRpby1jb250ZXh0Jyk7XG52YXIgc3VwcG9ydHNBdWRpbyA9IHJlcXVpcmUoJy4vc3JjL3N5bnRoL3N1cHBvcnRzLWF1ZGlvJyk7XG52YXIgcGxheUV2ZW50ID0gcmVxdWlyZSgnLi9zcmMvc3ludGgvcGxheS1ldmVudCcpO1xudmFyIFN5bnRoQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vc3JjL3N5bnRoL3N5bnRoLWNvbnRyb2xsZXInKTtcblxuYWJjanMuc3ludGggPSB7XG5cdENyZWF0ZVN5bnRoOiBDcmVhdGVTeW50aCxcblx0aW5zdHJ1bWVudEluZGV4VG9OYW1lOiBpbnN0cnVtZW50SW5kZXhUb05hbWUsXG5cdHBpdGNoVG9Ob3RlTmFtZTogcGl0Y2hUb05vdGVOYW1lLFxuXHRTeW50aENvbnRyb2xsZXI6IFN5bnRoQ29udHJvbGxlcixcblx0U3ludGhTZXF1ZW5jZTogU3ludGhTZXF1ZW5jZSxcblx0Q3JlYXRlU3ludGhDb250cm9sOiBDcmVhdGVTeW50aENvbnRyb2wsXG5cdHJlZ2lzdGVyQXVkaW9Db250ZXh0OiByZWdpc3RlckF1ZGlvQ29udGV4dCxcblx0YWN0aXZlQXVkaW9Db250ZXh0OiBhY3RpdmVBdWRpb0NvbnRleHQsXG5cdHN1cHBvcnRzQXVkaW86IHN1cHBvcnRzQXVkaW8sXG5cdHBsYXlFdmVudDogcGxheUV2ZW50XG59O1xuXG52YXIgZWRpdG9yID0gcmVxdWlyZSgnLi9zcmMvZWRpdC9hYmNfZWRpdG9yJyk7XG5hYmNqc1snRWRpdG9yJ10gPSBlZGl0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gYWJjanM7XG4iLCIvLyAgICBhYmNfYW5pbWF0aW9uLmpzOiBoYW5kbGVzIGFuaW1hdGluZyB0aGUgbXVzaWMgaW4gcmVhbCB0aW1lLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDE0LTIwMTggUGF1bCBSb3NlbiAocGF1bCBhdCBwYXVscm9zZW4gZG90IG5ldClcbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHNwYWNpbmcgPSByZXF1aXJlKCcuLi93cml0ZS9hYmNfc3BhY2luZycpO1xudmFyIHBhcnNlQ29tbW9uID0gcmVxdWlyZSgnLi4vcGFyc2UvYWJjX2NvbW1vbicpO1xudmFyIFRpbWluZ0NhbGxiYWNrcyA9IHJlcXVpcmUoJy4vYWJjX3RpbWluZ19jYWxsYmFja3MnKTtcblxudmFyIGFuaW1hdGlvbiA9IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciB0aW1lcjtcblx0dmFyIGN1cnNvcjtcblx0YW5pbWF0aW9uLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24ocGFwZXIsIHR1bmUsIG9wdGlvbnMpIHtcblx0XHQvL29wdGlvbnMuYnBtXG5cdFx0Ly9vcHRpb25zLnNob3dDdXJzb3Jcblx0XHQvL29wdGlvbnMuaGlkZUN1cnJlbnRNZWFzdXJlXG5cdFx0Ly9vcHRpb25zLmhpZGVGaW5pc2hlZE1lYXN1cmVzXG5cdFx0aWYgKHRpbWVyKSB7XG5cdFx0XHR0aW1lci5zdG9wKCk7XG5cdFx0XHR0aW1lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zaG93Q3Vyc29yKSB7XG5cdFx0XHRjdXJzb3IgPSBwYXBlci5xdWVyeVNlbGVjdG9yKCcuYWJjanMtY3Vyc29yJyk7XG5cdFx0XHRpZiAoIWN1cnNvcikge1xuXHRcdFx0XHRjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcblx0XHRcdFx0Y3Vyc29yLmNsYXNzTmFtZSA9ICdhYmNqcy1jdXJzb3IgY3Vyc29yJztcblx0XHRcdFx0Y3Vyc29yLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuXHRcdFx0XHRwYXBlci5hcHBlbmRDaGlsZChjdXJzb3IpO1xuXHRcdFx0XHRwYXBlci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGlkZU1lYXN1cmVzKGVsZW1lbnRzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG5cdFx0XHRcdGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2FiY2pzLWJhcicpKVxuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsYXN0TWVhc3VyZTtcblx0XHRmdW5jdGlvbiBkaXNhcHBlYXJNZWFzdXJlc0FmdGVyKHNlbGVjdG9yKSB7XG5cdFx0XHRpZiAobGFzdE1lYXN1cmUpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnRzID0gcGFwZXIucXVlcnlTZWxlY3RvckFsbChsYXN0TWVhc3VyZSk7XG5cdFx0XHRcdGhpZGVNZWFzdXJlcyhlbGVtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRsYXN0TWVhc3VyZSA9IHNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc2FwcGVhck1lYXN1cmVzQmVmb3JlKHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBwYXBlci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdGhpZGVNZWFzdXJlcyhlbGVtZW50cyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWVhc3VyZUNhbGxiYWNrKHNlbGVjdG9yKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5oaWRlQ3VycmVudE1lYXN1cmUpIHtcblx0XHRcdFx0ZGlzYXBwZWFyTWVhc3VyZXNCZWZvcmUoc2VsZWN0b3IpO1xuXHRcdFx0fSBlbHNlIGlmIChvcHRpb25zLmhpZGVGaW5pc2hlZE1lYXN1cmVzKSB7XG5cdFx0XHRcdGRpc2FwcGVhck1lYXN1cmVzQWZ0ZXIoc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldExpbmVBbmRNZWFzdXJlKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiAnLmFiY2pzLWwnICsgZWxlbWVudC5saW5lICsgJy5hYmNqcy1tJyArIGVsZW1lbnQubWVhc3VyZU51bWJlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRDdXJzb3IocmFuZ2UpIHtcblx0XHRcdGlmIChyYW5nZSkge1xuXHRcdFx0XHRpZiAocmFuZ2UubWVhc3VyZVN0YXJ0KSB7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdG9yID0gZ2V0TGluZUFuZE1lYXN1cmUocmFuZ2UpO1xuXHRcdFx0XHRcdGlmIChzZWxlY3Rvcilcblx0XHRcdFx0XHRcdG1lYXN1cmVDYWxsYmFjayhzZWxlY3Rvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN1cnNvcikge1xuXHRcdFx0XHRcdGN1cnNvci5zdHlsZS5sZWZ0ID0gcmFuZ2UubGVmdCArIFwicHhcIjtcblx0XHRcdFx0XHRjdXJzb3Iuc3R5bGUudG9wID0gcmFuZ2UudG9wICsgXCJweFwiO1xuXHRcdFx0XHRcdGN1cnNvci5zdHlsZS53aWR0aCA9IHJhbmdlLndpZHRoICsgXCJweFwiO1xuXHRcdFx0XHRcdGN1cnNvci5zdHlsZS5oZWlnaHQgPSByYW5nZS5oZWlnaHQgKyBcInB4XCI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpbWVyLnN0b3AoKTtcblx0XHRcdFx0dGltZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGltZXIgPSBuZXcgVGltaW5nQ2FsbGJhY2tzKHR1bmUsIHtcblx0XHRcdHFwbTogb3B0aW9ucy5icG0sXG5cdFx0XHRldmVudENhbGxiYWNrOiBzZXRDdXJzb3Jcblx0XHR9KTtcblx0XHR0aW1lci5zdGFydCgpO1xuXHR9O1xuXG5cdGFuaW1hdGlvbi5wYXVzZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKHBhdXNlKSB7XG5cdFx0aWYgKHRpbWVyKSB7XG5cdFx0XHRpZiAocGF1c2UpXG5cdFx0XHRcdHRpbWVyLnBhdXNlKCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRpbWVyLnN0YXJ0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdGFuaW1hdGlvbi5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRpbWVyKSB7XG5cdFx0XHR0aW1lci5zdG9wKCk7XG5cdFx0XHR0aW1lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH07XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYW5pbWF0aW9uO1xuIiwiXG52YXIgVGltaW5nQ2FsbGJhY2tzID0gZnVuY3Rpb24odGFyZ2V0LCBwYXJhbXMpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG5cdHNlbGYucXBtID0gcGFyYW1zLnFwbSA/IHBhcnNlSW50KHBhcmFtcy5xcG0sIDEwKSA6IG51bGw7XG5cdGlmICghc2VsZi5xcG0pIHtcblx0XHR2YXIgdGVtcG8gPSB0YXJnZXQubWV0YVRleHQgPyB0YXJnZXQubWV0YVRleHQudGVtcG8gOiBudWxsO1xuXHRcdHNlbGYucXBtID0gdGFyZ2V0LmdldEJwbSh0ZW1wbyk7XG5cdH1cblx0c2VsZi5leHRyYU1lYXN1cmVzQXRCZWdpbm5pbmcgPSBwYXJhbXMuZXh0cmFNZWFzdXJlc0F0QmVnaW5uaW5nID8gcGFyc2VJbnQocGFyYW1zLmV4dHJhTWVhc3VyZXNBdEJlZ2lubmluZywgMTApIDogMDtcblx0c2VsZi5iZWF0Q2FsbGJhY2sgPSBwYXJhbXMuYmVhdENhbGxiYWNrOyAvLyBUaGlzIGlzIGNhbGxlZCBmb3IgZWFjaCBiZWF0LlxuXHRzZWxmLmV2ZW50Q2FsbGJhY2sgPSBwYXJhbXMuZXZlbnRDYWxsYmFjazsgICAvLyBUaGlzIGlzIGNhbGxlZCBmb3IgZWFjaCBub3RlIG9yIHJlc3QgZW5jb3VudGVyZWQuXG5cdHNlbGYubGluZUVuZENhbGxiYWNrID0gcGFyYW1zLmxpbmVFbmRDYWxsYmFjazsgICAvLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBlbmQgb2YgYSBsaW5lIGlzIGFwcHJvYWNoaW5nLlxuXHRzZWxmLmxpbmVFbmRBbnRpY2lwYXRpb24gPSBwYXJhbXMubGluZUVuZEFudGljaXBhdGlvbiA/IHBhcnNlSW50KHBhcmFtcy5saW5lRW5kQW50aWNpcGF0aW9uLCAxMCkgOiAwOyAgIC8vIEhvdyBtYW55IG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIGVuZCBzaG91bGQgdGhlIGNhbGwgaGFwcGVuLlxuXHRzZWxmLmJlYXRTdWJkaXZpc2lvbnMgPSBwYXJhbXMuYmVhdFN1YmRpdmlzaW9ucyA/IHBhcnNlSW50KHBhcmFtcy5iZWF0U3ViZGl2aXNpb25zLCAxMCkgOiAxOyAvLyBob3cgbWFueSBjYWxsYmFja3MgcGVyIGJlYXQgaXMgZGVzaXJlZC5cblxuXHRzZWxmLnJlcGxhY2VUYXJnZXQgPSBmdW5jdGlvbihuZXdUYXJnZXQpIHtcblx0XHRuZXdUYXJnZXQuc2V0VGltaW5nKHNlbGYucXBtLCBzZWxmLmV4dHJhTWVhc3VyZXNBdEJlZ2lubmluZyk7XG5cdFx0aWYgKG5ld1RhcmdldC5ub3RlVGltaW5ncy5sZW5ndGggPT09IDApXG5cdFx0XHRuZXdUYXJnZXQuc2V0VGltaW5nKDAsMCk7XG5cdFx0aWYgKHNlbGYubGluZUVuZENhbGxiYWNrKSB7XG5cdFx0XHRzZWxmLmxpbmVFbmRUaW1pbmdzID0gZ2V0TGluZUVuZFRpbWluZ3MobmV3VGFyZ2V0Lm5vdGVUaW1pbmdzLCBzZWxmLmxpbmVFbmRBbnRpY2lwYXRpb24pO1xuXHRcdH1cblx0XHRzZWxmLm5vdGVUaW1pbmdzID0gbmV3VGFyZ2V0Lm5vdGVUaW1pbmdzO1xuXHR9O1xuXG5cdHNlbGYucmVwbGFjZVRhcmdldCh0YXJnZXQpO1xuXHRpZiAoc2VsZi5ub3RlVGltaW5ncy5sZW5ndGggPT09IDApXG5cdFx0cmV0dXJuO1xuXG5cdC8vIG5vdGVUaW1pbmdzIGNvbnRhaW5zIGFuIGFycmF5IG9mIGV2ZW50cyBzb3J0ZWQgYnkgdGltZS4gRXZlbnRzIHRoYXQgaGFwcGVuIGF0IHRoZSBzYW1lIHRpbWUgYXJlIGluIHRoZSBzYW1lIGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuXHRzZWxmLm5vdGVUaW1pbmdzID0gdGFyZ2V0Lm5vdGVUaW1pbmdzO1xuXHRzZWxmLm1pbGxpc2Vjb25kc1BlckJlYXQgPSAxMDAwIC8gKHNlbGYucXBtIC8gNjApIC8gc2VsZi5iZWF0U3ViZGl2aXNpb25zO1xuXHRzZWxmLmxhc3RNb21lbnQgPSBzZWxmLm5vdGVUaW1pbmdzW3NlbGYubm90ZVRpbWluZ3MubGVuZ3RoLTFdLm1pbGxpc2Vjb25kcztcblx0c2VsZi50b3RhbEJlYXRzID0gTWF0aC5yb3VuZChzZWxmLmxhc3RNb21lbnQgLyBzZWxmLm1pbGxpc2Vjb25kc1BlckJlYXQpO1xuXG5cdHNlbGYuc3RhcnRUaW1lID0gbnVsbDtcblx0c2VsZi5jdXJyZW50QmVhdCA9IDA7XG5cdHNlbGYuY3VycmVudEV2ZW50ID0gMDtcblx0c2VsZi5pc1BhdXNlZCA9IGZhbHNlO1xuXHRzZWxmLmlzUnVubmluZyA9IGZhbHNlO1xuXHRzZWxmLnBhdXNlZFRpbWUgPSBudWxsO1xuXHRzZWxmLmp1c3RVbnBhdXNlZCA9IGZhbHNlO1xuXG5cdHNlbGYubmV3U2Vla1BlcmNlbnQgPSAwO1xuXHRzZWxmLmp1c3RTZWVrZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXRDdXJyZW50TG9jYXRpb24odGltZXN0YW1wKSB7XG5cdFx0Ly8gRmlyc3QgZmluZCB0aGUgcmVsYXRpdmUgYW1vdW50IHRvIG1vdmU6IHRoYXQgaXMsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgcGVyY2VudGFnZSBhbmQgdGhlIHBhc3NlZCBpbiBwZXJjZW50LlxuXHRcdHZhciBjdXJyZW50UGVyY2VudCA9ICh0aW1lc3RhbXAgLSBzZWxmLnN0YXJ0VGltZSkgLyBzZWxmLmxhc3RNb21lbnQ7XG5cdFx0dmFyIHBlcmNlbnREaWZmZXJlbmNlID0gY3VycmVudFBlcmNlbnQgLSBzZWxmLm5ld1NlZWtQZXJjZW50O1xuXHRcdHZhciB0aW1lRGlmZmVyZW5jZSA9IHNlbGYubGFzdE1vbWVudCAqIHBlcmNlbnREaWZmZXJlbmNlO1xuXHRcdHNlbGYuc3RhcnRUaW1lID0gc2VsZi5zdGFydFRpbWUgKyB0aW1lRGlmZmVyZW5jZTtcblxuXHRcdHZhciBjdXJyZW50VGltZSA9IHRpbWVzdGFtcCAtIHNlbGYuc3RhcnRUaW1lO1xuXHRcdGN1cnJlbnRUaW1lICs9IDUwOyAvLyBBZGQgYSBsaXR0bGUgc2xvcCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXNuJ3QgY2FsbGVkIGV4YWN0bHkuXG5cblx0XHR2YXIgb2xkQmVhdCA9IHNlbGYuY3VycmVudEJlYXQ7XG5cdFx0c2VsZi5jdXJyZW50QmVhdCA9IE1hdGguZmxvb3IoY3VycmVudFRpbWUgLyBzZWxmLm1pbGxpc2Vjb25kc1BlckJlYXQpO1xuXHRcdGlmIChzZWxmLmJlYXRDYWxsYmFjayAmJiBvbGRCZWF0ICE9PSBzZWxmLmN1cnJlbnRCZWF0KSAvLyBJZiB0aGUgbW92ZW1lbnQgY2F1c2VkIHRoZSBiZWF0IHRvIGNoYW5nZSwgdGhlbiBpbW1lZGlhdGVseSByZXBvcnQgaXQgdG8gdGhlIGNsaWVudC5cblx0XHRcdHNlbGYuYmVhdENhbGxiYWNrKHNlbGYuY3VycmVudEJlYXQgLyBzZWxmLmJlYXRTdWJkaXZpc2lvbnMsIHNlbGYudG90YWxCZWF0cyAvIHNlbGYuYmVhdFN1YmRpdmlzaW9ucywgc2VsZi5sYXN0TW9tZW50KTtcblxuXHRcdHNlbGYuY3VycmVudEV2ZW50ID0gMDtcblx0XHR3aGlsZSAoc2VsZi5ub3RlVGltaW5ncy5sZW5ndGggPiBzZWxmLmN1cnJlbnRFdmVudCAmJiBzZWxmLm5vdGVUaW1pbmdzW3NlbGYuY3VycmVudEV2ZW50XS5taWxsaXNlY29uZHMgPCBjdXJyZW50VGltZSkge1xuXHRcdFx0c2VsZi5jdXJyZW50RXZlbnQrKztcblx0XHR9XG5cdFx0aWYgKHNlbGYuZXZlbnRDYWxsYmFjayAmJiBzZWxmLmN1cnJlbnRFdmVudCA+IDAgJiYgc2VsZi5ub3RlVGltaW5nc1tzZWxmLmN1cnJlbnRFdmVudCAtIDFdLnR5cGUgPT09ICdldmVudCcpXG5cdFx0XHRzZWxmLmV2ZW50Q2FsbGJhY2soc2VsZi5ub3RlVGltaW5nc1tzZWxmLmN1cnJlbnRFdmVudCAtIDFdKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKFwiY3VycmVudFBlcmNlbnQ9XCIrY3VycmVudFBlcmNlbnQrXG5cdFx0Ly8gXHRcIiBuZXdTZWVrUGVyY2VudD1cIitzZWxmLm5ld1NlZWtQZXJjZW50K1xuXHRcdC8vIFx0XCIgcGVyY2VudERpZmZlcmVuY2U9XCIrcGVyY2VudERpZmZlcmVuY2UrXG5cdFx0Ly8gXHRcIiB0aW1lRGlmZmVyZW5jZT1cIix0aW1lRGlmZmVyZW5jZStcblx0XHQvLyBcdFwiIGN1cnJlbnRCZWF0PVwiK3NlbGYuY3VycmVudEJlYXQrXG5cdFx0Ly8gXHRcIiBjdXJyZW50RXZlbnQ9XCIrc2VsZi5jdXJyZW50RXZlbnQpO1xuXHR9XG5cblx0c2VsZi5kb1RpbWluZyA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcblx0XHRpZiAoIXNlbGYuc3RhcnRUaW1lKSB7XG5cdFx0XHRzZWxmLnN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcblx0XHR9IGVsc2UgaWYgKHNlbGYuanVzdFVucGF1c2VkKSB7XG5cdFx0XHQvLyBBZGQgdGhlIGFtb3VudCB3ZSBwYXVzZWQgdG8gdGhlIHN0YXJ0IHRpbWUgdG8gZ2V0IHRoZSByaWdodCBwbGFjZS5cblx0XHRcdHZhciB0aW1lUGF1c2VkID0gKHRpbWVzdGFtcCAtIHNlbGYucGF1c2VkVGltZSk7XG5cdFx0XHRzZWxmLnN0YXJ0VGltZSArPSB0aW1lUGF1c2VkO1xuXHRcdH1cblx0XHRzZWxmLmp1c3RVbnBhdXNlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKHNlbGYuanVzdFNlZWtlZCkge1xuXHRcdFx0c2V0Q3VycmVudExvY2F0aW9uKHRpbWVzdGFtcCk7XG5cdFx0XHRzZWxmLmp1c3RTZWVrZWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHNlbGYuaXNQYXVzZWQpIHtcblx0XHRcdHNlbGYucGF1c2VkVGltZSA9IHRpbWVzdGFtcDtcblx0XHR9IGVsc2UgaWYgKHNlbGYuaXNSdW5uaW5nKSB7XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSB0aW1lc3RhbXAgLSBzZWxmLnN0YXJ0VGltZTtcblx0XHRcdGN1cnJlbnRUaW1lICs9IDUwOyAvLyBBZGQgYSBsaXR0bGUgc2xvcCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXNuJ3QgY2FsbGVkIGV4YWN0bHkuXG5cdFx0XHR3aGlsZSAoc2VsZi5ub3RlVGltaW5ncy5sZW5ndGggPiBzZWxmLmN1cnJlbnRFdmVudCAmJiBzZWxmLm5vdGVUaW1pbmdzW3NlbGYuY3VycmVudEV2ZW50XS5taWxsaXNlY29uZHMgPCBjdXJyZW50VGltZSkge1xuXHRcdFx0XHRpZiAoc2VsZi5ldmVudENhbGxiYWNrICYmIHNlbGYubm90ZVRpbWluZ3Nbc2VsZi5jdXJyZW50RXZlbnRdLnR5cGUgPT09ICdldmVudCcpXG5cdFx0XHRcdFx0c2VsZi5ldmVudENhbGxiYWNrKHNlbGYubm90ZVRpbWluZ3Nbc2VsZi5jdXJyZW50RXZlbnRdKTtcblx0XHRcdFx0c2VsZi5jdXJyZW50RXZlbnQrKztcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VGltZSA8IHNlbGYubGFzdE1vbWVudCkge1xuXHRcdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VsZi5kb1RpbWluZyk7XG5cdFx0XHRcdGlmIChzZWxmLmN1cnJlbnRCZWF0ICogc2VsZi5taWxsaXNlY29uZHNQZXJCZWF0IDwgY3VycmVudFRpbWUpIHtcblx0XHRcdFx0XHRpZiAoc2VsZi5iZWF0Q2FsbGJhY2spXG5cdFx0XHRcdFx0XHRzZWxmLmJlYXRDYWxsYmFjayhzZWxmLmN1cnJlbnRCZWF0IC8gc2VsZi5iZWF0U3ViZGl2aXNpb25zLCBzZWxmLnRvdGFsQmVhdHMgLyBzZWxmLmJlYXRTdWJkaXZpc2lvbnMsIHNlbGYubGFzdE1vbWVudCk7XG5cdFx0XHRcdFx0c2VsZi5jdXJyZW50QmVhdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHNlbGYuY3VycmVudEJlYXQgPD0gc2VsZi50b3RhbEJlYXRzKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2Ugb2YgdGltaW5nIGlzc3VlcyAoZm9yIGluc3RhbmNlLCBpZiB0aGUgYnJvd3NlciB0YWIgaXNuJ3QgYWN0aXZlKSwgdGhlIGJlYXQgY2FsbGJhY2tzIG1pZ2h0IG5vdCBoYXZlIGhhcHBlbmVkIHdoZW4gdGhleSBhcmUgc3VwcG9zZWQgdG8uIFRvIGtlZXAgdGhlIGNsaWVudCBwcm9ncmFtcyBmcm9tIGhhdmluZyB0byBkZWFsIHdpdGggdGhhdCwgdGhpcyB3aWxsIGtlZXAgY2FsbGluZyB0aGUgbG9vcCB1bnRpbCBhbGwgb2YgdGhlbSBoYXZlIGJlZW4gc2VudC5cblx0XHRcdFx0aWYgKHNlbGYuYmVhdENhbGxiYWNrKSB7XG5cdFx0XHRcdFx0c2VsZi5iZWF0Q2FsbGJhY2soc2VsZi5jdXJyZW50QmVhdCAvIHNlbGYuYmVhdFN1YmRpdmlzaW9ucywgc2VsZi50b3RhbEJlYXRzIC8gc2VsZi5iZWF0U3ViZGl2aXNpb25zLCBzZWxmLmxhc3RNb21lbnQpO1xuXHRcdFx0XHRcdHNlbGYuY3VycmVudEJlYXQrKztcblx0XHRcdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VsZi5kb1RpbWluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlbGYubGluZUVuZENhbGxiYWNrICYmIHNlbGYubGluZUVuZFRpbWluZ3MubGVuZ3RoICYmIHNlbGYubGluZUVuZFRpbWluZ3NbMF0ubWlsbGlzZWNvbmRzIDw9IGN1cnJlbnRUaW1lKSB7XG5cdFx0XHRcdHNlbGYubGluZUVuZENhbGxiYWNrKHNlbGYubGluZUVuZFRpbWluZ3NbMF0pO1xuXHRcdFx0XHRzZWxmLmxpbmVFbmRUaW1pbmdzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50VGltZSA+PSBzZWxmLmxhc3RNb21lbnQgJiYgc2VsZi5ldmVudENhbGxiYWNrKVxuXHRcdFx0XHRzZWxmLmV2ZW50Q2FsbGJhY2sobnVsbCk7XG5cdFx0fVxuXHR9O1xuXG5cdHNlbGYuc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0XHRzZWxmLmlzUnVubmluZyA9IHRydWU7XG5cdFx0aWYgKHNlbGYuaXNQYXVzZWQpIHtcblx0XHRcdHNlbGYuaXNQYXVzZWQgPSBmYWxzZTtcblx0XHRcdHNlbGYuanVzdFVucGF1c2VkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNlbGYuZG9UaW1pbmcpO1xuXHR9O1xuXHRzZWxmLnBhdXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5pc1BhdXNlZCA9IHRydWU7XG5cdFx0c2VsZi5pc1J1bm5pbmcgPSBmYWxzZTtcblx0fTtcblx0c2VsZi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuY3VycmVudEJlYXQgPSAwO1xuXHRcdHNlbGYuY3VycmVudEV2ZW50ID0gMDtcblx0XHRzZWxmLnN0YXJ0VGltZSA9IG51bGw7XG5cdFx0c2VsZi5wYXVzZWRUaW1lID0gbnVsbDtcblx0XHRpZiAoc2VsZi5saW5lRW5kQ2FsbGJhY2spIHtcblx0XHRcdHNlbGYubGluZUVuZFRpbWluZ3MgPSBnZXRMaW5lRW5kVGltaW5ncyhzZWxmLm5vdGVUaW1pbmdzLCBzZWxmLmxpbmVFbmRBbnRpY2lwYXRpb24pO1xuXHRcdH1cblx0fTtcblx0c2VsZi5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5wYXVzZSgpO1xuXHRcdHNlbGYucmVzZXQoKTtcblx0fTtcblx0c2VsZi5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uKHBlcmNlbnQpIHtcblx0XHQvLyB0aGlzIGlzIHBhc3NlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cblx0XHQvLyB0aGUgZWZmZWN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gbW92ZSBzdGFydFRpbWUgc28gdGhhdCB0aGUgY2FsbGJhY2tzIGhhcHBlbiBjb3JyZWN0bHkgZm9yIHRoZSBuZXcgc2Vlay5cblx0XHRpZiAocGVyY2VudCA8IDApIHBlcmNlbnQgPSAwO1xuXHRcdGlmIChwZXJjZW50ID4gMSkgcGVyY2VudCA9IDE7XG5cblx0XHRzZWxmLm5ld1NlZWtQZXJjZW50ID0gcGVyY2VudDtcblx0XHRzZWxmLmp1c3RTZWVrZWQgPSB0cnVlO1xuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZShzZWxmLmRvVGltaW5nKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGdldExpbmVFbmRUaW1pbmdzKHRpbWluZ3MsIGFudGljaXBhdGlvbikge1xuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIG1pbGxpc2Vjb25kcyB0byBjYWxsIHRoZSBsaW5lRW5kQ2FsbGJhY2suXG5cdC8vIFRoaXMgZmlndXJlcyBvdXQgdGhlIHRpbWluZyBvZiB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggbGluZSBhbmQgc3VidHJhY3RzIHRoZSBhbnRpY2lwYXRpb24gZnJvbSBpdC5cblx0dmFyIGNhbGxiYWNrVGltZXMgPSBbXTtcblx0dmFyIGxhc3RUb3AgPSBudWxsO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRpbWluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdGltaW5nID0gdGltaW5nc1tpXTtcblx0XHRpZiAodGltaW5nLnRvcCAhPT0gbGFzdFRvcCkge1xuXHRcdFx0Y2FsbGJhY2tUaW1lcy5wdXNoKHsgbWlsbGlzZWNvbmRzOiB0aW1pbmcubWlsbGlzZWNvbmRzIC0gYW50aWNpcGF0aW9uLCB0b3A6IHRpbWluZy50b3AsIGJvdHRvbTogdGltaW5nLnRvcCt0aW1pbmcuaGVpZ2h0IH0pO1xuXHRcdFx0bGFzdFRvcCA9IHRpbWluZy50b3A7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjYWxsYmFja1RpbWVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWluZ0NhbGxiYWNrcztcblxuIiwiLy8gICAgYWJjX3R1bmVib29rLmpzOiBzcGxpdHMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIEFCQyBNdXNpYyBOb3RhdGlvbiBpbnRvIGluZGl2aWR1YWwgdHVuZXMuXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBQYXVsIFJvc2VuIChwYXVsIGF0IHBhdWxyb3NlbiBkb3QgbmV0KVxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vKmdsb2JhbCBkb2N1bWVudCAqL1xuLypnbG9iYWwgd2luZG93LCBBQkNKUywgY29uc29sZSAqL1xuXG52YXIgcGFyc2VDb21tb24gPSByZXF1aXJlKCcuLi9wYXJzZS9hYmNfY29tbW9uJyk7XG52YXIgUGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZS9hYmNfcGFyc2UnKTtcblxudmFyIHR1bmVib29rID0ge307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dHVuZWJvb2subnVtYmVyT2ZUdW5lcyA9IGZ1bmN0aW9uKGFiYykge1xuXHRcdHZhciB0dW5lcyA9IGFiYy5zcGxpdChcIlxcblg6XCIpO1xuXHRcdHZhciBudW0gPSB0dW5lcy5sZW5ndGg7XG5cdFx0aWYgKG51bSA9PT0gMCkgbnVtID0gMTtcblx0XHRyZXR1cm4gbnVtO1xuXHR9O1xuXG5cdHZhciBUdW5lQm9vayA9IHR1bmVib29rLlR1bmVCb29rID0gZnVuY3Rpb24oYm9vaykge1xuXHRcdHZhciBUaGlzID0gdGhpcztcblx0XHR2YXIgZGlyZWN0aXZlcyA9IFwiXCI7XG5cdFx0Ym9vayA9IHBhcnNlQ29tbW9uLnN0cmlwKGJvb2spO1xuXHRcdHZhciB0dW5lcyA9IGJvb2suc3BsaXQoXCJcXG5YOlwiKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHR1bmVzLmxlbmd0aDsgaSsrKVx0Ly8gUHV0IGJhY2sgdGhlIFg6IHRoYXQgd2UgbG9zdCB3aGVuIHNwbGl0dGluZyB0aGUgdHVuZXMuXG5cdFx0XHR0dW5lc1tpXSA9IFwiWDpcIiArIHR1bmVzW2ldO1xuXHRcdC8vIEtlZXAgdHJhY2sgb2YgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBlYWNoIHR1bmUgc3RhcnRzIHdpdGguXG5cdFx0dmFyIHBvcyA9IDA7XG5cdFx0VGhpcy50dW5lcyA9IFtdO1xuXHRcdHBhcnNlQ29tbW9uLmVhY2godHVuZXMsIGZ1bmN0aW9uKHR1bmUpIHtcblx0XHRcdFRoaXMudHVuZXMucHVzaCh7IGFiYzogdHVuZSwgc3RhcnRQb3M6IHBvc30pO1xuXHRcdFx0cG9zICs9IHR1bmUubGVuZ3RoICsgMTsgLy8gV2UgYWxzbyBsb3N0IGEgbmV3bGluZSB3aGVuIHNwbGl0dGluZywgc28gY291bnQgdGhhdC5cblx0XHR9KTtcblx0XHRpZiAoVGhpcy50dW5lcy5sZW5ndGggPiAxICYmICFwYXJzZUNvbW1vbi5zdGFydHNXaXRoKFRoaXMudHVuZXNbMF0uYWJjLCAnWDonKSkge1x0Ly8gSWYgdGhlcmUgaXMgb25seSBvbmUgdHVuZSwgdGhlIFg6IG1pZ2h0IGJlIG1pc3NpbmcsIG90aGVyd2lzZSBhc3N1bWUgdGhlIHRvcCBvZiB0aGUgZmlsZSBpcyBcImludGVydHVuZVwiXG5cdFx0XHQvLyBUaGVyZSBjb3VsZCBiZSBmaWxlLXdpZGUgZGlyZWN0aXZlcyBpbiB0aGlzLCBpZiBzbywgd2UgbmVlZCB0byBpbnNlcnQgaXQgaW50byBlYWNoIHR1bmUuIFdlIGNhbiBwcm9iYWJseSBnZXQgYXdheSB3aXRoXG5cdFx0XHQvLyBqdXN0IGxvb2tpbmcgZm9yIGZpbGUtd2lkZSBkaXJlY3RpdmVzIGhlcmUgKGJlZm9yZSB0aGUgZmlyc3QgdHVuZSkgYW5kIGluc2VydGluZyB0aGVtIGF0IHRoZSBib3R0b20gb2YgZWFjaCB0dW5lLCBzaW5jZVxuXHRcdFx0Ly8gdGhlIHR1bmUgaXMgcGFyc2VkIGFsbCBhdCBvbmNlLiBUaGUgZGlyZWN0aXZlcyB3aWxsIGJlIHNlZW4gYmVmb3JlIHRoZSBlbmdyYXZlciBiZWdpbnMgcHJvY2Vzc2luZy5cblx0XHRcdHZhciBkaXIgPSBUaGlzLnR1bmVzLnNoaWZ0KCk7XG5cdFx0XHR2YXIgYXJyRGlyID0gZGlyLmFiYy5zcGxpdCgnXFxuJyk7XG5cdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGFyckRpciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChsaW5lLCAnJSUnKSlcblx0XHRcdFx0XHRkaXJlY3RpdmVzICs9IGxpbmUgKyAnXFxuJztcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRUaGlzLmhlYWRlciA9IGRpcmVjdGl2ZXM7XG5cblx0XHQvLyBOb3csIHRoZSB0dW5lIGVuZHMgYXQgYSBibGFuayBsaW5lLCBzbyB0cnVuY2F0ZSBpdCBpZiBuZWVkZWQuIFRoZXJlIG1heSBiZSBcImludGVydHVuZVwiIHN0dWZmLlxuXHRcdHBhcnNlQ29tbW9uLmVhY2goVGhpcy50dW5lcywgZnVuY3Rpb24odHVuZSkge1xuXHRcdFx0dmFyIGVuZCA9IHR1bmUuYWJjLmluZGV4T2YoJ1xcblxcbicpO1xuXHRcdFx0aWYgKGVuZCA+IDApXG5cdFx0XHRcdHR1bmUuYWJjID0gdHVuZS5hYmMuc3Vic3RyaW5nKDAsIGVuZCk7XG5cdFx0XHR0dW5lLnB1cmUgPSB0dW5lLmFiYztcblx0XHRcdHR1bmUuYWJjID0gZGlyZWN0aXZlcyArIHR1bmUuYWJjO1xuXG5cdFx0XHQvLyBmb3IgdGhlIHVzZXIncyBjb252ZW5pZW5jZSwgcGFyc2UgYW5kIHN0b3JlIHRoZSB0aXRsZSBzZXBhcmF0ZWx5LiBUaGUgdGl0bGUgaXMgYmV0d2VlbiB0aGUgZmlyc3QgVDogYW5kIHRoZSBuZXh0IFxcblxuXHRcdFx0dmFyIHRpdGxlID0gdHVuZS5wdXJlLnNwbGl0KFwiVDpcIik7XG5cdFx0XHRpZiAodGl0bGUubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aXRsZSA9IHRpdGxlWzFdLnNwbGl0KFwiXFxuXCIpO1xuXHRcdFx0XHR0dW5lLnRpdGxlID0gdGl0bGVbMF0ucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHR1bmUudGl0bGUgPSBcIlwiO1xuXG5cdFx0XHQvLyBmb3IgdGhlIHVzZXIncyBjb252ZW5pZW5jZSwgcGFyc2UgYW5kIHN0b3JlIHRoZSBpZCBzZXBhcmF0ZWx5LiBUaGUgaWQgaXMgYmV0d2VlbiB0aGUgZmlyc3QgWDogYW5kIHRoZSBuZXh0IFxcblxuXHRcdFx0dmFyIGlkID0gdHVuZS5wdXJlLnN1YnN0cmluZygyLCB0dW5lLnB1cmUuaW5kZXhPZihcIlxcblwiKSk7XG5cdFx0XHR0dW5lLmlkID0gaWQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFR1bmVCb29rLnByb3RvdHlwZS5nZXRUdW5lQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnR1bmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy50dW5lc1tpXS5pZCA9PT0gJycraWQpXG5cdFx0XHRcdHJldHVybiB0aGlzLnR1bmVzW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHRUdW5lQm9vay5wcm90b3R5cGUuZ2V0VHVuZUJ5VGl0bGUgPSBmdW5jdGlvbih0aXRsZSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50dW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMudHVuZXNbaV0udGl0bGUgPT09IHRpdGxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy50dW5lc1tpXTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0dHVuZWJvb2sucGFyc2VPbmx5ID0gZnVuY3Rpb24oYWJjLCBwYXJhbXMpIHtcblx0XHR2YXIgdHVuZXMgPSBbXTtcblx0XHR2YXIgbnVtVHVuZXMgPSB0dW5lYm9vay5udW1iZXJPZlR1bmVzKGFiYyk7XG5cblx0XHQvLyB0aGlzIGp1c3QgbmVlZHMgdG8gYmUgcGFzc2VkIGluIGJlY2F1c2UgdGhpcyB0ZWxscyB0aGUgZW5naW5lIGhvdyBtYW55IHR1bmVzIHRvIHByb2Nlc3MuXG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHVuZXM7IGkrKykge1xuXHRcdFx0b3V0cHV0LnB1c2goMSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuXHRcdFx0Ly8gRG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyB3aXRoIHRoZSBwYXJzZWQgdHVuZXMuXG5cdFx0fVxuXHRcdHJldHVybiB0dW5lYm9vay5yZW5kZXJFbmdpbmUoY2FsbGJhY2ssIG91dHB1dCwgYWJjLCBwYXJhbXMpO1xuXHR9O1xuXG5cdHR1bmVib29rLnJlbmRlckVuZ2luZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3V0cHV0LCBhYmMsIHBhcmFtcykge1xuXHRcdHZhciByZXQgPSBbXTtcblx0XHR2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKHRlc3RPYmplY3QpIHtcblx0XHRcdHJldHVybiB0ZXN0T2JqZWN0ICYmICEodGVzdE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnbGVuZ3RoJykpICYmIHR5cGVvZiB0ZXN0T2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGVzdE9iamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xuXHRcdH07XG5cblx0XHQvLyBjaGVjayBhbmQgbm9ybWFsaXplIGlucHV0IHBhcmFtZXRlcnNcblx0XHRpZiAob3V0cHV0ID09PSB1bmRlZmluZWQgfHwgYWJjID09PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKCFpc0FycmF5KG91dHB1dCkpXG5cdFx0XHRvdXRwdXQgPSBbIG91dHB1dCBdO1xuXHRcdGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZClcblx0XHRcdHBhcmFtcyA9IHt9O1xuXHRcdHZhciBjdXJyZW50VHVuZSA9IHBhcmFtcy5zdGFydGluZ1R1bmUgPyBwYXJzZUludChwYXJhbXMuc3RhcnRpbmdUdW5lLCAxMCkgOiAwO1xuXG5cdFx0Ly8gcGFyc2UgdGhlIGFiYyBzdHJpbmdcblx0XHR2YXIgYm9vayA9IG5ldyBUdW5lQm9vayhhYmMpO1xuXHRcdHZhciBhYmNQYXJzZXIgPSBuZXcgUGFyc2UoKTtcblxuXHRcdC8vIG91dHB1dCBlYWNoIHR1bmUsIGlmIGl0IGV4aXN0cy4gT3RoZXJ3aXNlIGNsZWFyIHRoZSBkaXYuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkaXYgPSBvdXRwdXRbaV07XG5cdFx0XHRpZiAoZGl2ID09PSBcIipcIikge1xuXHRcdFx0XHQvLyBUaGlzIGlzIGZvciBcImhlYWRsZXNzXCIgcmVuZGVyaW5nOiBkb2luZyB0aGUgd29yayBidXQgbm90IHNob3dpbmcgdGhlIHN2Zy5cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKGRpdikgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRcdGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdik7XG5cdFx0XHRpZiAoZGl2KSB7XG5cdFx0XHRcdGlmIChjdXJyZW50VHVuZSA+PSAwICYmIGN1cnJlbnRUdW5lIDwgYm9vay50dW5lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRhYmNQYXJzZXIucGFyc2UoYm9vay50dW5lc1tjdXJyZW50VHVuZV0uYWJjLCBwYXJhbXMsIGJvb2sudHVuZXNbY3VycmVudFR1bmVdLnN0YXJ0UG9zIC0gYm9vay5oZWFkZXIubGVuZ3RoKTtcblx0XHRcdFx0XHR2YXIgdHVuZSA9IGFiY1BhcnNlci5nZXRUdW5lKCk7XG5cdFx0XHRcdFx0dmFyIG92ZXJyaWRlID0gY2FsbGJhY2soZGl2LCB0dW5lLCBpLCBib29rLnR1bmVzW2N1cnJlbnRUdW5lXS5hYmMpO1xuXHRcdFx0XHRcdHJldC5wdXNoKG92ZXJyaWRlID8gb3ZlcnJpZGUgOiB0dW5lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoZGl2Lmhhc093blByb3BlcnR5KCdpbm5lckhUTUwnKSlcblx0XHRcdFx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50VHVuZSsrO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGZsYXR0ZW5UdW5lKHR1bmVPYmopIHtcblx0XHQvLyBUaGlzIHJlbW92ZXMgdGhlIGxpbmUgYnJlYWtzIGFuZCByZW1vdmVzIHRoZSBub24tbXVzaWMgbGluZXMuXG5cdFx0dmFyIHN0YXZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgdHVuZU9iai5saW5lcy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxpbmUgPSB0dW5lT2JqLmxpbmVzW2pdO1xuXHRcdFx0aWYgKGxpbmUuc3RhZmYpIHtcblx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBsaW5lLnN0YWZmLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0dmFyIHN0YWZmID0gbGluZS5zdGFmZltrXTtcblx0XHRcdFx0XHRpZiAoIXN0YXZlc1trXSlcblx0XHRcdFx0XHRcdHN0YXZlc1trXSA9IHN0YWZmO1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdGFmZi52b2ljZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKHN0YXZlc1trXS52b2ljZXNbaV0pXG5cdFx0XHRcdFx0XHRcdFx0c3RhdmVzW2tdLnZvaWNlc1tpXSA9IHN0YXZlc1trXS52b2ljZXNbaV0uY29uY2F0KHN0YWZmLnZvaWNlc1tpXSk7XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE8tUEVSOiBJZiBzdGF2ZXNba10udm9pY2VzW2ldIGRvZXNuJ3QgZXhpc3QsIHRoYXQgbWVhbnMgYSB2b2ljZSBhcHBlYXJlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0dW5lLiBUaGF0IGlzbid0IGhhbmRsZWQgeWV0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gc3RhdmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWVhc3VyZXNQYXJzZXIoc3RhZmYsIHR1bmUpIHtcblx0XHR2YXIgdm9pY2VzID0gW107XG5cdFx0dmFyIGxhc3RDaG9yZCA9IG51bGw7XG5cdFx0dmFyIG1lYXN1cmVTdGFydENob3JkID0gbnVsbDtcblx0XHR2YXIgZnJhZ1N0YXJ0ID0gbnVsbDtcblx0XHR2YXIgaGFzTm90ZXMgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZmYudm9pY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdm9pY2UgPSBzdGFmZi52b2ljZXNbaV07XG5cdFx0XHR2b2ljZXMucHVzaChbXSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHZvaWNlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdm9pY2Vbal07XG5cdFx0XHRcdGlmIChmcmFnU3RhcnQgPT09IG51bGwgJiYgZWxlbS5zdGFydENoYXIgPj0gMCkge1xuXHRcdFx0XHRcdGZyYWdTdGFydCA9IGVsZW0uc3RhcnRDaGFyO1xuXHRcdFx0XHRcdGlmIChlbGVtLmNob3JkID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRtZWFzdXJlU3RhcnRDaG9yZCA9IGxhc3RDaG9yZDtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRtZWFzdXJlU3RhcnRDaG9yZCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVsZW0uY2hvcmQpXG5cdFx0XHRcdFx0bGFzdENob3JkID0gZWxlbTtcblx0XHRcdFx0aWYgKGVsZW0uZWxfdHlwZSA9PT0gJ2JhcicpIHtcblx0XHRcdFx0XHRpZiAoaGFzTm90ZXMpIHtcblx0XHRcdFx0XHRcdHZhciBmcmFnID0gdHVuZS5hYmMuc3Vic3RyaW5nKGZyYWdTdGFydCwgZWxlbS5lbmRDaGFyKTtcblx0XHRcdFx0XHRcdHZhciBtZWFzdXJlID0ge2FiYzogZnJhZ307XG5cdFx0XHRcdFx0XHRsYXN0Q2hvcmQgPSBtZWFzdXJlU3RhcnRDaG9yZCAmJiBtZWFzdXJlU3RhcnRDaG9yZC5jaG9yZCAmJiBtZWFzdXJlU3RhcnRDaG9yZC5jaG9yZC5sZW5ndGggPiAwID8gbWVhc3VyZVN0YXJ0Q2hvcmQuY2hvcmRbMF0ubmFtZSA6IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAobGFzdENob3JkKVxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlLmxhc3RDaG9yZCA9IGxhc3RDaG9yZDtcblx0XHRcdFx0XHRcdGlmIChlbGVtLnN0YXJ0RW5kaW5nKVxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlLnN0YXJ0RW5kaW5nID0gZWxlbS5zdGFydEVuZGluZztcblx0XHRcdFx0XHRcdGlmIChlbGVtLmVuZEVuZGluZylcblx0XHRcdFx0XHRcdFx0bWVhc3VyZS5lbmRFbmRpbmcgPSBlbGVtLmVuZEVuZGluZztcblx0XHRcdFx0XHRcdHZvaWNlc1tpXS5wdXNoKG1lYXN1cmUpO1xuXHRcdFx0XHRcdFx0ZnJhZ1N0YXJ0ID0gbnVsbDtcblx0XHRcdFx0XHRcdGhhc05vdGVzID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW0uZWxfdHlwZSA9PT0gJ25vdGUnKSB7XG5cdFx0XHRcdFx0aGFzTm90ZXMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2b2ljZXM7XG5cdH1cblxuXHR0dW5lYm9vay5leHRyYWN0TWVhc3VyZXMgPSBmdW5jdGlvbihhYmMpIHtcblx0XHR2YXIgdHVuZXMgPSBbXTtcblx0XHR2YXIgYm9vayA9IG5ldyBUdW5lQm9vayhhYmMpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYm9vay50dW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHR1bmUgPSBib29rLnR1bmVzW2ldO1xuXHRcdFx0dmFyIGFyciA9IHR1bmUuYWJjLnNwbGl0KFwiSzpcIik7XG5cdFx0XHR2YXIgYXJyMiA9IGFyclsxXS5zcGxpdChcIlxcblwiKTtcblx0XHRcdHZhciBoZWFkZXIgPSBhcnJbMF0gKyBcIks6XCIgKyBhcnIyWzBdICsgXCJcXG5cIjtcblx0XHRcdHZhciBsYXN0Q2hvcmQgPSBudWxsO1xuXHRcdFx0dmFyIG1lYXN1cmVTdGFydENob3JkID0gbnVsbDtcblx0XHRcdHZhciBmcmFnU3RhcnQgPSBudWxsO1xuXHRcdFx0dmFyIG1lYXN1cmVzID0gW107XG5cdFx0XHR2YXIgaGFzTm90ZXMgPSBmYWxzZTtcblx0XHRcdHZhciB0dW5lT2JqID0gdHVuZWJvb2sucGFyc2VPbmx5KHR1bmUuYWJjKVswXTtcblx0XHRcdHZhciBoYXNQaWNrdXAgPSB0dW5lT2JqLmdldFBpY2t1cExlbmd0aCgpID4gMDtcblx0XHRcdC8vIHZhciBzdGF2ZXMgPSBmbGF0dGVuVHVuZSh0dW5lT2JqKTtcblx0XHRcdC8vIGZvciAodmFyIHMgPSAwOyBzIDwgc3RhdmVzLmxlbmd0aDsgcysrKSB7XG5cdFx0XHQvLyBcdHZhciB2b2ljZXMgPSBtZWFzdXJlc1BhcnNlcihzdGF2ZXNbc10sIHR1bmUpO1xuXHRcdFx0Ly8gXHRpZiAocyA9PT0gMClcblx0XHRcdC8vIFx0XHRtZWFzdXJlcyA9IHZvaWNlcztcblx0XHRcdC8vIFx0ZWxzZSB7XG5cdFx0XHQvLyBcdFx0Zm9yICh2YXIgc3MgPSAwOyBzcyA8IHZvaWNlcy5sZW5ndGg7IHNzKyspIHtcblx0XHRcdC8vIFx0XHRcdHZhciB2b2ljZSA9IHZvaWNlc1tzc107XG5cdFx0XHQvLyBcdFx0XHRpZiAobWVhc3VyZXMubGVuZ3RoIDw9IHNzKVxuXHRcdFx0Ly8gXHRcdFx0XHRtZWFzdXJlcy5wdXNoKFtdKTtcblx0XHRcdC8vIFx0XHRcdHZhciBtZWFzdXJlVm9pY2UgPSBtZWFzdXJlc1tzc107XG5cdFx0XHQvLyBcdFx0XHRmb3IgKHZhciBzc3MgPSAwOyBzc3MgPCB2b2ljZS5sZW5ndGg7IHNzcysrKSB7XG5cdFx0XHQvLyBcdFx0XHRcdGlmIChtZWFzdXJlVm9pY2UubGVuZ3RoID4gc3NzKVxuXHRcdFx0Ly8gXHRcdFx0XHRcdG1lYXN1cmVWb2ljZVtzc3NdLmFiYyArPSBcIlxcblwiICsgdm9pY2Vbc3NzXS5hYmM7XG5cdFx0XHQvLyBcdFx0XHRcdGVsc2Vcblx0XHRcdC8vIFx0XHRcdFx0XHRtZWFzdXJlcy5wdXNoKHZvaWNlW3Nzc10pO1xuXHRcdFx0Ly8gXHRcdFx0fVxuXHRcdFx0Ly8gXHRcdH1cblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gXHRjb25zb2xlLmxvZyh2b2ljZXMpO1xuXHRcdFx0Ly8gfVxuXHRcdFx0Ly8gbWVhc3VyZXMgPSBtZWFzdXJlc1swXTtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0dW5lT2JqLmxpbmVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciBsaW5lID0gdHVuZU9iai5saW5lc1tqXTtcblx0XHRcdFx0aWYgKGxpbmUuc3RhZmYpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDEgLypsaW5lLnN0YWZmLmxlbmd0aCovOyBrKyspIHtcblx0XHRcdFx0XHRcdHZhciBzdGFmZiA9IGxpbmUuc3RhZmZba107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrayA9IDA7IGtrIDwgMSAvKnN0YWZmLnZvaWNlcy5sZW5ndGgqLzsga2srKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdm9pY2UgPSBzdGFmZi52b2ljZXNba2tdO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBra2sgPSAwOyBra2sgPCB2b2ljZS5sZW5ndGg7IGtraysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVsZW0gPSB2b2ljZVtra2tdO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChmcmFnU3RhcnQgPT09IG51bGwgJiYgZWxlbS5zdGFydENoYXIgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZnJhZ1N0YXJ0ID0gZWxlbS5zdGFydENoYXI7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbS5jaG9yZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtZWFzdXJlU3RhcnRDaG9yZCA9IGxhc3RDaG9yZDtcblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWVhc3VyZVN0YXJ0Q2hvcmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbS5jaG9yZClcblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RDaG9yZCA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW0uZWxfdHlwZSA9PT0gJ2JhcicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChoYXNOb3Rlcykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZnJhZyA9IHR1bmUuYWJjLnN1YnN0cmluZyhmcmFnU3RhcnQsIGVsZW0uZW5kQ2hhcik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBtZWFzdXJlID0ge2FiYzogZnJhZ307XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhc3RDaG9yZCA9IG1lYXN1cmVTdGFydENob3JkICYmIG1lYXN1cmVTdGFydENob3JkLmNob3JkICYmIG1lYXN1cmVTdGFydENob3JkLmNob3JkLmxlbmd0aCA+IDAgPyBtZWFzdXJlU3RhcnRDaG9yZC5jaG9yZFswXS5uYW1lIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxhc3RDaG9yZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZWFzdXJlLmxhc3RDaG9yZCA9IGxhc3RDaG9yZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW0uc3RhcnRFbmRpbmcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWVhc3VyZS5zdGFydEVuZGluZyA9IGVsZW0uc3RhcnRFbmRpbmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbGVtLmVuZEVuZGluZylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZWFzdXJlLmVuZEVuZGluZyA9IGVsZW0uZW5kRW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtZWFzdXJlcy5wdXNoKG1lYXN1cmUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmcmFnU3RhcnQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRoYXNOb3RlcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZWxlbS5lbF90eXBlID09PSAnbm90ZScpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGhhc05vdGVzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHR1bmVzLnB1c2goe1xuXHRcdFx0XHRoZWFkZXI6IGhlYWRlcixcblx0XHRcdFx0bWVhc3VyZXM6IG1lYXN1cmVzLFxuXHRcdFx0XHRoYXNQaWNrdXA6IGhhc1BpY2t1cFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0dW5lcztcblx0fTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gdHVuZWJvb2s7XG4iLCJ2YXIgdHVuZWJvb2sgPSByZXF1aXJlKCcuL2FiY190dW5lYm9vaycpO1xudmFyIFR1bmUgPSByZXF1aXJlKCcuLi9kYXRhL2FiY190dW5lJyk7XG5cbnZhciBFbmdyYXZlckNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi93cml0ZS9hYmNfZW5ncmF2ZXJfY29udHJvbGxlcicpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UvYWJjX3BhcnNlJyk7XG52YXIgd3JhcCA9IHJlcXVpcmUoJy4uL3BhcnNlL3dyYXBfbGluZXMnKTtcblxudmFyIHJlc2l6ZURpdnMgPSB7fTtcbmZ1bmN0aW9uIHJlc2l6ZU91dGVyKCkge1xuICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGZvciAodmFyIGlkIGluIHJlc2l6ZURpdnMpIHtcbiAgICAgICAgaWYgKHJlc2l6ZURpdnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXIgPSByZXNpemVEaXZzW2lkXTtcbiAgICAgICAgICAgIHZhciBvZnMgPSBvdXRlci5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgd2lkdGggLT0gb2ZzICogMjtcbiAgICAgICAgICAgIG91dGVyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZU91dGVyKTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25DaGFuZ2VcIiwgcmVzaXplT3V0ZXIpO1xuXG5mdW5jdGlvbiByZW5kZXJPbmUoZGl2LCB0dW5lLCBwYXJhbXMsIHR1bmVOdW1iZXIpIHtcbiAgICBpZiAocGFyYW1zLnZpZXdwb3J0SG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBDcmVhdGUgYW4gaW5uZXIgZGl2IHRoYXQgaG9sZHMgdGhlIG11c2ljLCBzbyB0aGF0IHRoZSBwYXNzZWQgaW4gZGl2IHdpbGwgYmUgdGhlIHZpZXdwb3J0LlxuICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJhYmNqcy1pbm5lclwiPjwvZGl2Pic7XG4gICAgICAgIGlmIChwYXJhbXMuc2Nyb2xsSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZGl2LnN0eWxlLm92ZXJmbG93WCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgZGl2LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZGl2LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgcmVzaXplRGl2c1tkaXYuaWRdID0gZGl2OyAvLyBXZSB1c2UgYSBoYXNoIG9uIHRoZSBlbGVtZW50J3MgaWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB3b24ndCBrZWVwIGFkZGluZyB0byB0aGUgbGlzdC5cbiAgICAgICAgZGl2ID0gZGl2LmNoaWxkcmVuWzBdOyAvLyBUaGUgbXVzaWMgc2hvdWxkIGJlIHJlbmRlcmVkIGluIHRoZSBpbm5lciBkaXYuXG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmFtcy52aWV3cG9ydFZlcnRpY2FsKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbm5lciBkaXYgdGhhdCBob2xkcyB0aGUgbXVzaWMsIHNvIHRoYXQgdGhlIHBhc3NlZCBpbiBkaXYgd2lsbCBiZSB0aGUgdmlld3BvcnQuXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImFiY2pzLWlubmVyIHNjcm9sbC1hbW91bnRcIj48L2Rpdj4nO1xuICAgICAgICBkaXYuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgZGl2LnN0eWxlLm92ZXJmbG93WSA9IFwiYXV0b1wiO1xuICAgICAgICBkaXYgPSBkaXYuY2hpbGRyZW5bMF07IC8vIFRoZSBtdXNpYyBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIGlubmVyIGRpdi5cbiAgICB9XG4gICAgZWxzZVxuXHQgICAgZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gICAgdmFyIGVuZ3JhdmVyX2NvbnRyb2xsZXIgPSBuZXcgRW5ncmF2ZXJDb250cm9sbGVyKGRpdiwgcGFyYW1zKTtcbiAgICBlbmdyYXZlcl9jb250cm9sbGVyLmVuZ3JhdmVBQkModHVuZSwgdHVuZU51bWJlcik7XG4gICAgdHVuZS5lbmdyYXZlciA9IGVuZ3JhdmVyX2NvbnRyb2xsZXI7XG4gICAgaWYgKHBhcmFtcy52aWV3cG9ydFZlcnRpY2FsIHx8IHBhcmFtcy52aWV3cG9ydEhvcml6b250YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgYWRkZWQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZGl2LCB0aGVuIHdlIG5lZWQgdG8gc2l6ZSB0aGUgd3JhcHBlciwgdG9vLlxuICAgICAgICB2YXIgcGFyZW50ID0gZGl2LnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS53aWR0aDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckVhY2hMaW5lU2VwYXJhdGVseShkaXYsIHR1bmUsIHBhcmFtcywgdHVuZU51bWJlcikge1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVUdW5lTGluZSh0dW5lKSB7XG4gICAgICAgIHZhciBvYmogPSBuZXcgVHVuZSgpO1xuICAgICAgICBvYmouZm9ybWF0dGluZyA9IHR1bmUuZm9ybWF0dGluZztcbiAgICAgICAgb2JqLm1lZGlhID0gdHVuZS5tZWRpYTtcbiAgICAgICAgb2JqLnZlcnNpb24gPSB0dW5lLnZlcnNpb247XG4gICAgICAgIG9iai5tZXRhVGV4dCA9IHt9O1xuICAgICAgICBvYmoubGluZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBCZWZvcmUgcmVuZGVyaW5nLCBjaG9wIHVwIHRoZSByZXR1cm5lZCB0dW5lIGludG8gYW4gYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGEgbGluZS5cbiAgICAvLyBUaGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgZ2V0cyB0aGUgdGl0bGUgYW5kIG90aGVyIGl0ZW1zIHRoYXQgZ28gb24gdG9wLCB0aGUgbGFzdCBlbGVtZW50XG4gICAgLy8gb2YgdGhlIGFycmF5IGdldHMgdGhlIGV4dHJhIHRleHQgdGhhdCBnb2VzIG9uIGJvdHRvbS4gRWFjaCBlbGVtZW50IGdldHMgYW55IG5vbi1tdXNpYyBpbmZvIHRoYXQgY29tZXMgYmVmb3JlIGl0LlxuICAgIHZhciB0dW5lcyA9IFtdO1xuICAgIHZhciB0dW5lTGluZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR1bmUubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0dW5lLmxpbmVzW2ldO1xuICAgICAgICBpZiAoIXR1bmVMaW5lKVxuICAgICAgICAgICAgdHVuZUxpbmUgPSBpbml0aWFsaXplVHVuZUxpbmUodHVuZSk7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIGl0ZW1zIGdvIG9uIHRvcCBvZiB0aGUgbXVzaWNcbiAgICAgICAgICAgIHR1bmVMaW5lLm1ldGFUZXh0LnRlbXBvID0gdHVuZS5tZXRhVGV4dC50ZW1wbztcbiAgICAgICAgICAgIHR1bmVMaW5lLm1ldGFUZXh0LnRpdGxlID0gdHVuZS5tZXRhVGV4dC50aXRsZTtcbiAgICAgICAgICAgIHR1bmVMaW5lLm1ldGFUZXh0LmhlYWRlciA9IHR1bmUubWV0YVRleHQuaGVhZGVyO1xuICAgICAgICAgICAgdHVuZUxpbmUubWV0YVRleHQucmh5dGhtID0gdHVuZS5tZXRhVGV4dC5yaHl0aG07XG4gICAgICAgICAgICB0dW5lTGluZS5tZXRhVGV4dC5vcmlnaW4gPSB0dW5lLm1ldGFUZXh0Lm9yaWdpbjtcbiAgICAgICAgICAgIHR1bmVMaW5lLm1ldGFUZXh0LmNvbXBvc2VyID0gdHVuZS5tZXRhVGV4dC5jb21wb3NlcjtcbiAgICAgICAgICAgIHR1bmVMaW5lLm1ldGFUZXh0LmF1dGhvciA9IHR1bmUubWV0YVRleHQuYXV0aG9yO1xuICAgICAgICAgICAgdHVuZUxpbmUubWV0YVRleHQucGFydE9yZGVyID0gdHVuZS5tZXRhVGV4dC5wYXJ0T3JkZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdXNoIHRoZSBsaW5lcyB1bnRpbCB3ZSBnZXQgdG8gYSBtdXNpYyBsaW5lXG4gICAgICAgIHR1bmVMaW5lLmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGlmIChsaW5lLnN0YWZmKSB7XG4gICAgICAgICAgICB0dW5lcy5wdXNoKHR1bmVMaW5lKTtcbiAgICAgICAgICAgIHR1bmVMaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBhbnkgZXh0cmEgc3R1ZmYgdG8gdGhlIGxhc3QgbGluZS5cbiAgICBpZiAodHVuZUxpbmUpIHtcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gdHVuZXNbdHVuZXMubGVuZ3RoLTFdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHR1bmVMaW5lLmxpbmVzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgbGFzdExpbmUubGluZXMucHVzaCh0dW5lTGluZS5saW5lc1tqXSk7XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgaXRlbXMgZ28gYmVsb3cgdGhlIG11c2ljXG4gICAgdHVuZUxpbmUgPSB0dW5lc1t0dW5lcy5sZW5ndGgtMV07XG4gICAgdHVuZUxpbmUubWV0YVRleHQudW5hbGlnbmVkV29yZHMgPSB0dW5lLm1ldGFUZXh0LnVuYWxpZ25lZFdvcmRzO1xuICAgIHR1bmVMaW5lLm1ldGFUZXh0LmJvb2sgPSB0dW5lLm1ldGFUZXh0LmJvb2s7XG4gICAgdHVuZUxpbmUubWV0YVRleHQuc291cmNlID0gdHVuZS5tZXRhVGV4dC5zb3VyY2U7XG4gICAgdHVuZUxpbmUubWV0YVRleHQuZGlzY29ncmFwaHkgPSB0dW5lLm1ldGFUZXh0LmRpc2NvZ3JhcGh5O1xuICAgIHR1bmVMaW5lLm1ldGFUZXh0Lm5vdGVzID0gdHVuZS5tZXRhVGV4dC5ub3RlcztcbiAgICB0dW5lTGluZS5tZXRhVGV4dC50cmFuc2NyaXB0aW9uID0gdHVuZS5tZXRhVGV4dC50cmFuc2NyaXB0aW9uO1xuICAgIHR1bmVMaW5lLm1ldGFUZXh0Lmhpc3RvcnkgPSB0dW5lLm1ldGFUZXh0Lmhpc3Rvcnk7XG4gICAgdHVuZUxpbmUubWV0YVRleHRbJ2FiYy1jb3B5cmlnaHQnXSA9IHR1bmUubWV0YVRleHRbJ2FiYy1jb3B5cmlnaHQnXTtcbiAgICB0dW5lTGluZS5tZXRhVGV4dFsnYWJjLWNyZWF0b3InXSA9IHR1bmUubWV0YVRleHRbJ2FiYy1jcmVhdG9yJ107XG4gICAgdHVuZUxpbmUubWV0YVRleHRbJ2FiYy1lZGl0ZWQtYnknXSA9IHR1bmUubWV0YVRleHRbJ2FiYy1lZGl0ZWQtYnknXTtcbiAgICB0dW5lTGluZS5tZXRhVGV4dC5mb290ZXIgPSB0dW5lLm1ldGFUZXh0LmZvb3RlcjtcblxuICAgIC8vIE5vdyBjcmVhdGUgc3ViLWRpdnMgYW5kIHJlbmRlciBlYWNoIGxpbmUuIE5lZWQgdG8gY29weSB0aGUgcGFyYW1zIHRvIGNoYW5nZSB0aGUgcGFkZGluZyBmb3IgdGhlIGludGVyaW9yIHNsaWNlcy5cbiAgICB2YXIgZXAgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXBba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBvcmlnUGFkZGluZ1RvcCA9IGVwLnBhZGRpbmd0b3A7XG4gICAgdmFyIG9yaWdQYWRkaW5nQm90dG9tID0gZXAucGFkZGluZ2JvdHRvbTtcbiAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHR1bmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBsaW5lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobGluZUVsKTtcblxuICAgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIGVwLnBhZGRpbmd0b3AgPSBvcmlnUGFkZGluZ1RvcDtcblx0ICAgICAgICBlcC5wYWRkaW5nYm90dG9tID0gLTIwO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IHR1bmVzLmxlbmd0aC0xKSB7XG5cdCAgICAgICAgZXAucGFkZGluZ3RvcCA9IDEwO1xuXHQgICAgICAgIGVwLnBhZGRpbmdib3R0b20gPSBvcmlnUGFkZGluZ0JvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlcC5wYWRkaW5ndG9wID0gMTA7XG5cdCAgICAgICAgZXAucGFkZGluZ2JvdHRvbSA9IC0yMDtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJPbmUobGluZUVsLCB0dW5lc1trXSwgZXAsIHR1bmVOdW1iZXIpO1xuICAgICAgICBpZiAoayA9PT0gMClcbiAgICAgICAgICAgIHR1bmUuZW5ncmF2ZXIgPSB0dW5lc1trXS5lbmdyYXZlcjtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXR1bmUuZW5ncmF2ZXIuc3RhZmZncm91cHMpXG4gICAgICAgICAgICAgICAgdHVuZS5lbmdyYXZlci5zdGFmZmdyb3VwcyA9IHR1bmVzW2tdLmVuZ3JhdmVyLnN0YWZmZ3JvdXBzO1xuICAgICAgICAgICAgZWxzZSBpZiAodHVuZXNba10uZW5ncmF2ZXIuc3RhZmZncm91cHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB0dW5lLmVuZ3JhdmVyLnN0YWZmZ3JvdXBzLnB1c2godHVuZXNba10uZW5ncmF2ZXIuc3RhZmZncm91cHNbMF0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBBIHF1aWNrIHdheSB0byByZW5kZXIgYSB0dW5lIGZyb20gamF2YXNjcmlwdCB3aGVuIGludGVyYWN0aXZpdHkgaXMgbm90IHJlcXVpcmVkLlxuLy8gVGhpcyBpcyB1c2VkIHdoZW4gYSBqYXZhc2NyaXB0IHJvdXRpbmUgaGFzIHNvbWUgYWJjIHRleHQgdGhhdCBpdCB3YW50cyB0byByZW5kZXJcbi8vIGluIGEgZGl2IG9yIGNvbGxlY3Rpb24gb2YgZGl2cy4gT25lIHR1bmUgb3IgbWFueSBjYW4gYmUgcmVuZGVyZWQuXG4vL1xuLy8gcGFyYW1ldGVyczpcbi8vICAgICAgb3V0cHV0OiBhbiBhcnJheSBvZiBkaXZzIHRoYXQgdGhlIGluZGl2aWR1YWwgdHVuZXMgYXJlIHJlbmRlcmVkIHRvLlxuLy8gICAgICAgICAgSWYgdGhlIG51bWJlciBvZiB0dW5lcyBleGNlZWRzIHRoZSBudW1iZXIgb2YgZGl2cyBpbiB0aGUgYXJyYXksIHRoZW5cbi8vICAgICAgICAgIG9ubHkgdGhlIGZpcnN0IHR1bmVzIGFyZSByZW5kZXJlZC4gSWYgdGhlIG51bWJlciBvZiBkaXZzIGV4Y2VlZHMgdGhlIG51bWJlclxuLy8gICAgICAgICAgb2YgdHVuZXMsIHRoZW4gdGhlIHVudXNlZCBkaXZzIGFyZSBjbGVhcmVkLiBUaGUgZGl2cyBjYW4gYmUgcGFzc2VkIGFzIGVpdGhlclxuLy8gICAgICAgICAgZWxlbWVudHMgb3Igc3RyaW5ncyBvZiBpZHMuIElmIGlkcyBhcmUgcGFzc2VkLCB0aGVuIHRoZSBkaXYgTVVTVCBleGlzdCBhbHJlYWR5LlxuLy8gICAgICAgICAgKGlmIGEgc2luZ2xlIGVsZW1lbnQgaXMgcGFzc2VkLCB0aGVuIGl0IGlzIGFuIGltcGxpZWQgYXJyYXkgb2YgbGVuZ3RoIG9uZS4pXG4vLyAgICAgICAgICAoaWYgYSBudWxsIGlzIHBhc3NlZCBmb3IgYW4gZWxlbWVudCwgb3IgdGhlIGVsZW1lbnQgZG9lc24ndCBleGlzdCwgdGhlbiB0aGF0IHR1bmUgaXMgc2tpcHBlZC4pXG4vLyAgICAgIGFiYzogdGV4dCByZXByZXNlbnRpbmcgYSB0dW5lIG9yIGFuIGVudGlyZSB0dW5lIGJvb2sgaW4gQUJDIG5vdGF0aW9uLlxuLy8gICAgICByZW5kZXJQYXJhbXM6IGhhc2ggb2Y6XG4vLyAgICAgICAgICBzdGFydGluZ1R1bmU6IGFuIGluZGV4LCBzdGFydGluZyBhdCB6ZXJvLCByZXByZXNlbnRpbmcgd2hpY2ggdHVuZSB0byBzdGFydCByZW5kZXJpbmcgYXQuXG4vLyAgICAgICAgICAgICAgKElmIHRoaXMgZWxlbWVudCBpcyBub3QgcHJlc2VudCwgdGhlbiByZW5kZXJpbmcgc3RhcnRzIGF0IHplcm8uKVxuLy8gICAgICAgICAgd2lkdGg6IDgwMCBieSBkZWZhdWx0LiBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBvdXRwdXQgcGFwZXJcbnZhciByZW5kZXJBYmMgPSBmdW5jdGlvbihvdXRwdXQsIGFiYywgcGFyc2VyUGFyYW1zLCBlbmdyYXZlclBhcmFtcywgcmVuZGVyUGFyYW1zKSB7XG4gICAgLy8gTm90ZTogYWxsIHBhcmFtZXRlcnMgaGF2ZSBiZWVuIGNvbmRlbnNlZCBpbnRvIHRoZSBmaXJzdCBvbmVzLiBJdCBkb2Vzbid0IGh1cnQgYW55dGhpbmcgdG8gYWxsb3cgdGhlIG9sZCBmb3JtYXQsIHNvIGp1c3QgY29weSB0aGVtIGhlcmUuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgaWYgKHBhcnNlclBhcmFtcykge1xuICAgICAgICBmb3IgKGtleSBpbiBwYXJzZXJQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXJQYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gcGFyc2VyUGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZ3JhdmVyUGFyYW1zKSB7XG4gICAgICAgIGZvciAoa2V5IGluIGVuZ3JhdmVyUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoZW5ncmF2ZXJQYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbmZsaWN0IHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBcImxpc3RlbmVyXCIuIElmIGl0IGlzIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCB0aGVuIGl0IGlzIGZvciBjbGljay5cblx0ICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJsaXN0ZW5lclwiKSB7XG5cdCAgICAgICAgICAgIFx0aWYgKGVuZ3JhdmVyUGFyYW1zW2tleV0uaGlnaGxpZ2h0KVxuXHRcdCAgICAgICAgICAgICAgICBwYXJhbXMuY2xpY2tMaXN0ZW5lciA9IGVuZ3JhdmVyUGFyYW1zW2tleV0uaGlnaGxpZ2h0O1xuXHQgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBlbmdyYXZlclBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZW5kZXJQYXJhbXMpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVuZGVyUGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAocmVuZGVyUGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHJlbmRlclBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZGl2LCB0dW5lLCB0dW5lTnVtYmVyLCBhYmNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlbW92ZURpdiA9IGZhbHNlO1xuICAgICAgICBpZiAoZGl2ID09PSBcIipcIikge1xuICAgICAgICAgICAgcmVtb3ZlRGl2ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmU7XCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICB9XG4gICAgXHRpZiAocGFyYW1zLmFmdGVyUGFyc2luZylcbiAgICBcdFx0cGFyYW1zLmFmdGVyUGFyc2luZyh0dW5lLCB0dW5lTnVtYmVyLCBhYmNTdHJpbmcpO1xuICAgICAgICBpZiAoIXJlbW92ZURpdiAmJiBwYXJhbXMud3JhcCAmJiBwYXJhbXMuc3RhZmZ3aWR0aCkge1xuXHQgICAgICAgIHR1bmUgPSBkb0xpbmVXcmFwcGluZyhkaXYsIHR1bmUsIHR1bmVOdW1iZXIsIGFiY1N0cmluZywgcGFyYW1zKTtcblx0ICAgICAgICByZXR1cm4gdHVuZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW1vdmVEaXYgfHwgIXBhcmFtcy5vbmVTdmdQZXJMaW5lIHx8IHR1bmUubGluZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHJlbmRlck9uZShkaXYsIHR1bmUsIHBhcmFtcywgdHVuZU51bWJlcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlbmRlckVhY2hMaW5lU2VwYXJhdGVseShkaXYsIHR1bmUsIHBhcmFtcywgdHVuZU51bWJlcik7XG4gICAgICAgIGlmIChyZW1vdmVEaXYpXG4gICAgICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHVuZWJvb2sucmVuZGVyRW5naW5lKGNhbGxiYWNrLCBvdXRwdXQsIGFiYywgcGFyYW1zKTtcbn07XG5cbmZ1bmN0aW9uIGRvTGluZVdyYXBwaW5nKGRpdiwgdHVuZSwgdHVuZU51bWJlciwgYWJjU3RyaW5nLCBwYXJhbXMpIHtcblx0dmFyIGVuZ3JhdmVyX2NvbnRyb2xsZXIgPSBuZXcgRW5ncmF2ZXJDb250cm9sbGVyKGRpdiwgcGFyYW1zKTtcblx0dmFyIHdpZHRocyA9IGVuZ3JhdmVyX2NvbnRyb2xsZXIuZ2V0TWVhc3VyZVdpZHRocyh0dW5lKTtcblxuXHR2YXIgcmV0ID0gd3JhcC5jYWxjTGluZVdyYXBzKHR1bmUsIHdpZHRocywgYWJjU3RyaW5nLCBwYXJhbXMsIFBhcnNlLCBlbmdyYXZlcl9jb250cm9sbGVyKTtcbiAgICBpZiAoIXBhcmFtcy5vbmVTdmdQZXJMaW5lIHx8IHJldC50dW5lLmxpbmVzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJlbmRlck9uZShkaXYsIHJldC50dW5lLCByZXQucmV2aXNlZFBhcmFtcywgdHVuZU51bWJlcik7XG4gICAgZWxzZVxuICAgICAgICByZW5kZXJFYWNoTGluZVNlcGFyYXRlbHkoZGl2LCByZXQudHVuZSwgcmV0LnJldmlzZWRQYXJhbXMsIHR1bmVOdW1iZXIpO1xuXHRyZXQudHVuZS5leHBsYW5hdGlvbiA9IHJldC5leHBsYW5hdGlvbjtcblx0cmV0dXJuIHJldC50dW5lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlckFiYztcbiIsIi8vICAgIGFiY190dW5lLmpzOiBhIGNvbXB1dGVyIHVzYWJsZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIG9uZSB0dW5lLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggUGF1bCBSb3NlbiAocGF1bCBhdCBwYXVscm9zZW4gZG90IG5ldClcbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHBhcnNlQ29tbW9uID0gcmVxdWlyZSgnLi4vcGFyc2UvYWJjX2NvbW1vbicpO1xudmFyIHBhcnNlS2V5Vm9pY2UgPSByZXF1aXJlKCcuLi9wYXJzZS9hYmNfcGFyc2Vfa2V5X3ZvaWNlJyk7XG52YXIgc3BhY2luZyA9IHJlcXVpcmUoJy4uL3dyaXRlL2FiY19zcGFjaW5nJyk7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZGF0YSBmb3IgYSBzaW5nbGUgQUJDIHR1bmUuIEl0IGlzIGNyZWF0ZWQgYW5kIHBvcHVsYXRlZCBieSB0aGUgd2luZG93LkFCQ0pTLnBhcnNlLlBhcnNlIGNsYXNzLlxuICogQWxzbyBrbm93biBhcyB0aGUgQUJDSlMgQWJzdHJhY3QgU3ludGF4IFRyZWVcbiAqIEBhbHRlcm5hdGVDbGFzc05hbWUgQUJDSlMuVHVuZVxuICovXG52YXIgVHVuZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBUaGUgc3RydWN0dXJlIGNvbnNpc3RzIG9mIGEgaGFzaCB3aXRoIHRoZSBmb2xsb3dpbmcgdHdvIGl0ZW1zOlxuXHQvLyBtZXRhVGV4dDogYSBoYXNoIG9mIHtrZXksIHZhbHVlfSwgd2hlcmUga2V5IGlzIG9uZSBvZjogdGl0bGUsIGF1dGhvciwgcmh5dGhtLCBzb3VyY2UsIHRyYW5zY3JpcHRpb24sIHVuYWxpZ25lZFdvcmRzLCBldGMuLi5cblx0Ly8gdGVtcG86IHsgbm90ZUxlbmd0aDogbnVtYmVyIChlLmcuIC4xMjUpLCBicG06IG51bWJlciB9XG5cdC8vIGxpbmVzOiBhbiBhcnJheSBvZiBlbGVtZW50cywgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cdC8vXG5cdC8vIFNUQUZGOiBhcnJheSBvZiBlbGVtZW50c1xuXHQvLyBTVUJUSVRMRTogc3RyaW5nXG5cdC8vXG5cdC8vIFRPRE86IGFjdHVhbGx5LCB0aGUgc3RhcnQgYW5kIGVuZCBjaGFyIHNob3VsZCBtb2RpZnkgZWFjaCBwYXJ0IG9mIHRoZSBub3RlIHR5cGVcblx0Ly8gVGhlIGVsZW1lbnRzIGFsbCBoYXZlIGEgdHlwZSBmaWVsZCBhbmQgYSBzdGFydCBhbmQgZW5kIGNoYXJcblx0Ly8gZmllbGQuIFRoZSByZXN0IG9mIHRoZSBmaWVsZHMgZGVwZW5kIG9uIHRoZSB0eXBlIGFuZCBhcmUgbGlzdGVkIGJlbG93OlxuXHQvLyBSRVNUOiBkdXJhdGlvbj0xLDIsNCw4OyBjaG9yZDogc3RyaW5nXG5cdC8vIE5PVEU6IGFjY2lkZW50YWw9bm9uZSxkYmxfZmxhdCxmbGF0LG5hdHVyYWwsc2hhcnAsZGJsX3NoYXJwXG5cdC8vXHRcdHBpdGNoOiBcIkNcIiBpcyAwLiBUaGUgbnVtYmVycyByZWZlciB0byB0aGUgcGl0Y2ggbGV0dGVyLlxuXHQvL1x0XHRkdXJhdGlvbjogLjUgKHNpeHRlZW50aCksIC43NSAoZG90dGVkIHNpeHRlZW50aCksIDEgKGVpZ2h0aCksIDEuNSAoZG90dGVkIGVpZ2h0aClcblx0Ly9cdFx0XHQyIChxdWFydGVyKSwgMyAoZG90dGVkIHF1YXJ0ZXIpLCA0IChoYWxmKSwgNiAoZG90dGVkIGhhbGYpIDggKHdob2xlKVxuXHQvL1x0XHRjaG9yZDogeyBuYW1lOmNob3JkLCBwb3NpdGlvbjogb25lIG9mICdkZWZhdWx0JywgJ2Fib3ZlJywgJ2JlbG93JyB9XG5cdC8vXHRcdGVuZF9iZWFtID0gdHJ1ZSBvciB1bmRlZmluZWQgaWYgdGhpcyBpcyB0aGUgbGFzdCBub3RlIGluIGEgYmVhbS5cblx0Ly9cdFx0bHlyaWM6IGFycmF5IG9mIHsgc3lsbGFibGU6IHh4eCwgZGl2aWRlcjogb25lIG9mIFwiIC1fXCIgfVxuXHQvL1x0XHRzdGFydFRpZSA9IHRydWV8dW5kZWZpbmVkXG5cdC8vXHRcdGVuZFRpZSA9IHRydWV8dW5kZWZpbmVkXG5cdC8vXHRcdHN0YXJ0VHJpcGxldCA9IG51bSA8LSB0aGF0IGlzIHRoZSBudW1iZXIgdG8gcHJpbnRcblx0Ly9cdFx0ZW5kVHJpcGxldCA9IHRydWV8dW5kZWZpbmVkICh0aGUgbGFzdCBub3RlIG9mIHRoZSB0cmlwbGV0KVxuXHQvLyBUT0RPOiBhY3R1YWxseSwgZGVjb3JhdGlvbiBzaG91bGQgYmUgYW4gYXJyYXkuXG5cdC8vXHRcdGRlY29yYXRpb246IHVwYm93LCBkb3duYm93LCBhY2NlbnRcblx0Ly8gQkFSOiB0eXBlPWJhcl90aGluLCBiYXJfdGhpbl90aGljaywgYmFyX3RoaW5fdGhpbiwgYmFyX3RoaWNrX3RoaW4sIGJhcl9yaWdodF9yZXBlYXQsIGJhcl9sZWZ0X3JlcGVhdCwgYmFyX2RvdWJsZV9yZXBlYXRcblx0Ly9cdG51bWJlcjogMSBvciAyOiBpZiBpdCBpcyB0aGUgc3RhcnQgb2YgYSBmaXJzdCBvciBzZWNvbmQgZW5kaW5nXG5cdC8vIENMRUY6IHR5cGU9dHJlYmxlLGJhc3Ncblx0Ly8gS0VZLVNJRzpcblx0Ly9cdFx0YWNjaWRlbnRhbHNbXTogeyBhY2M6c2hhcnB8ZGJsc2hhcnB8bmF0dXJhbHxmbGF0fGRibGZsYXQsICBub3RlOmF8YnxjfGR8ZXxmfGcgfVxuXHQvLyBNRVRFUjogdHlwZTogY29tbW9uX3RpbWUsY3V0X3RpbWUsc3BlY2lmaWVkXG5cdC8vXHRcdGlmIHNwZWNpZmllZCwgeyBudW06IDk5LCBkZW46IDk5IH1cblxuXHR0aGlzLmdldEJlYXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5saW5lc1tpXS5zdGFmZi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmW2pdLm1ldGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0ZXIgPSB0aGlzLmxpbmVzW2ldLnN0YWZmW2pdLm1ldGVyO1xuXHRcdFx0XHRcdFx0aWYgKG1ldGVyLnR5cGUgPT09IFwic3BlY2lmaWVkXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG1ldGVyLnZhbHVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbnVtID0gcGFyc2VJbnQobWV0ZXIudmFsdWVbMF0ubnVtLCAxMCk7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlbiA9IHBhcnNlSW50KG1ldGVyLnZhbHVlWzBdLmRlbiwgMTApO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChudW0gPT09IDMgJiYgZGVuID09PSA4KSByZXR1cm4gMy84O1xuXHRcdFx0XHRcdFx0XHRcdGlmIChudW0gPT09IDYgJiYgZGVuID09PSA4KSByZXR1cm4gMy84O1xuXHRcdFx0XHRcdFx0XHRcdGlmIChudW0gPT09IDYgJiYgZGVuID09PSA0KSByZXR1cm4gMy80O1xuXHRcdFx0XHRcdFx0XHRcdGlmIChudW0gPT09IDkgJiYgZGVuID09PSA4KSByZXR1cm4gMy84O1xuXHRcdFx0XHRcdFx0XHRcdGlmIChudW0gPT09IDEyICYmIGRlbiA9PT0gOCkgcmV0dXJuIDMvODtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gMS9kZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAxLzQ7IC8vIE5vIG1ldGVyIHdhcyBzcGVjaWZpZWQsIHNvIHVzZSB0aGlzIGRlZmF1bHRcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobWV0ZXIudHlwZSA9PT0gJ2N1dF90aW1lJykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gMS8yO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIDEvNDsgLy8gVE9ETy1QRVI6IHRoaXMgd29ya3MgZm9yIGNvbW1vbiB0aW1lLCBidXQgbm90IGZvciB0aGUgYW5jaWVudCBtZXRlcnMuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAxLzQ7IC8vIE5vIG1ldGVyIHdhcyBzcGVjaWZpZWQsIHNvIHVzZSB0aGlzIGRlZmF1bHRcblx0fTtcblxuXHR0aGlzLmdldFBpY2t1cExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwaWNrdXBMZW5ndGggPSAwO1xuXHRcdHZhciBiYXJMZW5ndGggPSB0aGlzLmdldEJhckxlbmd0aCgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMubGluZXNbaV0uc3RhZmYpIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxpbmVzW2ldLnN0YWZmLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgdiA9IDA7IHYgPCB0aGlzLmxpbmVzW2ldLnN0YWZmW2pdLnZvaWNlcy5sZW5ndGg7IHYrKykge1xuXHRcdFx0XHRcdFx0dmFyIHZvaWNlID0gdGhpcy5saW5lc1tpXS5zdGFmZltqXS52b2ljZXNbdl07XG5cdFx0XHRcdFx0XHR2YXIgaGFzTm90ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dmFyIHRyaXBsZXRNdWx0aXBsaWVyID0gMTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGVsID0gMDsgZWwgPCB2b2ljZS5sZW5ndGg7IGVsKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlzU3BhY2VyID0gdm9pY2VbZWxdLnJlc3QgJiYgdm9pY2VbZWxdLnJlc3QudHlwZSA9PT0gXCJzcGFjZXJcIjtcblx0XHRcdFx0XHRcdFx0aWYgKHZvaWNlW2VsXS5zdGFydFRyaXBsZXQpXG5cdFx0XHRcdFx0XHRcdFx0dHJpcGxldE11bHRpcGxpZXIgPSB2b2ljZVtlbF0udHJpcGxldE11bHRpcGxpZXI7XG5cdFx0XHRcdFx0XHRcdGlmICh2b2ljZVtlbF0uZHVyYXRpb24gJiYgIWlzU3BhY2VyKVxuXHRcdFx0XHRcdFx0XHRcdHBpY2t1cExlbmd0aCArPSB2b2ljZVtlbF0uZHVyYXRpb24gKiB0cmlwbGV0TXVsdGlwbGllcjtcblx0XHRcdFx0XHRcdFx0aWYgKHZvaWNlW2VsXS5lbmRUcmlwbGV0KVxuXHRcdFx0XHRcdFx0XHRcdHRyaXBsZXRNdWx0aXBsaWVyID0gMTtcblx0XHRcdFx0XHRcdFx0aWYgKHBpY2t1cExlbmd0aCA+PSBiYXJMZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0cGlja3VwTGVuZ3RoIC09IGJhckxlbmd0aDtcblx0XHRcdFx0XHRcdFx0aWYgKHZvaWNlW2VsXS5lbF90eXBlID09PSAnYmFyJylcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGlja3VwTGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGlja3VwTGVuZ3RoO1xuXHR9O1xuXG5cdHRoaXMuZ2V0QmFyTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1ldGVyID0gdGhpcy5nZXRNZXRlckZyYWN0aW9uKCk7XG5cdFx0cmV0dXJuIG1ldGVyLm51bSAvIG1ldGVyLmRlbjtcblx0fTtcblxuXHR0aGlzLm1pbGxpc2Vjb25kc1Blck1lYXN1cmUgPSBmdW5jdGlvbihicG1PdmVycmlkZSkge1xuXHRcdHZhciBicG07XG5cdFx0aWYgKGJwbU92ZXJyaWRlKSB7XG5cdFx0XHRicG0gPSBicG1PdmVycmlkZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHRlbXBvID0gdGhpcy5tZXRhVGV4dCA/IHRoaXMubWV0YVRleHQudGVtcG8gOiBudWxsO1xuXHRcdFx0YnBtID0gdGhpcy5nZXRCcG0odGVtcG8pO1xuXHRcdH1cblx0XHRpZiAoYnBtIDw9IDApXG5cdFx0XHRicG0gPSAxOyAvLyBJIGRvbid0IHRoaW5rIHRoaXMgY2FuIGhhcHBlbiwgYnV0IHdlIGRvbid0IHdhbnQgYSBwb3NzaWJpbGl0eSBvZiBkaXZpZGluZyBieSB6ZXJvLlxuXG5cdFx0dmFyIGJlYXRzUGVyTWVhc3VyZSA9IHRoaXMuZ2V0QmVhdHNQZXJNZWFzdXJlKCk7XG5cblx0XHR2YXIgbWludXRlc1Blck1lYXN1cmUgPSBiZWF0c1Blck1lYXN1cmUgLyBicG07XG5cdFx0cmV0dXJuIG1pbnV0ZXNQZXJNZWFzdXJlICogNjAwMDA7XG5cdH07XG5cblx0dGhpcy5nZXRCZWF0c1Blck1lYXN1cmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYmVhdHNQZXJNZWFzdXJlO1xuXHRcdHZhciBtZXRlciA9IHRoaXMuZ2V0TWV0ZXJGcmFjdGlvbigpO1xuXHRcdGlmIChtZXRlci5kZW4gPT09IDgpIHtcblx0XHRcdGJlYXRzUGVyTWVhc3VyZSA9IG1ldGVyLm51bSAvIDM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJlYXRzUGVyTWVhc3VyZSA9IG1ldGVyLm51bTtcblx0XHR9XG5cdFx0aWYgKGJlYXRzUGVyTWVhc3VyZSA8PSAwKSAvLyBUaGlzIHByb2JhYmx5IHdvbid0IGhhcHBlbiBpbiBhbnkgbm9ybWFsIGNhc2UgLSBidXQgaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgbWV0ZXIgY291bGQgYmUgc2V0IHRvIHNvbWV0aGluZyBub25zZW5zaWNhbC5cblx0XHRcdGJlYXRzUGVyTWVhc3VyZSA9IDE7XG5cdFx0cmV0dXJuIGJlYXRzUGVyTWVhc3VyZTtcblx0fTtcblxuXHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMudmVyc2lvbiA9IFwiMS4wLjFcIjtcblx0XHR0aGlzLm1lZGlhID0gXCJzY3JlZW5cIjtcblx0XHR0aGlzLm1ldGFUZXh0ID0ge307XG5cdFx0dGhpcy5mb3JtYXR0aW5nID0ge307XG5cdFx0dGhpcy5saW5lcyA9IFtdO1xuXHRcdHRoaXMuc3RhZmZOdW0gPSAwO1xuXHRcdHRoaXMudm9pY2VOdW0gPSAwO1xuXHRcdHRoaXMubGluZU51bSA9IDA7XG5cdH07XG5cblx0dGhpcy5yZXNvbHZlT3ZlcmxheXMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWFkZUNoYW5nZXMgPSBmYWxzZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcblx0XHRcdGlmIChsaW5lLnN0YWZmKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5zdGFmZi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBzdGFmZiA9IGxpbmUuc3RhZmZbal07XG5cdFx0XHRcdFx0dmFyIG92ZXJsYXlWb2ljZSA9IFtdO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RhZmYudm9pY2VzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdm9pY2UgPSBzdGFmZi52b2ljZXNba107XG5cdFx0XHRcdFx0XHRvdmVybGF5Vm9pY2UucHVzaCh7IGhhc092ZXJsYXk6IGZhbHNlLCB2b2ljZTogW10sIHNuaXA6IFtdfSk7XG5cdFx0XHRcdFx0XHR2YXIgZHVyYXRpb25UaGlzQmFyID0gMDtcblx0XHRcdFx0XHRcdHZhciBpbk92ZXJsYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhciBzbmlwU3RhcnQgPSAtMTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGtrID0gMDsga2sgPCB2b2ljZS5sZW5ndGg7IGtrKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGV2ZW50ID0gdm9pY2Vba2tdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZXZlbnQuZWxfdHlwZSA9PT0gXCJvdmVybGF5XCIgJiYgIWluT3ZlcmxheSkge1xuXHRcdFx0XHRcdFx0XHRcdG1hZGVDaGFuZ2VzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRpbk92ZXJsYXkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdHNuaXBTdGFydCA9IGtrO1xuXHRcdFx0XHRcdFx0XHRcdG92ZXJsYXlWb2ljZVtrXS5oYXNPdmVybGF5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudC5lbF90eXBlID09PSBcImJhclwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluT3ZlcmxheSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZGVsZXRlIHRoZSBvdmVybGF5IGV2ZW50cyBmcm9tIHRoaXMgYXJyYXkgd2l0aG91dCBtZXNzaW5nIHVwIHRoaXMgbG9vcC5cblx0XHRcdFx0XHRcdFx0XHRcdGluT3ZlcmxheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0b3ZlcmxheVZvaWNlW2tdLnNuaXAucHVzaCh7IHN0YXJ0OiBzbmlwU3RhcnQsIGxlbjoga2sgLSBzbmlwU3RhcnR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdG92ZXJsYXlWb2ljZVtrXS52b2ljZS5wdXNoKGV2ZW50KTsgLy8gQWxzbyBlbmQgdGhlIG92ZXJsYXkgd2l0aCB0aGUgYmFybGluZS5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBrZWVwcyB0aGUgdm9pY2VzIGxpbmVkIHVwOiBpZiB0aGUgb3ZlcmxheSBpc24ndCBpbiB0aGUgZmlyc3QgbWVhc3VyZSB0aGVuIHdlIG5lZWQgYSBidW5jaCBvZiBpbnZpc2libGUgcmVzdHMuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZHVyYXRpb25UaGlzQmFyID4gMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3ZlcmxheVZvaWNlW2tdLnZvaWNlLnB1c2goeyBlbF90eXBlOiBcIm5vdGVcIiwgZHVyYXRpb246IGR1cmF0aW9uVGhpc0JhciwgcmVzdDoge3R5cGU6IFwiaW52aXNpYmxlXCJ9LCBzdGFydENoYXI6IGV2ZW50LnN0YXJ0Q2hhciwgZW5kQ2hhcjogZXZlbnQuZW5kQ2hhciB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdG92ZXJsYXlWb2ljZVtrXS52b2ljZS5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb25UaGlzQmFyID0gMDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudC5lbF90eXBlID09PSBcIm5vdGVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbk92ZXJsYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG92ZXJsYXlWb2ljZVtrXS52b2ljZS5wdXNoKGV2ZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb25UaGlzQmFyICs9IGV2ZW50LmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudC5lbF90eXBlID09PSBcInNjYWxlXCIgfHwgZXZlbnQuZWxfdHlwZSA9PT0gXCJzdGVtXCIgfHwgZXZlbnQuZWxfdHlwZSA9PT0gXCJvdmVybGF5XCIgfHwgZXZlbnQuZWxfdHlwZSA9PT0gXCJzdHlsZVwiIHx8IGV2ZW50LmVsX3R5cGUgPT09IFwidHJhbnNwb3NlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBUaGVzZSB0eXBlcyBvZiBldmVudHMgYXJlIGR1cGxpY2F0ZWQgb24gdGhlIG92ZXJsYXkgbGF5ZXIuXG5cdFx0XHRcdFx0XHRcdFx0b3ZlcmxheVZvaWNlW2tdLnZvaWNlLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob3ZlcmxheVZvaWNlW2tdLmhhc092ZXJsYXkgJiYgb3ZlcmxheVZvaWNlW2tdLnNuaXAubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoZXJlIHdhcyBubyBjbG9zaW5nIGJhciwgc28gd2UgZGlkbid0IHNldCB0aGUgc25pcCBhbW91bnQuXG5cdFx0XHRcdFx0XHRcdG92ZXJsYXlWb2ljZVtrXS5zbmlwLnB1c2goeyBzdGFydDogc25pcFN0YXJ0LCBsZW46IHZvaWNlLmxlbmd0aCAtIHNuaXBTdGFydH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGsgPSAwOyBrIDwgb3ZlcmxheVZvaWNlLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3YgPSBvdmVybGF5Vm9pY2Vba107XG5cdFx0XHRcdFx0XHRpZiAob3YuaGFzT3ZlcmxheSkge1xuXHRcdFx0XHRcdFx0XHRzdGFmZi52b2ljZXMucHVzaChvdi52b2ljZSk7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGtrayA9IG92LnNuaXAubGVuZ3RoLTE7IGtrayA+PSAwOyBra2stLSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBzbmlwID0gb3Yuc25pcFtra2tdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YWZmLnZvaWNlc1trXS5zcGxpY2Uoc25pcC5zdGFydCwgc25pcC5sZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBlbmRpbmcgbWFya3MgZnJvbSB0aGUgb3ZlcmxheSB2b2ljZSBzbyB0aGV5IGFyZSBub3QgcmVwZWF0ZWRcblx0XHRcdFx0XHRcdFx0Zm9yIChra2sgPSAwOyBra2sgPCBzdGFmZi52b2ljZXNbc3RhZmYudm9pY2VzLmxlbmd0aC0xXS5sZW5ndGg7IGtraysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhZmYudm9pY2VzW3N0YWZmLnZvaWNlcy5sZW5ndGgtMV1ba2trXSA9IHBhcnNlQ29tbW9uLmNsb25lKHN0YWZmLnZvaWNlc1tzdGFmZi52b2ljZXMubGVuZ3RoLTFdW2tra10pO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlbCA9IHN0YWZmLnZvaWNlc1tzdGFmZi52b2ljZXMubGVuZ3RoLTFdW2tra107XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsLmVsX3R5cGUgPT09ICdiYXInICYmIGVsLnN0YXJ0RW5kaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZWwuc3RhcnRFbmRpbmc7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChlbC5lbF90eXBlID09PSAnYmFyJyAmJiBlbC5lbmRFbmRpbmcpXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZWwuZW5kRW5kaW5nO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYWRlQ2hhbmdlcztcblx0fTtcblxuXHRmdW5jdGlvbiBmaXhUaXRsZXMobGluZXMpIHtcblx0XHQvLyBXZSBtaWdodCBoYXZlIG5hbWUgYW5kIHN1Ym5hbWUgZGVmaW5lZC4gV2Ugbm93IGtub3cgd2hhdCBsaW5lIGV2ZXJ5dGhpbmcgaXMgb24sIHNvIHdlIGNhbiBkZXRlcm1pbmUgd2hpY2ggdG8gdXNlLlxuXHRcdHZhciBmaXJzdE11c2ljTGluZSA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChsaW5lLnN0YWZmKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5zdGFmZi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBzdGFmZiA9IGxpbmUuc3RhZmZbal07XG5cdFx0XHRcdFx0aWYgKHN0YWZmLnRpdGxlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaGFzQVRpdGxlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHN0YWZmLnRpdGxlLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzdGFmZi50aXRsZVtrXSkge1xuXHRcdFx0XHRcdFx0XHRzdGFmZi50aXRsZVtrXSA9IChmaXJzdE11c2ljTGluZSkgPyBzdGFmZi50aXRsZVtrXS5uYW1lIDogc3RhZmYudGl0bGVba10uc3VibmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKHN0YWZmLnRpdGxlW2tdKVxuXHRcdFx0XHRcdFx0XHRcdGhhc0FUaXRsZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdHN0YWZmLnRpdGxlW2tdID0gJyc7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHN0YWZmLnRpdGxlW2tdID0gJyc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIWhhc0FUaXRsZSlcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0YWZmLnRpdGxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJzdE11c2ljTGluZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMuY2xlYW5VcCA9IGZ1bmN0aW9uKGRlZldpZHRoLCBkZWZMZW5ndGgsIGJhcnNwZXJzdGFmZiwgc3RhZmZub25vdGUsIGN1cnJTbHVyKSB7XG5cdFx0dGhpcy5jbG9zZUxpbmUoKTtcdC8vIENsb3NlIHRoZSBsYXN0IGxpbmUuXG5cblx0XHQvLyBJZiB0aGUgdGVtcG8gd2FzIGNyZWF0ZWQgd2l0aCBhIHN0cmluZyBsaWtlIFwiQWxsZWdyb1wiLCB0aGVuIHRoZSBkdXJhdGlvbiBvZiBhIGJlYXQgbmVlZHMgdG8gYmUgc2V0IGF0IHRoZSBsYXN0IG1vbWVudCwgd2hlbiBpdCBpcyBtb3N0IGxpa2VseSBrbm93bi5cblx0XHRpZiAodGhpcy5tZXRhVGV4dC50ZW1wbyAmJiB0aGlzLm1ldGFUZXh0LnRlbXBvLmJwbSAmJiAhdGhpcy5tZXRhVGV4dC50ZW1wby5kdXJhdGlvbilcblx0XHRcdHRoaXMubWV0YVRleHQudGVtcG8uZHVyYXRpb24gPSBbIHRoaXMuZ2V0QmVhdExlbmd0aCgpIF07XG5cblx0XHQvLyBSZW1vdmUgYW55IGJsYW5rIGxpbmVzXG5cdFx0dmFyIGFueURlbGV0ZWQgPSBmYWxzZTtcblx0XHR2YXIgaSwgcywgdjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMubGluZXNbaV0uc3RhZmYgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgaGFzQW55ID0gZmFsc2U7XG5cdFx0XHRcdGZvciAocyA9IDA7IHMgPCB0aGlzLmxpbmVzW2ldLnN0YWZmLmxlbmd0aDsgcysrKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMubGluZXNbaV0uc3RhZmZbc10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0YW55RGVsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLmxpbmVzW2ldLnN0YWZmW3NdID0gbnVsbDtcblx0XHRcdFx0XHRcdC8vdGhpcy5saW5lc1tpXS5zdGFmZltzXSA9IHsgdm9pY2VzOiBbXX07XHQvLyBUT0RPLVBFUjogVGhlcmUgd2FzIGEgcGFydCBtaXNzaW5nIGluIHRoZSBhYmMgbXVzaWMuIEhvdyBzaG91bGQgd2UgcmVjb3Zlcj9cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICh2ID0gMDsgdiA8IHRoaXMubGluZXNbaV0uc3RhZmZbc10udm9pY2VzLmxlbmd0aDsgdisrKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmW3NdLnZvaWNlc1t2XSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMubGluZXNbaV0uc3RhZmZbc10udm9pY2VzW3ZdID0gW107XHQvLyBUT0RPLVBFUjogVGhlcmUgd2FzIGEgcGFydCBtaXNzaW5nIGluIHRoZSBhYmMgbXVzaWMuIEhvdyBzaG91bGQgd2UgcmVjb3Zlcj9cblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbnRhaW5zTm90ZXModGhpcy5saW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl0pKSBoYXNBbnkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhhc0FueSkge1xuXHRcdFx0XHRcdHRoaXMubGluZXNbaV0gPSBudWxsO1xuXHRcdFx0XHRcdGFueURlbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChhbnlEZWxldGVkKSB7XG5cdFx0XHR0aGlzLmxpbmVzID0gcGFyc2VDb21tb24uY29tcGFjdCh0aGlzLmxpbmVzKTtcblx0XHRcdHBhcnNlQ29tbW9uLmVhY2godGhpcy5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRpZiAobGluZS5zdGFmZilcblx0XHRcdFx0XHRsaW5lLnN0YWZmID0gcGFyc2VDb21tb24uY29tcGFjdChsaW5lLnN0YWZmKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGlmIHdlIGV4Y2VlZGVkIHRoZSBudW1iZXIgb2YgYmFycyBhbGxvd2VkIG9uIGEgbGluZSwgdGhlbiBmb3JjZSBhIG5ldyBsaW5lXG5cdFx0aWYgKGJhcnNwZXJzdGFmZikge1xuXHRcdFx0d2hpbGUgKHdyYXBNdXNpY0xpbmVzKHRoaXMubGluZXMsIGJhcnNwZXJzdGFmZikpIHtcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIGtlZXAgd3JhcHBpbmcgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGllY2UuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2Ugd2VyZSBwYXNzZWQgc3RhZmZub25vdGUsIHRoZW4gd2Ugd2FudCB0byBnZXQgcmlkIG9mIGFsbCBzdGFmZnMgdGhhdCBjb250YWluIG9ubHkgcmVzdHMuXG5cdFx0aWYgKHN0YWZmbm9ub3RlKSB7XG5cdFx0XHRhbnlEZWxldGVkID0gZmFsc2U7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5saW5lc1tpXS5zdGFmZiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Zm9yIChzID0gMDsgcyA8IHRoaXMubGluZXNbaV0uc3RhZmYubGVuZ3RoOyBzKyspIHtcblx0XHRcdFx0XHRcdHZhciBrZWVwVGhpcyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Zm9yICh2ID0gMDsgdiA8IHRoaXMubGluZXNbaV0uc3RhZmZbc10udm9pY2VzLmxlbmd0aDsgdisrKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmNvbnRhaW5zTm90ZXNTdHJpY3QodGhpcy5saW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0a2VlcFRoaXMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIWtlZXBUaGlzKSB7XG5cdFx0XHRcdFx0XHRcdGFueURlbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxpbmVzW2ldLnN0YWZmW3NdID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbnlEZWxldGVkKSB7XG5cdFx0XHRcdHBhcnNlQ29tbW9uLmVhY2godGhpcy5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRcdGlmIChsaW5lLnN0YWZmKVxuXHRcdFx0XHRcdFx0bGluZS5zdGFmZiA9IHBhcnNlQ29tbW9uLmNvbXBhY3QobGluZS5zdGFmZik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZpeFRpdGxlcyh0aGlzLmxpbmVzKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IHdvcmtpbmcgdmFyaWFibGVzXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmKSB7XG5cdFx0XHRcdGZvciAocyA9IDA7IHMgPCB0aGlzLmxpbmVzW2ldLnN0YWZmLmxlbmd0aDsgcysrKVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMubGluZXNbaV0uc3RhZmZbc10ud29ya2luZ0NsZWY7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG92ZXJsYXlzLCBjcmVhdGUgbmV3IHZvaWNlcyBmb3IgdGhlbS5cblx0XHR3aGlsZSAodGhpcy5yZXNvbHZlT3ZlcmxheXMoKSkge1xuXHRcdFx0Ly8ga2VlcCByZXNvbHZpbmcgb3ZlcmxheXMgYXMgbG9uZyBhcyBhbnkgYXJlIGZvdW5kLlxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNsZWFuVXBTbHVyc0luTGluZShsaW5lKSB7XG5cdFx0XHR2YXIgeDtcbi8vXHRcdFx0dmFyIGx5ciA9IG51bGw7XHQvLyBUT0RPLVBFUjogZGVidWdnaW5nLlxuXG5cdFx0XHR2YXIgYWRkRW5kU2x1ciA9IGZ1bmN0aW9uKG9iaiwgbnVtLCBjaG9yZFBvcykge1xuXHRcdFx0XHRpZiAoY3VyclNsdXJbY2hvcmRQb3NdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBUaGVyZSBpc24ndCBhbiBleGFjdCBtYXRjaCBmb3Igbm90ZSBwb3NpdGlvbiwgYnV0IHdlJ2xsIHRha2UgYW55IG90aGVyIG9wZW4gc2x1ci5cblx0XHRcdFx0XHRmb3IgKHggPSAwOyB4IDwgY3VyclNsdXIubGVuZ3RoOyB4KyspIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyU2x1clt4XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGNob3JkUG9zID0geDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjdXJyU2x1cltjaG9yZFBvc10gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFyIG9mZk51bSA9IGNob3JkUG9zKjEwMCsxO1xuXHRcdFx0XHRcdFx0cGFyc2VDb21tb24uZWFjaChvYmouZW5kU2x1ciwgZnVuY3Rpb24oeCkgeyBpZiAob2ZmTnVtID09PSB4KSAtLW9mZk51bTsgfSk7XG5cdFx0XHRcdFx0XHRjdXJyU2x1cltjaG9yZFBvc10gPSBbb2ZmTnVtXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHNsdXJOdW07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcblx0XHRcdFx0XHRzbHVyTnVtID0gY3VyclNsdXJbY2hvcmRQb3NdLnBvcCgpO1xuXHRcdFx0XHRcdG9iai5lbmRTbHVyLnB1c2goc2x1ck51bSk7XG4vL1x0XHRcdFx0XHRseXIuc3lsbGFibGUgKz0gJzwnICsgc2x1ck51bTtcdC8vIFRPRE8tUEVSOiBkZWJ1Z2dpbmdcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3VyclNsdXJbY2hvcmRQb3NdLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRkZWxldGUgY3VyclNsdXJbY2hvcmRQb3NdO1xuXHRcdFx0XHRyZXR1cm4gc2x1ck51bTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBhZGRTdGFydFNsdXIgPSBmdW5jdGlvbihvYmosIG51bSwgY2hvcmRQb3MsIHVzZWROdW1zKSB7XG5cdFx0XHRcdG9iai5zdGFydFNsdXIgPSBbXTtcblx0XHRcdFx0aWYgKGN1cnJTbHVyW2Nob3JkUG9zXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Y3VyclNsdXJbY2hvcmRQb3NdID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG5leHROdW0gPSBjaG9yZFBvcyoxMDArMTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuXHRcdFx0XHRcdGlmICh1c2VkTnVtcykge1xuXHRcdFx0XHRcdFx0cGFyc2VDb21tb24uZWFjaCh1c2VkTnVtcywgZnVuY3Rpb24oeCkgeyBpZiAobmV4dE51bSA9PT0geCkgKytuZXh0TnVtOyB9KTtcblx0XHRcdFx0XHRcdHBhcnNlQ29tbW9uLmVhY2godXNlZE51bXMsIGZ1bmN0aW9uKHgpIHsgaWYgKG5leHROdW0gPT09IHgpICsrbmV4dE51bTsgfSk7XG5cdFx0XHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKHVzZWROdW1zLCBmdW5jdGlvbih4KSB7IGlmIChuZXh0TnVtID09PSB4KSArK25leHROdW07IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGN1cnJTbHVyW2Nob3JkUG9zXSwgZnVuY3Rpb24oeCkgeyBpZiAobmV4dE51bSA9PT0geCkgKytuZXh0TnVtOyB9KTtcblx0XHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGN1cnJTbHVyW2Nob3JkUG9zXSwgZnVuY3Rpb24oeCkgeyBpZiAobmV4dE51bSA9PT0geCkgKytuZXh0TnVtOyB9KTtcblxuXHRcdFx0XHRcdGN1cnJTbHVyW2Nob3JkUG9zXS5wdXNoKG5leHROdW0pO1xuXHRcdFx0XHRcdG9iai5zdGFydFNsdXIucHVzaCh7IGxhYmVsOiBuZXh0TnVtIH0pO1xuLy9cdFx0XHRcdFx0bHlyLnN5bGxhYmxlICs9ICcgJyArIG5leHROdW0gKyAnPic7XHQvLyBUT0RPLVBFUjpkZWJ1Z2dpbmdcblx0XHRcdFx0XHRuZXh0TnVtKys7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZWwgPSBsaW5lW2ldO1xuLy9cdFx0XHRcdGlmIChlbC5seXJpYyA9PT0gdW5kZWZpbmVkKVx0Ly8gVE9ETy1QRVI6IGRlYnVnZ2luZ1xuLy9cdFx0XHRcdFx0ZWwubHlyaWMgPSBbeyBkaXZpZGVyOiAnLScgfV07XHQvLyBUT0RPLVBFUjogZGVidWdnaW5nXG4vL1x0XHRcdFx0bHlyID0gZWwubHlyaWNbMF07XHQvLyBUT0RPLVBFUjogZGVidWdnaW5nXG4vL1x0XHRcdFx0bHlyLnN5bGxhYmxlID0gJyc7XHQvLyBUT0RPLVBFUjogZGVidWdnaW5nXG5cdFx0XHRcdGlmIChlbC5lbF90eXBlID09PSAnbm90ZScpIHtcblx0XHRcdFx0XHRpZiAoZWwuZ3JhY2Vub3Rlcykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgZyA9IDA7IGcgPCBlbC5ncmFjZW5vdGVzLmxlbmd0aDsgZysrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlbC5ncmFjZW5vdGVzW2ddLmVuZFNsdXIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZ2cgPSBlbC5ncmFjZW5vdGVzW2ddLmVuZFNsdXI7XG5cdFx0XHRcdFx0XHRcdFx0ZWwuZ3JhY2Vub3Rlc1tnXS5lbmRTbHVyID0gW107XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgZ2dnID0gMDsgZ2dnIDwgZ2c7IGdnZysrKVxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkRW5kU2x1cihlbC5ncmFjZW5vdGVzW2ddLCAxLCAyMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGVsLmdyYWNlbm90ZXNbZ10uc3RhcnRTbHVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0eCA9IGVsLmdyYWNlbm90ZXNbZ10uc3RhcnRTbHVyO1xuXHRcdFx0XHRcdFx0XHRcdGFkZFN0YXJ0U2x1cihlbC5ncmFjZW5vdGVzW2ddLCB4LCAyMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGVsLmVuZFNsdXIpIHtcblx0XHRcdFx0XHRcdHggPSBlbC5lbmRTbHVyO1xuXHRcdFx0XHRcdFx0ZWwuZW5kU2x1ciA9IFtdO1xuXHRcdFx0XHRcdFx0YWRkRW5kU2x1cihlbCwgeCwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChlbC5zdGFydFNsdXIpIHtcblx0XHRcdFx0XHRcdHggPSBlbC5zdGFydFNsdXI7XG5cdFx0XHRcdFx0XHRhZGRTdGFydFNsdXIoZWwsIHgsIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZWwucGl0Y2hlcykge1xuXHRcdFx0XHRcdFx0dmFyIHVzZWROdW1zID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBwID0gMDsgcCA8IGVsLnBpdGNoZXMubGVuZ3RoOyBwKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKGVsLnBpdGNoZXNbcF0uZW5kU2x1cikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBrID0gZWwucGl0Y2hlc1twXS5lbmRTbHVyO1xuXHRcdFx0XHRcdFx0XHRcdGVsLnBpdGNoZXNbcF0uZW5kU2x1ciA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgazsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc2x1ck51bSA9IGFkZEVuZFNsdXIoZWwucGl0Y2hlc1twXSwgMSwgcCsxKTtcblx0XHRcdFx0XHRcdFx0XHRcdHVzZWROdW1zLnB1c2goc2x1ck51bSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKHAgPSAwOyBwIDwgZWwucGl0Y2hlcy5sZW5ndGg7IHArKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZWwucGl0Y2hlc1twXS5zdGFydFNsdXIpIHtcblx0XHRcdFx0XHRcdFx0XHR4ID0gZWwucGl0Y2hlc1twXS5zdGFydFNsdXI7XG5cdFx0XHRcdFx0XHRcdFx0YWRkU3RhcnRTbHVyKGVsLnBpdGNoZXNbcF0sIHgsIHArMSwgdXNlZE51bXMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBDb3JyZWN0IGZvciB0aGUgd2VpcmQgZ3JhY2Vub3RlIGNhc2Ugd2hlcmUgKHtnfWEpIHNob3VsZCBtYXRjaC5cblx0XHRcdFx0XHRcdC8vIFRoZSBlbmQgc2x1ciB3YXMgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGUgbm90ZSwgYW5kIG5lZWRzIHRvIGJlIG1vdmVkIHRvIHRoZSBmaXJzdCBub3RlIG9mIHRoZSBncmFjZXMuXG5cdFx0XHRcdFx0XHRpZiAoZWwuZ3JhY2Vub3RlcyAmJiBlbC5waXRjaGVzWzBdLmVuZFNsdXIgJiYgZWwucGl0Y2hlc1swXS5lbmRTbHVyWzBdID09PSAxMDAgJiYgZWwucGl0Y2hlc1swXS5zdGFydFNsdXIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGVsLmdyYWNlbm90ZXNbMF0uZW5kU2x1cilcblx0XHRcdFx0XHRcdFx0XHRlbC5ncmFjZW5vdGVzWzBdLmVuZFNsdXIucHVzaChlbC5waXRjaGVzWzBdLnN0YXJ0U2x1clswXS5sYWJlbCk7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbC5ncmFjZW5vdGVzWzBdLmVuZFNsdXIgPSBbZWwucGl0Y2hlc1swXS5zdGFydFNsdXJbMF0ubGFiZWxdO1xuXHRcdFx0XHRcdFx0XHRpZiAoZWwucGl0Y2hlc1swXS5lbmRTbHVyLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZWwucGl0Y2hlc1swXS5lbmRTbHVyO1xuXHRcdFx0XHRcdFx0XHRlbHNlIGlmIChlbC5waXRjaGVzWzBdLmVuZFNsdXJbMF0gPT09IDEwMClcblx0XHRcdFx0XHRcdFx0XHRlbC5waXRjaGVzWzBdLmVuZFNsdXIuc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoZWwucGl0Y2hlc1swXS5lbmRTbHVyW2VsLnBpdGNoZXNbMF0uZW5kU2x1ci5sZW5ndGgtMV0gPT09IDEwMClcblx0XHRcdFx0XHRcdFx0XHRlbC5waXRjaGVzWzBdLmVuZFNsdXIucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChjdXJyU2x1clsxXS5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGN1cnJTbHVyWzFdO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0Y3VyclNsdXJbMV0ucG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETy1QRVI6IFRoaXMgY291bGQgYmUgZG9uZSBmYXN0ZXIgYXMgd2UgZ28gaW5zdGVhZCBvZiBhcyB0aGUgbGFzdCBzdGVwLlxuXHRcdGZ1bmN0aW9uIGZpeENsZWZQbGFjZW1lbnQoZWwpIHtcblx0XHRcdHBhcnNlS2V5Vm9pY2UuZml4Q2xlZihlbCk7XG5cdFx0XHQvL2lmIChlbC5lbF90eXBlID09PSAnY2xlZicpIHtcbi8vXHRcdFx0XHR2YXIgbWluID0gLTI7XG4vL1x0XHRcdFx0dmFyIG1heCA9IDU7XG4vL1x0XHRcdFx0c3dpdGNoKGVsLnR5cGUpIHtcbi8vXHRcdFx0XHRcdGNhc2UgJ3RyZWJsZSs4Jzpcbi8vXHRcdFx0XHRcdGNhc2UgJ3RyZWJsZS04Jzpcbi8vXHRcdFx0XHRcdFx0YnJlYWs7XG4vL1x0XHRcdFx0XHRjYXNlICdiYXNzJzpcbi8vXHRcdFx0XHRcdGNhc2UgJ2Jhc3MrOCc6XG4vL1x0XHRcdFx0XHRjYXNlICdiYXNzLTgnOlxuLy9cdFx0XHRcdFx0XHRlbC52ZXJ0aWNhbFBvcyA9IDIwICsgZWwudmVydGljYWxQb3M7IG1pbiArPSA2OyBtYXggKz0gNjtcbi8vXHRcdFx0XHRcdFx0YnJlYWs7XG4vL1x0XHRcdFx0XHRjYXNlICd0ZW5vcic6XG4vL1x0XHRcdFx0XHRjYXNlICd0ZW5vcis4Jzpcbi8vXHRcdFx0XHRcdGNhc2UgJ3Rlbm9yLTgnOlxuLy9cdFx0XHRcdFx0XHRlbC52ZXJ0aWNhbFBvcyA9IC0gZWwudmVydGljYWxQb3M7IG1pbiA9IC00MDsgbWF4ID0gNDA7XG4vLy8vXHRcdFx0XHRcdFx0ZWwudmVydGljYWxQb3MrPTI7IG1pbiArPSA2OyBtYXggKz0gNjtcbi8vXHRcdFx0XHRcdFx0YnJlYWs7XG4vL1x0XHRcdFx0XHRjYXNlICdhbHRvJzpcbi8vXHRcdFx0XHRcdGNhc2UgJ2FsdG8rOCc6XG4vL1x0XHRcdFx0XHRjYXNlICdhbHRvLTgnOlxuLy9cdFx0XHRcdFx0XHRlbC52ZXJ0aWNhbFBvcyA9IC0gZWwudmVydGljYWxQb3M7IG1pbiA9IC00MDsgbWF4ID0gNDA7XG4vLy8vXHRcdFx0XHRcdFx0ZWwudmVydGljYWxQb3MtPTI7IG1pbiArPSA0OyBtYXggKz0gNDtcbi8vXHRcdFx0XHRcdFx0YnJlYWs7XG4vL1x0XHRcdFx0fVxuLy9cdFx0XHRcdGlmIChlbC52ZXJ0aWNhbFBvcyA8IG1pbikge1xuLy9cdFx0XHRcdFx0d2hpbGUgKGVsLnZlcnRpY2FsUG9zIDwgbWluKVxuLy9cdFx0XHRcdFx0XHRlbC52ZXJ0aWNhbFBvcyArPSA3O1xuLy9cdFx0XHRcdH0gZWxzZSBpZiAoZWwudmVydGljYWxQb3MgPiBtYXgpIHtcbi8vXHRcdFx0XHRcdHdoaWxlIChlbC52ZXJ0aWNhbFBvcyA+IG1heClcbi8vXHRcdFx0XHRcdFx0ZWwudmVydGljYWxQb3MgLT0gNztcbi8vXHRcdFx0XHR9XG5cdFx0XHQvL31cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cmFwTXVzaWNMaW5lcyhsaW5lcywgYmFyc3BlcnN0YWZmKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGxpbmVzW2ldLnN0YWZmICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRmb3IgKHMgPSAwOyBzIDwgbGluZXNbaV0uc3RhZmYubGVuZ3RoOyBzKyspIHtcblx0XHRcdFx0XHRcdHZhciBwZXJtYW5lbnRJdGVtcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2ID0gMDsgdiA8IGxpbmVzW2ldLnN0YWZmW3NdLnZvaWNlcy5sZW5ndGg7IHYrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdm9pY2UgPSBsaW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl07XG5cdFx0XHRcdFx0XHRcdHZhciBiYXJOdW1UaGlzTGluZSA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG4gPSAwOyBuIDwgdm9pY2UubGVuZ3RoOyBuKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodm9pY2Vbbl0uZWxfdHlwZSA9PT0gJ2JhcicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGJhck51bVRoaXNMaW5lKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYmFyTnVtVGhpc0xpbmUgPj0gYmFyc3BlcnN0YWZmKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHB1c2ggZXZlcnl0aGluZyBlbHNlIHRvIHRoZSBuZXh0IGxpbmUsIGlmIHRoZXJlIGlzIGFueXRoaW5nIGVsc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCB0aGVyZSBpcyBhIG5leHQgbGluZS4gSWYgdGhlcmUgaXNuJ3QgYSBuZXh0IGxpbmUsIGNyZWF0ZSBvbmUuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChuIDwgdm9pY2UubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBuZXh0TGluZSA9IGdldE5leHRNdXNpY0xpbmUobGluZXMsIGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghbmV4dExpbmUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBjcCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGluZXNbaV0pKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxpbmVzLnB1c2gocGFyc2VDb21tb24uY2xvbmUoY3ApKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRMaW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKHZhciBzcyA9IDA7IHNzIDwgbmV4dExpbmUuc3RhZmYubGVuZ3RoOyBzcysrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIHZ2ID0gMDsgdnYgPCBuZXh0TGluZS5zdGFmZltzc10udm9pY2VzLmxlbmd0aDsgdnYrKylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0TGluZS5zdGFmZltzc10udm9pY2VzW3Z2XSA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhcnRFbGVtZW50ID0gbiArIDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHNlY3Rpb24gPSBsaW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl0uc2xpY2Uoc3RhcnRFbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsaW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl0gPSBsaW5lc1tpXS5zdGFmZltzXS52b2ljZXNbdl0uc2xpY2UoMCwgc3RhcnRFbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0TGluZS5zdGFmZltzXS52b2ljZXNbdl0gPSBwZXJtYW5lbnRJdGVtcy5jb25jYXQoc2VjdGlvbi5jb25jYXQobmV4dExpbmUuc3RhZmZbc10udm9pY2VzW3ZdKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2b2ljZVtuXS5kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGVybWFuZW50SXRlbXMucHVzaCh2b2ljZVtuXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TmV4dE11c2ljTGluZShsaW5lcywgY3VycmVudExpbmUpIHtcblx0XHRcdGN1cnJlbnRMaW5lKys7XG5cdFx0XHR3aGlsZSAobGluZXMubGVuZ3RoID4gY3VycmVudExpbmUpIHtcblx0XHRcdFx0aWYgKGxpbmVzW2N1cnJlbnRMaW5lXS5zdGFmZilcblx0XHRcdFx0XHRyZXR1cm4gbGluZXNbY3VycmVudExpbmVdO1xuXHRcdFx0XHRjdXJyZW50TGluZSsrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Zm9yICh0aGlzLmxpbmVOdW0gPSAwOyB0aGlzLmxpbmVOdW0gPCB0aGlzLmxpbmVzLmxlbmd0aDsgdGhpcy5saW5lTnVtKyspIHtcblx0XHRcdHZhciBzdGFmZiA9IHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZjtcblx0XHRcdGlmIChzdGFmZikge1xuXHRcdFx0XHRmb3IgKHRoaXMuc3RhZmZOdW0gPSAwOyB0aGlzLnN0YWZmTnVtIDwgc3RhZmYubGVuZ3RoOyB0aGlzLnN0YWZmTnVtKyspIHtcblx0XHRcdFx0XHRpZiAoc3RhZmZbdGhpcy5zdGFmZk51bV0uY2xlZilcblx0XHRcdFx0XHRcdGZpeENsZWZQbGFjZW1lbnQoc3RhZmZbdGhpcy5zdGFmZk51bV0uY2xlZik7XG5cdFx0XHRcdFx0Zm9yICh0aGlzLnZvaWNlTnVtID0gMDsgdGhpcy52b2ljZU51bSA8IHN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlcy5sZW5ndGg7IHRoaXMudm9pY2VOdW0rKykge1xuXHRcdFx0XHRcdFx0dmFyIHZvaWNlID0gc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dO1xuXHRcdFx0XHRcdFx0Y2xlYW5VcFNsdXJzSW5MaW5lKHZvaWNlKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgdm9pY2UubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZvaWNlW2pdLmVsX3R5cGUgPT09ICdjbGVmJylcblx0XHRcdFx0XHRcdFx0XHRmaXhDbGVmUGxhY2VtZW50KHZvaWNlW2pdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2b2ljZS5sZW5ndGggPiAwICYmIHZvaWNlW3ZvaWNlLmxlbmd0aC0xXS5iYXJOdW1iZXIpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgaGFuZyBhIGJhciBudW1iZXIgb24gdGhlIGxhc3QgYmFyIGxpbmU6IGl0IHNob3VsZCBnbyBvbiB0aGUgbmV4dCBsaW5lLlxuXHRcdFx0XHRcdFx0XHR2YXIgbmV4dExpbmUgPSBnZXROZXh0TXVzaWNMaW5lKHRoaXMubGluZXMsIHRoaXMubGluZU51bSk7XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0TGluZSlcblx0XHRcdFx0XHRcdFx0XHRuZXh0TGluZS5zdGFmZlswXS5iYXJOdW1iZXIgPSB2b2ljZVt2b2ljZS5sZW5ndGgtMV0uYmFyTnVtYmVyO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgdm9pY2Vbdm9pY2UubGVuZ3RoLTFdLmJhck51bWJlcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuZm9ybWF0dGluZy5wYWdld2lkdGgpXG5cdFx0XHR0aGlzLmZvcm1hdHRpbmcucGFnZXdpZHRoID0gZGVmV2lkdGg7XG5cdFx0aWYgKCF0aGlzLmZvcm1hdHRpbmcucGFnZWhlaWdodClcblx0XHRcdHRoaXMuZm9ybWF0dGluZy5wYWdlaGVpZ2h0ID0gZGVmTGVuZ3RoO1xuXG5cdFx0Ly8gUmVtb3ZlIHRlbXBvcmFyeSB2YXJpYWJsZXMgdGhhdCB0aGUgb3V0c2lkZSBkb2Vzbid0IG5lZWQgdG8ga25vdyBhYm91dFxuXHRcdGRlbGV0ZSB0aGlzLnN0YWZmTnVtO1xuXHRcdGRlbGV0ZSB0aGlzLnZvaWNlTnVtO1xuXHRcdGRlbGV0ZSB0aGlzLmxpbmVOdW07XG5cdFx0ZGVsZXRlIHRoaXMucG90ZW50aWFsU3RhcnRCZWFtO1xuXHRcdGRlbGV0ZSB0aGlzLnBvdGVudGlhbEVuZEJlYW07XG5cdFx0ZGVsZXRlIHRoaXMudnNraXBQZW5kaW5nO1xuXG5cdFx0cmV0dXJuIGN1cnJTbHVyO1xuXHR9O1xuXG5cdHRoaXMucmVzZXQoKTtcblxuXHR0aGlzLmdldExhc3ROb3RlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXSAmJiB0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmYgJiYgdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dICYmXG5cdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGVsID0gdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXVtpXTtcblx0XHRcdFx0aWYgKGVsLmVsX3R5cGUgPT09ICdub3RlJykge1xuXHRcdFx0XHRcdHJldHVybiBlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHR0aGlzLmFkZFRpZVRvTGFzdE5vdGUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPLVBFUjogaWYgdGhpcyBpcyBhIGNob3JkLCB3aGljaCBub3RlP1xuXHRcdHZhciBlbCA9IHRoaXMuZ2V0TGFzdE5vdGUoKTtcblx0XHRpZiAoZWwgJiYgZWwucGl0Y2hlcyAmJiBlbC5waXRjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdGVsLnBpdGNoZXNbMF0uc3RhcnRUaWUgPSB7fTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0dGhpcy5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uKGVsKSB7XG5cdFx0aWYgKGVsLmR1cmF0aW9uKSByZXR1cm4gZWwuZHVyYXRpb247XG5cdFx0Ly9pZiAoZWwucGl0Y2hlcyAmJiBlbC5waXRjaGVzLmxlbmd0aCA+IDApIHJldHVybiBlbC5waXRjaGVzWzBdLmR1cmF0aW9uO1xuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdHRoaXMuY2xvc2VMaW5lID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMucG90ZW50aWFsU3RhcnRCZWFtICYmIHRoaXMucG90ZW50aWFsRW5kQmVhbSkge1xuXHRcdFx0dGhpcy5wb3RlbnRpYWxTdGFydEJlYW0uc3RhcnRCZWFtID0gdHJ1ZTtcblx0XHRcdHRoaXMucG90ZW50aWFsRW5kQmVhbS5lbmRCZWFtID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMucG90ZW50aWFsU3RhcnRCZWFtO1xuXHRcdGRlbGV0ZSB0aGlzLnBvdGVudGlhbEVuZEJlYW07XG5cdH07XG5cblx0dGhpcy5hcHBlbmRFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgc3RhcnRDaGFyLCBlbmRDaGFyLCBoYXNoUGFyYW1zKVxuXHR7XG5cdFx0dmFyIFRoaXMgPSB0aGlzO1xuXHRcdHZhciBwdXNoTm90ZSA9IGZ1bmN0aW9uKGhwKSB7XG5cdFx0XHR2YXIgY3VyclN0YWZmID0gVGhpcy5saW5lc1tUaGlzLmxpbmVOdW1dLnN0YWZmW1RoaXMuc3RhZmZOdW1dO1xuXHRcdFx0aWYgKCFjdXJyU3RhZmYpIHtcblx0XHRcdFx0Ly8gVE9ETy1QRVI6IFRoaXMgcHJldmVudHMgYSBjcmFzaCwgYnV0IGl0IGRyb3BzIHRoZSBlbGVtZW50LiBOZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHRvIHN0YXJ0IGEgbmV3IGxpbmUsIG9yIGRlbGF5IGFkZGluZyB0aGlzLlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoaHAucGl0Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBtaWQgPSBjdXJyU3RhZmYud29ya2luZ0NsZWYudmVydGljYWxQb3M7XG5cdFx0XHRcdHBhcnNlQ29tbW9uLmVhY2goaHAucGl0Y2hlcywgZnVuY3Rpb24ocCkgeyBwLnZlcnRpY2FsUG9zID0gcC5waXRjaCAtIG1pZDsgfSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaHAuZ3JhY2Vub3RlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBtaWQyID0gY3VyclN0YWZmLndvcmtpbmdDbGVmLnZlcnRpY2FsUG9zO1xuXHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGhwLmdyYWNlbm90ZXMsIGZ1bmN0aW9uKHApIHsgcC52ZXJ0aWNhbFBvcyA9IHAucGl0Y2ggLSBtaWQyOyB9KTtcblx0XHRcdH1cblx0XHRcdGN1cnJTdGFmZi52b2ljZXNbVGhpcy52b2ljZU51bV0ucHVzaChocCk7XG5cdFx0fTtcblx0XHRoYXNoUGFyYW1zLmVsX3R5cGUgPSB0eXBlO1xuXHRcdGlmIChzdGFydENoYXIgIT09IG51bGwpXG5cdFx0XHRoYXNoUGFyYW1zLnN0YXJ0Q2hhciA9IHN0YXJ0Q2hhcjtcblx0XHRpZiAoZW5kQ2hhciAhPT0gbnVsbClcblx0XHRcdGhhc2hQYXJhbXMuZW5kQ2hhciA9IGVuZENoYXI7XG5cdFx0dmFyIGVuZEJlYW1IZXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRUaGlzLnBvdGVudGlhbFN0YXJ0QmVhbS5zdGFydEJlYW0gPSB0cnVlO1xuXHRcdFx0aGFzaFBhcmFtcy5lbmRCZWFtID0gdHJ1ZTtcblx0XHRcdGRlbGV0ZSBUaGlzLnBvdGVudGlhbFN0YXJ0QmVhbTtcblx0XHRcdGRlbGV0ZSBUaGlzLnBvdGVudGlhbEVuZEJlYW07XG5cdFx0fTtcblx0XHR2YXIgZW5kQmVhbUxhc3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChUaGlzLnBvdGVudGlhbFN0YXJ0QmVhbSAhPT0gdW5kZWZpbmVkICYmIFRoaXMucG90ZW50aWFsRW5kQmVhbSAhPT0gdW5kZWZpbmVkKSB7XHQvLyBEbyB3ZSBoYXZlIGEgc2V0IG9mIG5vdGVzIHRvIGJlYW0/XG5cdFx0XHRcdFRoaXMucG90ZW50aWFsU3RhcnRCZWFtLnN0YXJ0QmVhbSA9IHRydWU7XG5cdFx0XHRcdFRoaXMucG90ZW50aWFsRW5kQmVhbS5lbmRCZWFtID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBUaGlzLnBvdGVudGlhbFN0YXJ0QmVhbTtcblx0XHRcdGRlbGV0ZSBUaGlzLnBvdGVudGlhbEVuZEJlYW07XG5cdFx0fTtcblx0XHRpZiAodHlwZSA9PT0gJ25vdGUnKSB7IC8vICYmIChoYXNoUGFyYW1zLnJlc3QgIT09IHVuZGVmaW5lZCB8fCBoYXNoUGFyYW1zLmVuZF9iZWFtID09PSB1bmRlZmluZWQpKSB7XG5cdFx0XHQvLyBOb3csIGFkZCB0aGUgc3RhcnRCZWFtIGFuZCBlbmRCZWFtIHdoZXJlIGl0IGlzIG5lZWRlZC5cblx0XHRcdC8vIGVuZF9iZWFtIGlzIGFscmVhZHkgc2V0IG9uIHRoZSBwbGFjZXMgd2hlcmUgdGhlcmUgaXMgYSBmb3JjZWQgZW5kX2JlYW0uIFdlJ2xsIHJlbW92ZSB0aGF0IGhlcmUgYWZ0ZXIgdXNpbmcgdGhhdCBpbmZvLlxuXHRcdFx0Ly8gdGhpcy5wb3RlbnRpYWxTdGFydEJlYW0gZWl0aGVyIHBvaW50cyB0byBudWxsIG9yIHRoZSBzdGFydCBiZWFtLlxuXHRcdFx0Ly8gdGhpcy5wb3RlbnRpYWxFbmRCZWFtIGVpdGhlciBwb2ludHMgdG8gbnVsbCBvciB0aGUgc3RhcnQgYmVhbS5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBiZWFtIGJyZWFrIChub3RlIGlzIGxvbmdlciB0aGFuIGEgcXVhcnRlciwgb3IgYW4gZW5kX2JlYW0gaXMgb24gdGhpcyBlbGVtZW50KSwgdGhlbiBzZXQgdGhlIGJlYW0gaWYgd2UgaGF2ZSBvbmUuXG5cdFx0XHQvLyByZXNldCB0aGUgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBub3Rlcy5cblx0XHRcdHZhciBkdXIgPSBUaGlzLmdldER1cmF0aW9uKGhhc2hQYXJhbXMpO1xuXHRcdFx0aWYgKGR1ciA+PSAwLjI1KSB7XHQvLyBUaGUgYmVhbSBlbmRzIG9uIHRoZSBub3RlIGJlZm9yZSB0aGlzLlxuXHRcdFx0XHRlbmRCZWFtTGFzdCgpO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNoUGFyYW1zLmZvcmNlX2VuZF9iZWFtX2xhc3QgJiYgVGhpcy5wb3RlbnRpYWxTdGFydEJlYW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlbmRCZWFtTGFzdCgpO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNoUGFyYW1zLmVuZF9iZWFtICYmIFRoaXMucG90ZW50aWFsU3RhcnRCZWFtICE9PSB1bmRlZmluZWQpIHtcdC8vIHRoZSBiZWFtIGlzIGZvcmNlZCB0byBlbmQgb24gdGhpcyBub3RlLCBwcm9iYWJseSBiZWNhdXNlIG9mIGEgc3BhY2UgaW4gdGhlIEFCQ1xuXHRcdFx0XHRpZiAoaGFzaFBhcmFtcy5yZXN0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZW5kQmVhbUhlcmUoKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGVuZEJlYW1MYXN0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc2hQYXJhbXMucmVzdCA9PT0gdW5kZWZpbmVkKSB7XHQvLyB0aGlzIGEgc2hvcnQgbm90ZSBhbmQgd2UgYXJlbid0IGFib3V0IHRvIGVuZCB0aGUgYmVhbVxuXHRcdFx0XHRpZiAoVGhpcy5wb3RlbnRpYWxTdGFydEJlYW0gPT09IHVuZGVmaW5lZCkge1x0Ly8gV2UgYXJlbid0IGNvbGxlY3Rpbmcgbm90ZXMgZm9yIGEgYmVhbSwgc28gc3RhcnQgaGVyZS5cblx0XHRcdFx0XHRpZiAoIWhhc2hQYXJhbXMuZW5kX2JlYW0pIHtcblx0XHRcdFx0XHRcdFRoaXMucG90ZW50aWFsU3RhcnRCZWFtID0gaGFzaFBhcmFtcztcblx0XHRcdFx0XHRcdGRlbGV0ZSBUaGlzLnBvdGVudGlhbEVuZEJlYW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFRoaXMucG90ZW50aWFsRW5kQmVhbSA9IGhhc2hQYXJhbXM7XHQvLyBDb250aW51ZSB0aGUgYmVhbWluZywgbG9vayBmb3IgdGhlIGVuZCBuZXh0IG5vdGUuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gIGVuZF9iZWFtIGdvZXMgb24gcmVzdHMgYW5kIG5vdGVzIHdoaWNoIHByZWNlZGUgcmVzdHMgX2V4Y2VwdF8gd2hlbiBhIHJlc3QgKG9yIHNldCBvZiBhZGphY2VudCByZXN0cykgaGFzIG5vcm1hbCBub3RlcyBvbiBib3RoIHNpZGVzIChubyBzcGFjZXMpXG4vL1x0XHRcdGlmIChoYXNoUGFyYW1zLnJlc3QgIT09IHVuZGVmaW5lZClcbi8vXHRcdFx0e1xuLy9cdFx0XHRcdGhhc2hQYXJhbXMuZW5kX2JlYW0gPSB0cnVlO1xuLy9cdFx0XHRcdHZhciBlbDIgPSB0aGlzLmdldExhc3ROb3RlKCk7XG4vL1x0XHRcdFx0aWYgKGVsMikgZWwyLmVuZF9iZWFtID0gdHJ1ZTtcbi8vXHRcdFx0XHQvLyBUT0RPLVBFUjogaW1wbGVtZW50IGV4Y2VwdGlvbiBtZW50aW9uZWQgaW4gdGhlIGNvbW1lbnQuXG4vL1x0XHRcdH1cblx0XHR9IGVsc2Uge1x0Ly8gSXQncyBub3QgYSBub3RlLCBzbyB0aGVyZSBkZWZpbml0ZWx5IGlzbid0IGJlYW1pbmcgYWZ0ZXIgaXQuXG5cdFx0XHRlbmRCZWFtTGFzdCgpO1xuXHRcdH1cblx0XHRkZWxldGUgaGFzaFBhcmFtcy5lbmRfYmVhbTtcdC8vIFdlIGRvbid0IHdhbnQgdGhpcyB0ZW1wb3JhcnkgdmFyaWFibGUgaGFuZ2luZyBhcm91bmQuXG5cdFx0ZGVsZXRlIGhhc2hQYXJhbXMuZm9yY2VfZW5kX2JlYW1fbGFzdDtcdC8vIFdlIGRvbid0IHdhbnQgdGhpcyB0ZW1wb3JhcnkgdmFyaWFibGUgaGFuZ2luZyBhcm91bmQuXG5cdFx0cHVzaE5vdGUoaGFzaFBhcmFtcyk7XG5cdH07XG5cblx0dGhpcy5hcHBlbmRTdGFydGluZ0VsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBzdGFydENoYXIsIGVuZENoYXIsIGhhc2hQYXJhbXMyKVxuXHR7XG5cdFx0Ly8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBiZWFtaW5nLCB0aGVuIGVuZCB0aGUgYmVhbS5cblx0XHR0aGlzLmNsb3NlTGluZSgpO1xuXG5cdFx0Ly8gV2Ugb25seSBldmVyIHdhbnQgaW1wbGllZCBuYXR1cmFscyB0aGUgZmlyc3QgdGltZS5cblx0XHR2YXIgaW1wbGllZE5hdHVyYWxzO1xuXHRcdGlmICh0eXBlID09PSAna2V5Jykge1xuXHRcdFx0aW1wbGllZE5hdHVyYWxzID0gaGFzaFBhcmFtczIuaW1wbGllZE5hdHVyYWxzO1xuXHRcdFx0ZGVsZXRlIGhhc2hQYXJhbXMyLmltcGxpZWROYXR1cmFscztcblx0XHRcdGRlbGV0ZSBoYXNoUGFyYW1zMi5leHBsaWNpdEFjY2lkZW50YWxzO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSBvYmplY3QgYmVjYXVzZSBpdCB3aWxsIGJlIHN0aWNraW5nIGFyb3VuZCBmb3IgdGhlIG5leHQgbGluZSBhbmQgd2UgZG9uJ3Qgd2FudCB0aGUgZXh0cmEgZmllbGRzIGluIGl0LlxuXHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VDb21tb24uY2xvbmUoaGFzaFBhcmFtczIpO1xuXG5cdFx0aWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZikgeyAvLyBiZSBzdXJlIHRoYXQgd2UgYXJlIG9uIGEgbXVzaWMgdHlwZSBsaW5lIGJlZm9yZSBkb2luZyB0aGUgZm9sbG93aW5nLlxuXHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGlzIHN0YWZmLCB0aGVuIHdlIG1pZ2h0IGhhdmUgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhZmYsIGZpcnN0LlxuXHRcdFx0aWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZi5sZW5ndGggPD0gdGhpcy5zdGFmZk51bSkge1xuXHRcdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0gPSB7fTtcblx0XHRcdFx0dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLmNsZWYgPSBwYXJzZUNvbW1vbi5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0uY2xlZik7XG5cdFx0XHRcdHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS5rZXkgPSBwYXJzZUNvbW1vbi5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0ua2V5KTtcblx0XHRcdFx0aWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlswXS5tZXRlcilcblx0XHRcdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0ubWV0ZXIgPSBwYXJzZUNvbW1vbi5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0ubWV0ZXIpO1xuXHRcdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0ud29ya2luZ0NsZWYgPSBwYXJzZUNvbW1vbi5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0ud29ya2luZ0NsZWYpO1xuXHRcdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzID0gW1tdXTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjbGVmIHR5cGUsIHRoZW4gd2UgcmVwbGFjZSB0aGUgd29ya2luZyBjbGVmIG9uIHRoZSBsaW5lLiBUaGlzIGlzIGtlcHQgc2VwYXJhdGUgZnJvbVxuXHRcdFx0Ly8gdGhlIGNsZWYgaW4gY2FzZSB0aGVyZSBpcyBhbiBpbmxpbmUgY2xlZiBmaWVsZC4gV2UgbmVlZCB0byBrbm93IHdoYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gZm9yXG5cdFx0XHQvLyB0aGUgbm90ZSBpcy5cblx0XHRcdGlmICh0eXBlID09PSAnY2xlZicpIHtcblx0XHRcdFx0dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLndvcmtpbmdDbGVmID0gaGFzaFBhcmFtcztcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0d2ljZSwgc28gaWYgdGhlIGVsZW1lbnQgZXhpc3RzIG9uIHRoaXMgbGluZSB3aXRob3V0IGEgbm90ZSBvciBiYXIgYmVmb3JlIGl0LCBqdXN0IHJlcGxhY2UgdGhlIHN0YWZmIHZlcnNpb24uXG5cdFx0XHR2YXIgdm9pY2UgPSB0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2b2ljZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodm9pY2VbaV0uZWxfdHlwZSA9PT0gJ25vdGUnIHx8IHZvaWNlW2ldLmVsX3R5cGUgPT09ICdiYXInKSB7XG5cdFx0XHRcdFx0aGFzaFBhcmFtcy5lbF90eXBlID0gdHlwZTtcblx0XHRcdFx0XHRoYXNoUGFyYW1zLnN0YXJ0Q2hhciA9IHN0YXJ0Q2hhcjtcblx0XHRcdFx0XHRoYXNoUGFyYW1zLmVuZENoYXIgPSBlbmRDaGFyO1xuXHRcdFx0XHRcdGlmIChpbXBsaWVkTmF0dXJhbHMpXG5cdFx0XHRcdFx0XHRoYXNoUGFyYW1zLmFjY2lkZW50YWxzID0gaW1wbGllZE5hdHVyYWxzLmNvbmNhdChoYXNoUGFyYW1zLmFjY2lkZW50YWxzKTtcblx0XHRcdFx0XHR2b2ljZS5wdXNoKGhhc2hQYXJhbXMpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodm9pY2VbaV0uZWxfdHlwZSA9PT0gdHlwZSkge1xuXHRcdFx0XHRcdGhhc2hQYXJhbXMuZWxfdHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0aGFzaFBhcmFtcy5zdGFydENoYXIgPSBzdGFydENoYXI7XG5cdFx0XHRcdFx0aGFzaFBhcmFtcy5lbmRDaGFyID0gZW5kQ2hhcjtcblx0XHRcdFx0XHRpZiAoaW1wbGllZE5hdHVyYWxzKVxuXHRcdFx0XHRcdFx0aGFzaFBhcmFtcy5hY2NpZGVudGFscyA9IGltcGxpZWROYXR1cmFscy5jb25jYXQoaGFzaFBhcmFtcy5hY2NpZGVudGFscyk7XG5cdFx0XHRcdFx0dm9pY2VbaV0gPSBoYXNoUGFyYW1zO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gV2UgZGlkbid0IHNlZSBlaXRoZXIgdGhhdCB0eXBlIG9yIGEgbm90ZSwgc28gcmVwbGFjZSB0aGUgZWxlbWVudCB0byB0aGUgc3RhZmYuXG5cdFx0XHR0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV1bdHlwZV0gPSBoYXNoUGFyYW1zMjtcblx0XHR9XG5cdH07XG5cblx0dGhpcy5nZXROdW1MaW5lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aDtcblx0fTtcblxuXHR0aGlzLnB1c2hMaW5lID0gZnVuY3Rpb24oaGFzaCkge1xuXHRcdGlmICh0aGlzLnZza2lwUGVuZGluZykge1xuXHRcdFx0aGFzaC52c2tpcCA9IHRoaXMudnNraXBQZW5kaW5nO1xuXHRcdFx0ZGVsZXRlIHRoaXMudnNraXBQZW5kaW5nO1xuXHRcdH1cblx0XHR0aGlzLmxpbmVzLnB1c2goaGFzaCk7XG5cdH07XG5cblx0dGhpcy5hZGRTdWJ0aXRsZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHRoaXMucHVzaExpbmUoe3N1YnRpdGxlOiBzdHJ9KTtcblx0fTtcblxuXHR0aGlzLmFkZFNwYWNpbmcgPSBmdW5jdGlvbihudW0pIHtcblx0XHR0aGlzLnZza2lwUGVuZGluZyA9IG51bTtcblx0fTtcblxuXHR0aGlzLmFkZE5ld1BhZ2UgPSBmdW5jdGlvbihudW0pIHtcblx0XHR0aGlzLnB1c2hMaW5lKHtuZXdwYWdlOiBudW19KTtcblx0fTtcblxuXHR0aGlzLmFkZFNlcGFyYXRvciA9IGZ1bmN0aW9uKHNwYWNlQWJvdmUsIHNwYWNlQmVsb3csIGxpbmVMZW5ndGgpIHtcblx0XHR0aGlzLnB1c2hMaW5lKHtzZXBhcmF0b3I6IHtzcGFjZUFib3ZlOiBzcGFjZUFib3ZlLCBzcGFjZUJlbG93OiBzcGFjZUJlbG93LCBsaW5lTGVuZ3RoOiBsaW5lTGVuZ3RofX0pO1xuXHR9O1xuXG5cdHRoaXMuYWRkVGV4dCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHRoaXMucHVzaExpbmUoe3RleHQ6IHN0cn0pO1xuXHR9O1xuXG5cdHRoaXMuYWRkQ2VudGVyZWQgPSBmdW5jdGlvbihzdHIpIHtcblx0XHR0aGlzLnB1c2hMaW5lKHt0ZXh0OiBbe3RleHQ6IHN0ciwgY2VudGVyOiB0cnVlIH1dfSk7XG5cdH07XG5cblx0dGhpcy5jb250YWluc05vdGVzID0gZnVuY3Rpb24odm9pY2UpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm9pY2VbaV0uZWxfdHlwZSA9PT0gJ25vdGUnIHx8IHZvaWNlW2ldLmVsX3R5cGUgPT09ICdiYXInKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdHRoaXMuY29udGFpbnNOb3Rlc1N0cmljdCA9IGZ1bmN0aW9uKHZvaWNlKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2b2ljZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZvaWNlW2ldLmVsX3R5cGUgPT09ICdub3RlJyAmJiB2b2ljZVtpXS5yZXN0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cbi8vXHRhbnlWb2ljZUNvbnRhaW5zTm90ZXM6IGZ1bmN0aW9uKGxpbmUpIHtcbi8vXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5zdGFmZi52b2ljZXMubGVuZ3RoOyBpKyspIHtcbi8vXHRcdFx0aWYgKHRoaXMuY29udGFpbnNOb3RlcyhsaW5lLnN0YWZmLnZvaWNlc1tpXSkpXG4vL1x0XHRcdFx0cmV0dXJuIHRydWU7XG4vL1x0XHR9XG4vL1x0XHRyZXR1cm4gZmFsc2U7XG4vL1x0fSxcblx0dGhpcy5jaGFuZ2VWb2ljZVNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcblx0XHR2YXIgVGhpcyA9IHRoaXM7XG5cdFx0VGhpcy5hcHBlbmRFbGVtZW50KCdzY2FsZScsIG51bGwsIG51bGwsIHsgc2l6ZTogc2NhbGV9ICk7XG5cdH07XG5cblx0dGhpcy5zdGFydE5ld0xpbmUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHQvLyBJZiB0aGUgcG9pbnRlZCB0byBsaW5lIGRvZXNuJ3QgZXhpc3QsIGp1c3QgY3JlYXRlIHRoYXQuIElmIHRoZSBsaW5lIGRvZXMgZXhpc3QsIGJ1dCBkb2Vzbid0IGhhdmUgYW55IG11c2ljIG9uIGl0LCBqdXN0IHVzZSBpdC5cblx0XHQvLyBJZiBpdCBkb2VzIGV4aXN0IGFuZCBoYXMgbXVzaWMsIHRoZW4gaW5jcmVtZW50IHRoZSBsaW5lIG51bWJlci4gSWYgdGhlIG5ldyBlbGVtZW50IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdC5cblx0XHR2YXIgVGhpcyA9IHRoaXM7XG5cdFx0dGhpcy5jbG9zZUxpbmUoKTtcdC8vIENsb3NlIHRoZSBwcmV2aW91cyBsaW5lLlxuXHRcdHZhciBjcmVhdGVWb2ljZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0dmFyIHRoaXNTdGFmZiA9IFRoaXMubGluZXNbVGhpcy5saW5lTnVtXS5zdGFmZltUaGlzLnN0YWZmTnVtXTtcblx0XHRcdHRoaXNTdGFmZi52b2ljZXNbVGhpcy52b2ljZU51bV0gPSBbXTtcblx0XHRcdGlmICghdGhpc1N0YWZmLnRpdGxlKVxuXHRcdFx0XHR0aGlzU3RhZmYudGl0bGUgPSBbXTtcblx0XHRcdHRoaXNTdGFmZi50aXRsZVtUaGlzLnZvaWNlTnVtXSA9IHsgbmFtZTogcGFyYW1zLm5hbWUsIHN1Ym5hbWU6IHBhcmFtcy5zdWJuYW1lIH07XG5cdFx0XHRpZiAocGFyYW1zLnN0eWxlKVxuXHRcdFx0XHRUaGlzLmFwcGVuZEVsZW1lbnQoJ3N0eWxlJywgbnVsbCwgbnVsbCwge2hlYWQ6IHBhcmFtcy5zdHlsZX0pO1xuXHRcdFx0aWYgKHBhcmFtcy5zdGVtKVxuXHRcdFx0XHRUaGlzLmFwcGVuZEVsZW1lbnQoJ3N0ZW0nLCBudWxsLCBudWxsLCB7ZGlyZWN0aW9uOiBwYXJhbXMuc3RlbX0pO1xuXHRcdFx0ZWxzZSBpZiAoVGhpcy52b2ljZU51bSA+IDApIHtcblx0XHRcdFx0aWYgKHRoaXNTdGFmZi52b2ljZXNbMF0hPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzU3RhZmYudm9pY2VzWzBdLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpc1N0YWZmLnZvaWNlc1swXS5lbF90eXBlID09PSAnc3RlbScpXG5cdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHRcdFx0dmFyIHN0ZW0gPSB7IGVsX3R5cGU6ICdzdGVtJywgZGlyZWN0aW9uOiAndXAnIH07XG5cdFx0XHRcdFx0XHR0aGlzU3RhZmYudm9pY2VzWzBdLnNwbGljZSgwLDAsc3RlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFRoaXMuYXBwZW5kRWxlbWVudCgnc3RlbScsIG51bGwsIG51bGwsIHtkaXJlY3Rpb246ICdkb3duJ30pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhcmFtcy5zY2FsZSlcblx0XHRcdFx0VGhpcy5hcHBlbmRFbGVtZW50KCdzY2FsZScsIG51bGwsIG51bGwsIHsgc2l6ZTogcGFyYW1zLnNjYWxlfSApO1xuXHRcdH07XG5cdFx0dmFyIGNyZWF0ZVN0YWZmID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0XHRpZiAocGFyYW1zLmtleSAmJiBwYXJhbXMua2V5LmltcGxpZWROYXR1cmFscykge1xuXHRcdFx0XHRwYXJhbXMua2V5LmFjY2lkZW50YWxzID0gcGFyYW1zLmtleS5hY2NpZGVudGFscy5jb25jYXQocGFyYW1zLmtleS5pbXBsaWVkTmF0dXJhbHMpO1xuXHRcdFx0XHRkZWxldGUgcGFyYW1zLmtleS5pbXBsaWVkTmF0dXJhbHM7XG5cdFx0XHR9XG5cblx0XHRcdFRoaXMubGluZXNbVGhpcy5saW5lTnVtXS5zdGFmZltUaGlzLnN0YWZmTnVtXSA9IHt2b2ljZXM6IFsgXSwgY2xlZjogcGFyYW1zLmNsZWYsIGtleTogcGFyYW1zLmtleSwgd29ya2luZ0NsZWY6IHBhcmFtcy5jbGVmIH07XG5cdFx0XHRpZiAocGFyYW1zLnN0YWZmbGluZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRUaGlzLmxpbmVzW1RoaXMubGluZU51bV0uc3RhZmZbVGhpcy5zdGFmZk51bV0uY2xlZi5zdGFmZmxpbmVzID0gcGFyYW1zLnN0YWZmbGluZXM7XG5cdFx0XHRcdFRoaXMubGluZXNbVGhpcy5saW5lTnVtXS5zdGFmZltUaGlzLnN0YWZmTnVtXS53b3JraW5nQ2xlZi5zdGFmZmxpbmVzID0gcGFyYW1zLnN0YWZmbGluZXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGFyYW1zLnN0YWZmc2NhbGUpIHtcblx0XHRcdFx0VGhpcy5saW5lc1tUaGlzLmxpbmVOdW1dLnN0YWZmW1RoaXMuc3RhZmZOdW1dLnN0YWZmc2NhbGUgPSBwYXJhbXMuc3RhZmZzY2FsZTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXJhbXMudHJpcGxldGZvbnQpIFRoaXMubGluZXNbVGhpcy5saW5lTnVtXS5zdGFmZltUaGlzLnN0YWZmTnVtXS50cmlwbGV0Zm9udCA9IHBhcmFtcy50cmlwbGV0Zm9udDtcblx0XHRcdGlmIChwYXJhbXMudm9jYWxmb250KSBUaGlzLmxpbmVzW1RoaXMubGluZU51bV0uc3RhZmZbVGhpcy5zdGFmZk51bV0udm9jYWxmb250ID0gcGFyYW1zLnZvY2FsZm9udDtcblx0XHRcdGlmIChwYXJhbXMuYnJhY2tldCkgVGhpcy5saW5lc1tUaGlzLmxpbmVOdW1dLnN0YWZmW1RoaXMuc3RhZmZOdW1dLmJyYWNrZXQgPSBwYXJhbXMuYnJhY2tldDtcblx0XHRcdGlmIChwYXJhbXMuYnJhY2UpIFRoaXMubGluZXNbVGhpcy5saW5lTnVtXS5zdGFmZltUaGlzLnN0YWZmTnVtXS5icmFjZSA9IHBhcmFtcy5icmFjZTtcblx0XHRcdGlmIChwYXJhbXMuY29ubmVjdEJhckxpbmVzKSBUaGlzLmxpbmVzW1RoaXMubGluZU51bV0uc3RhZmZbVGhpcy5zdGFmZk51bV0uY29ubmVjdEJhckxpbmVzID0gcGFyYW1zLmNvbm5lY3RCYXJMaW5lcztcblx0XHRcdGlmIChwYXJhbXMuYmFyTnVtYmVyKSBUaGlzLmxpbmVzW1RoaXMubGluZU51bV0uc3RhZmZbVGhpcy5zdGFmZk51bV0uYmFyTnVtYmVyID0gcGFyYW1zLmJhck51bWJlcjtcblx0XHRcdGNyZWF0ZVZvaWNlKHBhcmFtcyk7XG5cdFx0XHQvLyBTb21lIHN0dWZmIGp1c3QgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHZvaWNlXG5cdFx0XHRpZiAocGFyYW1zLnBhcnQpXG5cdFx0XHRcdFRoaXMuYXBwZW5kRWxlbWVudCgncGFydCcsIHBhcmFtcy5wYXJ0LnN0YXJ0Q2hhciwgcGFyYW1zLnBhcnQuZW5kQ2hhciwge3RpdGxlOiBwYXJhbXMucGFydC50aXRsZX0pO1xuXHRcdFx0aWYgKHBhcmFtcy5tZXRlciAhPT0gdW5kZWZpbmVkKSBUaGlzLmxpbmVzW1RoaXMubGluZU51bV0uc3RhZmZbVGhpcy5zdGFmZk51bV0ubWV0ZXIgPSBwYXJhbXMubWV0ZXI7XG5cdFx0fTtcblx0XHR2YXIgY3JlYXRlTGluZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0VGhpcy5saW5lc1tUaGlzLmxpbmVOdW1dID0ge3N0YWZmOiBbXX07XG5cdFx0XHRjcmVhdGVTdGFmZihwYXJhbXMpO1xuXHRcdH07XG5cdFx0aWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXSA9PT0gdW5kZWZpbmVkKSBjcmVhdGVMaW5lKHBhcmFtcyk7XG5cdFx0ZWxzZSBpZiAodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubGluZU51bSsrO1xuXHRcdFx0dGhpcy5zdGFydE5ld0xpbmUocGFyYW1zKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXSA9PT0gdW5kZWZpbmVkKSBjcmVhdGVTdGFmZihwYXJhbXMpO1xuXHRcdGVsc2UgaWYgKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV0gPT09IHVuZGVmaW5lZCkgY3JlYXRlVm9pY2UocGFyYW1zKTtcblx0XHRlbHNlIGlmICghdGhpcy5jb250YWluc05vdGVzKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV0pKSByZXR1cm47XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmxpbmVOdW0rKztcblx0XHRcdHRoaXMuc3RhcnROZXdMaW5lKHBhcmFtcyk7XG5cdFx0fVxuXHR9O1xuXG5cdHRoaXMuc2V0QmFyTnVtYmVySW1tZWRpYXRlID0gZnVuY3Rpb24oYmFyTnVtYmVyKSB7XG5cdFx0Ly8gSWYgdGhpcyBpcyBjYWxsZWQgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmUsIHRoZW4gY29ycmVjdCB0aGUgbWVhc3VyZSBudW1iZXIgdGhhdCBpcyBhbHJlYWR5IHdyaXR0ZW4uXG5cdFx0Ly8gSWYgdGhpcyBpcyBjYWxsZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIG1lYXN1cmUsIHRoZW4gY29ycmVjdCB0aGUgbWVhc3VyZSBudW1iZXIgdGhhdCB3YXMganVzdCBjcmVhdGVkLlxuXHRcdC8vIElmIHRoaXMgaXMgY2FsbGVkIGluIHRoZSBtaWRkbGUgb2YgYSBtZWFzdXJlLCB0aGVuIHN1YnRyYWN0IG9uZSBmcm9tIGl0LCBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jcmVtZW50ZWQgYmVmb3JlIGFwcGxpZWQuXG5cdFx0dmFyIGN1cnJlbnRWb2ljZSA9IHRoaXMuZ2V0Q3VycmVudFZvaWNlKCk7XG5cdFx0aWYgKGN1cnJlbnRWb2ljZSAmJiBjdXJyZW50Vm9pY2UubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGxhc3RFbGVtZW50ID0gY3VycmVudFZvaWNlW2N1cnJlbnRWb2ljZS5sZW5ndGgtMV07XG5cdFx0XHRpZiAobGFzdEVsZW1lbnQuZWxfdHlwZSA9PT0gJ2JhcicpIHtcblx0XHRcdFx0aWYgKGxhc3RFbGVtZW50LmJhck51bWJlciAhPT0gdW5kZWZpbmVkKSAvLyB0aGUgbWVhc3VyZSBudW1iZXIgbWlnaHQgbm90IGJlIHdyaXR0ZW4gZm9yIHRoaXMgYmFyLCBkb24ndCBvdmVycmlkZSB0aGF0LlxuXHRcdFx0XHRcdGxhc3RFbGVtZW50LmJhck51bWJlciA9IGJhck51bWJlcjtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRyZXR1cm4gYmFyTnVtYmVyLTE7XG5cdFx0fVxuXHRcdHJldHVybiBiYXJOdW1iZXI7XG5cdH07XG5cblx0dGhpcy5oYXNCZWdpbk11c2ljID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gcmV0dXJuIHRydWUgaWYgdGhlcmUgZXhpc3RzIGF0IGxlYXN0IG9uZSBsaW5lIHRoYXQgY29udGFpbnMgXCJzdGFmZlwiXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5saW5lc1tpXS5zdGFmZilcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR0aGlzLmlzRmlyc3RMaW5lID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRmb3IgKHZhciBpID0gaW5kZXgtMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0dGhpcy5nZXRNZXRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuXHRcdFx0aWYgKGxpbmUuc3RhZmYpIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnN0YWZmLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIG1ldGVyID0gbGluZS5zdGFmZltqXS5tZXRlcjtcblx0XHRcdFx0XHRpZiAobWV0ZXIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBtZXRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHsgdHlwZTogXCJjb21tb25fdGltZVwiIH07XG5cdH07XG5cblx0dGhpcy5nZXRNZXRlckZyYWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1ldGVyID0gdGhpcy5nZXRNZXRlcigpO1xuXHRcdHZhciBudW0gPSA0O1xuXHRcdHZhciBkZW4gPSA0O1xuXHRcdGlmIChtZXRlcikge1xuXHRcdFx0aWYgKG1ldGVyLnR5cGUgPT09ICdzcGVjaWZpZWQnKSB7XG5cdFx0XHRcdG51bSA9IHBhcnNlSW50KG1ldGVyLnZhbHVlWzBdLm51bSwgMTApO1xuXHRcdFx0XHRkZW4gPSBwYXJzZUludChtZXRlci52YWx1ZVswXS5kZW4sMTApO1xuXHRcdFx0fSBlbHNlIGlmIChtZXRlci50eXBlID09PSAnY3V0X3RpbWUnKSB7XG5cdFx0XHRcdG51bSA9IDI7XG5cdFx0XHRcdGRlbiA9IDI7XG5cdFx0XHR9IGVsc2UgaWYgKG1ldGVyLnR5cGUgPT09ICdjb21tb25fdGltZScpIHtcblx0XHRcdFx0bnVtID0gNDtcblx0XHRcdFx0ZGVuID0gNDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5tZXRlciA9IHsgbnVtOiBudW0sIGRlbjogZGVuIH07XG5cdFx0cmV0dXJuIHRoaXMubWV0ZXI7IC8vIFRPRE8tUEVSOiBpcyB0aGlzIHNhdmVkIHZhbHVlIHVzZWQgYW55d2hlcmU/IEEgZ2V0IGZ1bmN0aW9uIHNob3VsZG4ndCBjaGFuZ2Ugc3RhdGUuXG5cdH07XG5cblx0dGhpcy5nZXRLZXlTaWduYXR1cmUgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcblx0XHRcdGlmIChsaW5lLnN0YWZmKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5zdGFmZi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmIChsaW5lLnN0YWZmW2pdLmtleSlcblx0XHRcdFx0XHRcdHJldHVybiBsaW5lLnN0YWZmW2pdLmtleTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geyAgfTtcblx0fTtcblxuXHR0aGlzLmdldEN1cnJlbnRWb2ljZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXTtcblx0XHRlbHNlIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdHRoaXMuc2V0Q3VycmVudFZvaWNlID0gZnVuY3Rpb24oc3RhZmZOdW0sIHZvaWNlTnVtKSB7XG5cdFx0dGhpcy5zdGFmZk51bSA9IHN0YWZmTnVtO1xuXHRcdHRoaXMudm9pY2VOdW0gPSB2b2ljZU51bTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmKSB7XG5cdFx0XHRcdGlmICh0aGlzLmxpbmVzW2ldLnN0YWZmW3N0YWZmTnVtXSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGluZXNbaV0uc3RhZmZbc3RhZmZOdW1dLnZvaWNlc1t2b2ljZU51bV0gPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdCF0aGlzLmNvbnRhaW5zTm90ZXModGhpcy5saW5lc1tpXS5zdGFmZltzdGFmZk51bV0udm9pY2VzW3ZvaWNlTnVtXSApKSB7XG5cdFx0XHRcdFx0dGhpcy5saW5lTnVtID0gIGk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMubGluZU51bSA9ICBpO1xuXHR9O1xuXG5cdHRoaXMuYWRkTWV0YVRleHQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMubWV0YVRleHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5tZXRhVGV4dFtrZXldID0gdmFsdWU7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5tZXRhVGV4dFtrZXldICs9IFwiXFxuXCIgKyB2YWx1ZTtcblx0fTtcblxuXHR0aGlzLmFkZE1ldGFUZXh0QXJyYXkgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMubWV0YVRleHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5tZXRhVGV4dFtrZXldID0gW3ZhbHVlXTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLm1ldGFUZXh0W2tleV0ucHVzaCh2YWx1ZSk7XG5cdH07XG5cdHRoaXMuYWRkTWV0YVRleHRPYmogPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5tZXRhVGV4dFtrZXldID0gdmFsdWU7XG5cdH07XG5cblx0ZnVuY3Rpb24gYWRkVmVydGljYWxJbmZvKHRpbWluZ0V2ZW50cykge1xuXHRcdC8vIEFkZCB2ZXJ0aWNhbCBpbmZvIHRvIHRoZSBiYXIgZXZlbnRzOiBwdXQgdGhlIG5leHQgZXZlbnQncyB0b3AsIGFuZCB0aGUgZXZlbnQgYWZ0ZXIgdGhlIG5leHQgbWVhc3VyZSdzIHRvcC5cblx0XHR2YXIgbGFzdEJhclRvcDtcblx0XHR2YXIgbGFzdEJhckJvdHRvbTtcblx0XHR2YXIgbGFzdEV2ZW50VG9wO1xuXHRcdHZhciBsYXN0RXZlbnRCb3R0b207XG5cdFx0Zm9yICh2YXIgZSA9IHRpbWluZ0V2ZW50cy5sZW5ndGggLSAxOyBlID49IDA7IGUtLSkge1xuXHRcdFx0dmFyIGV2ID0gdGltaW5nRXZlbnRzW2VdO1xuXHRcdFx0aWYgKGV2LnR5cGUgPT09ICdiYXInKSB7XG5cdFx0XHRcdGV2LnRvcCA9IGxhc3RFdmVudFRvcDtcblx0XHRcdFx0ZXYubmV4dFRvcCA9IGxhc3RCYXJUb3A7XG5cdFx0XHRcdGxhc3RCYXJUb3AgPSBsYXN0RXZlbnRUb3A7XG5cblx0XHRcdFx0ZXYuYm90dG9tID0gbGFzdEV2ZW50Qm90dG9tO1xuXHRcdFx0XHRldi5uZXh0Qm90dG9tID0gbGFzdEJhckJvdHRvbTtcblx0XHRcdFx0bGFzdEJhckJvdHRvbSA9IGxhc3RFdmVudEJvdHRvbTtcblx0XHRcdH0gZWxzZSBpZiAoZXYudHlwZSA9PT0gJ2V2ZW50Jykge1xuXHRcdFx0XHRsYXN0RXZlbnRUb3AgPSBldi50b3A7XG5cdFx0XHRcdGxhc3RFdmVudEJvdHRvbSA9IGV2LnRvcCArIGV2LmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlU29ydGVkQXJyYXkoaGFzaCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBrIGluIGhhc2gpIHtcblx0XHRcdGlmIChoYXNoLmhhc093blByb3BlcnR5KGspKVxuXHRcdFx0XHRhcnIucHVzaChoYXNoW2tdKTtcblx0XHR9XG5cdFx0YXJyID0gYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHZhciBkaWZmID0gYS5taWxsaXNlY29uZHMgLSBiLm1pbGxpc2Vjb25kcztcblx0XHRcdC8vIGlmIHRoZSBldmVudHMgaGF2ZSB0aGUgc2FtZSB0aW1lLCBtYWtlIHN1cmUgYSBiYXIgY29tZXMgYmVmb3JlIGEgbm90ZVxuXHRcdFx0aWYgKGRpZmYgIT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGRpZmY7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGEudHlwZSA9PT0gXCJiYXJcIiA/IC0xIDogMTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0dGhpcy5hZGRFbGVtZW50VG9FdmVudHMgPSBmdW5jdGlvbihldmVudEhhc2gsIGVsZW1lbnQsIHZvaWNlVGltZU1pbGxpc2Vjb25kcywgdG9wLCBoZWlnaHQsIGxpbmUsIG1lYXN1cmVOdW1iZXIsIHRpbWVEaXZpZGVyLCBpc1RpZWRTdGF0ZSwgbmV4dElzQmFyKSB7XG5cdFx0aWYgKGVsZW1lbnQuaGludClcblx0XHRcdHJldHVybiB7IGlzVGllZFN0YXRlOiB1bmRlZmluZWQsIGR1cmF0aW9uOiAwIH07XG5cdFx0dmFyIHJlYWxEdXJhdGlvbiA9IGVsZW1lbnQuZHVyYXRpb25DbGFzcyA/IGVsZW1lbnQuZHVyYXRpb25DbGFzcyA6IGVsZW1lbnQuZHVyYXRpb247XG5cdFx0aWYgKGVsZW1lbnQuYWJjZWxlbS5yZXN0ICYmIGVsZW1lbnQuYWJjZWxlbS5yZXN0LnR5cGUgPT09IFwic3BhY2VyXCIpXG5cdFx0XHRyZWFsRHVyYXRpb24gPSAwO1xuXHRcdGlmIChyZWFsRHVyYXRpb24gPiAwKSB7XG5cdFx0XHR2YXIgZXMgPSBbXTtcblx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGludmlzaWJsZSByZXN0LCB0aGVuIHRoZXJlIGFyZSBub3QgZWxlbWVudHMsIHNvIGRvbid0IHB1c2ggYSBudWxsIG9uZS5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5lbGVtc2V0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmVsZW1zZXRbaV0gIT09IG51bGwpXG5cdFx0XHRcdFx0ZXMucHVzaChlbGVtZW50LmVsZW1zZXRbaV0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGlzVGllZFRvTmV4dCA9IGVsZW1lbnQuc3RhcnRUaWU7XG5cdFx0XHRpZiAoaXNUaWVkU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgaXNUaWVkU3RhdGVdLmVsZW1lbnRzLnB1c2goZXMpOyAvLyBBZGQgdGhlIHRpZWQgbm90ZSB0byB0aGUgZmlyc3Qgbm90ZSB0aGF0IGl0IGlzIHRpZWQgdG9cblx0XHRcdFx0aWYgKG5leHRJc0Jhcikge1xuXHRcdFx0XHRcdGlmICghZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10pIHtcblx0XHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdID0ge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBcImV2ZW50XCIsXG5cdFx0XHRcdFx0XHRcdG1pbGxpc2Vjb25kczogdm9pY2VUaW1lTWlsbGlzZWNvbmRzLFxuXHRcdFx0XHRcdFx0XHRsaW5lOiBsaW5lLFxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlTnVtYmVyOiBtZWFzdXJlTnVtYmVyLFxuXHRcdFx0XHRcdFx0XHR0b3A6IHRvcCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IG51bGwsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50czogW10sXG5cdFx0XHRcdFx0XHRcdHN0YXJ0Q2hhcjogbnVsbCxcblx0XHRcdFx0XHRcdFx0ZW5kQ2hhcjogbnVsbCxcblx0XHRcdFx0XHRcdFx0c3RhcnRDaGFyQXJyYXk6IFtdLFxuXHRcdFx0XHRcdFx0XHRlbmRDaGFyQXJyYXk6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5tZWFzdXJlU3RhcnQgPSB0cnVlO1xuXHRcdFx0XHRcdG5leHRJc0JhciA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNUaWVkVG9OZXh0KVxuXHRcdFx0XHRcdGlzVGllZFN0YXRlID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdGhlIGxhc3Qgbm90ZSB3YXNuJ3QgdGllZC5cblx0XHRcdFx0aWYgKCFldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXSkge1xuXHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdID0ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJldmVudFwiLFxuXHRcdFx0XHRcdFx0bWlsbGlzZWNvbmRzOiB2b2ljZVRpbWVNaWxsaXNlY29uZHMsXG5cdFx0XHRcdFx0XHRsaW5lOiBsaW5lLFxuXHRcdFx0XHRcdFx0bWVhc3VyZU51bWJlcjogbWVhc3VyZU51bWJlcixcblx0XHRcdFx0XHRcdHRvcDogdG9wLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiBlbGVtZW50LngsXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxlbWVudC53LFxuXHRcdFx0XHRcdFx0ZWxlbWVudHM6IFtlc10sXG5cdFx0XHRcdFx0XHRzdGFydENoYXI6IGVsZW1lbnQuYWJjZWxlbS5zdGFydENoYXIsXG5cdFx0XHRcdFx0XHRlbmRDaGFyOiBlbGVtZW50LmFiY2VsZW0uZW5kQ2hhcixcblx0XHRcdFx0XHRcdHN0YXJ0Q2hhckFycmF5OiBbZWxlbWVudC5hYmNlbGVtLnN0YXJ0Q2hhcl0sXG5cdFx0XHRcdFx0XHRlbmRDaGFyQXJyYXk6IFtlbGVtZW50LmFiY2VsZW0uZW5kQ2hhcl0sXG5cdFx0XHRcdFx0XHRtaWRpUGl0Y2hlczogZWxlbWVudC5hYmNlbGVtLm1pZGlQaXRjaGVzID8gcGFyc2VDb21tb24uY2xvbmVBcnJheShlbGVtZW50LmFiY2VsZW0ubWlkaVBpdGNoZXMpIDogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChlbGVtZW50LmFiY2VsZW0ubWlkaUdyYWNlTm90ZVBpdGNoZXMpXG5cdFx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5taWRpR3JhY2VOb3RlUGl0Y2hlcyA9IHBhcnNlQ29tbW9uLmNsb25lQXJyYXkoZWxlbWVudC5hYmNlbGVtLm1pZGlHcmFjZU5vdGVQaXRjaGVzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHZvaWNlIHRoZW4gdHdvIG5vdGVzIGNhbiBmYWxsIGF0IHRoZSBzYW1lIHRpbWUuIFVzdWFsbHkgdGhleSB3b3VsZCBiZSBsaW5lZCB1cCBpbiB0aGUgc2FtZSBwbGFjZSwgYnV0IGlmIGl0IGlzIGEgd2hvbGUgcmVzdCwgdGhlbiBpdCBpcyBwbGFjZWQgZnVubnkuIEluIGFueSBjYXNlLCB0aGUgbGVmdCBtb3N0IGVsZW1lbnQgd2lucy5cblx0XHRcdFx0XHRpZiAoZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10ubGVmdClcblx0XHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdLmxlZnQgPSBNYXRoLm1pbihldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5sZWZ0LCBlbGVtZW50LngpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdLmxlZnQgPSBlbGVtZW50Lng7XG5cdFx0XHRcdFx0ZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10uZWxlbWVudHMucHVzaChlcyk7XG5cdFx0XHRcdFx0ZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10uc3RhcnRDaGFyQXJyYXkucHVzaChlbGVtZW50LmFiY2VsZW0uc3RhcnRDaGFyKTtcblx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5lbmRDaGFyQXJyYXkucHVzaChlbGVtZW50LmFiY2VsZW0uZW5kQ2hhcik7XG5cdFx0XHRcdFx0aWYgKGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdLnN0YXJ0Q2hhciA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdLnN0YXJ0Q2hhciA9ZWxlbWVudC5hYmNlbGVtLnN0YXJ0Q2hhcjtcblx0XHRcdFx0XHRpZiAoZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10uZW5kQ2hhciA9PT0gbnVsbClcblx0XHRcdFx0XHRcdGV2ZW50SGFzaFtcImV2ZW50XCIgKyB2b2ljZVRpbWVNaWxsaXNlY29uZHNdLmVuZENoYXIgPWVsZW1lbnQuYWJjZWxlbS5lbmRDaGFyO1xuXHRcdFx0XHRcdGlmIChlbGVtZW50LmFiY2VsZW0ubWlkaVBpdGNoZXMgJiYgZWxlbWVudC5hYmNlbGVtLm1pZGlQaXRjaGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5taWRpUGl0Y2hlcylcblx0XHRcdFx0XHRcdFx0ZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10ubWlkaVBpdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5hYmNlbGVtLm1pZGlQaXRjaGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5taWRpUGl0Y2hlcy5wdXNoKGVsZW1lbnQuYWJjZWxlbS5taWRpUGl0Y2hlc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChlbGVtZW50LmFiY2VsZW0ubWlkaUdyYWNlTm90ZVBpdGNoZXMgJiYgZWxlbWVudC5hYmNlbGVtLm1pZGlHcmFjZU5vdGVQaXRjaGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5taWRpR3JhY2VOb3RlUGl0Y2hlcylcblx0XHRcdFx0XHRcdFx0ZXZlbnRIYXNoW1wiZXZlbnRcIiArIHZvaWNlVGltZU1pbGxpc2Vjb25kc10ubWlkaUdyYWNlTm90ZVBpdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZWxlbWVudC5hYmNlbGVtLm1pZGlHcmFjZU5vdGVQaXRjaGVzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5taWRpR3JhY2VOb3RlUGl0Y2hlcy5wdXNoKGVsZW1lbnQuYWJjZWxlbS5taWRpR3JhY2VOb3RlUGl0Y2hlc1tqXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZXh0SXNCYXIpIHtcblx0XHRcdFx0XHRldmVudEhhc2hbXCJldmVudFwiICsgdm9pY2VUaW1lTWlsbGlzZWNvbmRzXS5tZWFzdXJlU3RhcnQgPSB0cnVlO1xuXHRcdFx0XHRcdG5leHRJc0JhciA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1RpZWRUb05leHQpXG5cdFx0XHRcdFx0aXNUaWVkU3RhdGUgPSB2b2ljZVRpbWVNaWxsaXNlY29uZHM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7IGlzVGllZFN0YXRlOiBpc1RpZWRTdGF0ZSwgZHVyYXRpb246IHJlYWxEdXJhdGlvbiAvIHRpbWVEaXZpZGVyLCBuZXh0SXNCYXI6IG5leHRJc0JhciB8fCBlbGVtZW50LnR5cGUgPT09ICdiYXInIH07XG5cdH07XG5cblx0dGhpcy5tYWtlVm9pY2VzQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBGaXJzdCBtYWtlIGEgbmV3IGFycmF5IHRoYXQgaXMgYXJyYW5nZWQgYnkgdm9pY2Ugc28gdGhhdCB0aGUgcmVwZWF0cyB0aGF0IHNwYW4gZGlmZmVyZW50IGxpbmVzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cblx0XHR2YXIgdm9pY2VzQXJyID0gW107XG5cdFx0Zm9yICh2YXIgbGluZSA9IDA7IGxpbmUgPCB0aGlzLmVuZ3JhdmVyLnN0YWZmZ3JvdXBzLmxlbmd0aDsgbGluZSsrKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLmVuZ3JhdmVyLnN0YWZmZ3JvdXBzW2xpbmVdO1xuXHRcdFx0dmFyIGZpcnN0U3RhZmYgPSBncm91cC5zdGFmZnNbMF07XG5cdFx0XHR2YXIgbWlkZGxlQyA9IGZpcnN0U3RhZmYuYWJzb2x1dGVZO1xuXHRcdFx0dmFyIHRvcCA9IG1pZGRsZUMgLSBmaXJzdFN0YWZmLnRvcCAqIHNwYWNpbmcuU1RFUDtcblx0XHRcdHZhciBsYXN0U3RhZmYgPSBncm91cC5zdGFmZnNbZ3JvdXAuc3RhZmZzLmxlbmd0aCAtIDFdO1xuXHRcdFx0bWlkZGxlQyA9IGxhc3RTdGFmZi5hYnNvbHV0ZVk7XG5cdFx0XHR2YXIgYm90dG9tID0gbWlkZGxlQyAtIGxhc3RTdGFmZi5ib3R0b20gKiBzcGFjaW5nLlNURVA7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG5cdFx0XHR2YXIgdm9pY2VzID0gZ3JvdXAudm9pY2VzO1xuXHRcdFx0Zm9yICh2YXIgdiA9IDA7IHYgPCB2b2ljZXMubGVuZ3RoOyB2KyspIHtcblx0XHRcdFx0dmFyIG1lYXN1cmVOdW1iZXIgPSAwO1xuXHRcdFx0XHR2YXIgbm90ZUZvdW5kID0gZmFsc2U7XG5cdFx0XHRcdGlmICghdm9pY2VzQXJyW3ZdKVxuXHRcdFx0XHRcdHZvaWNlc0Fyclt2XSA9IFtdO1xuXHRcdFx0XHR2YXIgZWxlbWVudHMgPSB2b2ljZXNbdl0uY2hpbGRyZW47XG5cdFx0XHRcdGZvciAodmFyIGVsZW0gPSAwOyBlbGVtIDwgZWxlbWVudHMubGVuZ3RoOyBlbGVtKyspIHtcblx0XHRcdFx0XHR2b2ljZXNBcnJbdl0ucHVzaCh7dG9wOiB0b3AsIGhlaWdodDogaGVpZ2h0LCBsaW5lOiBsaW5lLCBtZWFzdXJlTnVtYmVyOiBtZWFzdXJlTnVtYmVyLCBlbGVtOiBlbGVtZW50c1tlbGVtXX0pO1xuXHRcdFx0XHRcdGlmIChlbGVtZW50c1tlbGVtXS50eXBlID09PSAnYmFyJyAmJiBub3RlRm91bmQpIC8vIENvdW50IHRoZSBtZWFzdXJlcyBieSBjb3VudGluZyB0aGUgYmFyIGxpbmVzLCBidXQgc2tpcCBhIGJhciBsaW5lIHRoYXQgYXBwZWFycyBhdCB0aGUgbGVmdCBvZiB0aGUgbXVzaWMsIGJlZm9yZSBhbnkgbm90ZXMuXG5cdFx0XHRcdFx0XHRtZWFzdXJlTnVtYmVyKys7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRzW2VsZW1dLnR5cGUgPT09ICdub3RlJyB8fCBlbGVtZW50c1tlbGVtXS50eXBlID09PSAncmVzdCcpXG5cdFx0XHRcdFx0XHRub3RlRm91bmQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2b2ljZXNBcnI7XG5cdH07XG5cblx0dGhpcy5zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uKHN0YXJ0aW5nRGVsYXksIHRpbWVEaXZpZGVyLCBicG0pIHtcblx0XHR2YXIgdGltaW5nRXZlbnRzID0gW107XG5cblx0XHR2YXIgZXZlbnRIYXNoID0ge307XG5cdFx0Ly8gVGhlIHRpbWUgaXMgdGhlIG51bWJlciBvZiBzZWNvbmRzIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgcGllY2UuXG5cdFx0Ly8gVGhlIHVuaXRzIHdlIGFyZSBzY2FubmluZyBhcmUgaW4gbm90YXRpb24gdW5pdHMgKGkuZS4gMC4yNSBpcyBhIHF1YXJ0ZXIgbm90ZSlcblx0XHR2YXIgdGltZSA9IHN0YXJ0aW5nRGVsYXk7XG5cdFx0dmFyIGlzVGllZFN0YXRlO1xuXHRcdHZhciBuZXh0SXNCYXIgPSB0cnVlO1xuXHRcdHZhciB2b2ljZXMgPSB0aGlzLm1ha2VWb2ljZXNBcnJheSgpO1xuXHRcdGZvciAodmFyIHYgPSAwOyB2IDwgdm9pY2VzLmxlbmd0aDsgdisrKSB7XG5cdFx0XHR2YXIgdm9pY2VUaW1lID0gdGltZTtcblx0XHRcdHZhciB2b2ljZVRpbWVNaWxsaXNlY29uZHMgPSBNYXRoLnJvdW5kKHZvaWNlVGltZSAqIDEwMDApO1xuXHRcdFx0dmFyIHN0YXJ0aW5nUmVwZWF0RWxlbSA9IDA7XG5cdFx0XHR2YXIgZW5kaW5nUmVwZWF0RWxlbSA9IC0xO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gdm9pY2VzW3ZdO1xuXHRcdFx0Zm9yICh2YXIgZWxlbSA9IDA7IGVsZW0gPCBlbGVtZW50cy5sZW5ndGg7IGVsZW0rKykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2VsZW1dLmVsZW07XG5cdFx0XHRcdGlmIChlbGVtZW50LmFiY2VsZW0uZWxfdHlwZSA9PT0gXCJ0ZW1wb1wiKSB7XG5cdFx0XHRcdFx0dmFyIGJwbSA9IHRoaXMuZ2V0QnBtKGVsZW1lbnQuYWJjZWxlbSk7XG5cdFx0XHRcdFx0dmFyIGJlYXRMZW5ndGggPSB0aGlzLmdldEJlYXRMZW5ndGgoKTtcblx0XHRcdFx0XHR2YXIgYmVhdHNQZXJTZWNvbmQgPSBicG0gLyA2MDtcblx0XHRcdFx0XHR0aW1lRGl2aWRlciA9IGJlYXRMZW5ndGggKiBiZWF0c1BlclNlY29uZDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmV0ID0gdGhpcy5hZGRFbGVtZW50VG9FdmVudHMoZXZlbnRIYXNoLCBlbGVtZW50LCB2b2ljZVRpbWVNaWxsaXNlY29uZHMsIGVsZW1lbnRzW2VsZW1dLnRvcCwgZWxlbWVudHNbZWxlbV0uaGVpZ2h0LCBlbGVtZW50c1tlbGVtXS5saW5lLCBlbGVtZW50c1tlbGVtXS5tZWFzdXJlTnVtYmVyLCB0aW1lRGl2aWRlciwgaXNUaWVkU3RhdGUsIG5leHRJc0Jhcik7XG5cdFx0XHRcdGlzVGllZFN0YXRlID0gcmV0LmlzVGllZFN0YXRlO1xuXHRcdFx0XHRuZXh0SXNCYXIgPSByZXQubmV4dElzQmFyO1xuXHRcdFx0XHR2b2ljZVRpbWUgKz0gcmV0LmR1cmF0aW9uO1xuXHRcdFx0XHR2b2ljZVRpbWVNaWxsaXNlY29uZHMgPSBNYXRoLnJvdW5kKHZvaWNlVGltZSAqIDEwMDApO1xuXHRcdFx0XHRpZiAoZWxlbWVudC50eXBlID09PSAnYmFyJykge1xuXHRcdFx0XHRcdHZhciBiYXJUeXBlID0gZWxlbWVudC5hYmNlbGVtLnR5cGU7XG5cdFx0XHRcdFx0dmFyIGVuZFJlcGVhdCA9IChiYXJUeXBlID09PSBcImJhcl9yaWdodF9yZXBlYXRcIiB8fCBiYXJUeXBlID09PSBcImJhcl9kYmxfcmVwZWF0XCIpO1xuXHRcdFx0XHRcdHZhciBzdGFydEVuZGluZyA9IChlbGVtZW50LmFiY2VsZW0uc3RhcnRFbmRpbmcgPT09ICcxJyk7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0UmVwZWF0ID0gKGJhclR5cGUgPT09IFwiYmFyX2xlZnRfcmVwZWF0XCIgfHwgYmFyVHlwZSA9PT0gXCJiYXJfZGJsX3JlcGVhdFwiIHx8IGJhclR5cGUgPT09IFwiYmFyX3JpZ2h0X3JlcGVhdFwiKTtcblx0XHRcdFx0XHRpZiAoZW5kUmVwZWF0KSB7XG5cdFx0XHRcdFx0XHRpZiAoZW5kaW5nUmVwZWF0RWxlbSA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGVuZGluZ1JlcGVhdEVsZW0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgZWwyID0gc3RhcnRpbmdSZXBlYXRFbGVtOyBlbDIgPCBlbmRpbmdSZXBlYXRFbGVtOyBlbDIrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbWVudDIgPSBlbGVtZW50c1tlbDJdLmVsZW07XG5cdFx0XHRcdFx0XHRcdHJldCA9IHRoaXMuYWRkRWxlbWVudFRvRXZlbnRzKGV2ZW50SGFzaCwgZWxlbWVudDIsIHZvaWNlVGltZU1pbGxpc2Vjb25kcywgZWxlbWVudHNbZWwyXS50b3AsIGVsZW1lbnRzW2VsMl0uaGVpZ2h0LCBlbGVtZW50c1tlbDJdLmxpbmUsIGVsZW1lbnRzW2VsMl0ubWVhc3VyZU51bWJlciwgdGltZURpdmlkZXIsIGlzVGllZFN0YXRlLCBuZXh0SXNCYXIpO1xuXHRcdFx0XHRcdFx0XHRpc1RpZWRTdGF0ZSA9IHJldC5pc1RpZWRTdGF0ZTtcblx0XHRcdFx0XHRcdFx0bmV4dElzQmFyID0gcmV0Lm5leHRJc0Jhcjtcblx0XHRcdFx0XHRcdFx0dm9pY2VUaW1lICs9IHJldC5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0dm9pY2VUaW1lTWlsbGlzZWNvbmRzID0gTWF0aC5yb3VuZCh2b2ljZVRpbWUgKiAxMDAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5leHRJc0JhciA9IHRydWU7XG5cdFx0XHRcdFx0XHRlbmRpbmdSZXBlYXRFbGVtID0gLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzdGFydEVuZGluZylcblx0XHRcdFx0XHRcdGVuZGluZ1JlcGVhdEVsZW0gPSBlbGVtO1xuXHRcdFx0XHRcdGlmIChzdGFydFJlcGVhdClcblx0XHRcdFx0XHRcdHN0YXJ0aW5nUmVwZWF0RWxlbSA9IGVsZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gbm93IHdlIGhhdmUgYWxsIHRoZSBldmVudHMsIGJ1dCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdm9pY2VzIHRoZW4gdGhlcmUgbWF5IGJlIGV2ZW50cyBvdXQgb2Ygb3JkZXIgb3IgZHVwbGljYXRlZCwgc28gbm9ybWFsaXplIGl0LlxuXHRcdHRpbWluZ0V2ZW50cyA9IG1ha2VTb3J0ZWRBcnJheShldmVudEhhc2gpO1xuXHRcdGFkZFZlcnRpY2FsSW5mbyh0aW1pbmdFdmVudHMpO1xuXHRcdHRpbWluZ0V2ZW50cy5wdXNoKHsgdHlwZTogXCJlbmRcIiwgbWlsbGlzZWNvbmRzOiB2b2ljZVRpbWVNaWxsaXNlY29uZHMgfSk7XG5cdFx0dGhpcy5hZGRVc2VmdWxDYWxsYmFja0luZm8odGltaW5nRXZlbnRzLCBicG0pO1xuXHRcdHJldHVybiB0aW1pbmdFdmVudHM7XG5cdH07XG5cblx0dGhpcy5hZGRVc2VmdWxDYWxsYmFja0luZm8gPSBmdW5jdGlvbih0aW1pbmdFdmVudHMsIGJwbSkge1xuXHRcdHZhciBtaWxsaXNlY29uZHNQZXJNZWFzdXJlID0gdGhpcy5taWxsaXNlY29uZHNQZXJNZWFzdXJlKGJwbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aW1pbmdFdmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldiA9IHRpbWluZ0V2ZW50c1tpXTtcblx0XHRcdGV2Lm1pbGxpc2Vjb25kc1Blck1lYXN1cmUgPSBtaWxsaXNlY29uZHNQZXJNZWFzdXJlO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBnZXRWZXJ0aWNhbChncm91cCkge1xuXHRcdHZhciB2b2ljZXMgPSBncm91cC52b2ljZXM7XG5cdFx0dmFyIGZpcnN0U3RhZmYgPSBncm91cC5zdGFmZnNbMF07XG5cdFx0dmFyIG1pZGRsZUMgPSBmaXJzdFN0YWZmLmFic29sdXRlWTtcblx0XHR2YXIgdG9wID0gbWlkZGxlQyAtIGZpcnN0U3RhZmYudG9wKnNwYWNpbmcuU1RFUDtcblx0XHR2YXIgbGFzdFN0YWZmID0gZ3JvdXAuc3RhZmZzW2dyb3VwLnN0YWZmcy5sZW5ndGgtMV07XG5cdFx0bWlkZGxlQyA9IGxhc3RTdGFmZi5hYnNvbHV0ZVk7XG5cdFx0dmFyIGJvdHRvbSA9IG1pZGRsZUMgLSBsYXN0U3RhZmYuYm90dG9tKnNwYWNpbmcuU1RFUDtcblx0XHR2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXHRcdHJldHVybiB7IHRvcDogdG9wLCBoZWlnaHQ6IGhlaWdodCB9O1xuXHR9XG5cblx0dGhpcy5nZXRCcG0gPSBmdW5jdGlvbih0ZW1wbykge1xuXHRcdHZhciBicG07XG5cdFx0aWYgKHRlbXBvKSB7XG5cdFx0XHRicG0gPSB0ZW1wby5icG07XG5cdFx0XHR2YXIgYmVhdExlbmd0aCA9IHRoaXMuZ2V0QmVhdExlbmd0aCgpO1xuXHRcdFx0dmFyIHN0YXRlZEJlYXRMZW5ndGggPSB0ZW1wby5kdXJhdGlvbiAmJiB0ZW1wby5kdXJhdGlvbi5sZW5ndGggPiAwID8gdGVtcG8uZHVyYXRpb25bMF0gOiBiZWF0TGVuZ3RoO1xuXHRcdFx0YnBtID0gYnBtICogc3RhdGVkQmVhdExlbmd0aCAvIGJlYXRMZW5ndGg7XG5cdFx0fVxuXHRcdGlmICghYnBtKSB7XG5cdFx0XHRicG0gPSAxODA7XG5cdFx0XHQvLyBDb21wZW5zYXRlIGZvciBjb21wb3VuZCBtZXRlciwgd2hlcmUgdGhlIGJlYXQgaXNuJ3QgYSBiZWF0LlxuXHRcdFx0dmFyIG1ldGVyID0gdGhpcy5nZXRNZXRlckZyYWN0aW9uKCk7XG5cdFx0XHRpZiAobWV0ZXIgJiYgbWV0ZXIuZGVuID09PSA4KSB7XG5cdFx0XHRcdGJwbSA9IDEyMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJwbTtcblx0fTtcblxuXHR0aGlzLnNldFRpbWluZyA9IGZ1bmN0aW9uIChicG0sIG1lYXN1cmVzT2ZEZWxheSkge1xuXHRcdGlmICghYnBtKSB7XG5cdFx0XHR2YXIgdGVtcG8gPSB0aGlzLm1ldGFUZXh0ID8gdGhpcy5tZXRhVGV4dC50ZW1wbyA6IG51bGw7XG5cdFx0XHRicG0gPSB0aGlzLmdldEJwbSh0ZW1wbyk7XG5cdFx0fVxuXG5cdFx0dmFyIGJlYXRMZW5ndGggPSB0aGlzLmdldEJlYXRMZW5ndGgoKTtcblx0XHR2YXIgYmVhdHNQZXJTZWNvbmQgPSBicG0gLyA2MDtcblxuXHRcdHZhciBtZWFzdXJlTGVuZ3RoID0gdGhpcy5nZXRCYXJMZW5ndGgoKTtcblxuXHRcdHZhciBzdGFydGluZ0RlbGF5ID0gbWVhc3VyZUxlbmd0aCAvIGJlYXRMZW5ndGggKiBtZWFzdXJlc09mRGVsYXkgLyBiZWF0c1BlclNlY29uZDtcblx0XHRpZiAoc3RhcnRpbmdEZWxheSlcblx0XHRcdHN0YXJ0aW5nRGVsYXkgLT0gdGhpcy5nZXRQaWNrdXBMZW5ndGgoKSAvIGJlYXRMZW5ndGggLyBiZWF0c1BlclNlY29uZDtcblx0XHR2YXIgdGltZURpdmlkZXIgPSBiZWF0TGVuZ3RoICogYmVhdHNQZXJTZWNvbmQ7XG5cblx0XHR0aGlzLm5vdGVUaW1pbmdzID0gdGhpcy5zZXR1cEV2ZW50cyhzdGFydGluZ0RlbGF5LCB0aW1lRGl2aWRlciwgYnBtKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHVuZTtcbiIsIi8vIGFiY19lZGl0b3IuanNcbi8vIHdpbmRvdy5BQkNKUy5FZGl0b3IgaXMgdGhlIGludGVyZmFjZSBjbGFzcyBmb3IgdGhlIGFyZWEgdGhhdCBjb250YWlucyB0aGUgQUJDIHRleHQuIEl0IGlzIHJlc3BvbnNpYmxlIGZvclxuLy8gaG9sZGluZyB0aGUgdGV4dCBvZiB0aGUgdHVuZSBhbmQgY2FsbGluZyB0aGUgcGFyc2VyIGFuZCB0aGUgcmVuZGVyaW5nIGVuZ2luZXMuXG4vL1xuLy8gRWRpdEFyZWEgaXMgYW4gZXhhbXBsZSBvZiB1c2luZyBhIHRleHRhcmVhIGFzIHRoZSBjb250cm9sIHRoYXQgaXMgc2hvd24gdG8gdGhlIHVzZXIuIEFzIGxvbmcgYXNcbi8vIHRoZSBzYW1lIGludGVyZmFjZSBpcyB1c2VkLCB3aW5kb3cuQUJDSlMuRWRpdG9yIGNhbiB1c2UgYSBkaWZmZXJlbnQgdHlwZSBvZiBvYmplY3QuXG4vL1xuLy8gRWRpdEFyZWE6XG4vLyAtIGNvbnN0cnVjdG9yKHRleHRhcmVhaWQpXG4vL1x0XHRUaGlzIGNvbnRhaW5zIHRoZSBpZCBvZiBhIHRleHRhcmVhIGNvbnRyb2wgdGhhdCB3aWxsIGJlIHVzZWQuXG4vLyAtIGFkZFNlbGVjdGlvbkxpc3RlbmVyKGxpc3RlbmVyKVxuLy9cdFx0QSBjYWxsYmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBlbnRyeSBwb2ludCBmaXJlU2VsZWN0aW9uQ2hhbmdlZCgpXG4vLyAtIGFkZENoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKVxuLy9cdFx0QSBjYWxsYmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBlbnRyeSBwb2ludCBmaXJlQ2hhbmdlZCgpXG4vLyAtIGdldFNlbGVjdGlvbigpXG4vL1x0XHRyZXR1cm5zIHRoZSBvYmplY3QgeyBzdGFydDogLCBlbmQ6IH0gd2l0aCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gY2hhcmFjdGVyc1xuLy8gLSBzZXRTZWxlY3Rpb24oc3RhcnQsIGVuZClcbi8vXHRcdHN0YXJ0IGFuZCBlbmQgYXJlIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb25zIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkLlxuLy8gLSBnZXRTdHJpbmcoKVxuLy9cdFx0cmV0dXJucyB0aGUgQUJDIHRleHQgdGhhdCBpcyBjdXJyZW50bHkgZGlzcGxheWVkLlxuLy8gLSBzZXRTdHJpbmcoc3RyKVxuLy9cdFx0c2V0cyB0aGUgQUJDIHRleHQgdGhhdCBpcyBjdXJyZW50bHkgZGlzcGxheWVkLCBhbmQgcmVzZXRzIHRoZSBpbml0aWFsVGV4dCB2YXJpYWJsZVxuLy8gLSBnZXRFbGVtKClcbi8vXHRcdHJldHVybnMgdGhlIHRleHRhcmVhIGVsZW1lbnRcbi8vIC0gc3RyaW5nIGluaXRpYWxUZXh0XG4vL1x0XHRDb250YWlucyB0aGUgc3RhcnRpbmcgdGV4dC4gVGhpcyBjYW4gYmUgY29tcGFyZWQgYWdhaW5zdCB0aGUgY3VycmVudCB0ZXh0IHRvIHNlZSBpZiBhbnl0aGluZyBjaGFuZ2VkLlxuLy9cblxuLypnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgY2xlYXJUaW1lb3V0LCBzZXRUaW1lb3V0ICovXG5cbnZhciBUdW5lQm9vayA9IHJlcXVpcmUoJy4uL2FwaS9hYmNfdHVuZWJvb2snKS5UdW5lQm9vaztcbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2FiY19jb21tb24nKTtcbnZhciBQYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlL2FiY19wYXJzZScpO1xudmFyIFRleHRQcmludGVyID0gcmVxdWlyZSgnLi4vdHJhbnNmb3JtL2FiYzJhYmNfd3JpdGUnKTtcbnZhciBFbmdyYXZlckNvbnRyb2xsZXIgPSByZXF1aXJlKCcuLi93cml0ZS9hYmNfZW5ncmF2ZXJfY29udHJvbGxlcicpO1xudmFyIFN5bnRoQ29udHJvbGxlciA9IHJlcXVpcmUoJy4uL3N5bnRoL3N5bnRoLWNvbnRyb2xsZXInKTtcbnZhciBzdXBwb3J0c0F1ZGlvID0gcmVxdWlyZSgnLi4vc3ludGgvc3VwcG9ydHMtYXVkaW8nKTtcblxuLy8gUG9seWZpbGwgZm9yIEN1c3RvbUV2ZW50IGZvciBvbGQgSUUgdmVyc2lvbnNcbmlmICggdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiICkge1xuXHR2YXIgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcblx0XHR2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdFx0ZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcblx0XHRyZXR1cm4gZXZ0O1xuXHR9O1xuXHRDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuXHR3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbn1cblxudmFyIEVkaXRBcmVhID0gZnVuY3Rpb24odGV4dGFyZWFpZCkge1xuICB0aGlzLnRleHRhcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGV4dGFyZWFpZCk7XG4gIHRoaXMuaW5pdGlhbFRleHQgPSB0aGlzLnRleHRhcmVhLnZhbHVlO1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbn1cblxuRWRpdEFyZWEucHJvdG90eXBlLmFkZFNlbGVjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgdGhpcy50ZXh0YXJlYS5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdCAgaWYgKHRoaXMuaXNEcmFnZ2luZylcblx0ICAgIGxpc3RlbmVyLmZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gIH07XG59O1xuXG5FZGl0QXJlYS5wcm90b3R5cGUuYWRkQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICB0aGlzLmNoYW5nZWxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMudGV4dGFyZWEub25rZXl1cCA9IGZ1bmN0aW9uKCkge1xuICAgIGxpc3RlbmVyLmZpcmVDaGFuZ2VkKCk7XG4gIH07XG4gIHRoaXMudGV4dGFyZWEub25tb3VzZWRvd24gPSBmdW5jdGlvbigpIHtcblx0dGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICBsaXN0ZW5lci5maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICB9O1xuICB0aGlzLnRleHRhcmVhLm9ubW91c2V1cCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICBsaXN0ZW5lci5maXJlQ2hhbmdlZCgpO1xuICB9O1xuICB0aGlzLnRleHRhcmVhLm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgbGlzdGVuZXIuZmlyZUNoYW5nZWQoKTtcbiAgfTtcbn07XG5cbi8vVE9ETyB3b24ndCB3b3JrIHVuZGVyIElFP1xuRWRpdEFyZWEucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge3N0YXJ0OiB0aGlzLnRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LCBlbmQ6IHRoaXMudGV4dGFyZWEuc2VsZWN0aW9uRW5kfTtcbn07XG5cbkVkaXRBcmVhLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdGlmKHRoaXMudGV4dGFyZWEuc2V0U2VsZWN0aW9uUmFuZ2UpXG5cdCAgIHRoaXMudGV4dGFyZWEuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XG5cdGVsc2UgaWYodGhpcy50ZXh0YXJlYS5jcmVhdGVUZXh0UmFuZ2UpIHtcblx0XHQvLyBGb3IgSUU4XG5cdCAgIHZhciBlID0gdGhpcy50ZXh0YXJlYS5jcmVhdGVUZXh0UmFuZ2UoKTtcblx0ICAgZS5jb2xsYXBzZSh0cnVlKTtcblx0ICAgZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuXHQgICBlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuXHQgICBlLnNlbGVjdCgpO1xuXHR9XG4gIHRoaXMudGV4dGFyZWEuZm9jdXMoKTtcbn07XG5cbkVkaXRBcmVhLnByb3RvdHlwZS5nZXRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGV4dGFyZWEudmFsdWU7XG59O1xuXG5FZGl0QXJlYS5wcm90b3R5cGUuc2V0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHRoaXMudGV4dGFyZWEudmFsdWUgPSBzdHI7XG4gIHRoaXMuaW5pdGlhbFRleHQgPSB0aGlzLmdldFN0cmluZygpO1xuICBpZiAodGhpcy5jaGFuZ2VsaXN0ZW5lcikge1xuICAgIHRoaXMuY2hhbmdlbGlzdGVuZXIuZmlyZUNoYW5nZWQoKTtcbiAgfVxufTtcblxuRWRpdEFyZWEucHJvdG90eXBlLmdldEVsZW0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudGV4dGFyZWE7XG59O1xuXG4vL1xuLy8gd2luZG93LkFCQ0pTLkVkaXRvcjpcbi8vXG4vLyBjb25zdHJ1Y3RvcihlZGl0YXJlYSwgcGFyYW1zKVxuLy9cdFx0aWYgZWRpdGFyZWEgaXMgYSBzdHJpbmcsIHRoZW4gaXQgaXMgYW4gSFRNTCBpZCBvZiBhIHRleHRhcmVhIGNvbnRyb2wuXG4vL1x0XHRPdGhlcndpc2UsIGl0IHNob3VsZCBiZSBhbiBpbnN0YW50aWF0aW9uIG9mIGFuIG9iamVjdCB0aGF0IGV4cHJlc3NlcyB0aGUgRWRpdEFyZWEgaW50ZXJmYWNlLlxuLy9cbi8vXHRcdHBhcmFtcyBpcyBhIGhhc2ggb2Y6XG4vL1x0XHRjYW52YXNfaWQ6IG9yIHBhcGVyX2lkOiBIVE1MIGlkIHRvIGRyYXcgaW4uIElmIG5vdCBwcmVzZW50LCB0aGVuIHRoZSBkcmF3aW5nIGhhcHBlbnMganVzdCBiZWxvdyB0aGUgZWRpdG9yLlxuLy9cdFx0Z2VuZXJhdGVfbWlkaTogaWYgcHJlc2VudCwgdGhlbiBtaWRpIGlzIGdlbmVyYXRlZC5cbi8vXHRcdG1pZGlfaWQ6IGlmIHByZXNlbnQsIHRoZSBIVE1MIGlkIHRvIHBsYWNlIHRoZSBtaWRpIGNvbnRyb2wuIE90aGVyd2lzZSBpdCBpcyBwbGFjZWQgaW4gdGhlIHNhbWUgZGl2IGFzIHRoZSBwYXBlci5cbi8vXHRcdG1pZGlfZG93bmxvYWRfaWQ6IGlmIHByZXNlbnQsIHRoZSBIVE1MIGlkIHRvIHBsYWNlIHRoZSBtaWRpIGRvd25sb2FkIGxpbmsuIE90aGVyd2lzZSBpdCBpcyBwbGFjZWQgaW4gdGhlIHNhbWUgZGl2IGFzIHRoZSBwYXBlci5cbi8vXHRcdGdlbmVyYXRlX3dhcm5pbmdzOiBpZiBwcmVzZW50LCB0aGVuIHBhcnNlciB3YXJuaW5ncyBhcmUgZGlzcGxheWVkIG9uIHRoZSBwYWdlLlxuLy9cdFx0d2FybmluZ3NfaWQ6IGlmIHByZXNlbnQsIHRoZSBIVE1MIGlkIHRvIHBsYWNlIHRoZSB3YXJuaW5ncy4gT3RoZXJ3aXNlIHRoZXkgYXJlIHBsYWNlZCBpbiB0aGUgc2FtZSBkaXYgYXMgdGhlIHBhcGVyLlxuLy9cdFx0b25jaGFuZ2U6IGlmIHByZXNlbnQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW5ldmVyIHRoZXJlIGhhcyBiZWVuIGEgY2hhbmdlLlxuLy9cdFx0Z3VpOiBpZiBwcmVzZW50LCB0aGUgcGFwZXIgY2FuIHNlbmQgY2hhbmdlcyBiYWNrIHRvIHRoZSBlZGl0b3IgKHByZXN1bWFibHkgYmVjYXVzZSB0aGUgdXNlciBjaGFuZ2VkIHNvbWV0aGluZyBkaXJlY3RseS4pXG4vL1x0XHRwYXJzZXJfb3B0aW9uczogb3B0aW9ucyB0byBzZW5kIHRvIHRoZSBwYXJzZXIgZW5naW5lLlxuLy9cdFx0bWlkaV9vcHRpb25zOiBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIG1pZGkgZW5naW5lLlxuLy9cdFx0cmVuZGVyX29wdGlvbnM6IG9wdGlvbnMgdG8gc2VuZCB0byB0aGUgcmVuZGVyIGVuZ2luZS5cbi8vXHRcdGluZGljYXRlX2NoYW5nZWQ6IHRoZSBkaXJ0eSBmbGFnIGlzIHNldCBpZiB0aGlzIGlzIHRydWUuXG4vL1xuLy8gLSBzZXRSZWFkT25seShib29sKVxuLy9cdFx0YWRkcyBvciByZW1vdmVzIHRoZSBjbGFzcyBhYmNfdGV4dGFyZWFfcmVhZG9ubHksIGFuZCBhZGRzIG9yIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZSByZWFkb25seT15ZXNcbi8vIC0gc2V0RGlydHlTdHlsZShib29sKVxuLy9cdFx0YWRkcyBvciByZW1vdmVzIHRoZSBjbGFzcyBhYmNfdGV4dGFyZWFfZGlydHlcbi8vIC0gcmVuZGVyVHVuZShhYmMsIHBhcnNlcnBhcmFtcywgZGl2KVxuLy9cdFx0SW1tZWRpYXRlbHkgcmVuZGVycyB0aGUgdHVuZS4gKFVzZWZ1bCBmb3IgY3JlYXRpbmcgdGhlIFNWRyBvdXRwdXQgYmVoaW5kIHRoZSBzY2VuZXMsIGlmIGRpdiBpcyBoaWRkZW4pXG4vL1x0XHRzdHJpbmcgYWJjOiB0aGUgQUJDIHRleHRcbi8vXHRcdHBhcnNlcnBhcmFtczogcGFyYW1zIHRvIHNlbmQgdG8gdGhlIHBhcnNlclxuLy9cdFx0ZGl2OiB0aGUgSFRNTCBpZCB0byByZW5kZXIgdG8uXG4vLyAtIG1vZGVsQ2hhbmdlZCgpXG4vL1x0XHRDYWxsZWQgd2hlbiB0aGUgbW9kZWwgaGFzIGJlZW4gY2hhbmdlZCB0byB0cmlnZ2VyIHJlLXJlbmRlcmluZ1xuLy8gLSBwYXJzZUFCQygpXG4vL1x0XHRDYWxsZWQgaW50ZXJuYWxseSBieSBmaXJlQ2hhbmdlZCgpXG4vL1x0XHRyZXR1cm5zIHRydWUgaWYgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2Ugc2luY2UgbGFzdCBjYWxsLlxuLy8gLSB1cGRhdGVTZWxlY3Rpb24oKVxuLy9cdFx0Q2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHNlbGVjdGlvbi4gVGhpcyBjYWxscyB0aGUgZW5ncmF2ZXJfY29udHJvbGxlciB0byBzaG93IHRoZSBzZWxlY3Rpb24uXG4vLyAtIGZpcmVTZWxlY3Rpb25DaGFuZ2VkKClcbi8vXHRcdENhbGxlZCBieSB0aGUgdGV4dGFyZWEgb2JqZWN0IHdoZW4gdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHNlbGVjdGlvbi5cbi8vIC0gcGFyYW1DaGFuZ2VkKGVuZ3JhdmVycGFyYW1zKVxuLy9cdFx0Q2FsbGVkIHRvIHNpZ25hbCB0aGF0IHRoZSBlbmdyYXZlciBwYXJhbXMgaGF2ZSBjaGFuZ2VkLCBzbyByZS1yZW5kZXJpbmcgc2hvdWxkIG9jY3VyLlxuLy8gLSBmaXJlQ2hhbmdlZCgpXG4vL1x0XHRDYWxsZWQgYnkgdGhlIHRleHRhcmVhIG9iamVjdCB3aGVuIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHNvbWV0aGluZy5cbi8vIC0gc2V0Tm90RGlydHkoKVxuLy9cdFx0Q2FsbGVkIGJ5IHRoZSBjbGllbnQgYXBwIHRvIHJlc2V0IHRoZSBkaXJ0eSBmbGFnXG4vLyAtIGlzRGlydHkoKVxuLy9cdFx0UmV0dXJucyB0cnVlIG9yIGZhbHNlLCB3aGV0aGVyIHRoZSB0ZXh0YXJlYSBjb250YWlucyB0aGUgc2FtZSB0ZXh0IHRoYXQgaXQgc3RhcnRlZCB3aXRoLlxuLy8gLSBoaWdobGlnaHQoYWJjZWxlbSlcbi8vXHRcdENhbGxlZCBieSB0aGUgZW5ncmF2ZXJfY29udHJvbGxlciB0byBoaWdobGlnaHQgYW4gYXJlYS5cbi8vIC0gcGF1c2UoYm9vbClcbi8vXHRcdFN0b3BzIHRoZSBhdXRvbWF0aWMgcmVuZGVyaW5nIHdoZW4gdGhlIHVzZXIgaXMgdHlwaW5nLlxuLy9cblxudmFyIEVkaXRvciA9IGZ1bmN0aW9uKGVkaXRhcmVhLCBwYXJhbXMpIHtcblx0Ly8gQ29weSBhbGwgdGhlIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoXG5cdHRoaXMuYWJjanNQYXJhbXMgPSB7fTtcblx0dmFyIGtleTtcblx0aWYgKHBhcmFtcy5hYmNqc1BhcmFtcykge1xuXHRcdGZvciAoa2V5IGluIHBhcmFtcy5hYmNqc1BhcmFtcykge1xuXHRcdFx0aWYgKHBhcmFtcy5hYmNqc1BhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdHRoaXMuYWJjanNQYXJhbXNba2V5XSA9IHBhcmFtcy5hYmNqc1BhcmFtc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAocGFyYW1zLm1pZGlfb3B0aW9ucykge1xuXHRcdGZvciAoa2V5IGluIHBhcmFtcy5taWRpX29wdGlvbnMpIHtcblx0XHRcdGlmIChwYXJhbXMubWlkaV9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0dGhpcy5hYmNqc1BhcmFtc1trZXldID0gcGFyYW1zLm1pZGlfb3B0aW9uc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAocGFyYW1zLnBhcnNlcl9vcHRpb25zKSB7XG5cdFx0Zm9yIChrZXkgaW4gcGFyYW1zLnBhcnNlcl9vcHRpb25zKSB7XG5cdFx0XHRpZiAocGFyYW1zLnBhcnNlcl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0dGhpcy5hYmNqc1BhcmFtc1trZXldID0gcGFyYW1zLnBhcnNlcl9vcHRpb25zW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmIChwYXJhbXMucmVuZGVyX29wdGlvbnMpIHtcblx0XHRmb3IgKGtleSBpbiBwYXJhbXMucmVuZGVyX29wdGlvbnMpIHtcblx0XHRcdGlmIChwYXJhbXMucmVuZGVyX29wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHR0aGlzLmFiY2pzUGFyYW1zW2tleV0gPSBwYXJhbXMucmVuZGVyX29wdGlvbnNba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAocGFyYW1zLmluZGljYXRlX2NoYW5nZWQpXG5cdFx0dGhpcy5pbmRpY2F0ZV9jaGFuZ2VkID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBlZGl0YXJlYSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuZWRpdGFyZWEgPSBuZXcgRWRpdEFyZWEoZWRpdGFyZWEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWRpdGFyZWEgPSBlZGl0YXJlYTtcbiAgfVxuICB0aGlzLmVkaXRhcmVhLmFkZFNlbGVjdGlvbkxpc3RlbmVyKHRoaXMpO1xuICB0aGlzLmVkaXRhcmVhLmFkZENoYW5nZUxpc3RlbmVyKHRoaXMpO1xuXG4gIGlmIChwYXJhbXMuY2FudmFzX2lkKSB7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJhbXMuY2FudmFzX2lkKTtcbiAgfSBlbHNlIGlmIChwYXJhbXMucGFwZXJfaWQpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtcy5wYXBlcl9pZCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgIHRoaXMuZWRpdGFyZWEuZ2V0RWxlbSgpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZGl2LCB0aGlzLmVkaXRhcmVhLmdldEVsZW0oKSk7XG4gIH1cblxuICBpZiAocGFyYW1zLnNlbGVjdGlvbkNoYW5nZUNhbGxiYWNrKSB7XG4gIFx0dGhpcy5zZWxlY3Rpb25DaGFuZ2VDYWxsYmFjayA9IHBhcmFtcy5zZWxlY3Rpb25DaGFuZ2VDYWxsYmFjaztcbiAgfVxuXG4gIGlmIChwYXJhbXMuc3ludGgpIHtcbiAgXHRpZiAoc3VwcG9ydHNBdWRpbygpKSB7XG5cdCAgICB0aGlzLnN5bnRoID0ge1xuXHRcdCAgICBlbDogcGFyYW1zLnN5bnRoLmVsLFxuXHRcdCAgICBjdXJzb3JDb250cm9sOiBwYXJhbXMuc3ludGguY3Vyc29yQ29udHJvbCxcblx0XHQgICAgb3B0aW9uczogcGFyYW1zLnN5bnRoLm9wdGlvbnNcblx0ICAgIH1cbiAgICB9XG4gIH1cblx0Ly8gSWYgdGhlIHVzZXIgd2FudHMgbWlkaSwgdGhlbiBzdG9yZSB0aGUgZWxlbWVudHMgdGhhdCBpdCB3aWxsIGJlIHdyaXR0ZW4gdG8uIFRoZSBlbGVtZW50IGNvdWxkIGVpdGhlciBiZSBwYXNzZWQgaW4gYXMgYW4gaWQsXG5cdC8vIGFuIGVsZW1lbnQsIG9yIG5vdGhpbmcuIElmIG5vdGhpbmcgaXMgcGFzc2VkIGluLCB0aGVuIGp1c3QgcHV0IHRoZSBtaWRpIG9uIHRvcCBvZiB0aGUgZ2VuZXJhdGVkIG11c2ljLlxuXHRpZiAocGFyYW1zLmdlbmVyYXRlX21pZGkpIHtcblx0ICBcdHRoaXMuZ2VuZXJhdGVfbWlkaSA9IHBhcmFtcy5nZW5lcmF0ZV9taWRpO1xuXHRcdGlmICh0aGlzLmFiY2pzUGFyYW1zLmdlbmVyYXRlRG93bmxvYWQpIHtcblx0XHRcdGlmICh0eXBlb2YgcGFyYW1zLm1pZGlfZG93bmxvYWRfaWQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHR0aGlzLmRvd25sb2FkTWlkaSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmFtcy5taWRpX2Rvd25sb2FkX2lkKTtcblx0XHRcdGVsc2UgaWYgKHBhcmFtcy5taWRpX2Rvd25sb2FkX2lkKSAvLyBhc3N1bWUsIGlmIHRoZSB2YXIgaXMgbm90IGEgc3RyaW5nIGl0IGlzIGFuIGVsZW1lbnQuIElmIG5vdCwgaXQgd2lsbCBjcmFzaCBzb29uIGVub3VnaC5cblx0XHRcdFx0dGhpcy5kb3dubG9hZE1pZGkgPSBwYXJhbXMubWlkaV9kb3dubG9hZF9pZDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYWJjanNQYXJhbXMuZ2VuZXJhdGVJbmxpbmUgIT09IGZhbHNlKSB7IC8vIFRoZSBkZWZhdWx0IGZvciB0aGlzIGlzIHRydWUsIHNvIHVuZGVmaW5lZCBpcyBhbHNvIHRydWUuXG5cdFx0XHRpZiAodHlwZW9mIHBhcmFtcy5taWRpX2lkID09PSAnc3RyaW5nJylcblx0XHRcdFx0dGhpcy5pbmxpbmVNaWRpID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyYW1zLm1pZGlfaWQpO1xuXHRcdFx0ZWxzZSBpZiAocGFyYW1zLm1pZGlfaWQpIC8vIGFzc3VtZSwgaWYgdGhlIHZhciBpcyBub3QgYSBzdHJpbmcgaXQgaXMgYW4gZWxlbWVudC4gSWYgbm90LCBpdCB3aWxsIGNyYXNoIHNvb24gZW5vdWdoLlxuXHRcdFx0XHR0aGlzLmlubGluZU1pZGkgPSBwYXJhbXMubWlkaV9pZDtcblx0XHR9XG5cdH1cblxuICBpZiAocGFyYW1zLmdlbmVyYXRlX3dhcm5pbmdzIHx8IHBhcmFtcy53YXJuaW5nc19pZCkge1xuICAgIGlmIChwYXJhbXMud2FybmluZ3NfaWQpIHtcbiAgICAgIHRoaXMud2FybmluZ3NkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJhbXMud2FybmluZ3NfaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm5pbmdzZGl2ID0gdGhpcy5kaXY7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbmNoYW5nZUNhbGxiYWNrID0gcGFyYW1zLm9uY2hhbmdlO1xuXG4gIGlmIChwYXJhbXMuZ3VpKSB7XG4gICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlZGl0YXJlYSk7XG4gICAgdGhpcy5hYmNqc1BhcmFtcy5lZGl0YWJsZSA9IHRydWU7XG4gIH1cbiAgdGhpcy5vbGR0ID0gXCJcIjtcbiAgdGhpcy5iUmVlbnRyeSA9IGZhbHNlO1xuICB0aGlzLnBhcnNlQUJDKCk7XG4gIHRoaXMubW9kZWxDaGFuZ2VkKCk7XG5cbiAgdGhpcy5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgaGFzQ2xhc3NOYW1lID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgcmV0dXJuIChlbGVtZW50Q2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgKGVsZW1lbnRDbGFzc05hbWUgPT09IGNsYXNzTmFtZSB8fFxuICAgICAgICBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKS50ZXN0KGVsZW1lbnRDbGFzc05hbWUpKSk7XG4gICAgfTtcblxuICAgIGlmICghaGFzQ2xhc3NOYW1lKGVsZW1lbnQsIGNsYXNzTmFtZSkpXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWU7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IHBhcnNlQ29tbW9uLnN0cmlwKGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoXG4gICAgICBuZXcgUmVnRXhwKFwiKF58XFxcXHMrKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHMrfCQpXCIpLCAnICcpKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB0aGlzLnNldFJlYWRPbmx5ID0gZnVuY3Rpb24ocmVhZE9ubHkpIHtcblx0ICB2YXIgcmVhZG9ubHlDbGFzcyA9ICdhYmNfdGV4dGFyZWFfcmVhZG9ubHknO1xuXHQgIHZhciBlbCA9IHRoaXMuZWRpdGFyZWEuZ2V0RWxlbSgpO1xuICAgIGlmIChyZWFkT25seSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICd5ZXMnKTtcblx0ICB0aGlzLmFkZENsYXNzTmFtZShlbCwgcmVhZG9ubHlDbGFzcyk7XG5cdH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG5cdCAgdGhpcy5yZW1vdmVDbGFzc05hbWUoZWwsIHJlYWRvbmx5Q2xhc3MpO1xuICAgIH1cbiAgfTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUucmVuZGVyVHVuZSA9IGZ1bmN0aW9uKGFiYywgcGFyYW1zLCBkaXYpIHtcbiAgdmFyIHR1bmVib29rID0gbmV3IFR1bmVCb29rKGFiYyk7XG4gIHZhciBhYmNQYXJzZXIgPSBQYXJzZSgpO1xuICBhYmNQYXJzZXIucGFyc2UodHVuZWJvb2sudHVuZXNbMF0uYWJjLCBwYXJhbXMsIHR1bmVib29rLnR1bmVzWzBdLnN0YXJ0UG9zIC0gdHVuZWJvb2suaGVhZGVyLmxlbmd0aCk7IC8vVE9ETyBoYW5kbGUgbXVsdGlwbGUgdHVuZXNcbiAgdmFyIHR1bmUgPSBhYmNQYXJzZXIuZ2V0VHVuZSgpO1xuICB2YXIgZW5ncmF2ZXJfY29udHJvbGxlciA9IG5ldyBFbmdyYXZlckNvbnRyb2xsZXIoZGl2LCB0aGlzLmFiY2pzUGFyYW1zKTtcbiAgZW5ncmF2ZXJfY29udHJvbGxlci5lbmdyYXZlQUJDKHR1bmUpO1xufTtcblxuRWRpdG9yLnByb3RvdHlwZS5yZWRyYXdNaWRpID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmdlbmVyYXRlX21pZGkgJiYgIXRoaXMubWlkaVBhdXNlKSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcImdlbmVyYXRlTWlkaVwiLCB7XG5cdFx0XHRkZXRhaWw6IHtcblx0XHRcdFx0dHVuZXM6IHRoaXMudHVuZXMsXG5cdFx0XHRcdGFiY2pzUGFyYW1zOiB0aGlzLmFiY2pzUGFyYW1zLFxuXHRcdFx0XHRkb3dubG9hZE1pZGlFbDogdGhpcy5kb3dubG9hZE1pZGksXG5cdFx0XHRcdGlubGluZU1pZGlFbDogdGhpcy5pbmxpbmVNaWRpLFxuXHRcdFx0XHRlbmdyYXZpbmdFbDogdGhpcy5kaXZcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH1cblx0aWYgKHRoaXMuc3ludGgpIHtcblx0XHRpZiAoIXRoaXMuc3ludGguc3ludGhDb250cm9sKSB7XG5cdFx0XHR0aGlzLnN5bnRoLnN5bnRoQ29udHJvbCA9IG5ldyBTeW50aENvbnRyb2xsZXIoKTtcblx0XHRcdHRoaXMuc3ludGguc3ludGhDb250cm9sLmxvYWQodGhpcy5zeW50aC5lbCwgdGhpcy5zeW50aC5jdXJzb3JDb250cm9sLCB0aGlzLnN5bnRoLm9wdGlvbnMpO1xuXHRcdH1cblx0XHR0aGlzLnN5bnRoLnN5bnRoQ29udHJvbC5zZXRUdW5lKHRoaXMudHVuZXNbMF0sIGZhbHNlKTtcblx0fVxufTtcblxuRWRpdG9yLnByb3RvdHlwZS5tb2RlbENoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudHVuZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmRvd25sb2FkTWlkaSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuZG93bmxvYWRNaWRpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgaWYgKHRoaXMuaW5saW5lTWlkaSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuaW5saW5lTWlkaS5pbm5lckhUTUwgPSBcIlwiO1xuICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmJSZWVudHJ5KVxuICAgIHJldHVybjsgLy8gVE9ETyBpcyB0aGlzIGxpa2VseT8gbWF5YmUsIGlmIHdlIHJld3JpdGUgYWJjIGltbWVkaWF0ZWx5IHcvIGFiYzJhYmNcbiAgdGhpcy5iUmVlbnRyeSA9IHRydWU7XG4gIHRoaXMudGltZXJJZCA9IG51bGw7XG4gIHRoaXMuZGl2LmlubmVySFRNTCA9IFwiXCI7XG4gIHRoaXMuZW5ncmF2ZXJfY29udHJvbGxlciA9IG5ldyBFbmdyYXZlckNvbnRyb2xsZXIodGhpcy5kaXYsIHRoaXMuYWJjanNQYXJhbXMpO1xuICB0aGlzLmVuZ3JhdmVyX2NvbnRyb2xsZXIuZW5ncmF2ZUFCQyh0aGlzLnR1bmVzKTtcblx0dGhpcy50dW5lc1swXS5lbmdyYXZlciA9IHRoaXMuZW5ncmF2ZXJfY29udHJvbGxlcjtcdC8vIFRPRE8tUEVSOiBXZSBhY3R1YWxseSB3YW50IGFuIG91dHB1dCBvYmplY3QgZm9yIGVhY2ggdHVuZSwgbm90IHRoZSBlbnRpcmUgY29udHJvbGxlci4gV2hlbiByZWZhY3RvcmluZywgZG9uJ3Qgc2F2ZSBkYXRhIGluIHRoZSBjb250cm9sbGVyLlxuXHR0aGlzLnJlZHJhd01pZGkoKTtcblxuICBpZiAodGhpcy53YXJuaW5nc2Rpdikge1xuICAgIHRoaXMud2FybmluZ3NkaXYuaW5uZXJIVE1MID0gKHRoaXMud2FybmluZ3MpID8gdGhpcy53YXJuaW5ncy5qb2luKFwiPGJyIC8+XCIpIDogXCJObyBlcnJvcnNcIjtcbiAgfVxuICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICB2YXIgdGV4dHByaW50ZXIgPSBuZXcgVGV4dFByaW50ZXIodGhpcy50YXJnZXQsIHRydWUpO1xuICAgIHRleHRwcmludGVyLnByaW50QUJDKHRoaXMudHVuZXNbMF0pOyAvL1RPRE8gaGFuZGxlIG11bHRpcGxlIHR1bmVzXG4gIH1cbiAgdGhpcy5lbmdyYXZlcl9jb250cm9sbGVyLmFkZFNlbGVjdExpc3RlbmVyKHRoaXMuaGlnaGxpZ2h0LmJpbmQodGhpcykpO1xuICB0aGlzLnVwZGF0ZVNlbGVjdGlvbigpO1xuICB0aGlzLmJSZWVudHJ5ID0gZmFsc2U7XG59O1xuXG4vLyBDYWxsIHRoaXMgdG8gcmVwYXJzZSBpbiByZXNwb25zZSB0byB0aGUgcHJpbnRpbmcgcGFyYW1ldGVycyBjaGFuZ2luZ1xuRWRpdG9yLnByb3RvdHlwZS5wYXJhbUNoYW5nZWQgPSBmdW5jdGlvbihlbmdyYXZlclBhcmFtcykge1xuXHRpZiAoZW5ncmF2ZXJQYXJhbXMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gZW5ncmF2ZXJQYXJhbXMpIHtcblx0XHRcdGlmIChlbmdyYXZlclBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdHRoaXMuYWJjanNQYXJhbXNba2V5XSA9IGVuZ3JhdmVyUGFyYW1zW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRoaXMub2xkdCA9IFwiXCI7XG5cdHRoaXMuZmlyZUNoYW5nZWQoKTtcbn07XG5cbi8vIHJldHVybiB0cnVlIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZFxuRWRpdG9yLnByb3RvdHlwZS5wYXJzZUFCQyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuZWRpdGFyZWEuZ2V0U3RyaW5nKCk7XG4gIGlmICh0PT09dGhpcy5vbGR0KSB7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLm9sZHQgPSB0O1xuICBpZiAodCA9PT0gXCJcIikge1xuXHR0aGlzLnR1bmVzID0gdW5kZWZpbmVkO1xuXHR0aGlzLndhcm5pbmdzID0gXCJcIjtcblx0cmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHR1bmVib29rID0gbmV3IFR1bmVCb29rKHQpO1xuXG4gIHRoaXMudHVuZXMgPSBbXTtcbiAgdGhpcy5zdGFydFBvcyA9IFtdO1xuICB0aGlzLndhcm5pbmdzID0gW107XG4gIGZvciAodmFyIGk9MDsgaTx0dW5lYm9vay50dW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhYmNQYXJzZXIgPSBuZXcgUGFyc2UoKTtcbiAgICBhYmNQYXJzZXIucGFyc2UodHVuZWJvb2sudHVuZXNbaV0uYWJjLCB0aGlzLmFiY2pzUGFyYW1zLCB0dW5lYm9vay50dW5lc1tpXS5zdGFydFBvcyAtIHR1bmVib29rLmhlYWRlci5sZW5ndGgpO1xuICAgIHRoaXMudHVuZXNbaV0gPSBhYmNQYXJzZXIuZ2V0VHVuZSgpO1xuXHQgIHRoaXMuc3RhcnRQb3NbaV0gPSB0dW5lYm9vay50dW5lc1tpXS5zdGFydFBvcztcbiAgICB2YXIgd2FybmluZ3MgPSBhYmNQYXJzZXIuZ2V0V2FybmluZ3MoKSB8fCBbXTtcbiAgICBmb3IgKHZhciBqPTA7IGo8d2FybmluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRoaXMud2FybmluZ3MucHVzaCh3YXJuaW5nc1tqXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuRWRpdG9yLnByb3RvdHlwZS51cGRhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZWRpdGFyZWEuZ2V0U2VsZWN0aW9uKCk7XG4gIHRyeSB7XG4gICAgdGhpcy5lbmdyYXZlcl9jb250cm9sbGVyLnJhbmdlSGlnaGxpZ2h0KHNlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLmVuZCk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIG1heWJlIHByaW50ZXIgaXNuJ3QgZGVmaW5lZCB5ZXQ/XG5cdGlmICh0aGlzLnNlbGVjdGlvbkNoYW5nZUNhbGxiYWNrKVxuXHRcdHRoaXMuc2VsZWN0aW9uQ2hhbmdlQ2FsbGJhY2soc2VsZWN0aW9uLnN0YXJ0LCBzZWxlY3Rpb24uZW5kKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuZmlyZVNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuc2V0RGlydHlTdHlsZSA9IGZ1bmN0aW9uKGlzRGlydHkpIHtcblx0aWYgKHRoaXMuaW5kaWNhdGVfY2hhbmdlZCA9PT0gdW5kZWZpbmVkKVxuXHRcdHJldHVybjtcbiAgdmFyIGFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIHZhciBoYXNDbGFzc05hbWUgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50Q2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XG4gICAgICByZXR1cm4gKGVsZW1lbnRDbGFzc05hbWUubGVuZ3RoID4gMCAmJiAoZWxlbWVudENsYXNzTmFtZSA9PT0gY2xhc3NOYW1lIHx8XG4gICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpLnRlc3QoZWxlbWVudENsYXNzTmFtZSkpKTtcbiAgICB9O1xuXG4gICAgaWYgKCFoYXNDbGFzc05hbWUoZWxlbWVudCwgY2xhc3NOYW1lKSlcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgcmVtb3ZlQ2xhc3NOYW1lID0gZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBwYXJzZUNvbW1vbi5zdHJpcChlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFxuICAgICAgbmV3IFJlZ0V4cChcIihefFxcXFxzKylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzK3wkKVwiKSwgJyAnKSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG5cblx0dmFyIHJlYWRvbmx5Q2xhc3MgPSAnYWJjX3RleHRhcmVhX2RpcnR5Jztcblx0dmFyIGVsID0gdGhpcy5lZGl0YXJlYS5nZXRFbGVtKCk7XG5cdGlmIChpc0RpcnR5KSB7XG5cdFx0YWRkQ2xhc3NOYW1lKGVsLCByZWFkb25seUNsYXNzKTtcblx0fSBlbHNlIHtcblx0XHRyZW1vdmVDbGFzc05hbWUoZWwsIHJlYWRvbmx5Q2xhc3MpO1xuICAgIH1cbn07XG5cbi8vIGNhbGwgd2hlbiBhYmMgdGV4dCBpcyBjaGFuZ2VkIGFuZCBuZWVkcyByZS1wYXJzaW5nXG5FZGl0b3IucHJvdG90eXBlLmZpcmVDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmJJc1BhdXNlZClcbiAgICByZXR1cm47XG4gIGlmICh0aGlzLnBhcnNlQUJDKCkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMudGltZXJJZClcdC8vIElmIHRoZSB1c2VyIGlzIHN0aWxsIHR5cGluZywgY2FuY2VsIHRoZSB1cGRhdGVcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5tb2RlbENoYW5nZWQoKTtcbiAgICB9LCAzMDApO1x0Ly8gSXMgdGhpcyBhIGdvb2QgY29tcHJvbWlzZSBiZXR3ZWVuIHJlc3BvbnNpdmVuZXNzIGFuZCBub3QgcmVkcmF3aW5nIHRvbyBtdWNoP1xuXHQgIHZhciBpc0RpcnR5ID0gdGhpcy5pc0RpcnR5KCk7XG5cdCAgaWYgKHRoaXMud2FzRGlydHkgIT09IGlzRGlydHkpIHtcblx0XHQgIHRoaXMud2FzRGlydHkgPSBpc0RpcnR5O1xuXHRcdCAgdGhpcy5zZXREaXJ0eVN0eWxlKGlzRGlydHkpO1xuXHQgIH1cblx0ICBpZiAodGhpcy5vbmNoYW5nZUNhbGxiYWNrKVxuXHRcdCAgdGhpcy5vbmNoYW5nZUNhbGxiYWNrKHRoaXMpO1xuXHQgIH1cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuc2V0Tm90RGlydHkgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5lZGl0YXJlYS5pbml0aWFsVGV4dCA9IHRoaXMuZWRpdGFyZWEuZ2V0U3RyaW5nKCk7XG5cdHRoaXMud2FzRGlydHkgPSBmYWxzZTtcblx0dGhpcy5zZXREaXJ0eVN0eWxlKGZhbHNlKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5pbmRpY2F0ZV9jaGFuZ2VkID09PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdGhpcy5lZGl0YXJlYS5pbml0aWFsVGV4dCAhPT0gdGhpcy5lZGl0YXJlYS5nZXRTdHJpbmcoKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuaGlnaGxpZ2h0ID0gZnVuY3Rpb24oYWJjZWxlbSwgdHVuZU51bWJlciwgY2xhc3Nlcykge1xuXHQvLyBUT0RPLVBFUjogVGhlIG1hcmtlciBhcHBlYXJzIHRvIGdldCBvZmYgYnkgb25lIGZvciBlYWNoIHR1bmUgcGFyc2VkLiBJJ20gbm90IHN1cmUgd2h5LCBidXQgYWRkaW5nIHRoZSB0dW5lTnVtYmVyIGluIGNvcnJlY3RzIGl0IGZvciB0aGUgdGltZSBiZWluZy5cbi8vXHR2YXIgb2Zmc2V0ID0gKHR1bmVOdW1iZXIgIT09IHVuZGVmaW5lZCkgPyB0aGlzLnN0YXJ0UG9zW3R1bmVOdW1iZXJdICsgdHVuZU51bWJlciA6IDA7XG5cbiAgdGhpcy5lZGl0YXJlYS5zZXRTZWxlY3Rpb24oYWJjZWxlbS5zdGFydENoYXIsIGFiY2VsZW0uZW5kQ2hhcik7XG5cdGlmICh0aGlzLnNlbGVjdGlvbkNoYW5nZUNhbGxiYWNrKVxuXHRcdHRoaXMuc2VsZWN0aW9uQ2hhbmdlQ2FsbGJhY2soYWJjZWxlbS5zdGFydENoYXIsIGFiY2VsZW0uZW5kQ2hhcik7XG59O1xuXG5FZGl0b3IucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oc2hvdWxkUGF1c2UpIHtcblx0dGhpcy5iSXNQYXVzZWQgPSBzaG91bGRQYXVzZTtcblx0aWYgKCFzaG91bGRQYXVzZSlcblx0XHR0aGlzLmZpcmVDaGFuZ2VkKCk7XG59O1xuXG5FZGl0b3IucHJvdG90eXBlLm1pbGxpc2Vjb25kc1Blck1lYXN1cmUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3ludGguc3ludGhDb250cm9sLnZpc3VhbE9iai5taWxsaXNlY29uZHNQZXJNZWFzdXJlKCk7XG59O1xuXG5FZGl0b3IucHJvdG90eXBlLnBhdXNlTWlkaSA9IGZ1bmN0aW9uKHNob3VsZFBhdXNlKSB7XG5cdHRoaXMubWlkaVBhdXNlID0gc2hvdWxkUGF1c2U7XG5cdGlmICghc2hvdWxkUGF1c2UpXG5cdFx0dGhpcy5yZWRyYXdNaWRpKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVkaXRvcjtcbiIsIi8vICAgIGFiY19taWRpX2ZsYXR0ZW5lci5qczogVHVybiBhIGxpbmVhciBzZXJpZXMgb2YgZXZlbnRzIGludG8gYSBzZXJpZXMgb2YgTUlESSBjb21tYW5kcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gV2UgaW5wdXQgYSBzZXQgb2Ygdm9pY2VzLCBidXQgdGhlIG5vdGVzIGFyZSBzdGlsbCBjb21wbGV4LiBUaGlzIHBhc3MgY2hhbmdlcyB0aGUgbG9naWNhbCBkZWZpbml0aW9uc1xuLy8gb2YgdGhlIGdyYWNlIG5vdGVzLCBkZWNvcmF0aW9ucywgdGllcywgdHJpcGxldHMsIHJlc3RzLCB0cmFuc3Bvc2l0aW9ucywga2V5cywgYW5kIGFjY2lkZW50YWxzIGludG8gYWN0dWFsIG5vdGUgZHVyYXRpb25zLlxuLy8gSXQgYWxzbyBleHRyYWN0cyBndWl0YXIgY2hvcmRzIHRvIGEgc2VwYXJhdGUgdm9pY2UgYW5kIHJlc29sdmVzIHRoZWlyIHJoeXRobS5cblxudmFyIGZsYXR0ZW47XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJhckFjY2lkZW50YWxzO1xuXHR2YXIgYWNjaWRlbnRhbHM7XG5cdHZhciB0cmFuc3Bvc2U7XG5cdHZhciBiYWdwaXBlcztcblx0dmFyIG11bHRpcGxpZXI7XG5cdHZhciB0cmFja3M7XG5cdHZhciBzdGFydGluZ1RlbXBvO1xuXHR2YXIgc3RhcnRpbmdNZXRlcjtcblx0dmFyIHRlbXBvQ2hhbmdlRmFjdG9yID0gMTtcblx0dmFyIGluc3RydW1lbnQ7XG5cdHZhciBjdXJyZW50SW5zdHJ1bWVudDtcblx0Ly8gdmFyIGNoYW5uZWw7XG5cdHZhciBjdXJyZW50VHJhY2s7XG5cdHZhciBwaXRjaGVzVGllZDtcblx0dmFyIGxhc3ROb3RlRHVyYXRpb25Qb3NpdGlvbjtcblx0dmFyIGN1cnJlbnRUcmFja0NvdW50ZXI7XG5cblx0dmFyIG1ldGVyID0geyBudW06IDQsIGRlbjogNCB9O1xuXHR2YXIgY2hvcmRUcmFjaztcblx0dmFyIGNob3JkVHJhY2tGaW5pc2hlZDtcblx0dmFyIGNob3JkQ2hhbm5lbDtcblx0dmFyIGNob3JkSW5zdHJ1bWVudCA9IDA7XG5cdHZhciBkcnVtSW5zdHJ1bWVudCA9IDEyODtcblx0dmFyIGN1cnJlbnRDaG9yZHM7XG5cdHZhciBsYXN0Q2hvcmQ7XG5cdHZhciBiYXJCZWF0O1xuXHR2YXIgZ0Nob3JkVGFjZXQgPSBmYWxzZTtcblx0dmFyIGRvQmVhdEFjY2VudHMgPSB0cnVlO1xuXHR2YXIgc3RyZXNzQmVhdDEgPSAxMDU7XG5cdHZhciBzdHJlc3NCZWF0RG93biA9IDk1O1xuXHR2YXIgc3RyZXNzQmVhdFVwID0gODU7XG5cdHZhciBiZWF0RnJhY3Rpb24gPSAwLjI1O1xuXHR2YXIgbmV4dFZvbHVtZTtcblx0dmFyIG5leHRWb2x1bWVEZWx0YTtcblxuXHR2YXIgZHJ1bVRyYWNrO1xuXHR2YXIgZHJ1bVRyYWNrRmluaXNoZWQ7XG5cdHZhciBkcnVtRGVmaW5pdGlvbiA9IHt9O1xuXG5cdHZhciBub3JtYWxCcmVha0JldHdlZW5Ob3RlcyA9IDEuMC8xMjg7XHQvLyBhIDEyOHRoIG5vdGUgb2Ygc2lsZW5jZSBiZXR3ZWVuIG5vdGVzIGZvciBhcnRpY3VsYXRpb24uXG5cblx0ZmxhdHRlbiA9IGZ1bmN0aW9uKHZvaWNlcywgb3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXHRcdGJhckFjY2lkZW50YWxzID0gW107XG5cdFx0YWNjaWRlbnRhbHMgPSBbMCwwLDAsMCwwLDAsMF07XG5cdFx0YmFncGlwZXMgPSBmYWxzZTtcblx0XHRtdWx0aXBsaWVyID0gMTtcblx0XHR0cmFja3MgPSBbXTtcblx0XHRzdGFydGluZ1RlbXBvID0gdW5kZWZpbmVkO1xuXHRcdHN0YXJ0aW5nTWV0ZXIgPSB1bmRlZmluZWQ7XG5cdFx0dGVtcG9DaGFuZ2VGYWN0b3IgPSAxO1xuXHRcdGluc3RydW1lbnQgPSB1bmRlZmluZWQ7XG5cdFx0Y3VycmVudEluc3RydW1lbnQgPSB1bmRlZmluZWQ7XG5cdFx0Ly8gY2hhbm5lbCA9IHVuZGVmaW5lZDtcblx0XHRjdXJyZW50VHJhY2sgPSB1bmRlZmluZWQ7XG5cdFx0Y3VycmVudFRyYWNrQ291bnRlciA9IHVuZGVmaW5lZDtcblx0XHRwaXRjaGVzVGllZCA9IHt9O1xuXG5cdFx0Ly8gRm9yIHJlc29sdmluZyBjaG9yZHMuXG5cdFx0bWV0ZXIgPSB7IG51bTogNCwgZGVuOiA0IH07XG5cdFx0Y2hvcmRUcmFjayA9IFtdO1xuXHRcdGNob3JkQ2hhbm5lbCA9IHZvaWNlcy5sZW5ndGg7IC8vIGZpcnN0IGZyZWUgY2hhbm5lbCBmb3IgY2hvcmRzXG5cdFx0Y2hvcmRUcmFja0ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0Y3VycmVudENob3JkcyA9IFtdO1xuXHRcdGxhc3RDaG9yZCA9IHVuZGVmaW5lZDtcblx0XHRiYXJCZWF0ID0gMDtcblx0XHRnQ2hvcmRUYWNldCA9IG9wdGlvbnMuY2hvcmRzT2ZmID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0ZG9CZWF0QWNjZW50cyA9IHRydWU7XG5cdFx0c3RyZXNzQmVhdDEgPSAxMDU7XG5cdFx0c3RyZXNzQmVhdERvd24gPSA5NTtcblx0XHRzdHJlc3NCZWF0VXAgPSA4NTtcblx0XHRiZWF0RnJhY3Rpb24gPSAwLjI1O1xuXHRcdG5leHRWb2x1bWUgPSB1bmRlZmluZWQ7XG5cdFx0bmV4dFZvbHVtZURlbHRhID0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gRm9yIHRoZSBkcnVtL21ldHJvbm9tZSB0cmFjay5cblx0XHRkcnVtVHJhY2sgPSBbXTtcblx0XHRkcnVtVHJhY2tGaW5pc2hlZCA9IGZhbHNlO1xuXHRcdGRydW1EZWZpbml0aW9uID0ge307XG5cblx0XHR6ZXJvT3V0TWlsbGlzZWNvbmRzKHZvaWNlcyk7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJhbnNwb3NlID0gMDtcblx0XHRcdGxhc3ROb3RlRHVyYXRpb25Qb3NpdGlvbiA9IC0xO1xuXHRcdFx0dmFyIHZvaWNlID0gdm9pY2VzW2ldO1xuXHRcdFx0Y3VycmVudFRyYWNrID0gW3sgY21kOiAncHJvZ3JhbScsIGNoYW5uZWw6IGksIGluc3RydW1lbnQ6IGluc3RydW1lbnQgfV07XG5cdFx0XHRjdXJyZW50VHJhY2tDb3VudGVyID0gMDtcblx0XHRcdHBpdGNoZXNUaWVkID0ge307XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHZvaWNlLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdm9pY2Vbal07XG5cdFx0XHRcdHN3aXRjaCAoZWxlbWVudC5lbF90eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIm5vdGVcIjpcblx0XHRcdFx0XHRcdHdyaXRlTm90ZShlbGVtZW50LCBvcHRpb25zLnZvaWNlc09mZik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwia2V5XCI6XG5cdFx0XHRcdFx0XHRhY2NpZGVudGFscyA9IHNldEtleVNpZ25hdHVyZShlbGVtZW50KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJtZXRlclwiOlxuXHRcdFx0XHRcdFx0aWYgKCFzdGFydGluZ01ldGVyKVxuXHRcdFx0XHRcdFx0XHRzdGFydGluZ01ldGVyID0gZWxlbWVudDtcblx0XHRcdFx0XHRcdG1ldGVyID0gZWxlbWVudDtcblx0XHRcdFx0XHRcdGJlYXRGcmFjdGlvbiA9IGdldEJlYXRGcmFjdGlvbihtZXRlcik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwidGVtcG9cIjpcblx0XHRcdFx0XHRcdGlmICghc3RhcnRpbmdUZW1wbylcblx0XHRcdFx0XHRcdFx0c3RhcnRpbmdUZW1wbyA9IGVsZW1lbnQucXBtO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHR0ZW1wb0NoYW5nZUZhY3RvciA9IGVsZW1lbnQucXBtID8gc3RhcnRpbmdUZW1wbyAvIGVsZW1lbnQucXBtIDogMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJ0cmFuc3Bvc2VcIjpcblx0XHRcdFx0XHRcdHRyYW5zcG9zZSA9IGVsZW1lbnQudHJhbnNwb3NlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImJhclwiOlxuXHRcdFx0XHRcdFx0aWYgKGNob3JkVHJhY2subGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmVDaG9yZHMoKTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudENob3JkcyA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YmFyQmVhdCA9IDA7XG5cdFx0XHRcdFx0XHRiYXJBY2NpZGVudGFscyA9IFtdO1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09IDApIC8vIE9ubHkgd3JpdGUgdGhlIGRydW0gcGFydCBvbiB0aGUgZmlyc3Qgdm9pY2Ugc28gdGhhdCBpdCBpcyBub3QgZHVwbGljYXRlZC5cblx0XHRcdFx0XHRcdFx0d3JpdGVEcnVtKHZvaWNlcy5sZW5ndGgrMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYmFncGlwZXNcIjpcblx0XHRcdFx0XHRcdGJhZ3BpcGVzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbnN0cnVtZW50XCI6XG5cdFx0XHRcdFx0XHRpZiAoaW5zdHJ1bWVudCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHRpbnN0cnVtZW50ID0gZWxlbWVudC5wcm9ncmFtO1xuXHRcdFx0XHRcdFx0Y3VycmVudEluc3RydW1lbnQgPSBlbGVtZW50LnByb2dyYW07XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudFRyYWNrLmxlbmd0aCA+IDAgJiYgY3VycmVudFRyYWNrW2N1cnJlbnRUcmFjay5sZW5ndGgtMV0uY21kID09PSAncHJvZ3JhbScpXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFja1tjdXJyZW50VHJhY2subGVuZ3RoLTFdLmluc3RydW1lbnQgPSBlbGVtZW50LnByb2dyYW07XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGlpID0gY3VycmVudFRyYWNrLmxlbmd0aC0xOyBpaSA+PSAwICYmIGN1cnJlbnRUcmFja1tpaV0uY21kICE9PSAncHJvZ3JhbSc7IGlpLS0pXG5cdFx0XHRcdFx0XHRcdFx0O1xuXHRcdFx0XHRcdFx0XHRpZiAoaWkgPCAwIHx8IGN1cnJlbnRUcmFja1tpaV0uaW5zdHJ1bWVudCAhPT0gZWxlbWVudC5wcm9ncmFtKVxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFjay5wdXNoKHtjbWQ6ICdwcm9ncmFtJywgY2hhbm5lbDogaSwgaW5zdHJ1bWVudDogZWxlbWVudC5wcm9ncmFtfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiY2hhbm5lbFwiOlxuXHRcdFx0XHRcdC8vIFx0aWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHQvLyBcdFx0Y2hhbm5lbCA9IGVsZW1lbnQuY2hhbm5lbDtcblx0XHRcdFx0XHQvLyBcdGN1cnJlbnRUcmFja1swXS5jaGFubmVsID0gZWxlbWVudC5jaGFubmVsO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImRydW1cIjpcblx0XHRcdFx0XHRcdGRydW1EZWZpbml0aW9uID0gbm9ybWFsaXplRHJ1bURlZmluaXRpb24oZWxlbWVudC5wYXJhbXMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImdjaG9yZFwiOlxuXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmNob3Jkc09mZilcblx0XHRcdFx0XHRcdFx0Z0Nob3JkVGFjZXQgPSBlbGVtZW50LnRhY2V0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImJlYXRcIjpcblx0XHRcdFx0XHRcdHN0cmVzc0JlYXQxID0gZWxlbWVudC5iZWF0c1swXTtcblx0XHRcdFx0XHRcdHN0cmVzc0JlYXREb3duID0gZWxlbWVudC5iZWF0c1sxXTtcblx0XHRcdFx0XHRcdHN0cmVzc0JlYXRVcCA9IGVsZW1lbnQuYmVhdHNbMl07XG5cdFx0XHRcdFx0XHQvLyBUT0RPLVBFUjogYWxzbyB1c2UgdGhlIGxhc3QgcGFyYW1ldGVyIC0gd2hpY2ggY2hhbmdlcyB3aGljaCBiZWF0cyBhcmUgc3Ryb25nLlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInZvbFwiOlxuXHRcdFx0XHRcdFx0bmV4dFZvbHVtZSA9IGVsZW1lbnQudm9sdW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcInZvbGluY1wiOlxuXHRcdFx0XHRcdFx0bmV4dFZvbHVtZURlbHRhID0gZWxlbWVudC52b2x1bWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYmVhdGFjY2VudHNcIjpcblx0XHRcdFx0XHRcdGRvQmVhdEFjY2VudHMgPSBlbGVtZW50LnZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJNSURJIGNyZWF0aW9uLiBVbmtub3duIGVsX3R5cGU6IFwiICsgZWxlbWVudC5lbF90eXBlICsgXCJcXG5cIik7Ly8ganNoaW50IGlnbm9yZTpsaW5lXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRUcmFja1swXS5pbnN0cnVtZW50ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGN1cnJlbnRUcmFja1swXS5pbnN0cnVtZW50ID0gaW5zdHJ1bWVudCA/IGluc3RydW1lbnQgOiAwO1xuXHRcdFx0dHJhY2tzLnB1c2goY3VycmVudFRyYWNrKTtcblx0XHRcdGlmIChjaG9yZFRyYWNrLmxlbmd0aCA+IDApIC8vIERvbid0IGRvIGNob3JkcyBvbiBtb3JlIHRoYW4gb25lIHRyYWNrLCBzbyB0dXJuIG9mZiBjaG9yZCBkZXRlY3Rpb24gYWZ0ZXIgd2UgY3JlYXRlIGl0LlxuXHRcdFx0XHRjaG9yZFRyYWNrRmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0aWYgKGRydW1UcmFjay5sZW5ndGggPiAwKSAvLyBEb24ndCBkbyBkcnVtcyBvbiBtb3JlIHRoYW4gb25lIHRyYWNrLCBzbyB0dXJuIG9mZiBkcnVtIGFmdGVyIHdlIGNyZWF0ZSBpdC5cblx0XHRcdFx0ZHJ1bVRyYWNrRmluaXNoZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoY2hvcmRUcmFjay5sZW5ndGggPiAwKVxuXHRcdFx0dHJhY2tzLnB1c2goY2hvcmRUcmFjayk7XG5cdFx0aWYgKGRydW1UcmFjay5sZW5ndGggPiAwKVxuXHRcdFx0dHJhY2tzLnB1c2goZHJ1bVRyYWNrKTtcblx0XHQvLyBBZGp1c3QgdGhlIHRlbXBvIGFjY29yZGluZyB0byB0aGUgbWV0ZXIuIFRoZSBydWxlcyBhcmUgdGhpczpcblx0XHQvLyAxKSBJZiB0aGUgZGVub21pbmF0b3IgaXMgMiBvciA0LCB0aGVuIGFsd2F5cyBtYWtlIGEgYmVhdCBiZSB0aGUgZGVub21pbmF0b3IuXG5cdFx0Ly9cblx0XHQvLyAyKSBJZiB0aGUgZGVub21pbmF0b3IgaXMgOCBvciAxNiwgdGhlbjpcblx0XHQvLyBhKSBJZiB0aGUgbnVtZXJhdG9yIGlzIGRpdmlzaWJsZSBieSAzLCB0aGUgYmVhdCBpcyAzKmRlbm9taW5hdG9yLlxuXHRcdC8vIGIpIE90aGVyd2lzZSB0aGUgYmVhdCBpcyB0aGUgZGVub21pbmF0b3IuXG5cdFx0Ly9cblx0XHQvLyAzKSBJZiB0aGUgZGVub21pbmF0b3IgaXMgYW55dGhpbmcgZWxzZSwgdGhlbiBkb24ndCB3b3JyeSBhYm91dCBpdCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZS4gRG9uJ3QgbW9kaWZ5IGl0IGFuZCBob3BlIGZvciB0aGUgYmVzdC5cblx0XHQvL1xuXHRcdC8vIFJpZ2h0IG5vdywgdGhlIHN0YXJ0aW5nVGVtcG8gaXMgY2FsY3VsYXRlZCBmb3IgYSBxdWFydGVyIG5vdGUsIHNvIG1vZGlmeSBpdCBpZiBuZWNlc3NhcnkuXG5cdFx0Ly8gdmFyIG51bSA9IHN0YXJ0aW5nTWV0ZXIgPyBwYXJzZUludChzdGFydGluZ01ldGVyLm51bSwgMTApIDogbWV0ZXIubnVtO1xuXHRcdC8vIHZhciBkZW4gPSBzdGFydGluZ01ldGVyID8gcGFyc2VJbnQoc3RhcnRpbmdNZXRlci5kZW4sIDEwKSA6IG1ldGVyLmRlbjtcblx0XHQvLyBpZiAoZGVuID09PSAyKVxuXHRcdC8vIFx0c3RhcnRpbmdUZW1wbyAqPSAyO1xuXHRcdC8vIGVsc2UgaWYgKGRlbiA9PT0gOCkge1xuXHRcdC8vIFx0aWYgKHBhcnNlSW50KG51bSwgMTApICUgMyA9PT0gMClcblx0XHQvLyBcdFx0c3RhcnRpbmdUZW1wbyAqPSAzLzI7XG5cdFx0Ly8gXHRlbHNlXG5cdFx0Ly8gXHRcdHN0YXJ0aW5nVGVtcG8gLz0gMjtcblx0XHQvLyB9IGVsc2UgaWYgKGRlbiA9PT0gMTYpIHtcblx0XHQvLyBcdGlmIChudW0gJSAzID09PSAwKVxuXHRcdC8vIFx0XHRzdGFydGluZ1RlbXBvICo9IDMvNDtcblx0XHQvLyBcdGVsc2Vcblx0XHQvLyBcdFx0c3RhcnRpbmdUZW1wbyAvPSA0O1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiB7IHRlbXBvOiBzdGFydGluZ1RlbXBvLCBpbnN0cnVtZW50OiBpbnN0cnVtZW50LCB0cmFja3M6IHRyYWNrcywgdG90YWxEdXJhdGlvbjogdG90YWxEdXJhdGlvbih0cmFja3MpIH07XG5cdH07XG5cblx0ZnVuY3Rpb24gemVyb091dE1pbGxpc2Vjb25kcyh2b2ljZXMpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHZvaWNlID0gdm9pY2VzW2ldO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB2b2ljZS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHZvaWNlW2pdO1xuXHRcdFx0XHRkZWxldGUgZWxlbWVudC5jdXJyZW50VHJhY2tNaWxsaXNlY29uZHM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdG90YWxEdXJhdGlvbih0cmFja3MpIHtcblx0XHR2YXIgdG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cdFx0XHR2YXIgdHJhY2tUb3RhbCA9IDA7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRyYWNrLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IHRyYWNrW2pdO1xuXHRcdFx0XHRpZiAoZXZlbnQuZHVyYXRpb24pXG5cdFx0XHRcdFx0dHJhY2tUb3RhbCArPSBldmVudC5kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHRvdGFsID0gTWF0aC5tYXgodG90YWwsIHRyYWNrVG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gdG90YWw7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCZWF0RnJhY3Rpb24obWV0ZXIpIHtcblx0XHRzd2l0Y2ggKG1ldGVyLmRlbikge1xuXHRcdFx0Y2FzZSAyOiByZXR1cm4gMC41O1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gMC4yNTtcblx0XHRcdGNhc2UgODogcmV0dXJuIDAuMzc1O1xuXHRcdFx0Y2FzZSAxNjogcmV0dXJuIDAuMTI1O1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yNTtcblx0fVxuXHQvL1xuXHQvLyBUaGUgYWxnb3JpdGhtIGZvciBjaG9yZHMgaXM6XG5cdC8vIC0gVGhlIGNob3JkcyBhcmUgZG9uZSBpbiBhIHNlcGFyYXRlIHRyYWNrLlxuXHQvLyAtIElmIHRoZXJlIGFyZSBub3RlcyBiZWZvcmUgdGhlIGZpcnN0IGNob3JkLCB0aGVuIHB1dCB0aGF0IG11Y2ggc2lsZW5jZSB0byBzdGFydCB0aGUgdHJhY2suXG5cdC8vIC0gVGhlIHBhdHRlcm4gb2YgY2hvcmQgZXhwcmVzc2lvbiBkZXBlbmRzIG9uIHRoZSBtZXRlciwgYW5kIGhvdyBtYW55IGNob3JkcyBhcmUgaW4gYSBtZWFzdXJlLlxuXHQvLyAtIFRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdGhhdCBhIG1lYXN1cmUgd2lsbCBoYXZlIGFuIGluY29ycmVjdCBudW1iZXIgb2YgYmVhdHMsIGlmIHRoYXQgaXMgdGhlIGNhc2UsIHRoZW5cblx0Ly8gc3RhcnQgdGhlIHBhdHRlcm4gYW5ldyBvbiB0aGUgbmV4dCBtZWFzdXJlIG51bWJlci5cblx0Ly8gLSBJZiBhIGNob3JkIHJvb3QgaXMgbm90IEEtRywgdGhlbiBpZ25vcmUgaXQgYXMgaWYgdGhlIGNob3JkIHdhc24ndCB0aGVyZSBhdCBhbGwuXG5cdC8vIC0gSWYgYSBjaG9yZCBtb2RpZmljYXRpb24gaXNuJ3QgaW4gb3VyIHN1cHBvcnRlZCBsaXN0LCBjaGFuZ2UgaXQgdG8gYSBtYWpvciB0cmlhZC5cblx0Ly9cblx0Ly8gLSBJZiB0aGVyZSBpcyBvbmx5IG9uZSBjaG9yZCBpbiBhIG1lYXN1cmU6XG5cdC8vXHRcdC0gSWYgMi80LCBwbGF5IHJvb3QgY2hvcmRcblx0Ly9cdFx0LSBJZiBjdXQgdGltZSwgcGxheSByb290KDEpIGNob3JkKDMpXG5cdC8vXHRcdC0gSWYgMy80LCBwbGF5IHJvb3QgY2hvcmQgY2hvcmRcblx0Ly9cdFx0LSBJZiA0LzQgb3IgY29tbW9uIHRpbWUsIHBsYXkgcm9vdCBjaG9yZCBmaWZ0aCBjaG9yZFxuXHQvL1x0XHQtIElmIDYvOCwgcGxheSByb290KDEpIGNob3JkKDMpIGZpZnRoKDQpIGNob3JkKDYpXG5cdC8vXHRcdC0gRm9yIGFueSBvdGhlciBtZXRlciwgcGxheSB0aGUgZnVsbCBjaG9yZCBvbiBlYWNoIGJlYXQuIChUT0RPLVBFUjogZXhwYW5kIHRoaXMgYXMgbW9yZSBzdXBwb3J0IGlzIGFkZGVkLilcblx0Ly9cblx0Ly9cdC0gSWYgdGhlcmUgaXMgYSBjaG9yZCBzcGVjaWZpZWQgdGhhdCBpcyBub3Qgb24gYSBiZWF0LCBtb3ZlIGl0IGVhcmxpZXIgdG8gdGhlIHByZXZpb3VzIGJlYXQsIHVubGVzcyB0aGVyZSBpcyBhbHJlYWR5IGEgY2hvcmQgb24gdGhhdCBiZWF0LlxuXHQvL1x0LSBPdGhlcndpc2UsIG1vdmUgaXQgbGF0ZXIsIHVubGVzcyB0aGVyZSBpcyBhbHJlYWR5IGEgY2hvcmQgb24gdGhhdCBiZWF0LlxuXHQvLyBcdC0gT3RoZXJ3aXNlLCBpZ25vcmUgaXQuIChUT0RPLVBFUjogZXhwYW5kIHRoaXMgYXMgbW9yZSBzdXBwb3J0IGlzIGFkZGVkLilcblx0Ly9cblx0Ly8gLSBJZiB0aGVyZSBpcyBhIGNob3JkIG9uIHRoZSBzZWNvbmQgYmVhdCwgcGxheSBhIGNob3JkIGZvciB0aGUgZmlyc3QgYmVhdCBpbnN0ZWFkIG9mIGEgYmFzcyBub3RlLlxuXHQvLyAtIExpa2V3aXNlLCBpZiB0aGVyZSBpcyBhIGNob3JkIG9uIHRoZSBmb3VydGggYmVhdCBvZiA0LzQsIHBsYXkgYSBjaG9yZCBvbiB0aGUgdGhpcmQgYmVhdCBpbnN0ZWFkIG9mIGEgYmFzcyBub3RlLlxuXHQvL1xuXHR2YXIgYnJlYWtTeW5vbnltcyA9IFsgJ2JyZWFrJywgJyhicmVhayknLCAnbm8gY2hvcmQnLCAnbi5jLicsICd0YWNldCddO1xuXG5cdGZ1bmN0aW9uIGZpbmRDaG9yZChlbGVtKSB7XG5cdFx0aWYgKGdDaG9yZFRhY2V0KVxuXHRcdFx0cmV0dXJuICdicmVhayc7XG5cblx0XHQvLyBUT0RPLVBFUjogSnVzdCB1c2luZyB0aGUgZmlyc3QgY2hvcmQgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUuXG5cdFx0aWYgKGNob3JkVHJhY2tGaW5pc2hlZCB8fCAhZWxlbS5jaG9yZCB8fCBlbGVtLmNob3JkLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBmaXJzdCBhbm5vdGF0aW9uIHRoYXQgaXMgYSByZWd1bGFyIGNob3JkOiB0aGF0IGlzLCBpdCBpcyBpbiB0aGUgZGVmYXVsdCBwbGFjZSBvciBpcyBhIHJlY29nbml6ZWQgXCJ0YWNldFwiIHBocmFzZS5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hvcmQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjaCA9IGVsZW0uY2hvcmRbaV07XG5cdFx0XHRpZiAoY2gucG9zaXRpb24gPT09ICdkZWZhdWx0Jylcblx0XHRcdFx0cmV0dXJuIGNoLm5hbWU7XG5cdFx0XHRpZiAoYnJlYWtTeW5vbnltcy5pbmRleE9mKGNoLm5hbWUudG9Mb3dlckNhc2UoKSkgPj0gMClcblx0XHRcdFx0cmV0dXJuICdicmVhayc7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gdGltZUZyb21TdGFydCgpIHtcblx0XHR2YXIgZGlzdGFuY2UgPSAwO1xuXHRcdGZvciAodmFyIGN0ID0gMDsgY3QgPCBjdXJyZW50VHJhY2subGVuZ3RoOyBjdCsrKSB7XG5cdFx0XHRpZiAoY3VycmVudFRyYWNrW2N0XS5jbWQgPT09ICdtb3ZlJylcblx0XHRcdFx0ZGlzdGFuY2UgKz0gY3VycmVudFRyYWNrW2N0XS5kdXJhdGlvbjtcblx0XHR9XG5cdFx0cmV0dXJuIGRpc3RhbmNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVOb3RlKGVsZW0sIHZvaWNlT2ZmKSB7XG5cdFx0Ly9cblx0XHQvLyBDcmVhdGUgYSBzZXJpZXMgb2Ygbm90ZSBldmVudHMgdG8gYXBwZW5kIHRvIHRoZSBjdXJyZW50IHRyYWNrLlxuXHRcdC8vIFRoZSBvdXRwdXQgZXZlbnQgaXMgb25lIG9mOiB7IHBpdGNoU3RhcnQ6IHBpdGNoX2luX2FiY191bml0cywgdm9sdW1lOiBmcm9tXzFfdG9fNjQgfVxuXHRcdC8vIHsgcGl0Y2hTdG9wOiBwaXRjaF9pbl9hYmNfdW5pdHMgfVxuXHRcdC8vIHsgbW92ZVRpbWU6IGR1cmF0aW9uX2luX2FiY191bml0cyB9XG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGd1aXRhciBjaG9yZHMsIHRoZW4gdGhleSBhcmUgcHV0IGluIGEgc2VwYXJhdGUgdHJhY2ssIGJ1dCB0aGV5IGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxuXHRcdC8vXG5cblx0XHR2YXIgdm9sdW1lO1xuXHRcdGlmIChuZXh0Vm9sdW1lKSB7XG5cdFx0XHR2b2x1bWUgPSBuZXh0Vm9sdW1lO1xuXHRcdFx0bmV4dFZvbHVtZSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCFkb0JlYXRBY2NlbnRzKSB7XG5cdFx0XHR2b2x1bWUgPSBzdHJlc3NCZWF0RG93bjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGJhckJlYXQgPT09IDApXG5cdFx0XHRcdHZvbHVtZSA9IHN0cmVzc0JlYXQxO1xuXHRcdFx0ZWxzZSBpZiAoYmFyQmVhdCAlIGJlYXRGcmFjdGlvbiA8IDAuMDAxKSAvLyBBIGxpdHRsZSBzbG9wIGJlY2F1c2Ugb2YgSmF2YVNjcmlwdCBmbG9hdGluZyBwb2ludCBtYXRoLlxuXHRcdFx0XHR2b2x1bWUgPSBzdHJlc3NCZWF0RG93bjtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dm9sdW1lID0gc3RyZXNzQmVhdFVwO1xuXHRcdH1cblx0XHRpZiAobmV4dFZvbHVtZURlbHRhKSB7XG5cdFx0XHR2b2x1bWUgKz0gbmV4dFZvbHVtZURlbHRhO1xuXHRcdFx0bmV4dFZvbHVtZURlbHRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAodm9sdW1lIDwgMClcblx0XHRcdHZvbHVtZSA9IDA7XG5cdFx0aWYgKHZvbHVtZSA+IDEyNylcblx0XHRcdHZvbHVtZSA9IDEyNztcblx0XHR2YXIgdmVsb2NpdHkgPSB2b2ljZU9mZiA/IDAgOiB2b2x1bWU7XG5cdFx0dmFyIGNob3JkID0gZmluZENob3JkKGVsZW0pO1xuXHRcdGlmIChjaG9yZCkge1xuXHRcdFx0dmFyIGMgPSBpbnRlcnByZXRDaG9yZChjaG9yZCk7XG5cdFx0XHQvLyBJZiB0aGlzIGlzbid0IGEgcmVjb2duaXplZCBjaG9yZCwganVzdCBjb21wbGV0ZWx5IGlnbm9yZSBpdC5cblx0XHRcdGlmIChjKSB7XG5cdFx0XHRcdC8vIElmIHdlIGV2ZXIgaGF2ZSBhIGNob3JkIGluIHRoaXMgdm9pY2UsIHRoZW4gd2UgYWRkIHRoZSBjaG9yZCB0cmFjay5cblx0XHRcdFx0Ly8gSG93ZXZlciwgaWYgdGhlcmUgYXJlIGNob3JkcyBvbiBtb3JlIHRoYW4gb25lIHZvaWNlLCB0aGVuIGp1c3QgdXNlIHRoZSBmaXJzdCB2b2ljZS5cblx0XHRcdFx0aWYgKGNob3JkVHJhY2subGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Y2hvcmRUcmFjay5wdXNoKHtjbWQ6ICdwcm9ncmFtJywgY2hhbm5lbDogY2hvcmRDaGFubmVsLCBpbnN0cnVtZW50OiBjaG9yZEluc3RydW1lbnR9KTtcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IGZhciBpbiB0aW1lIHRoZSBjaG9yZCBzdGFydGVkOiBpZiB0aGVyZSBhcmUgcGlja3VwIG5vdGVzIGJlZm9yZSB0aGUgY2hvcmRzIHN0YXJ0LCB3ZSBuZWVkIHBhdXNlcy5cblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSB0aW1lRnJvbVN0YXJ0KCk7XG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlID4gMClcblx0XHRcdFx0XHRcdGNob3JkVHJhY2sucHVzaCh7Y21kOiAnbW92ZScsIGR1cmF0aW9uOiBkaXN0YW5jZSp0ZW1wb0NoYW5nZUZhY3RvciB9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxhc3RDaG9yZCA9IGM7XG5cdFx0XHRcdGN1cnJlbnRDaG9yZHMucHVzaCh7Y2hvcmQ6IGxhc3RDaG9yZCwgYmVhdDogYmFyQmVhdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlbGVtLnN0YXJ0VHJpcGxldCkge1xuXHRcdFx0bXVsdGlwbGllciA9IGVsZW0udHJpcGxldE11bHRpcGxpZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGR1cmF0aW9uID0gKGVsZW0uZHVyYXRpb25DbGFzcyA/IGVsZW0uZHVyYXRpb25DbGFzcyA6IGVsZW0uZHVyYXRpb24pICptdWx0aXBsaWVyO1xuXHRcdGJhckJlYXQgKz0gZHVyYXRpb247XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgZ3JhY2Ugbm90ZXMsIHRoZW4gYWxzbyBwbGF5IHRoZW0uXG5cdFx0Ly8gSSdtIG5vdCBzdXJlIHRoZXJlIGlzIGFuIGV4YWN0IHJ1bGUgZm9yIHRoZSBsZW5ndGggb2YgdGhlIG5vdGVzLiBNeSBydWxlLCB1bmxlc3MgSSBmaW5kXG5cdFx0Ly8gYSBiZXR0ZXIgb25lIGlzOiB0aGUgZ3JhY2Ugbm90ZXMgY2Fubm90IHRha2UgbW9yZSB0aGFuIDEvMiBvZiB0aGUgbWFpbiBub3RlJ3MgdmFsdWUuXG5cdFx0Ly8gQSBncmFjZSBub3RlIChvZiAxLzggbm90ZSBkdXJhdGlvbikgdGFrZXMgMS84IG9mIHRoZSBtYWluIG5vdGUncyB2YWx1ZS5cblx0XHR2YXIgZ3JhY2VzO1xuXHRcdGlmIChlbGVtLmdyYWNlbm90ZXMpIHtcblx0XHRcdC8vIFRoZXJlIGFyZSB0d28gY2FzZXM6IGlmIHRoaXMgaXMgYmFncGlwZSwgdGhlIGdyYWNlIG5vdGVzIGFyZSBwbGF5ZWQgb24gdGhlIGJlYXQgd2l0aCB0aGUgY3VycmVudCBub3RlLlxuXHRcdFx0Ly8gTm9ybWFsbHksIHRoZSBncmFjZSBub3RlcyB3b3VsZCBiZSBwbGF5ZWQgYmVmb3JlIHRoZSBiZWF0LiAoSWYgdGhpcyBpcyB0aGUgZmlyc3Qgbm90ZSBpbiB0aGUgdHJhY2ssIGhvd2V2ZXIsIHRoZW4gaXQgaXMgcGxheWVkIG9uIHRoZSBjdXJyZW50IGJlYXQuKVxuXHRcdFx0Ly8gVGhlIHJlYXNvbiBmb3IgdGhlIGV4Y2VwdGlvbiBvbiB0aGUgZmlyc3Qgbm90ZSBpcyB0aGF0IGl0IHdvdWxkIG90aGVyd2lzZSBtb3ZlIHRoZSB3aG9sZSB0cmFjayBpbiB0aW1lIGFuZCB3b3VsZCBhZmZlY3QgYWxsIHRoZSBvdGhlciB0cmFja3MuXG5cdFx0XHR2YXIgc3RlYWxGcm9tQ3VycmVudCA9IChiYWdwaXBlcyB8fCBsYXN0Tm90ZUR1cmF0aW9uUG9zaXRpb24gPCAwIHx8IGN1cnJlbnRUcmFjay5sZW5ndGggPT09IDApO1xuXHRcdFx0dmFyIHN0ZWFsRnJvbUR1cmF0aW9uID0gc3RlYWxGcm9tQ3VycmVudCA/IGR1cmF0aW9uIDogY3VycmVudFRyYWNrW2xhc3ROb3RlRHVyYXRpb25Qb3NpdGlvbl0uZHVyYXRpb247XG5cdFx0XHRncmFjZXMgPSBwcm9jZXNzR3JhY2VOb3RlcyhlbGVtLmdyYWNlbm90ZXMsIHN0ZWFsRnJvbUR1cmF0aW9uKTtcblx0XHRcdGlmICghYmFncGlwZXMpIHtcblx0XHRcdFx0ZHVyYXRpb24gPSB3cml0ZUdyYWNlTm90ZXMoZ3JhY2VzLCBzdGVhbEZyb21DdXJyZW50LCBkdXJhdGlvbiwgbnVsbCwgdmVsb2NpdHkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRoZSBjdXJyZW50VHJhY2tDb3VudGVyIGlzIHRoZSBudW1iZXIgb2Ygd2hvbGUgbm90ZXMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwaWVjZS5cblx0XHQvLyBUaGUgYmVhdCBmcmFjdGlvbiBpcyB0aGUgbm90ZSB0aGF0IGdldHMgYSBiZWF0ICguMjUgaXMgYSBxdWFydGVyIG5vdGUpXG5cdFx0Ly8gVGhlIHRlbXBvIGlzIGluIG1pbnV0ZXMgYW5kIHdlIHdhbnQgdG8gZ2V0IHRvIG1pbGxpc2Vjb25kcy5cblx0XHRpZiAoIWVsZW0uY3VycmVudFRyYWNrTWlsbGlzZWNvbmRzKVxuXHRcdFx0ZWxlbS5jdXJyZW50VHJhY2tNaWxsaXNlY29uZHMgPSBbXTtcblx0XHRlbGVtLmN1cnJlbnRUcmFja01pbGxpc2Vjb25kcy5wdXNoKGN1cnJlbnRUcmFja0NvdW50ZXIgLyBiZWF0RnJhY3Rpb24gLyBzdGFydGluZ1RlbXBvICogNjAqMTAwMCk7XG5cdFx0aWYgKGVsZW0ucGl0Y2hlcykge1xuXHRcdFx0aWYgKGdyYWNlcyAmJiBiYWdwaXBlcykge1xuXHRcdFx0XHQvLyBJZiBpdCBpcyBiYWdwaXBlcywgdGhlbiB0aGUgZ3JhY2VzIGFyZSBwbGF5ZWQgd2l0aCB0aGUgbm90ZS4gSWYgdGhlIGdyYWNlIGhhcyB0aGUgc2FtZSBwaXRjaCBhcyB0aGUgbm90ZSwgdGhlbiB3ZSBqdXN0IHNraXAgaXQuXG5cdFx0XHRcdGR1cmF0aW9uID0gd3JpdGVHcmFjZU5vdGVzKGdyYWNlcywgdHJ1ZSwgZHVyYXRpb24sIG51bGwsIHZlbG9jaXR5KTtcblx0XHRcdH1cblx0XHRcdHZhciBwaXRjaGVzID0gW107XG5cdFx0XHRlbGVtLm1pZGlQaXRjaGVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8ZWxlbS5waXRjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBub3RlID0gZWxlbS5waXRjaGVzW2ldO1xuXHRcdFx0XHR2YXIgYWN0dWFsUGl0Y2ggPSBhZGp1c3RQaXRjaChub3RlKTtcblx0XHRcdFx0cGl0Y2hlcy5wdXNoKHsgcGl0Y2g6IGFjdHVhbFBpdGNoLCBzdGFydFRpZTogbm90ZS5zdGFydFRpZSB9KTtcblx0XHRcdFx0ZWxlbS5taWRpUGl0Y2hlcy5wdXNoKHsgcGl0Y2g6IGFjdHVhbFBpdGNoKzYwLCBkdXJhdGlvbkluTWVhc3VyZXM6IGR1cmF0aW9uKnRlbXBvQ2hhbmdlRmFjdG9yLCB2b2x1bWU6IHZvbHVtZSwgaW5zdHJ1bWVudDogY3VycmVudEluc3RydW1lbnQgfSk7IC8vIFRPRE8tUEVSOiB3aHkgaXMgdGhlIGludGVybmFsIG51bWJlcmluZyBzeXN0ZW0gb2Zmc2V0IGJ5IDYwIGZyb20gbWlkaT8gSXQgc2hvdWxkIHByb2JhYmx5IGJlIHRoZSBzYW1lIGFzIG1pZGkuXG5cblx0XHRcdFx0aWYgKCFwaXRjaGVzVGllZFsnJythY3R1YWxQaXRjaF0pXHQvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgbm90ZSBvZiBhIHRpZSwgd2UgZG9uJ3Qgc3RhcnQgaXQgYWdhaW4uXG5cdFx0XHRcdFx0Y3VycmVudFRyYWNrLnB1c2goeyBjbWQ6ICdzdGFydCcsIHBpdGNoOiBhY3R1YWxQaXRjaCwgdm9sdW1lOiB2ZWxvY2l0eSB9KTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gYnV0IHdlIGRvIGFkZCB0aGUgZHVyYXRpb24gdG8gd2hhdCB3ZSBjYWxsIGJhY2suXG5cdFx0XHRcdFx0Zm9yICh2YXIgbGFzdCA9IGN1cnJlbnRUcmFjay5sZW5ndGgtMTsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50VHJhY2tbbGFzdF0uY21kID09PSAnc3RhcnQnICYmIGN1cnJlbnRUcmFja1tsYXN0XS5waXRjaCA9PT0gYWN0dWFsUGl0Y2ggJiYgY3VycmVudFRyYWNrW2xhc3RdLmVsZW0pIHtcblx0XHRcdFx0XHRcdFx0dmFyIHBpdGNoQXJyYXkgPSBjdXJyZW50VHJhY2tbbGFzdF0uZWxlbS5taWRpUGl0Y2hlcztcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbGFzdDIgPSAwOyBsYXN0MiA8IHBpdGNoQXJyYXkubGVuZ3RoOyBsYXN0MisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBpdGNoQXJyYXlbbGFzdDJdLnBpdGNoLTYwID09PSBhY3R1YWxQaXRjaCkgeyAvLyBUT0RPLVBFUjogdGhlIDYwIGlzIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBtaWRpIHBpdGNoIG51bWJlcnMgYWdhaW4uXG5cdFx0XHRcdFx0XHRcdFx0XHRwaXRjaEFycmF5W2xhc3QyXS5kdXJhdGlvbkluTWVhc3VyZXMgKz0gZHVyYXRpb24gKiB0ZW1wb0NoYW5nZUZhY3Rvcjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5vdGUuc3RhcnRUaWUpIHtcblx0XHRcdFx0XHRwaXRjaGVzVGllZFsnJyArIGFjdHVhbFBpdGNoXSA9IHRydWU7XG5cdFx0XHRcdFx0Y3VycmVudFRyYWNrW2N1cnJlbnRUcmFjay5sZW5ndGgtMV0uZWxlbSA9IGVsZW07XG5cdFx0XHRcdH0gZWxzZSBpZiAobm90ZS5lbmRUaWUpXG5cdFx0XHRcdFx0cGl0Y2hlc1RpZWRbJycrYWN0dWFsUGl0Y2hdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWxlbS5ncmFjZW5vdGVzKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZWxlbS5ncmFjZW5vdGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0ZWxlbS5taWRpR3JhY2VOb3RlUGl0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdHZhciBncmFjZSA9IGVsZW0uZ3JhY2Vub3Rlc1tqXTtcblx0XHRcdFx0XHRlbGVtLm1pZGlHcmFjZU5vdGVQaXRjaGVzLnB1c2goeyBwaXRjaDogYWRqdXN0UGl0Y2goZ3JhY2UpKzYwLCBkdXJhdGlvbkluTWVhc3VyZXM6IDAsIHZvbHVtZTogdm9sdW1lLCBpbnN0cnVtZW50OiBjdXJyZW50SW5zdHJ1bWVudH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGhpc0JyZWFrQmV0d2Vlbk5vdGVzID0gbm9ybWFsQnJlYWtCZXR3ZWVuTm90ZXM7XG5cdFx0XHR2YXIgc291bmREdXJhdGlvbiA9IGR1cmF0aW9uLW5vcm1hbEJyZWFrQmV0d2Vlbk5vdGVzO1xuXHRcdFx0aWYgKHNvdW5kRHVyYXRpb24gPCAwKSB7XG5cdFx0XHRcdHNvdW5kRHVyYXRpb24gPSAwO1xuXHRcdFx0XHR0aGlzQnJlYWtCZXR3ZWVuTm90ZXMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudFRyYWNrLnB1c2goeyBjbWQ6ICdtb3ZlJywgZHVyYXRpb246IHNvdW5kRHVyYXRpb24qdGVtcG9DaGFuZ2VGYWN0b3IgfSk7XG5cdFx0XHRsYXN0Tm90ZUR1cmF0aW9uUG9zaXRpb24gPSBjdXJyZW50VHJhY2subGVuZ3RoLTE7XG5cdFx0XHRjdXJyZW50VHJhY2tDb3VudGVyICs9IHNvdW5kRHVyYXRpb24qdGVtcG9DaGFuZ2VGYWN0b3I7XG5cblx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBwaXRjaGVzLmxlbmd0aDsgaWkrKykge1xuXHRcdFx0XHRpZiAoIXBpdGNoZXNUaWVkWycnK3BpdGNoZXNbaWldLnBpdGNoXSlcblx0XHRcdFx0XHRjdXJyZW50VHJhY2sucHVzaCh7IGNtZDogJ3N0b3AnLCBwaXRjaDogcGl0Y2hlc1tpaV0ucGl0Y2ggfSk7XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50VHJhY2sucHVzaCh7IGNtZDogJ21vdmUnLCBkdXJhdGlvbjogdGhpc0JyZWFrQmV0d2Vlbk5vdGVzKnRlbXBvQ2hhbmdlRmFjdG9yIH0pO1xuXHRcdFx0Y3VycmVudFRyYWNrQ291bnRlciArPSB0aGlzQnJlYWtCZXR3ZWVuTm90ZXMqdGVtcG9DaGFuZ2VGYWN0b3I7XG5cdFx0fSBlbHNlIGlmIChlbGVtLnJlc3QpIHtcblx0XHRcdGN1cnJlbnRUcmFjay5wdXNoKHsgY21kOiAnbW92ZScsIGR1cmF0aW9uOiBkdXJhdGlvbip0ZW1wb0NoYW5nZUZhY3RvciB9KTtcblx0XHRcdGN1cnJlbnRUcmFja0NvdW50ZXIgKz0gZHVyYXRpb24qdGVtcG9DaGFuZ2VGYWN0b3I7XG5cdFx0fVxuXG5cdFx0aWYgKGVsZW0uZW5kVHJpcGxldCkge1xuXHRcdFx0bXVsdGlwbGllcj0xO1xuXHRcdH1cblx0fVxuXG5cdHZhciBzY2FsZSA9IFswLDIsNCw1LDcsOSwxMV07XG5cdGZ1bmN0aW9uIGFkanVzdFBpdGNoKG5vdGUpIHtcblx0XHRpZiAobm90ZS5taWRpcGl0Y2gpXG5cdFx0XHRyZXR1cm4gbm90ZS5taWRpcGl0Y2ggLSA2MDtcblx0XHR2YXIgcGl0Y2ggPSBub3RlLnBpdGNoO1xuXHRcdGlmIChub3RlLmFjY2lkZW50YWwpIHtcblx0XHRcdHN3aXRjaChub3RlLmFjY2lkZW50YWwpIHsgLy8gY2hhbmdlIHRoYXQgcGl0Y2ggKG5vdCBvdGhlciBvY3RhdmVzKSBmb3IgdGhlIHJlc3Qgb2YgdGhlIGJhclxuXHRcdFx0XHRjYXNlIFwic2hhcnBcIjpcblx0XHRcdFx0XHRiYXJBY2NpZGVudGFsc1twaXRjaF09MTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmbGF0XCI6XG5cdFx0XHRcdFx0YmFyQWNjaWRlbnRhbHNbcGl0Y2hdPS0xOyBicmVhaztcblx0XHRcdFx0Y2FzZSBcIm5hdHVyYWxcIjpcblx0XHRcdFx0XHRiYXJBY2NpZGVudGFsc1twaXRjaF09MDsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkYmxzaGFycFwiOlxuXHRcdFx0XHRcdGJhckFjY2lkZW50YWxzW3BpdGNoXT0yOyBicmVhaztcblx0XHRcdFx0Y2FzZSBcImRibGZsYXRcIjpcblx0XHRcdFx0XHRiYXJBY2NpZGVudGFsc1twaXRjaF09LTI7IGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBhY3R1YWxQaXRjaCA9IGV4dHJhY3RPY3RhdmUocGl0Y2gpICoxMiArIHNjYWxlW2V4dHJhY3ROb3RlKHBpdGNoKV07XG5cblx0XHRpZiAoIGJhckFjY2lkZW50YWxzW3BpdGNoXSE9PXVuZGVmaW5lZCkge1xuXHRcdFx0YWN0dWFsUGl0Y2ggKz0gIGJhckFjY2lkZW50YWxzW3BpdGNoXTtcblx0XHR9IGVsc2UgeyAvLyB1c2Ugbm9ybWFsIGFjY2lkZW50YWxzXG5cdFx0XHRhY3R1YWxQaXRjaCArPSAgYWNjaWRlbnRhbHNbZXh0cmFjdE5vdGUocGl0Y2gpXTtcblx0XHR9XG5cdFx0YWN0dWFsUGl0Y2ggKz0gdHJhbnNwb3NlO1xuXHRcdHJldHVybiBhY3R1YWxQaXRjaDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEtleVNpZ25hdHVyZShlbGVtKSB7XG5cdFx0dmFyIGFjY2lkZW50YWxzID0gWzAsMCwwLDAsMCwwLDBdO1xuXHRcdGlmICghZWxlbS5hY2NpZGVudGFscykgcmV0dXJuIGFjY2lkZW50YWxzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbS5hY2NpZGVudGFscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFjYyA9IGVsZW0uYWNjaWRlbnRhbHNbaV07XG5cdFx0XHR2YXIgZCA9IChhY2MuYWNjID09PSBcInNoYXJwXCIpID8gMSA6IChhY2MuYWNjID09PSBcIm5hdHVyYWxcIikgPzAgOiAtMTtcblxuXHRcdFx0dmFyIGxvd2VyY2FzZSA9IGFjYy5ub3RlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgbm90ZSA9IGV4dHJhY3ROb3RlKGxvd2VyY2FzZS5jaGFyQ29kZUF0KDApLSdjJy5jaGFyQ29kZUF0KDApKTtcblx0XHRcdGFjY2lkZW50YWxzW25vdGVdKz1kO1xuXHRcdH1cblx0XHRyZXR1cm4gYWNjaWRlbnRhbHM7XG5cdH1cblxuXHR2YXIgZ3JhY2VEaXZpZGVyID0gODsgLy8gVGhpcyBpcyB0aGUgZnJhY3Rpb24gb2YgYSBub3RlIHRoYXQgdGhlIGdyYWNlIHJlcHJlc2VudHMuIFRoYXQgaXMsIGlmIHRoaXMgaXMgMiwgdGhlbiBhIGdyYWNlIG5vdGUgb2YgMS8xNiB3b3VsZCBiZSBhIDEvMzIuXG5cdGZ1bmN0aW9uIHByb2Nlc3NHcmFjZU5vdGVzKGdyYWNlcywgY29tcGFuaW9uRHVyYXRpb24pIHtcblx0XHR2YXIgZ3JhY2VEdXJhdGlvbiA9IDA7XG5cdFx0dmFyIHJldCA9IFtdO1xuXHRcdHZhciBncmFjZTtcblx0XHRmb3IgKHZhciBnID0gMDsgZyA8IGdyYWNlcy5sZW5ndGg7IGcrKykge1xuXHRcdFx0Z3JhY2UgPSBncmFjZXNbZ107XG5cdFx0XHRncmFjZUR1cmF0aW9uICs9IGdyYWNlLmR1cmF0aW9uO1xuXHRcdH1cblx0XHRncmFjZUR1cmF0aW9uID0gZ3JhY2VEdXJhdGlvbiAvIGdyYWNlRGl2aWRlcjtcblx0XHR2YXIgbXVsdGlwbGllciA9IChncmFjZUR1cmF0aW9uICogMiA+IGNvbXBhbmlvbkR1cmF0aW9uKSA/IGNvbXBhbmlvbkR1cmF0aW9uLyhncmFjZUR1cmF0aW9uICogMikgOiAxO1xuXG5cdFx0Zm9yIChnID0gMDsgZyA8IGdyYWNlcy5sZW5ndGg7IGcrKykge1xuXHRcdFx0Z3JhY2UgPSBncmFjZXNbZ107XG5cdFx0XHR2YXIgcGl0Y2ggPSBncmFjZS5taWRpcGl0Y2ggPyBncmFjZS5taWRpcGl0Y2ggLSA2MCA6IGdyYWNlLnBpdGNoO1xuXHRcdFx0cmV0LnB1c2goeyBwaXRjaDogcGl0Y2gsIGR1cmF0aW9uOiBncmFjZS5kdXJhdGlvbi9ncmFjZURpdmlkZXIqbXVsdGlwbGllciB9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZ1bmN0aW9uIHdyaXRlR3JhY2VOb3RlcyhncmFjZXMsIHN0ZWFsRnJvbUN1cnJlbnQsIGR1cmF0aW9uLCBza2lwTm90ZSwgdmVsb2NpdHkpIHtcblx0XHRmb3IgKHZhciBnID0gMDsgZyA8IGdyYWNlcy5sZW5ndGg7IGcrKykge1xuXHRcdFx0dmFyIGdwID0gZ3JhY2VzW2ddO1xuXHRcdFx0aWYgKGdwICE9PSBza2lwTm90ZSlcblx0XHRcdFx0Y3VycmVudFRyYWNrLnB1c2goe2NtZDogJ3N0YXJ0JywgcGl0Y2g6IGdwLnBpdGNoLCB2b2x1bWU6IHZlbG9jaXR5fSk7XG5cdFx0XHRjdXJyZW50VHJhY2sucHVzaCh7Y21kOiAnbW92ZScsIGR1cmF0aW9uOiBncmFjZXNbZ10uZHVyYXRpb24qdGVtcG9DaGFuZ2VGYWN0b3IgfSk7XG5cdFx0XHRpZiAoZ3AgIT09IHNraXBOb3RlKVxuXHRcdFx0XHRjdXJyZW50VHJhY2sucHVzaCh7Y21kOiAnc3RvcCcsIHBpdGNoOiBncC5waXRjaH0pO1xuXHRcdFx0aWYgKCFzdGVhbEZyb21DdXJyZW50KVxuXHRcdFx0XHRjdXJyZW50VHJhY2tbbGFzdE5vdGVEdXJhdGlvblBvc2l0aW9uXS5kdXJhdGlvbiAtPSBncmFjZXNbZ10uZHVyYXRpb247XG5cdFx0XHRkdXJhdGlvbiAtPSBncmFjZXNbZ10uZHVyYXRpb247XG5cdFx0fVxuXHRcdHJldHVybiBkdXJhdGlvbjtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dHJhY3RPY3RhdmUocGl0Y2gpIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihwaXRjaC83KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dHJhY3ROb3RlKHBpdGNoKSB7XG5cdFx0cGl0Y2ggPSBwaXRjaCU3O1xuXHRcdGlmIChwaXRjaDwwKSBwaXRjaCs9Nztcblx0XHRyZXR1cm4gcGl0Y2g7XG5cdH1cblxuXHR2YXIgYmFzc2VzID0ge1xuXHRcdCdBJzogLTI3LCAnQic6IC0yNSwgJ0MnOiAtMjQsICdEJzogLTIyLCAnRSc6IC0yMCwgJ0YnOiAtMTksICdHJzogLTE3XG5cdH07XG5cdGZ1bmN0aW9uIGludGVycHJldENob3JkKG5hbWUpIHtcblx0XHQvLyBjaG9yZHMgaGF2ZSB0aGUgZm9ybWF0OlxuXHRcdC8vIFtyb290XVthY2NdW21vZGlmaWVyXVsvXVtiYXNzXVthY2NdXG5cdFx0Ly8gKFRoZSBjaG9yZCBtaWdodCBiZSBzdXJyb3VuZGVkIGJ5IHBhcmVucy4gSnVzdCBpZ25vcmUgdGhlbS4pXG5cdFx0Ly8gcm9vdCBtdXN0IGJlIHByZXNlbnQgYW5kIG11c3QgYmUgZnJvbSBBLUcuXG5cdFx0Ly8gYWNjIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgIyBvciBiXG5cdFx0Ly8gVGhlIG1vZGlmaWVyIGNhbiBiZSBhIHdpZGUgdmFyaWV0eSBvZiB0aGluZ3MsIGxpa2UgXCJtYWo3XCIuIEFzIHRoZXkgYXJlIGRpc2NvdmVyZWQsIG1vcmUgYXJlIHN1cHBvcnRlZCBoZXJlLlxuXHRcdC8vIElmIHRoZXJlIGlzIGEgc2xhc2gsIHRoZW4gdGhlcmUgaXMgYSBiYXNzIG5vdGUsIHdoaWNoIGNhbiBiZSBmcm9tIEEtRywgd2l0aCBhbiBvcHRpb25hbCBhY2MuXG5cdFx0Ly8gSWYgdGhlIHJvb3QgaXMgdW5yZWNvZ25pemVkLCB0aGVuIFwidW5kZWZpbmVkXCIgaXMgcmV0dXJuZWQgYW5kIHRoZXJlIGlzIG5vIGNob3JkLlxuXHRcdC8vIElmIHRoZSBtb2RpZmllciBpcyB1bnJlY29nbml6ZWQsIGEgbWFqb3IgdHJpYWQgaXMgcmV0dXJuZWQuXG5cdFx0Ly8gSWYgdGhlIGJhc3Mgbm90ZXMgaXMgdW5yZWNvZ25pemVkLCBpdCBpcyBpZ25vcmVkLlxuXHRcdGlmIChuYW1lLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0aWYgKG5hbWUgPT09ICdicmVhaycpXG5cdFx0XHRyZXR1cm4geyBjaGljazogW119O1xuXHRcdHZhciByb290ID0gbmFtZS5zdWJzdHJpbmcoMCwxKTtcblx0XHRpZiAocm9vdCA9PT0gJygnKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSxuYW1lLmxlbmd0aC0yKTtcblx0XHRcdGlmIChuYW1lLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdHJvb3QgPSBuYW1lLnN1YnN0cmluZygwLDEpO1xuXHRcdH1cblx0XHR2YXIgYmFzcyA9IGJhc3Nlc1tyb290XTtcblx0XHRpZiAoIWJhc3MpXHQvLyBJZiB0aGUgYmFzcyBub3RlIGlzbid0IGxpc3RlZCwgdGhlbiB0aGlzIHdhcyBhbiB1bmtub3duIHJvb3QuIE9ubHkgQS1HIGFyZSBhY2NlcHRlZC5cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0YmFzcyAgKz0gdHJhbnNwb3NlO1xuXHRcdHZhciBiYXNzMiA9IGJhc3MgLSA1O1x0Ly8gVGhlIGFsdGVybmF0aW5nIGJhc3MgaXMgYSA0dGggYmVsb3dcblx0XHR2YXIgY2hpY2s7XG5cdFx0aWYgKG5hbWUubGVuZ3RoID09PSAxKVxuXHRcdFx0Y2hpY2sgPSBjaG9yZE5vdGVzKGJhc3MsICcnKTtcblx0XHR2YXIgcmVtYWluaW5nID0gbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0dmFyIGFjYyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoMCwxKTtcblx0XHRpZiAoYWNjID09PSAnYicgfHwgYWNjID09PSAn4pmtJykge1xuXHRcdFx0YmFzcy0tO1xuXHRcdFx0YmFzczItLTtcblx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoMSk7XG5cdFx0fSBlbHNlIGlmIChhY2MgPT09ICcjJyB8fCBhY2MgPT09ICfima8nKSB7XG5cdFx0XHRiYXNzKys7XG5cdFx0XHRiYXNzMisrO1xuXHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZygxKTtcblx0XHR9XG5cdFx0dmFyIGFyciA9IHJlbWFpbmluZy5zcGxpdCgnLycpO1xuXHRcdGNoaWNrID0gY2hvcmROb3RlcyhiYXNzLCBhcnJbMF0pO1xuXHRcdGlmIChhcnIubGVuZ3RoID09PSAyKSB7XG5cdFx0XHR2YXIgZXhwbGljaXRCYXNzID0gYmFzc2VzW2FyclsxXS5zdWJzdHJpbmcoMCwxKV07XG5cdFx0XHRpZiAoZXhwbGljaXRCYXNzKSB7XG5cdFx0XHRcdHZhciBiYXNzQWNjID0gYXJyWzFdLnN1YnN0cmluZygxKTtcblx0XHRcdFx0dmFyIGJhc3NTaGlmdCA9IHsnIyc6IDEsICfima8nOiAxLCAnYic6IC0xLCAn4pmtJzogLTF9W2Jhc3NBY2NdIHx8IDA7XG5cdFx0XHRcdGJhc3MgPSBiYXNzZXNbYXJyWzFdLnN1YnN0cmluZygwLDEpXSArIGJhc3NTaGlmdCArIHRyYW5zcG9zZTtcblx0XHRcdFx0YmFzczIgPSBiYXNzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geyBib29tOiBiYXNzLCBib29tMjogYmFzczIsIGNoaWNrOiBjaGljayB9O1xuXHR9XG5cblx0dmFyIGNob3JkSW50ZXJ2YWxzID0ge1xuXHRcdC8vIGRpbWluaXNoZWQgKGFsbCBmbGF0IDUgY2hvcmRzKVxuXHRcdCdkaW0nOiBbIDAsIDMsIDYgXSxcblx0XHQnwrAnOiBbIDAsIDMsIDYgXSxcblx0XHQny5onOiBbIDAsIDMsIDYgXSxcblxuXHRcdCdkaW03JzogWyAwLCAzLCA2LCA5IF0sXG5cdFx0J8KwNyc6IFsgMCwgMywgNiwgOSBdLFxuXHRcdCfLmjcnOiBbIDAsIDMsIDYsIDkgXSxcblxuXHRcdCfDuDcnOiBbIDAsIDMsIDYsIDEwIF0sXG5cdFx0J203KGI1KSc6IFsgMCwgMywgNiwgMTAgXSxcblx0XHQnbTdiNSc6IFsgMCwgMywgNiwgMTAgXSxcblx0XHQnLTcoYjUpJzogWyAwLCAzLCA2LCAxMCBdLFxuXHRcdCctN2I1JzogWyAwLCAzLCA2LCAxMCBdLFxuXG5cdFx0JzdiNSc6IFsgMCwgNCwgNiwgMTAgXSxcblx0XHQnNyhiNSknOiBbIDAsIDQsIDYsIDEwIF0sXG5cdFx0Jzfima01JzogWyAwLCA0LCA2LCAxMCBdLFxuXG5cdFx0JzcoYjksYjUpJzogWyAwLCA0LCA2LCAxMCwgMTMgXSxcblx0XHQnN2I5LGI1JzogWyAwLCA0LCA2LCAxMCwgMTMgXSxcblx0XHQnNygjOSxiNSknOiBbIDAsIDQsIDYsIDEwLCAxNSBdLFxuXHRcdCc3IzliNSc6IFsgMCwgNCwgNiwgMTAsIDE1IF0sXG5cdFx0J21hajcoYjUpJzogWyAwLCAzLCA2LCAxMSBdLFxuXHRcdCdtYWo3YjUnOiBbIDAsIDMsIDYsIDExIF0sXG5cdFx0JzEzKGI1KSc6IFsgMCwgNCwgNiwgMTAsIDE0LCAxOCBdLFxuXHRcdCcxM2I1JzogWyAwLCA0LCA2LCAxMCwgMTQsIDE4IF0sXG5cblx0XHQvLyBtaW5vciAoYWxsIG5vcm1hbCA1LCBtaW5vciAzIGNob3Jkcylcblx0XHQnbSc6IFsgMCwgMywgNyBdLFxuXHRcdCctJzogWyAwLCAzLCA3IF0sXG5cdFx0J202JzogWyAwLCAzLCA3LCA5IF0sXG5cdFx0Jy02JzogWyAwLCAzLCA3LCA5IF0sXG5cdFx0J203JzogWyAwLCAzLCA3LCAxMCBdLFxuXHRcdCctNyc6IFsgMCwgMywgNywgMTAgXSxcblxuXHRcdCctKGI2KSc6IFsgMCwgMywgNywgOCBdLFxuXHRcdCctYjYnOiBbIDAsIDMsIDcsIDggXSxcblx0XHQnLTYvOSc6IFsgMCwgMywgNywgOSwgMTQgXSxcblx0XHQnLTcoYjkpJzogWyAwLCAzLCA3LCAxMCwgMTMgXSxcblx0XHQnLTdiOSc6IFsgMCwgMywgNywgMTAsIDEzIF0sXG5cdFx0Jy1tYWo3JzogWyAwLCAzLCA3LCAxMSBdLFxuXHRcdCctOSs3JzogWyAwLCAzLCA3LCAxMSwgMTMgXSxcblx0XHQnLTExJzogWyAgMCwgMywgNywgMTEsIDE0LCAxNiBdLFxuXG5cdFx0Ly8gbWFqb3IgKGFsbCBub3JtYWwgNSwgbWFqb3IgMyBjaG9yZHMpXG5cdFx0J00nOiBbIDAsIDQsIDcgXSxcblx0XHQnNic6IFsgMCwgNCwgNywgOSBdLFxuXHRcdCc2LzknOiBbIDAsIDQsIDcsIDksIDE0IF0sXG5cblx0XHQnNyc6IFsgMCwgNCwgNywgMTAgXSxcblx0XHQnOSc6IFsgMCwgNCwgNywgMTAsIDE0IF0sXG5cdFx0JzExJzogWyAwLCA0LCA3LCAxMCwgMTQsIDE2IF0sXG5cdFx0JzEzJzogWyAwLCA0LCA3LCAxMCwgMTQsIDE4IF0sXG5cdFx0JzdiOSc6IFsgMCwgNCwgNywgMTAsIDEzIF0sXG5cdFx0Jzfima05JzogWyAwLCA0LCA3LCAxMCwgMTMgXSxcblx0XHQnNyhiOSknOiBbIDAsIDQsIDcsIDEwLCAxMyBdLFxuXHRcdCc3KCM5KSc6IFsgMCwgNCwgNywgMTAsIDE1IF0sXG5cdFx0JzcjOSc6IFsgMCwgNCwgNywgMTAsIDE1IF0sXG5cdFx0JygxMyknOiBbIDAsIDQsIDcsIDEwLCAxNCwgMTggXSxcblx0XHQnNyg5LDEzKSc6IFsgMCwgNCwgNywgMTAsIDE0LCAxOCBdLFxuXHRcdCc3KCM5LGIxMyknOiBbIDAsIDQsIDcsIDEwLCAxNSwgMTcgXSxcblx0XHQnNygjMTEpJzogWyAwLCA0LCA3LCAxMCwgMTQsIDE3IF0sXG5cdFx0JzcjMTEnOiBbIDAsIDQsIDcsIDEwLCAxNCwgMTcgXSxcblx0XHQnNyhiMTMpJzogWyAwLCA0LCA3LCAxMCwgMTcgXSxcblx0XHQnN2IxMyc6IFsgMCwgNCwgNywgMTAsIDE3IF0sXG5cdFx0JzkoIzExKSc6IFsgMCwgNCwgNywgMTAsIDE0LCAxNyBdLFxuXHRcdCc5IzExJzogWyAwLCA0LCA3LCAxMCwgMTQsIDE3IF0sXG5cdFx0JzEzKCMxMSknOiBbIDAsIDQsIDcsIDEwLCAxNSwgMTggXSxcblx0XHQnMTMjMTEnOiBbIDAsIDQsIDcsIDEwLCAxNSwgMTggXSxcblxuXHRcdCdtYWo3JzogWyAwLCA0LCA3LCAxMSBdLFxuXHRcdCfiiIY3JzogWyAwLCA0LCA3LCAxMSBdLFxuXHRcdCfOlDcnOiBbIDAsIDQsIDcsIDExIF0sXG5cdFx0J21hajknOiBbIDAsIDQsIDcsIDExLCAxNCBdLFxuXHRcdCdtYWo3KDkpJzogWyAwLCA0LCA3LCAxMSwgMTQgXSxcblx0XHQnbWFqNygxMSknOiBbIDAsIDQsIDcsIDExLCAxNiBdLFxuXHRcdCdtYWo3KCMxMSknOiBbIDAsIDQsIDcsIDExLCAxNyBdLFxuXHRcdCdtYWo3KDEzKSc6IFsgMCwgNCwgNywgMTEsIDE4IF0sXG5cdFx0J21hajcoOSwxMyknOiBbIDAsIDQsIDcsIDExLCAxNCwgMTggXSxcblxuXHRcdCc3c3VzNCc6IFsgMCwgNSwgNywgMTAgXSxcblx0XHQnbTdzdXM0JzogWyAwLCA1LCA3LCAxMCBdLFxuXHRcdCdzdXM0JzogWyAwLCA1LCA3IF0sXG5cdFx0J3N1czInOiBbIDAsIDIsIDcgXSxcblx0XHQnN3N1czInOiBbIDAsIDIsIDcsIDEwIF0sXG5cdFx0JzlzdXM0JzogWyAwLCA1LCA3LCAxNCBdLFxuXHRcdCcxM3N1czQnOiBbIDAsIDUsIDcsIDE4IF0sXG5cblx0XHQvLyBhdWdtZW50ZWQgKGFsbCBzaGFycCA1IGNob3Jkcylcblx0XHQnYXVnNyc6IFsgMCwgNCwgOCwgMTAgXSxcblx0XHQnKzcnOiBbIDAsIDQsIDgsIDEwIF0sXG5cdFx0JysnOiBbIDAsIDQsIDggXSxcblx0XHQnNyM1JzogWyAwLCA0LCA4LCAxMCBdLFxuXHRcdCc34pmvNSc6IFsgMCwgNCwgOCwgMTAgXSxcblx0XHQnNys1JzogWyAwLCA0LCA4LCAxMCBdLFxuXHRcdCc5IzUnOiBbIDAsIDQsIDgsIDEwLCAxNCBdLFxuXHRcdCc54pmvNSc6IFsgMCwgNCwgOCwgMTAsIDE0IF0sXG5cdFx0JzkrNSc6IFsgMCwgNCwgOCwgMTAsIDE0IF0sXG5cdFx0Jy03KCM1KSc6IFsgMCwgMywgOCwgMTAgXSxcblx0XHQnLTcjNSc6IFsgMCwgMywgOCwgMTAgXSxcblx0XHQnNygjNSknOiBbIDAsIDQsIDgsIDEwIF0sXG5cdFx0JzcoYjksIzUpJzogWyAwLCA0LCA4LCAxMCwgMTMgXSxcblx0XHQnN2I5IzUnOiBbIDAsIDQsIDgsIDEwLCAxMyBdLFxuXHRcdCdtYWo3KCM1KSc6IFsgMCwgNCwgOCwgMTEgXSxcblx0XHQnbWFqNyM1JzogWyAwLCA0LCA4LCAxMSBdLFxuXHRcdCdtYWo3KCM1LCMxMSknOiBbIDAsIDQsIDgsIDExLCAxNCBdLFxuXHRcdCdtYWo3IzUjMTEnOiBbIDAsIDQsIDgsIDExLCAxNCBdLFxuXHRcdCc5KCM1KSc6IFsgMCwgNCwgOCwgMTAsIDE0IF0sXG5cdFx0JzEzKCM1KSc6IFsgMCwgNCwgOCwgMTAsIDE0LCAxOCBdLFxuXHRcdCcxMyM1JzogWyAwLCA0LCA4LCAxMCwgMTQsIDE4IF1cbn07XG5cdGZ1bmN0aW9uIGNob3JkTm90ZXMoYmFzcywgbW9kaWZpZXIpIHtcblx0XHR2YXIgaW50ZXJ2YWxzID0gY2hvcmRJbnRlcnZhbHNbbW9kaWZpZXJdO1xuXHRcdGlmICghaW50ZXJ2YWxzKVxuXHRcdFx0aW50ZXJ2YWxzID0gY2hvcmRJbnRlcnZhbHMuTTtcblx0XHRiYXNzICs9IDEyO1x0Ly8gdGhlIGNob3JkIGlzIGFuIG9jdGF2ZSBhYm92ZSB0aGUgYmFzcyBub3RlLlxuXHRcdHZhciBub3RlcyA9IFsgXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGludGVydmFscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bm90ZXMucHVzaChiYXNzICsgaW50ZXJ2YWxzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vdGVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVCb29tKGJvb20sIGJlYXRMZW5ndGgpIHtcblx0XHQvLyB1bmRlZmluZWQgbWVhbnMgdGhlcmUgaXMgYSBzdG9wIHRpbWUuXG5cdFx0aWYgKGJvb20gIT09IHVuZGVmaW5lZClcblx0XHRcdGNob3JkVHJhY2sucHVzaCh7Y21kOiAnc3RhcnQnLCBwaXRjaDogYm9vbSwgdm9sdW1lOiA2NH0pO1xuXHRcdGNob3JkVHJhY2sucHVzaCh7IGNtZDogJ21vdmUnLCBkdXJhdGlvbjogKGJlYXRMZW5ndGgvMikqdGVtcG9DaGFuZ2VGYWN0b3IgfSk7XG5cdFx0aWYgKGJvb20gIT09IHVuZGVmaW5lZClcblx0XHRcdGNob3JkVHJhY2sucHVzaCh7IGNtZDogJ3N0b3AnLCBwaXRjaDogYm9vbSB9KTtcblx0XHRjaG9yZFRyYWNrLnB1c2goeyBjbWQ6ICdtb3ZlJywgZHVyYXRpb246IChiZWF0TGVuZ3RoLzIpKnRlbXBvQ2hhbmdlRmFjdG9yIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVDaGljayhjaGljaywgYmVhdExlbmd0aCkge1xuXHRcdGZvciAodmFyIGMgPSAwOyBjIDwgY2hpY2subGVuZ3RoOyBjKyspXG5cdFx0XHRjaG9yZFRyYWNrLnB1c2goe2NtZDogJ3N0YXJ0JywgcGl0Y2g6IGNoaWNrW2NdLCB2b2x1bWU6IDQ4fSk7XG5cdFx0Y2hvcmRUcmFjay5wdXNoKHsgY21kOiAnbW92ZScsIGR1cmF0aW9uOiAoYmVhdExlbmd0aC8yKSp0ZW1wb0NoYW5nZUZhY3RvciB9KTtcblx0XHRmb3IgKGMgPSAwOyBjIDwgY2hpY2subGVuZ3RoOyBjKyspXG5cdFx0XHRjaG9yZFRyYWNrLnB1c2goeyBjbWQ6ICdzdG9wJywgcGl0Y2g6IGNoaWNrW2NdIH0pO1xuXHRcdGNob3JkVHJhY2sucHVzaCh7IGNtZDogJ21vdmUnLCBkdXJhdGlvbjogKGJlYXRMZW5ndGgvMikqdGVtcG9DaGFuZ2VGYWN0b3IgfSk7XG5cdH1cblxuXHR2YXIgcmh5dGhtUGF0dGVybnMgPSB7IFwiMi8yXCI6IFsgJ2Jvb20nLCAnY2hpY2snIF0sXG5cdFx0XCIyLzRcIjogWyAnYm9vbScsICdjaGljaycgXSxcblx0XHRcIjMvNFwiOiBbICdib29tJywgJ2NoaWNrJywgJ2NoaWNrJyBdLFxuXHRcdFwiNC80XCI6IFsgJ2Jvb20nLCAnY2hpY2snLCAnYm9vbTInLCAnY2hpY2snIF0sXG5cdFx0XCI1LzRcIjogWyAnYm9vbScsICdjaGljaycsICdjaGljaycsICdib29tMicsICdjaGljaycgXSxcblx0XHRcIjYvOFwiOiBbICdib29tJywgJycsICdjaGljaycsICdib29tMicsICcnLCAnY2hpY2snIF0sXG5cdFx0XCI5LzhcIjogWyAnYm9vbScsICcnLCAnY2hpY2snLCAnYm9vbTInLCAnJywgJ2NoaWNrJywgJ2Jvb20yJywgJycsICdjaGljaycgXSxcblx0XHRcIjEyLzhcIjogWyAnYm9vbScsICcnLCAnY2hpY2snLCAnYm9vbTInLCAnJywgJ2NoaWNrJywgJ2Jvb20yJywgJycsICdjaGljaycsICdib29tMicsICcnLCAnY2hpY2snIF0sXG5cdH07XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUNob3JkcygpIHtcblx0XHR2YXIgbnVtID0gbWV0ZXIubnVtO1xuXHRcdHZhciBkZW4gPSBtZXRlci5kZW47XG5cdFx0dmFyIGJlYXRMZW5ndGggPSAxL2Rlbjtcblx0XHR2YXIgcGF0dGVybiA9IHJoeXRobVBhdHRlcm5zW251bSsnLycrZGVuXTtcblx0XHR2YXIgdGhpc01lYXN1cmVMZW5ndGggPSBwYXJzZUludChudW0sMTApL3BhcnNlSW50KGRlbiwxMCk7XG5cdFx0Ly8gU2VlIGlmIHRoaXMgaXMgYSBmdWxsIG1lYXN1cmU6IHVuZm9ydHVuYXRlbHksIHdpdGggdHJpcGxldHMsIHRoZXJlIGlzbid0IGFuIGV4YWN0IG1hdGNoLCB3aGF0IHdpdGggdGhlIGZsb2F0aW5nIHBvaW50LCBzbyB3ZSBqdXN0IHNlZSBpZiBpdCBpcyBcImNsb3NlXCIuXG5cdFx0dmFyIHBvcnRpb25PZkFNZWFzdXJlID0gTWF0aC5hYnModGhpc01lYXN1cmVMZW5ndGggLSBiYXJCZWF0KTtcblx0XHRpZiAoIXBhdHRlcm4gfHwgcG9ydGlvbk9mQU1lYXN1cmUgPiAwLjAwNzgxMjUpIHsgLy8gSWYgaXQgaXMgYW4gdW5zdXBwb3J0ZWQgbWV0ZXIsIG9yIHRoaXMgaXNuJ3QgYSBmdWxsIGJhciwganVzdCBjaGljayBvbiBlYWNoIGJlYXQuXG5cdFx0XHRwYXR0ZXJuID0gW107XG5cdFx0XHR2YXIgYmVhdHNQcmVzZW50ID0gYmFyQmVhdCAvIGJlYXRMZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBwID0gMDsgcCA8IGJlYXRzUHJlc2VudDsgcCsrKVxuXHRcdFx0XHRwYXR0ZXJuLnB1c2goXCJjaGlja1wiKTtcblx0XHR9XG5cblx0XHRpZiAoY3VycmVudENob3Jkcy5sZW5ndGggPT09IDApIHsgLy8gdGhlcmUgd2Fzbid0IGEgbmV3IGNob3JkIHRoaXMgbWVhc3VyZSwgc28gdXNlIHRoZSBsYXN0IGNob3JkIGRlY2xhcmVkLlxuXHRcdFx0Y3VycmVudENob3Jkcy5wdXNoKHsgYmVhdDogMCwgY2hvcmQ6IGxhc3RDaG9yZH0pO1xuXHRcdH1cblx0XHRpZiAoY3VycmVudENob3Jkc1swXS5iZWF0ICE9PSAwICYmIGxhc3RDaG9yZCkgeyAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGEgY2hvcmQgZGVjbGFyZWQgaW4gdGhlIG1lYXN1cmUsIGJ1dCBub3Qgb24gaXRzIGZpcnN0IGJlYXQuXG5cdFx0XHRjdXJyZW50Q2hvcmRzLnVuc2hpZnQoeyBiZWF0OiAwLCBjaG9yZDogbGFzdENob3JkfSk7XG5cdFx0fVxuXHRcdGlmIChjdXJyZW50Q2hvcmRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0Zm9yICh2YXIgbSA9IDA7IG0gPCBwYXR0ZXJuLmxlbmd0aDsgbSsrKSB7XG5cdFx0XHRcdHN3aXRjaCAocGF0dGVyblttXSkge1xuXHRcdFx0XHRcdGNhc2UgJ2Jvb20nOlxuXHRcdFx0XHRcdFx0d3JpdGVCb29tKGN1cnJlbnRDaG9yZHNbMF0uY2hvcmQuYm9vbSwgYmVhdExlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdib29tMic6XG5cdFx0XHRcdFx0XHR3cml0ZUJvb20oY3VycmVudENob3Jkc1swXS5jaG9yZC5ib29tMiwgYmVhdExlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjaGljayc6XG5cdFx0XHRcdFx0XHR3cml0ZUNoaWNrKGN1cnJlbnRDaG9yZHNbMF0uY2hvcmQuY2hpY2ssIGJlYXRMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0XHRcdGNob3JkVHJhY2sucHVzaCh7IGNtZDogJ21vdmUnLCBkdXJhdGlvbjogYmVhdExlbmd0aCp0ZW1wb0NoYW5nZUZhY3RvciB9KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgYXJlIGhlcmUgaXQgaXMgYmVjYXVzZSBtb3JlIHRoYW4gb25lIGNob3JkIHdhcyBkZWNsYXJlZCBpbiB0aGUgbWVhc3VyZSwgc28gd2UgaGF2ZSB0byBzb3J0IG91dCB3aGF0IGNob3JkIGdvZXMgd2hlcmUuXG5cblx0XHQvLyBGaXJzdCwgbm9ybWFsaXplIHRoZSBjaG9yZHMgb24gYmVhdHMuXG5cdFx0dmFyIGJlYXRzID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50Q2hvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2MgPSBjdXJyZW50Q2hvcmRzW2ldO1xuXHRcdFx0dmFyIGJlYXQgPSBNYXRoLmZsb29yKGNjLmJlYXQgLyBiZWF0TGVuZ3RoKTtcdC8vIG5vdyBhbGwgdGhlIGJlYXRzIGFyZSBpbnRlZ2VycywgdGhlcmUgbWF5IGJlXG5cdFx0XHRiZWF0c1snJytiZWF0XSA9IGNjO1xuXHRcdH1cblxuXHRcdC8vIC0gSWYgdGhlcmUgaXMgYSBjaG9yZCBvbiB0aGUgc2Vjb25kIGJlYXQsIHBsYXkgYSBjaG9yZCBmb3IgdGhlIGZpcnN0IGJlYXQgaW5zdGVhZCBvZiBhIGJhc3Mgbm90ZS5cblx0XHQvLyAtIExpa2V3aXNlLCBpZiB0aGVyZSBpcyBhIGNob3JkIG9uIHRoZSBmb3VydGggYmVhdCBvZiA0LzQsIHBsYXkgYSBjaG9yZCBvbiB0aGUgdGhpcmQgYmVhdCBpbnN0ZWFkIG9mIGEgYmFzcyBub3RlLlxuXHRcdGZvciAodmFyIG0yID0gMDsgbTIgPCBwYXR0ZXJuLmxlbmd0aDsgbTIrKykge1xuXHRcdFx0dmFyIHRoaXNDaG9yZDtcblx0XHRcdGlmIChiZWF0c1snJyttMl0pXG5cdFx0XHRcdHRoaXNDaG9yZCA9IGJlYXRzWycnK20yXTtcblx0XHRcdHN3aXRjaCAocGF0dGVyblttMl0pIHtcblx0XHRcdFx0Y2FzZSAnYm9vbSc6XG5cdFx0XHRcdFx0aWYgKGJlYXRzWycnKyhtMisxKV0pIC8vIElmIHRoZXJlIGlzIG5vdCBhIGNob3JkIGNoYW5nZSBvbiB0aGUgbmV4dCBiZWF0LCBwbGF5IGEgYmFzcyBub3RlLlxuXHRcdFx0XHRcdFx0d3JpdGVDaGljayh0aGlzQ2hvcmQuY2hvcmQuY2hpY2ssIGJlYXRMZW5ndGgpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHdyaXRlQm9vbSh0aGlzQ2hvcmQuY2hvcmQuYm9vbSwgYmVhdExlbmd0aCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2Jvb20yJzpcblx0XHRcdFx0XHRpZiAoYmVhdHNbJycrKG0yKzEpXSlcblx0XHRcdFx0XHRcdHdyaXRlQ2hpY2sodGhpc0Nob3JkLmNob3JkLmNoaWNrLCBiZWF0TGVuZ3RoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR3cml0ZUJvb20odGhpc0Nob3JkLmNob3JkLmJvb20yLCBiZWF0TGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnY2hpY2snOlxuXHRcdFx0XHRcdHdyaXRlQ2hpY2sodGhpc0Nob3JkLmNob3JkLmNoaWNrLCBiZWF0TGVuZ3RoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnJzpcblx0XHRcdFx0XHRpZiAoYmVhdHNbJycrbTJdKVx0Ly8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgY2hvcmQgb24gdGhpcyBiZWF0LCBwbGF5IGl0LlxuXHRcdFx0XHRcdFx0d3JpdGVDaGljayh0aGlzQ2hvcmQuY2hvcmQuY2hpY2ssIGJlYXRMZW5ndGgpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdGNob3JkVHJhY2sucHVzaCh7Y21kOiAnbW92ZScsIGR1cmF0aW9uOiBiZWF0TGVuZ3RoKnRlbXBvQ2hhbmdlRmFjdG9yIH0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZURydW1EZWZpbml0aW9uKHBhcmFtcykge1xuXHRcdC8vIEJlIHZlcnkgc3RyaWN0IHdpdGggdGhlIGRydW0gZGVmaW5pdGlvbi4gSWYgYW55dGhpbmcgaXMgbm90IHBlcmZlY3QsXG5cdFx0Ly8ganVzdCB0dXJuIHRoZSBkcnVtcyBvZmYuXG5cdFx0Ly8gUGVyaGFwcyBhbGwgb2YgdGhpcyBsb2dpYyBiZWxvbmdzIGluIHRoZSBwYXJzZXIgaW5zdGVhZC5cblx0XHRpZiAocGFyYW1zLnBhdHRlcm4ubGVuZ3RoID09PSAwIHx8IHBhcmFtcy5vbiA9PT0gZmFsc2UpXG5cdFx0XHRyZXR1cm4geyBvbjogZmFsc2UgfTtcblxuXHRcdHZhciBzdHIgPSBwYXJhbXMucGF0dGVyblswXTtcblx0XHR2YXIgZXZlbnRzID0gW107XG5cdFx0dmFyIGV2ZW50ID0gXCJcIjtcblx0XHR2YXIgdG90YWxQbGF5ID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHN0cltpXSA9PT0gJ2QnKVxuXHRcdFx0XHR0b3RhbFBsYXkrKztcblx0XHRcdGlmIChzdHJbaV0gPT09ICdkJyB8fCBzdHJbaV0gPT09ICd6Jykge1xuXHRcdFx0XHRpZiAoZXZlbnQubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdFx0ZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdGV2ZW50ID0gc3RyW2ldO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRldmVudCA9IGV2ZW50ICsgc3RyW2ldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGV2ZW50Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIHRoZXJlIHdhcyBhbiBlcnJvcjogdGhlIHN0cmluZyBzaG91bGQgaGF2ZSBzdGFydGVkIHdpdGggZCBvciB6XG5cdFx0XHRcdFx0cmV0dXJuIHtvbjogZmFsc2V9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50ID0gZXZlbnQgKyBzdHJbaV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50Lmxlbmd0aCAhPT0gMClcblx0XHRcdGV2ZW50cy5wdXNoKGV2ZW50KTtcblxuXHRcdC8vIE5vdyB0aGUgZXZlbnRzIGFycmF5IHNob3VsZCBoYXZlIG9uZSBpdGVtIHBlciBldmVudC5cblx0XHQvLyBUaGVyZSBzaG91bGQgYmUgdHdvIG1vcmUgcGFyYW1zIGZvciBlYWNoIGV2ZW50OiB0aGUgdm9sdW1lIGFuZCB0aGUgcGl0Y2guXG5cdFx0aWYgKHBhcmFtcy5wYXR0ZXJuLmxlbmd0aCAhPT0gdG90YWxQbGF5KjIgKyAxKVxuXHRcdFx0cmV0dXJuIHsgb246IGZhbHNlIH07XG5cblx0XHR2YXIgcmV0ID0geyBvbjogdHJ1ZSwgYmFyczogcGFyYW1zLmJhcnMsIHBhdHRlcm46IFtdfTtcblx0XHR2YXIgYmVhdExlbmd0aCA9IDEvbWV0ZXIuZGVuO1xuXHRcdHZhciBwbGF5Q291bnQgPSAwO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRldmVudCA9IGV2ZW50c1tqXTtcblx0XHRcdHZhciBsZW4gPSAxO1xuXHRcdFx0dmFyIGRpdiA9IGZhbHNlO1xuXHRcdFx0dmFyIG51bSA9IDA7XG5cdFx0XHRmb3IgKHZhciBrID0gMTsgayA8IGV2ZW50Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdHN3aXRjaChldmVudFtrXSkge1xuXHRcdFx0XHRcdGNhc2UgXCIvXCI6XG5cdFx0XHRcdFx0XHRpZiAobnVtICE9PSAwKVxuXHRcdFx0XHRcdFx0XHRsZW4gKj0gbnVtO1xuXHRcdFx0XHRcdFx0bnVtID0gMDtcblx0XHRcdFx0XHRcdGRpdiA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiMVwiOlxuXHRcdFx0XHRcdGNhc2UgXCIyXCI6XG5cdFx0XHRcdFx0Y2FzZSBcIjNcIjpcblx0XHRcdFx0XHRjYXNlIFwiNFwiOlxuXHRcdFx0XHRcdGNhc2UgXCI1XCI6XG5cdFx0XHRcdFx0Y2FzZSBcIjZcIjpcblx0XHRcdFx0XHRjYXNlIFwiN1wiOlxuXHRcdFx0XHRcdGNhc2UgXCI4XCI6XG5cdFx0XHRcdFx0Y2FzZSBcIjlcIjpcblx0XHRcdFx0XHRcdG51bSA9IG51bSoxMCArZXZlbnRba107XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHsgb246IGZhbHNlIH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXYpIHtcblx0XHRcdFx0aWYgKG51bSA9PT0gMCkgbnVtID0gMjsgLy8gYSBzbGFzaCBieSBpdHNlbGYgaXMgaW50ZXJwcmV0ZWQgYXMgXCIvMlwiXG5cdFx0XHRcdGxlbiAvPSBudW07XG5cdFx0XHR9IGVsc2UgaWYgKG51bSlcblx0XHRcdFx0bGVuICo9IG51bTtcblx0XHRcdGlmIChldmVudFswXSA9PT0gJ2QnKSB7XG5cdFx0XHRcdHJldC5wYXR0ZXJuLnB1c2goeyBsZW46IGxlbiAqIGJlYXRMZW5ndGgsIHBpdGNoOiBwYXJhbXMucGF0dGVyblsxICsgcGxheUNvdW50XSwgdmVsb2NpdHk6IHBhcmFtcy5wYXR0ZXJuWzEgKyBwbGF5Q291bnQgKyB0b3RhbFBsYXldfSk7XG5cdFx0XHRcdHBsYXlDb3VudCsrO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHJldC5wYXR0ZXJuLnB1c2goeyBsZW46IGxlbiAqIGJlYXRMZW5ndGgsIHBpdGNoOiBudWxsfSk7XG5cdFx0fVxuXHRcdC8vIE5vdyBub3JtYWxpemUgdGhlIHBhdHRlcm4gdG8gY292ZXIgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIG1lYXN1cmVzLiBUaGUgbm90ZSBsZW5ndGhzIHBhc3NlZCBhcmUgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciBhbmQgbmVlZCB0byBiZSBzY2FsZWQgdG8gZml0IGEgbWVhc3VyZS5cblx0XHR2YXIgdG90YWxUaW1lID0gMDtcblx0XHR2YXIgbWVhc3VyZXNQZXJCZWF0ID0gbWV0ZXIubnVtL21ldGVyLmRlbjtcblx0XHRmb3IgKHZhciBpaSA9IDA7IGlpIDwgcmV0LnBhdHRlcm4ubGVuZ3RoOyBpaSsrKVxuXHRcdFx0dG90YWxUaW1lICs9IHJldC5wYXR0ZXJuW2lpXS5sZW47XG5cdFx0dmFyIG51bUJhcnMgPSBwYXJhbXMuYmFycyA/IHBhcmFtcy5iYXJzIDogMTtcblx0XHR2YXIgZmFjdG9yID0gdG90YWxUaW1lIC8gIG51bUJhcnMgLyBtZWFzdXJlc1BlckJlYXQ7XG5cdFx0Zm9yIChpaSA9IDA7IGlpIDwgcmV0LnBhdHRlcm4ubGVuZ3RoOyBpaSsrKVxuXHRcdFx0cmV0LnBhdHRlcm5baWldLmxlbiA9IHJldC5wYXR0ZXJuW2lpXS5sZW4gLyBmYWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRydW1CZWF0KHBpdGNoLCBzb3VuZExlbmd0aCwgdm9sdW1lKSB7XG5cdFx0ZHJ1bVRyYWNrLnB1c2goeyBjbWQ6ICdzdGFydCcsIHBpdGNoOiBwaXRjaCAtIDYwLCB2b2x1bWU6IHZvbHVtZX0pO1xuXHRcdGRydW1UcmFjay5wdXNoKHsgY21kOiAnbW92ZScsIGR1cmF0aW9uOiBzb3VuZExlbmd0aCB9KTtcblx0XHRkcnVtVHJhY2sucHVzaCh7IGNtZDogJ3N0b3AnLCBwaXRjaDogcGl0Y2ggLSA2MCB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHdyaXRlRHJ1bShjaGFubmVsKSB7XG5cdFx0aWYgKGRydW1UcmFjay5sZW5ndGggPT09IDAgJiYgIWRydW1EZWZpbml0aW9uLm9uKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIG1lYXN1cmVMZW4gPSBtZXRlci5udW0vbWV0ZXIuZGVuO1xuXHRcdGlmIChkcnVtVHJhY2subGVuZ3RoID09PSAwKSB7XG5cdFx0XHRkcnVtVHJhY2sucHVzaCh7Y21kOiAncHJvZ3JhbScsIGNoYW5uZWw6IGNoYW5uZWwsIGluc3RydW1lbnQ6IGRydW1JbnN0cnVtZW50fSk7XG5cdFx0XHQvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IGZhciBpbiB0aW1lIHRoZSBiYXIgc3RhcnRlZDogaWYgdGhlcmUgYXJlIHBpY2t1cCBub3RlcyBiZWZvcmUgdGhlIGNob3JkcyBzdGFydCwgd2UgbmVlZCBwYXVzZXMuXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSB0aW1lRnJvbVN0YXJ0KCk7XG5cdFx0XHRpZiAoZGlzdGFuY2UgPiAwICYmIGRpc3RhbmNlIDwgbWVhc3VyZUxlbiAtIDAuMDEpIHsgLy8gYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCwgYWRkaW5nIHRoZSBub3RlcyBtaWdodCBub3QgZXhhY3RseSBlcXVhbCB0aGUgbWVhc3VyZSBzaXplLlxuXHRcdFx0XHRkcnVtVHJhY2sucHVzaCh7Y21kOiAnbW92ZScsIGR1cmF0aW9uOiBkaXN0YW5jZSAqIHRlbXBvQ2hhbmdlRmFjdG9yfSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWRydW1EZWZpbml0aW9uLm9uKSB7XG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGhhcyBiZWVuIGEgZHJ1bSB0cmFjaywgYnV0IGl0IHdhcyBzcGVjaWZpY2FsbHkgdHVybmVkIG9mZi5cblx0XHRcdGRydW1UcmFjay5wdXNoKHsgY21kOiAnbW92ZScsIGR1cmF0aW9uOiBtZWFzdXJlTGVuICogdGVtcG9DaGFuZ2VGYWN0b3IgfSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZHJ1bURlZmluaXRpb24ucGF0dGVybi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxlbiA9IGRydW1EZWZpbml0aW9uLnBhdHRlcm5baV0ubGVuICogdGVtcG9DaGFuZ2VGYWN0b3I7XG5cdFx0XHRpZiAoZHJ1bURlZmluaXRpb24ucGF0dGVybltpXS5waXRjaClcblx0XHRcdFx0ZHJ1bUJlYXQoZHJ1bURlZmluaXRpb24ucGF0dGVybltpXS5waXRjaCwgbGVuLCBkcnVtRGVmaW5pdGlvbi5wYXR0ZXJuW2ldLnZlbG9jaXR5KTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0ZHJ1bVRyYWNrLnB1c2goeyBjbWQ6ICdtb3ZlJywgZHVyYXRpb246IGxlbiB9KTtcblx0XHR9XG5cdH1cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsIi8vICAgIGFiY19taWRpX3NlcXVlbmNlci5qczogVHVybiBwYXJzZWQgYWJjIGludG8gYSBsaW5lYXIgc2VyaWVzIG9mIGV2ZW50cy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHNlcXVlbmNlO1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBtZWFzdXJlTGVuZ3RoO1xuXHQvLyBUaGUgYWJjIGlzIHByb3ZpZGVkIHRvIHVzIGxpbmUgYnkgbGluZS4gSXQgbWlnaHQgaGF2ZSByZXBlYXRzIGluIGl0LiBXZSB3YW50IHRvIHJlIGFycmFuZ2UgdGhlIGVsZW1lbnRzIHRvXG5cdC8vIGJlIGFuIGFycmF5IG9mIHZvaWNlcyB3aXRoIGFsbCB0aGUgcmVwZWF0cyBlbWJlZGRlZCwgYW5kIG5vIGxpbmVzLiBUaGVuIGl0IGlzIHRyaXZpYWwgdG8gZ28gdGhyb3VnaCB0aGUgZXZlbnRzXG5cdC8vIG9uZSBhdCBhIHRpbWUgYW5kIHR1cm4gaXQgaW50byBtaWRpLlxuXG5cdHZhciBQRVJDVVNTSU9OX1BST0dSQU0gPSAxMjg7XG5cblx0c2VxdWVuY2UgPSBmdW5jdGlvbihhYmN0dW5lLCBvcHRpb25zKSB7XG5cdFx0Ly8gR2xvYmFsIG9wdGlvbnNcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgcXBtID0gdW5kZWZpbmVkO1xuXHRcdHZhciBwcm9ncmFtID0gb3B0aW9ucy5wcm9ncmFtIHx8IDA7XHQvLyBUaGUgcHJvZ3JhbSBpZiB0aGVyZSBpc24ndCBhIHByb2dyYW0gc3BlY2lmaWVkLlxuXHRcdHZhciB0cmFuc3Bvc2UgPSBvcHRpb25zLm1pZGlUcmFuc3Bvc2UgfHwgMDtcblx0XHR2YXIgY2hhbm5lbCA9IG9wdGlvbnMuY2hhbm5lbCB8fCAwO1xuXHRcdHZhciBkcnVtUGF0dGVybiA9IG9wdGlvbnMuZHJ1bSB8fCBcIlwiO1xuXHRcdHZhciBkcnVtQmFycyA9IG9wdGlvbnMuZHJ1bUJhcnMgfHwgMTtcblx0XHR2YXIgZHJ1bUludHJvID0gb3B0aW9ucy5kcnVtSW50cm8gfHwgMDtcblx0XHR2YXIgZHJ1bU9uID0gZHJ1bVBhdHRlcm4gIT09IFwiXCI7XG5cblx0XHQvLyBBbGwgb2YgdGhlIGFib3ZlIG92ZXJyaWRlcyBuZWVkIHRvIGJlIGludGVnZXJzXG5cdFx0cHJvZ3JhbSA9IHBhcnNlSW50KHByb2dyYW0sIDEwKTtcblx0XHR0cmFuc3Bvc2UgPSBwYXJzZUludCh0cmFuc3Bvc2UsIDEwKTtcblx0XHRjaGFubmVsID0gcGFyc2VJbnQoY2hhbm5lbCwgMTApO1xuXHRcdGlmIChjaGFubmVsID09PSAxMClcblx0XHRcdHByb2dyYW0gPSBQRVJDVVNTSU9OX1BST0dSQU07XG5cdFx0ZHJ1bVBhdHRlcm4gPSBkcnVtUGF0dGVybi5zcGxpdChcIiBcIik7XG5cdFx0ZHJ1bUJhcnMgPSBwYXJzZUludChkcnVtQmFycywgMTApO1xuXHRcdGRydW1JbnRybyA9IHBhcnNlSW50KGRydW1JbnRybywgMTApO1xuXG5cdFx0dmFyIGJhZ3BpcGVzID0gYWJjdHVuZS5mb3JtYXR0aW5nLmJhZ3BpcGVzOyAvLyBJZiBpdCBpcyBiYWdwaXBlcywgdGhlbiB0aGUgZ3JhY2Vub3RlcyBhcmUgcGxheWVkIG9uIHRvcCBvZiB0aGUgbWFpbiBub3RlLlxuXHRcdGlmIChiYWdwaXBlcylcblx0XHRcdHByb2dyYW0gPSA3MTtcblxuXHRcdC8vICUlTUlESSBmZXJtYXRhZml4ZWRcblx0XHQvLyAlJU1JREkgZmVybWF0YXByb3BvcnRpb25hbFxuXHRcdC8vICUlTUlESSBkZWx0YWxvdWRuZXNzIG5cblx0XHQvLyAlJU1JREkgZ3JhY2VkaXZpZGVyIGJcblx0XHQvLyAlJU1JREkgcmF0aW8gbiBtXG5cdFx0Ly8gJSVNSURJIGJlYXQgYSBiIGMgblxuXHRcdC8vICUlTUlESSBncmFjZSBhL2Jcblx0XHQvLyAlJU1JREkgdHJpbSB4L3lcblxuXHRcdC8vICVNSURJIGdjaG9yZG9uXG5cdFx0Ly8gJU1JREkgZ2Nob3Jkb2ZmXG5cdFx0Ly8gJSVNSURJIGJhc3Nwcm9nIDQ1XG5cdFx0Ly8gJSVNSURJIGNob3JkcHJvZyAyNFxuXHRcdC8vICUlTUlESSBjaG9yZG5hbWUgbmFtZSBuMSBuMiBuMyBuNCBuNSBuNlxuXG5cdFx0Ly8lJU1JREkgYmVhdCDin6hpbnQx4p+pIOKfqGludDLin6kg4p+oaW50M+KfqSDin6hpbnQ04p+pOiBjb250cm9scyB0aGUgdm9sdW1lcyBvZiB0aGUgbm90ZXMgaW4gYSBtZWFzdXJlLiBUaGUgZmlyc3Qgbm90ZSBpbiBhIGJhciBoYXMgdm9sdW1lIOKfqGludDHin6k7IG90aGVyIOKAmHN0cm9uZ+KAmSBub3RlcyBoYXZlIHZvbHVtZSDin6hpbnQy4p+pIGFuZCBhbGwgdGhlIHJlc3QgaGF2ZSB2b2x1bWUg4p+oaW50M+KfqS4gVGhlc2UgdmFsdWVzIG11c3QgYmUgaW4gdGhlIHJhbmdlIDDigJMxMjcuIFRoZSBwYXJhbWV0ZXIg4p+oaW50NOKfqSBkZXRlcm1pbmVzIHdoaWNoIG5vdGVzIGFyZSDigJhzdHJvbmfigJkuIElmIHRoZSB0aW1lIHNpZ25hdHVyZSBpcyB4L3ksIHRoZW4gZWFjaCBub3RlIGlzIGdpdmVuIGEgcG9zaXRpb24gbnVtYmVyIGsgPSAwLCAxLCAyLiAuIC4geC0xIHdpdGhpbiBlYWNoIGJhci4gSWYgayBpcyBhIG11bHRpcGxlIG9mIOKfqGludDTin6ksIHRoZW4gdGhlIG5vdGUgaXMg4oCYc3Ryb25n4oCZLlxuXG5cdFx0dmFyIHN0YXJ0aW5nTWlkaSA9IFtdO1xuXHRcdGlmIChhYmN0dW5lLmZvcm1hdHRpbmcubWlkaSkge1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIk1JREkgRm9ybWF0dGluZzpcIiwgYWJjdHVuZS5mb3JtYXR0aW5nLm1pZGkpO1xuXHRcdFx0dmFyIGdsb2JhbHMgPSBhYmN0dW5lLmZvcm1hdHRpbmcubWlkaTtcblx0XHRcdGlmIChnbG9iYWxzLnByb2dyYW0gJiYgZ2xvYmFscy5wcm9ncmFtLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cHJvZ3JhbSA9IGdsb2JhbHMucHJvZ3JhbVswXTtcblx0XHRcdFx0aWYgKGdsb2JhbHMucHJvZ3JhbS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0cHJvZ3JhbSA9IGdsb2JhbHMucHJvZ3JhbVsxXTtcblx0XHRcdFx0XHRjaGFubmVsID0gZ2xvYmFscy5wcm9ncmFtWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ2xvYmFscy50cmFuc3Bvc2UpXG5cdFx0XHRcdHRyYW5zcG9zZSA9IGdsb2JhbHMudHJhbnNwb3NlWzBdO1xuXHRcdFx0aWYgKGdsb2JhbHMuY2hhbm5lbClcblx0XHRcdFx0Y2hhbm5lbCA9IGdsb2JhbHMuY2hhbm5lbFswXTtcblx0XHRcdGlmIChnbG9iYWxzLmRydW0pXG5cdFx0XHRcdGRydW1QYXR0ZXJuID0gZ2xvYmFscy5kcnVtO1xuXHRcdFx0aWYgKGdsb2JhbHMuZHJ1bWJhcnMpXG5cdFx0XHRcdGRydW1CYXJzID0gZ2xvYmFscy5kcnVtYmFyc1swXTtcblx0XHRcdGlmIChnbG9iYWxzLmRydW1vbilcblx0XHRcdFx0ZHJ1bU9uID0gdHJ1ZTtcblx0XHRcdGlmIChjaGFubmVsID09PSAxMClcblx0XHRcdFx0cHJvZ3JhbSA9IFBFUkNVU1NJT05fUFJPR1JBTTtcblx0XHRcdGlmIChnbG9iYWxzLmJlYXQpXG5cdFx0XHRcdHN0YXJ0aW5nTWlkaS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogZ2xvYmFscy5iZWF0IH0pXG5cdFx0XHRpZiAoZ2xvYmFscy5ub2JlYXRhY2NlbnRzKVxuXHRcdFx0XHRzdGFydGluZ01pZGkucHVzaCh7IGVsX3R5cGU6ICdiZWF0YWNjZW50cycsIHZhbHVlOiBmYWxzZSB9KTtcblxuXHRcdH1cblxuXHRcdC8vIFNwZWNpZmllZCBvcHRpb25zIGluIGFiYyBzdHJpbmcuXG5cblx0XHQvLyBJZiB0aGUgdGVtcG8gd2FzIHBhc3NlZCBpbiwgdXNlIHRoYXQuXG5cdFx0Ly8gSWYgdGhlIHRlbXBvIGlzIHNwZWNpZmllZCwgdXNlIHRoYXQuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYSBkZWZhdWx0LCB1c2UgdGhhdC5cblx0XHQvLyBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdC5cblx0XHRpZiAob3B0aW9ucy5xcG0pXG5cdFx0XHRxcG0gPSBwYXJzZUludChvcHRpb25zLnFwbSwgMTApO1xuXHRcdGVsc2UgaWYgKGFiY3R1bmUubWV0YVRleHQudGVtcG8pXG5cdFx0XHRxcG0gPSBpbnRlcnByZXRUZW1wbyhhYmN0dW5lLm1ldGFUZXh0LnRlbXBvKTtcblx0XHRlbHNlIGlmIChvcHRpb25zLmRlZmF1bHRRcG0pXG5cdFx0XHRxcG0gPSBvcHRpb25zLmRlZmF1bHRRcG07XG5cdFx0ZWxzZVxuXHRcdFx0cXBtID0gMTgwOyBcdC8vIFRoZSB0ZW1wbyBpZiB0aGVyZSBpc24ndCBhIHRlbXBvIHNwZWNpZmllZC5cblxuXHRcdHZhciBzdGFydFZvaWNlID0gW107XG5cdFx0aWYgKGJhZ3BpcGVzKVxuXHRcdFx0c3RhcnRWb2ljZS5wdXNoKHsgZWxfdHlwZTogJ2JhZ3BpcGVzJyB9KTtcblx0XHRzdGFydFZvaWNlLnB1c2goeyBlbF90eXBlOiAnaW5zdHJ1bWVudCcsIHByb2dyYW06IHByb2dyYW0gfSk7XG5cdFx0aWYgKGNoYW5uZWwpXG5cdFx0XHRzdGFydFZvaWNlLnB1c2goeyBlbF90eXBlOiAnY2hhbm5lbCcsIGNoYW5uZWw6IGNoYW5uZWwgfSk7XG5cdFx0aWYgKHRyYW5zcG9zZSlcblx0XHRcdHN0YXJ0Vm9pY2UucHVzaCh7IGVsX3R5cGU6ICd0cmFuc3Bvc2UnLCB0cmFuc3Bvc2U6IHRyYW5zcG9zZSB9KTtcblx0XHRzdGFydFZvaWNlLnB1c2goeyBlbF90eXBlOiAndGVtcG8nLCBxcG06IHFwbSB9KTtcblx0XHRmb3IgKHZhciBzcyA9IDA7IHNzIDwgc3RhcnRpbmdNaWRpLmxlbmd0aDtzcysrKVxuXHRcdFx0c3RhcnRWb2ljZS5wdXNoKHN0YXJ0aW5nTWlkaVtzc10pO1xuXG5cdFx0Ly8gdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGlucHV0IHN0cnVjdHVyZSBpczpcblx0XHQvLyBhYmN0dW5lXG5cdFx0Ly9cdFx0YXJyYXkgbGluZXNcblx0XHQvL1x0XHRcdGFycmF5IHN0YWZmXG5cdFx0Ly9cdFx0XHRcdG9iamVjdCBrZXlcblx0XHQvL1x0XHRcdFx0b2JqZWN0IG1ldGVyXG5cdFx0Ly9cdFx0XHRcdGFycmF5IHZvaWNlc1xuXHRcdC8vXHRcdFx0XHRcdGFycmF5IGFiY2VsZW1cblxuXHRcdC8vIHZpc2l0IGVhY2ggdm9pY2UgY29tcGxldGVseSBpbiB0dXJuXG5cdFx0dmFyIHZvaWNlcyA9IFtdO1xuXHRcdHZhciBzdGFydFJlcGVhdFBsYWNlaG9sZGVyID0gW107IC8vIFRoZXJlIGlzIGEgcGxhY2UgaG9sZGVyIGZvciBlYWNoIHZvaWNlLlxuXHRcdHZhciBza2lwRW5kaW5nUGxhY2Vob2xkZXIgPSBbXTsgLy8gVGhpcyBpcyB0aGUgcGxhY2Ugd2hlcmUgdGhlIGZpcnN0IGVuZGluZyBzdGFydHMuXG5cdFx0dmFyIHN0YXJ0aW5nRHJ1bVNldCA9IGZhbHNlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYWJjdHVuZS5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZ3JvdXAgb2Ygc3RhZmYgbGluZXMgaW4gdGhlIHR1bmUuXG5cdFx0XHR2YXIgbGluZSA9IGFiY3R1bmUubGluZXNbaV07XG5cdFx0XHRpZiAobGluZS5zdGFmZikge1xuXHRcdFx0XHR2YXIgc3RhdmVzID0gbGluZS5zdGFmZjtcblx0XHRcdFx0dmFyIHZvaWNlTnVtYmVyID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzdGF2ZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHR2YXIgc3RhZmYgPSBzdGF2ZXNbal07XG5cdFx0XHRcdFx0Ly8gRm9yIGVhY2ggc3RhZmYgbGluZVxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc3RhZmYudm9pY2VzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHQvLyBGb3IgZWFjaCB2b2ljZSBpbiBhIHN0YWZmIGxpbmVcblx0XHRcdFx0XHRcdHZhciB2b2ljZSA9IHN0YWZmLnZvaWNlc1trXTtcblx0XHRcdFx0XHRcdGlmICghdm9pY2VzW3ZvaWNlTnVtYmVyXSkge1xuXHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdID0gW10uY29uY2F0KEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RhcnRWb2ljZSkpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzdGFmZi5jbGVmICYmIHN0YWZmLmNsZWYudHlwZSA9PT0gJ3BlcmMnKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGNsID0gMDsgY2wgPCB2b2ljZXNbdm9pY2VOdW1iZXJdLmxlbmd0aDsgY2wrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2b2ljZXNbdm9pY2VOdW1iZXJdW2NsXS5lbF90eXBlID09PSAnaW5zdHJ1bWVudCcpXG5cdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdW2NsXS5wcm9ncmFtID0gUEVSQ1VTU0lPTl9QUk9HUkFNO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YWZmLmtleSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RhZmYua2V5LnJvb3QgPT09ICdIUCcpXG5cdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHtlbF90eXBlOiAna2V5JywgYWNjaWRlbnRhbHM6IFt7YWNjOiAnbmF0dXJhbCcsIG5vdGU6ICdnJ30sIHthY2M6ICdzaGFycCcsIG5vdGU6ICdmJ30sIHthY2M6ICdzaGFycCcsIG5vdGU6ICdjJ31dfSk7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goe2VsX3R5cGU6ICdrZXknLCBhY2NpZGVudGFsczogc3RhZmYua2V5LmFjY2lkZW50YWxzIH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHN0YWZmLm1ldGVyKSB7XG5cdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaChpbnRlcnByZXRNZXRlcihzdGFmZi5tZXRlcikpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCFzdGFydGluZ0RydW1TZXQgJiYgZHJ1bU9uKSB7IC8vIGRydW0gaW5mb3JtYXRpb24gaXMgb25seSBuZWVkZWQgb25jZSwgc28gdXNlIHRoZSBmaXJzdCBsaW5lIGFuZCB0cmFjayAwLlxuXHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goe2VsX3R5cGU6ICdkcnVtJywgcGFyYW1zOiB7cGF0dGVybjogZHJ1bVBhdHRlcm4sIGJhcnM6IGRydW1CYXJzLCBvbjogZHJ1bU9uLCBpbnRybzogZHJ1bUludHJvfX0pO1xuXHRcdFx0XHRcdFx0XHRzdGFydGluZ0RydW1TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHN0YWZmLmNsZWYgJiYgc3RhZmYuY2xlZi50cmFuc3Bvc2UpIHtcblx0XHRcdFx0XHRcdFx0c3RhZmYuY2xlZi5lbF90eXBlID0gJ2NsZWYnO1xuXHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAndHJhbnNwb3NlJywgdHJhbnNwb3NlOiBzdGFmZi5jbGVmLnRyYW5zcG9zZSB9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChhYmN0dW5lLmZvcm1hdHRpbmcubWlkaSAmJiBhYmN0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtb2ZmKSB7XG5cdFx0XHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGEgZHJ1bSBvZmYgY29tbWFuZCByaWdodCBhdCB0aGUgYmVnaW5uaW5nIGl0IGlzIHB1dCBpbiB0aGUgbWV0YVRleHQgaW5zdGVhZCBvZiB0aGUgc3RyZWFtLFxuXHRcdFx0XHRcdFx0XHQvLyBzbyB3ZSB3aWxsIGp1c3QgaW5zZXJ0IGl0IGhlcmUuXG5cdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICdiYXInIH0pO1xuXHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goe2VsX3R5cGU6ICdkcnVtJywgcGFyYW1zOiB7cGF0dGVybjogXCJcIiwgb246IGZhbHNlIH19KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBub3RlRXZlbnRzSW5CYXIgPSAwO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgdiA9IDA7IHYgPCB2b2ljZS5sZW5ndGg7IHYrKykge1xuXHRcdFx0XHRcdFx0XHQvLyBGb3IgZWFjaCBlbGVtZW50IGluIGEgdm9pY2Vcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW0gPSB2b2ljZVt2XTtcblx0XHRcdFx0XHRcdFx0c3dpdGNoIChlbGVtLmVsX3R5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibm90ZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVndWxhciBpdGVtcyBhcmUganVzdCBwdXNoZWQuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWVsZW0ucmVzdCB8fCBlbGVtLnJlc3QudHlwZSAhPT0gJ3NwYWNlcicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW0uZGVjb3JhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbGVtLmRlY29yYXRpb24uaW5kZXhPZigncHBwJykgPj0gMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICdiZWF0JywgYmVhdHM6IFszMCwgMjAsIDEwLCAxXSB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChlbGVtLmRlY29yYXRpb24uaW5kZXhPZigncHAnKSA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogWzQ1LCAzNSwgMjAsIDFdIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGVsZW0uZGVjb3JhdGlvbi5pbmRleE9mKCdwJykgPj0gMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICdiZWF0JywgYmVhdHM6IFs2MCwgNTAsIDM1LCAxXSB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChlbGVtLmRlY29yYXRpb24uaW5kZXhPZignbXAnKSA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogWzc1LCA2NSwgNTAsIDFdIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGVsZW0uZGVjb3JhdGlvbi5pbmRleE9mKCdtZicpID49IDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAnYmVhdCcsIGJlYXRzOiBbOTAsIDgwLCA2NSwgMV0gfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoZWxlbS5kZWNvcmF0aW9uLmluZGV4T2YoJ2YnKSA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogWzEwNSwgOTUsIDgwLCAxXSB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChlbGVtLmRlY29yYXRpb24uaW5kZXhPZignZmYnKSA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogWzEyMCwgMTEwLCA5NSwgMV0gfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoZWxlbS5kZWNvcmF0aW9uLmluZGV4T2YoJ2ZmZicpID49IDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAnYmVhdCcsIGJlYXRzOiBbMTI3LCAxMjUsIDExMCwgMV0gfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKGVsZW0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub3RlRXZlbnRzSW5CYXIrKztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJrZXlcIjpcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbGVtLnJvb3QgPT09ICdIUCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7ZWxfdHlwZTogJ2tleScsIGFjY2lkZW50YWxzOiBbe2FjYzogJ25hdHVyYWwnLCBub3RlOiAnZyd9LCB7YWNjOiAnc2hhcnAnLCBub3RlOiAnZid9LCB7YWNjOiAnc2hhcnAnLCBub3RlOiAnYyd9XX0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goe2VsX3R5cGU6ICdrZXknLCBhY2NpZGVudGFsczogZWxlbS5hY2NpZGVudGFscyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJtZXRlclwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKGludGVycHJldE1ldGVyKGVsZW0pKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJjbGVmXCI6IC8vIG5lZWQgdG8ga2VlcCB0aGlzIHRvIGNhdGNoIHRoZSBcInRyYW5zcG9zZVwiIGVsZW1lbnQuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbS50cmFuc3Bvc2UpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICd0cmFuc3Bvc2UnLCB0cmFuc3Bvc2U6IGVsZW0udHJhbnNwb3NlIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInRlbXBvXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRxcG0gPSBpbnRlcnByZXRUZW1wbyhlbGVtKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICd0ZW1wbycsIHFwbTogcXBtIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImJhclwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5vdGVFdmVudHNJbkJhciA+IDApIC8vIGRvbid0IGFkZCB0d28gYmFycyBpbiBhIHJvdy5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JhcicgfSk7IC8vIFdlIG5lZWQgdGhlIGJhciBtYXJraW5nIHRvIHJlc2V0IHRoZSBhY2NpZGVudGFscy5cblx0XHRcdFx0XHRcdFx0XHRcdG5vdGVFdmVudHNJbkJhciA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWd1cmUgb3V0IHJlcGVhdHMgYW5kIGVuZGluZ3MgLS1cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBpbXBvcnRhbnQgcGFydCBpcyB3aGVyZSB0aGVyZSBpcyBhIHN0YXJ0IHJlcGVhdCwgYW5kIGVuZCByZXBlYXQsIG9yIGEgZmlyc3QgZW5kaW5nLlxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGVuZFJlcGVhdCA9IChlbGVtLnR5cGUgPT09IFwiYmFyX3JpZ2h0X3JlcGVhdFwiIHx8IGVsZW0udHlwZSA9PT0gXCJiYXJfZGJsX3JlcGVhdFwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdGFydEVuZGluZyA9IChlbGVtLnN0YXJ0RW5kaW5nID09PSAnMScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXJ0UmVwZWF0ID0gKGVsZW0udHlwZSA9PT0gXCJiYXJfbGVmdF9yZXBlYXRcIiB8fCBlbGVtLnR5cGUgPT09IFwiYmFyX2RibF9yZXBlYXRcIiB8fCBlbGVtLnR5cGUgPT09IFwiYmFyX3JpZ2h0X3JlcGVhdFwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbmRSZXBlYXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHMgPSBzdGFydFJlcGVhdFBsYWNlaG9sZGVyW3ZvaWNlTnVtYmVyXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFzKSBzID0gMDsgLy8gSWYgdGhlcmUgd2Fzbid0IGEgbGVmdCByZXBlYXQsIHRoZW4gd2UgcmVwZWF0IGZyb20gdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGUgPSBza2lwRW5kaW5nUGxhY2Vob2xkZXJbdm9pY2VOdW1iZXJdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWUpIGUgPSB2b2ljZXNbdm9pY2VOdW1iZXJdLmxlbmd0aDsgLy8gSWYgdGhlcmUgd2Fzbid0IGEgZmlyc3QgZW5kaW5nIG1hcmtlciwgdGhlbiB3ZSBjb3B5IGV2ZXJ5dGhpbmcuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0gPSB2b2ljZXNbdm9pY2VOdW1iZXJdLmNvbmNhdCh2b2ljZXNbdm9pY2VOdW1iZXJdLnNsaWNlKHMsIGUpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzZXQgdGhlc2UgaW4gY2FzZSB0aGVyZSBpcyBhIHNlY29uZCByZXBlYXQgbGF0ZXIgb24uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNraXBFbmRpbmdQbGFjZWhvbGRlclt2b2ljZU51bWJlcl0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0UmVwZWF0UGxhY2Vob2xkZXJbdm9pY2VOdW1iZXJdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0RW5kaW5nKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRza2lwRW5kaW5nUGxhY2Vob2xkZXJbdm9pY2VOdW1iZXJdID0gdm9pY2VzW3ZvaWNlTnVtYmVyXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRSZXBlYXQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0UmVwZWF0UGxhY2Vob2xkZXJbdm9pY2VOdW1iZXJdID0gdm9pY2VzW3ZvaWNlTnVtYmVyXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdzdHlsZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPLVBFUjogSWYgdGhpcyBpcyBzZXQgdG8gcmh5dGhtIGhlYWRzLCB0aGVuIGl0IHNob3VsZCB1c2UgdGhlIHBlcmN1c3Npb24gY2hhbm5lbC5cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3BhcnQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IElmIHRoZXJlIGlzIGEgcGFydCBzZWN0aW9uIGluIHRoZSBoZWFkZXIsIHRoZW4gdGhpcyBzaG91bGQgcHJvYmFibHkgYWZmZWN0IHRoZSByZXBlYXRzLlxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnc3RlbSc6XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlc2UgZWxlbWVudHMgZG9uJ3QgYWZmZWN0IHNvdW5kXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdtaWRpJzpcblx0XHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJNSURJIGlubGluZVwiLCBlbGVtKTsgLy8gVE9ETy1QRVI6IGZvciBkZWJ1Z2dpbmcuIFJlbW92ZSB0aGlzLlxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRydW1DaGFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoZWxlbS5jbWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImRydW1vblwiOiBkcnVtT24gPSB0cnVlOyBkcnVtQ2hhbmdlID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJkcnVtb2ZmXCI6IGRydW1PbiA9IGZhbHNlOyBkcnVtQ2hhbmdlID0gdHJ1ZTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJkcnVtXCI6IGRydW1QYXR0ZXJuID0gZWxlbS5wYXJhbXM7IGRydW1DaGFuZ2UgPSB0cnVlOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImRydW1iYXJzXCI6IGRydW1CYXJzID0gZWxlbS5wYXJhbXNbMF07IGRydW1DaGFuZ2UgPSB0cnVlOyBicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImRydW1tYXBcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGhhbmRsZWQgYmVmb3JlIGdldHRpbmcgaGVyZSBzbyBpdCBjYW4gYmUgaWdub3JlZC5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInByb2dyYW1cIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAnaW5zdHJ1bWVudCcsIHByb2dyYW06IGVsZW0ucGFyYW1zWzBdIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwidHJhbnNwb3NlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ3RyYW5zcG9zZScsIHRyYW5zcG9zZTogZWxlbS5wYXJhbXNbMF0gfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJnY2hvcmRvZmZcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAnZ2Nob3JkJywgdGFjZXQ6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJnY2hvcmRvblwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICdnY2hvcmQnLCB0YWNldDogZmFsc2UgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJiZWF0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXQnLCBiZWF0czogZWxlbS5wYXJhbXMgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJub2JlYXRhY2NlbnRzXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ2JlYXRhY2NlbnRzJywgdmFsdWU6IGZhbHNlIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiYmVhdGFjY2VudHNcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbdm9pY2VOdW1iZXJdLnB1c2goeyBlbF90eXBlOiAnYmVhdGFjY2VudHMnLCB2YWx1ZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInZvbFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZvaWNlc1t2b2ljZU51bWJlcl0ucHVzaCh7IGVsX3R5cGU6ICd2b2wnLCB2b2x1bWU6IGVsZW0ucGFyYW1zWzBdIH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwidm9saW5jXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dm9pY2VzW3ZvaWNlTnVtYmVyXS5wdXNoKHsgZWxfdHlwZTogJ3ZvbGluYycsIHZvbHVtZTogZWxlbS5wYXJhbXNbMF0gfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJNSURJIHNlcTogbWlkaSBjbWQgbm90IGhhbmRsZWQ6IFwiLCBlbGVtLmNtZCwgZWxlbSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZHJ1bUNoYW5nZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2b2ljZXNbMF0ucHVzaCh7ZWxfdHlwZTogJ2RydW0nLCBwYXJhbXM6IHsgcGF0dGVybjogZHJ1bVBhdHRlcm4sIGJhcnM6IGRydW1CYXJzLCBpbnRybzogZHJ1bUludHJvLCBvbjogZHJ1bU9ufX0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydGluZ0RydW1TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiTUlESTogZWxlbWVudCB0eXBlIFwiICsgZWxlbS5lbF90eXBlICsgXCIgbm90IGhhbmRsZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2b2ljZU51bWJlcisrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZHJ1bUludHJvKSB7XG5cdFx0XHR2YXIgcGlja3VwcyA9IGFiY3R1bmUuZ2V0UGlja3VwTGVuZ3RoKCk7XG5cdFx0XHQvLyBhZGQgc29tZSBtZWFzdXJlcyBvZiByZXN0cyB0byB0aGUgc3RhcnQgb2YgZWFjaCB0cmFjay5cblx0XHRcdGZvciAodmFyIHZ2ID0gMDsgdnYgPCB2b2ljZXMubGVuZ3RoOyB2disrKSB7XG5cdFx0XHRcdHZhciBpbnNlcnRQb2ludCA9IDA7XG5cdFx0XHRcdHdoaWxlICh2b2ljZXNbdnZdW2luc2VydFBvaW50XS5lbF90eXBlICE9PSBcIm5vdGVcIiAmJiB2b2ljZXNbdnZdLmxlbmd0aCA+IGluc2VydFBvaW50KVxuXHRcdFx0XHRcdGluc2VydFBvaW50Kys7XG5cdFx0XHRcdGlmICh2b2ljZXNbdnZdLmxlbmd0aCA+IGluc2VydFBvaW50KSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgdyA9IDA7IHcgPCBkcnVtSW50cm87IHcrKykge1xuXHRcdFx0XHRcdFx0Ly8gSWYgaXQgaXMgdGhlIGxhc3QgbWVhc3VyZSBvZiBpbnRybywgc3VidHJhY3QgdGhlIHBpY2t1cHMuXG5cdFx0XHRcdFx0XHRpZiAocGlja3VwcyA9PT0gMCB8fCB3IDwgZHJ1bUludHJvLTEpXG5cdFx0XHRcdFx0XHRcdHZvaWNlc1t2dl0uc3BsaWNlKGluc2VydFBvaW50LCAwLCB7ZWxfdHlwZTogXCJub3RlXCIsIHJlc3Q6IHt0eXBlOiBcInJlc3RcIn0sIGR1cmF0aW9uOiBtZWFzdXJlTGVuZ3RofSxcblx0XHRcdFx0XHRcdFx0XHR7IGVsX3R5cGU6IFwiYmFyXCIgfSk7XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dm9pY2VzW3Z2XS5zcGxpY2UoaW5zZXJ0UG9pbnQsIDAsIHtlbF90eXBlOiBcIm5vdGVcIiwgcmVzdDoge3R5cGU6IFwicmVzdFwifSwgZHVyYXRpb246IG1lYXN1cmVMZW5ndGgtcGlja3Vwc30pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdm9pY2VzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGludGVycHJldFRlbXBvKGVsZW1lbnQpIHtcblx0XHR2YXIgZHVyYXRpb24gPSAxLzQ7XG5cdFx0aWYgKGVsZW1lbnQuZHVyYXRpb24pIHtcblx0XHRcdGR1cmF0aW9uID0gZWxlbWVudC5kdXJhdGlvblswXTtcblx0XHR9XG5cdFx0dmFyIGJwbSA9IDYwO1xuXHRcdGlmIChlbGVtZW50LmJwbSkge1xuXHRcdFx0YnBtID0gZWxlbWVudC5icG07XG5cdFx0fVxuXHRcdC8vIFRoZSB0ZW1wbyBpcyBkZWZpbmVkIHdpdGggYSBiZWF0IG9mIGEgMS80IG5vdGUsIHNvIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGlmIHRoZSB0ZW1wbyBpcyBleHByZXNzZWQgd2l0aCBvdGhlciB0aGFuIGEgcXVhcnRlciBub3RlLlxuXHRcdC8vIGV4cHJlc3NlZER1cmF0aW9uICogZXhwcmVzc2VkQmVhdHNQZXJNaW51dGUgLyBsZW5ndGhPZlF1YXJ0ZXJOb3RlID0gcXVhcnRlck5vdGVzUGVyTWludXRlXG5cdFx0cmV0dXJuIGR1cmF0aW9uICogYnBtIC8gMC4yNTtcblx0fVxuXG5cdGZ1bmN0aW9uIGludGVycHJldE1ldGVyKGVsZW1lbnQpIHtcblx0XHR2YXIgbWV0ZXI7XG5cdFx0c3dpdGNoIChlbGVtZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21tb25fdGltZVwiOlxuXHRcdFx0XHRtZXRlciA9IHsgZWxfdHlwZTogJ21ldGVyJywgbnVtOiA0LCBkZW46IDQgfTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiY3V0X3RpbWVcIjpcblx0XHRcdFx0bWV0ZXIgPSB7IGVsX3R5cGU6ICdtZXRlcicsIG51bTogMiwgZGVuOiAyIH07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInNwZWNpZmllZFwiOlxuXHRcdFx0XHQvLyBUT0RPLVBFUjogb25seSB0YWtpbmcgdGhlIGZpcnN0IG1ldGVyLCBzbyB0aGUgY29tcGxleCBtZXRlcnMgYXJlIG5vdCBoYW5kbGVkLlxuXHRcdFx0XHRtZXRlciA9IHsgZWxfdHlwZTogJ21ldGVyJywgbnVtOiBlbGVtZW50LnZhbHVlWzBdLm51bSwgZGVuOiBlbGVtZW50LnZhbHVlWzBdLmRlbiB9O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHRcdFx0bWV0ZXIgPSB7IGVsX3R5cGU6ICdtZXRlcicgfTtcblx0XHR9XG5cdFx0bWVhc3VyZUxlbmd0aCA9IG1ldGVyLm51bS9tZXRlci5kZW47XG5cdFx0cmV0dXJuIG1ldGVyO1xuXHR9XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlcXVlbmNlO1xuIiwiLy8gICAgYWJjX3BhcnNlLmpzOiBwYXJzZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIEFCQyBNdXNpYyBOb3RhdGlvbiBpbnRvIGEgdXNhYmxlIGludGVybmFsIHN0cnVjdHVyZS5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IFBhdWwgUm9zZW4gKHBhdWwgYXQgcGF1bHJvc2VuIGRvdCBuZXQpXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwYXJzZUNvbW1vbiA9IHt9O1xuXG5wYXJzZUNvbW1vbi5jbG9uZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0Zm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKVxuXHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxuXHRcdFx0ZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxucGFyc2VDb21tb24uY2xvbmVBcnJheSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHR2YXIgZGVzdGluYXRpb24gPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcblx0XHRkZXN0aW5hdGlvbi5wdXNoKHBhcnNlQ29tbW9uLmNsb25lKHNvdXJjZVtpXSkpO1xuXHR9XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbnBhcnNlQ29tbW9uLmNsb25lSGFzaE9mSGFzaCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0Zm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKVxuXHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKVxuXHRcdFx0ZGVzdGluYXRpb25bcHJvcGVydHldID0gcGFyc2VDb21tb24uY2xvbmUoc291cmNlW3Byb3BlcnR5XSk7XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbnBhcnNlQ29tbW9uLmNsb25lSGFzaE9mQXJyYXlPZkhhc2ggPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSlcblx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSlcblx0XHRcdGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHBhcnNlQ29tbW9uLmNsb25lQXJyYXkoc291cmNlW3Byb3BlcnR5XSk7XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbnBhcnNlQ29tbW9uLmdzdWIgPSBmdW5jdGlvbihzb3VyY2UsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cdHJldHVybiBzb3VyY2Uuc3BsaXQocGF0dGVybikuam9pbihyZXBsYWNlbWVudCk7XG59O1xuXG5wYXJzZUNvbW1vbi5zdHJpcCA9IGZ1bmN0aW9uKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xufTtcblxucGFyc2VDb21tb24uc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybikge1xuXHRyZXR1cm4gc3RyLmluZGV4T2YocGF0dGVybikgPT09IDA7XG59O1xuXG5wYXJzZUNvbW1vbi5lbmRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgcGF0dGVybikge1xuXHR2YXIgZCA9IHN0ci5sZW5ndGggLSBwYXR0ZXJuLmxlbmd0aDtcblx0cmV0dXJuIGQgPj0gMCAmJiBzdHIubGFzdEluZGV4T2YocGF0dGVybikgPT09IGQ7XG59O1xuXG5wYXJzZUNvbW1vbi5lYWNoID0gZnVuY3Rpb24oYXJyLCBpdGVyYXRvciwgY29udGV4dCkge1xuXHRmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKVxuXHQgIGl0ZXJhdG9yLmFwcGx5KGNvbnRleHQsIFthcnJbaV0saV0pO1xufTtcblxucGFyc2VDb21tb24ubGFzdCA9IGZ1bmN0aW9uKGFycikge1xuXHRpZiAoYXJyLmxlbmd0aCA9PT0gMClcblx0XHRyZXR1cm4gbnVsbDtcblx0cmV0dXJuIGFyclthcnIubGVuZ3RoLTFdO1xufTtcblxucGFyc2VDb21tb24uY29tcGFjdCA9IGZ1bmN0aW9uKGFycikge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGFycltpXSlcblx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn07XG5cbnBhcnNlQ29tbW9uLmRldGVjdCA9IGZ1bmN0aW9uKGFyciwgaXRlcmF0b3IpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoaXRlcmF0b3IoYXJyW2ldKSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFRoZSBmb2xsb3dpbmcgaXMgYSBwb2x5ZmlsbCBmb3IgT2JqZWN0LnJlbW92ZSBmb3IgSUU5LCBJRTEwLCBhbmQgSUUxMS5cbi8vIGZyb206aHR0cHM6Ly9naXRodWIuY29tL2pzZXJ6L2pzX3BpZWNlL2Jsb2IvbWFzdGVyL0RPTS9DaGlsZE5vZGUvcmVtb3ZlKCkvcmVtb3ZlKCkubWRcbihmdW5jdGlvbiAoYXJyKSB7XG5cdGFyci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0aWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoJ3JlbW92ZScpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtLCAncmVtb3ZlJywge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRcdFx0aWYgKHRoaXMucGFyZW50Tm9kZSAhPT0gbnVsbClcblx0XHRcdFx0XHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSkoW0VsZW1lbnQucHJvdG90eXBlLCBDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgRG9jdW1lbnRUeXBlLnByb3RvdHlwZV0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQ29tbW9uO1xuIiwiLy8gICAgYWJjX3BhcnNlLmpzOiBwYXJzZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIEFCQyBNdXNpYyBOb3RhdGlvbiBpbnRvIGEgdXNhYmxlIGludGVybmFsIHN0cnVjdHVyZS5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IFBhdWwgUm9zZW4gKHBhdWwgYXQgcGF1bHJvc2VuIGRvdCBuZXQpXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8qZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgcGFyc2VDb21tb24gPSByZXF1aXJlKCcuL2FiY19jb21tb24nKTtcbnZhciBwYXJzZURpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vYWJjX3BhcnNlX2RpcmVjdGl2ZScpO1xudmFyIFBhcnNlSGVhZGVyID0gcmVxdWlyZSgnLi9hYmNfcGFyc2VfaGVhZGVyJyk7XG52YXIgcGFyc2VLZXlWb2ljZSA9IHJlcXVpcmUoJy4vYWJjX3BhcnNlX2tleV92b2ljZScpO1xudmFyIFRva2VuaXplciA9IHJlcXVpcmUoJy4vYWJjX3Rva2VuaXplcicpO1xudmFyIHRyYW5zcG9zZSA9IHJlcXVpcmUoJy4vYWJjX3RyYW5zcG9zZScpO1xudmFyIHdyYXAgPSByZXF1aXJlKCcuL3dyYXBfbGluZXMnKTtcblxudmFyIFR1bmUgPSByZXF1aXJlKCcuLi9kYXRhL2FiY190dW5lJyk7XG5cbnZhciBQYXJzZSA9IGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIHR1bmUgPSBuZXcgVHVuZSgpO1xuXHR2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xuXG5cdHRoaXMuZ2V0VHVuZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRmb3JtYXR0aW5nOiB0dW5lLmZvcm1hdHRpbmcsXG5cdFx0XHRsaW5lczogdHVuZS5saW5lcyxcblx0XHRcdG1lZGlhOiB0dW5lLm1lZGlhLFxuXHRcdFx0bWV0YVRleHQ6IHR1bmUubWV0YVRleHQsXG5cdFx0XHR2ZXJzaW9uOiB0dW5lLnZlcnNpb24sXG5cblx0XHRcdGFkZEVsZW1lbnRUb0V2ZW50czogdHVuZS5hZGRFbGVtZW50VG9FdmVudHMsXG5cdFx0XHRhZGRVc2VmdWxDYWxsYmFja0luZm86IHR1bmUuYWRkVXNlZnVsQ2FsbGJhY2tJbmZvLFxuXHRcdFx0Z2V0QmFyTGVuZ3RoOiB0dW5lLmdldEJhckxlbmd0aCxcblx0XHRcdGdldEJlYXRMZW5ndGg6IHR1bmUuZ2V0QmVhdExlbmd0aCxcblx0XHRcdGdldEJlYXRzUGVyTWVhc3VyZTogdHVuZS5nZXRCZWF0c1Blck1lYXN1cmUsXG5cdFx0XHRnZXRCcG06IHR1bmUuZ2V0QnBtLFxuXHRcdFx0Z2V0TWV0ZXI6IHR1bmUuZ2V0TWV0ZXIsXG5cdFx0XHRnZXRNZXRlckZyYWN0aW9uOiB0dW5lLmdldE1ldGVyRnJhY3Rpb24sXG5cdFx0XHRnZXRQaWNrdXBMZW5ndGg6IHR1bmUuZ2V0UGlja3VwTGVuZ3RoLFxuXHRcdFx0Z2V0S2V5U2lnbmF0dXJlOiB0dW5lLmdldEtleVNpZ25hdHVyZSxcblx0XHRcdG1ha2VWb2ljZXNBcnJheTogdHVuZS5tYWtlVm9pY2VzQXJyYXksXG5cdFx0XHRtaWxsaXNlY29uZHNQZXJNZWFzdXJlOiB0dW5lLm1pbGxpc2Vjb25kc1Blck1lYXN1cmUsXG5cdFx0XHRzZXR1cEV2ZW50czogdHVuZS5zZXR1cEV2ZW50cyxcblx0XHRcdHNldFRpbWluZzogdHVuZS5zZXRUaW1pbmdcblx0XHR9O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGFkZFBvc2l0aW9uaW5nKGVsLCB0eXBlLCB2YWx1ZSkge1xuXHRcdGlmICghZWwucG9zaXRpb25pbmcpIGVsLnBvc2l0aW9uaW5nID0ge307XG5cdFx0ZWwucG9zaXRpb25pbmdbdHlwZV0gPSB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEZvbnQoZWwsIHR5cGUsIHZhbHVlKSB7XG5cdFx0aWYgKCFlbC5mb250cykgZWwuZm9udHMgPSB7fTtcblx0XHRlbC5mb250c1t0eXBlXSA9IHZhbHVlO1xuXHR9XG5cblx0dmFyIG11bHRpbGluZVZhcnMgPSB7XG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykge1xuXHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgdHlwZW9mIHRoaXNbcHJvcGVydHldICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpc1twcm9wZXJ0eV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuaUNoYXIgPSAwO1xuXHRcdFx0dGhpcy5rZXkgPSB7YWNjaWRlbnRhbHM6IFtdLCByb290OiAnbm9uZScsIGFjYzogJycsIG1vZGU6ICcnIH07XG5cdFx0XHR0aGlzLm1ldGVyID0gbnVsbDsgLy8gaWYgbm8gbWV0ZXIgaXMgc3BlY2lmaWVkLCBmcmVlIG1ldGVyIGlzIGFzc3VtZWRcblx0XHRcdHRoaXMub3JpZ01ldGVyID0gbnVsbDtcdC8vIHRoaXMgaXMgZm9yIG5ldyB2b2ljZXMgdGhhdCBhcmUgY3JlYXRlZCBhZnRlciB3ZSBzZXQgdGhlIG1ldGVyLlxuXHRcdFx0dGhpcy5oYXNNYWluVGl0bGUgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGVmYXVsdF9sZW5ndGggPSAwLjEyNTtcblx0XHRcdHRoaXMuY2xlZiA9IHsgdHlwZTogJ3RyZWJsZScsIHZlcnRpY2FsUG9zOiAwIH07XG5cdFx0XHR0aGlzLm5leHRfbm90ZV9kdXJhdGlvbiA9IDA7XG5cdFx0XHR0aGlzLnN0YXJ0X25ld19saW5lID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXNfaW5faGVhZGVyID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXNfaW5faGlzdG9yeSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5wYXJ0Rm9yTmV4dExpbmUgPSB7fTtcblx0XHRcdHRoaXMuaGF2ZW50X3NldF9sZW5ndGggPSB0cnVlO1xuXHRcdFx0dGhpcy52b2ljZXMgPSB7fTtcblx0XHRcdHRoaXMuc3RhdmVzID0gW107XG5cdFx0XHR0aGlzLm1hY3JvcyA9IHt9O1xuXHRcdFx0dGhpcy5jdXJyQmFyTnVtYmVyID0gMTtcblx0XHRcdHRoaXMuYmFyQ291bnRlciA9IHt9O1xuXHRcdFx0dGhpcy5pblRleHRCbG9jayA9IGZhbHNlO1xuXHRcdFx0dGhpcy5pblBzQmxvY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMuaWdub3JlZERlY29yYXRpb25zID0gW107XG5cdFx0XHR0aGlzLnRleHRCbG9jayA9IFwiXCI7XG5cdFx0XHR0aGlzLnNjb3JlX2lzX3ByZXNlbnQgPSBmYWxzZTtcdC8vIENhbid0IGhhdmUgb3JpZ2luYWwgVjogbGluZXMgd2hlbiB0aGVyZSBpcyB0aGUgc2NvcmUgZGlyZWN0aXZlXG5cdFx0XHR0aGlzLmluRW5kaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmluVGllID0gW107XG5cdFx0XHR0aGlzLmluVGllQ2hvcmQgPSB7fTtcblx0XHRcdHRoaXMudm9jYWxQb3NpdGlvbiA9IFwiYXV0b1wiO1xuXHRcdFx0dGhpcy5keW5hbWljUG9zaXRpb24gPSBcImF1dG9cIjtcblx0XHRcdHRoaXMuY2hvcmRQb3NpdGlvbiA9IFwiYXV0b1wiO1xuXHRcdFx0dGhpcy5vcm5hbWVudFBvc2l0aW9uID0gXCJhdXRvXCI7XG5cdFx0XHR0aGlzLnZvbHVtZVBvc2l0aW9uID0gXCJhdXRvXCI7XG5cdFx0XHR0aGlzLm9wZW5TbHVycyA9IFtdO1xuXHRcdFx0dGhpcy5mcmVlZ2Nob3JkID0gZmFsc2U7XG5cdFx0fSxcblx0XHRkaWZmZXJlbnRGb250OiBmdW5jdGlvbih0eXBlLCBkZWZhdWx0Rm9udHMpIHtcblx0XHRcdGlmICh0aGlzW3R5cGVdLmRlY29yYXRpb24gIT09IGRlZmF1bHRGb250c1t0eXBlXS5kZWNvcmF0aW9uKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmICh0aGlzW3R5cGVdLmZhY2UgIT09IGRlZmF1bHRGb250c1t0eXBlXS5mYWNlKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmICh0aGlzW3R5cGVdLnNpemUgIT09IGRlZmF1bHRGb250c1t0eXBlXS5zaXplKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGlmICh0aGlzW3R5cGVdLnN0eWxlICE9PSBkZWZhdWx0Rm9udHNbdHlwZV0uc3R5bGUpIHJldHVybiB0cnVlO1xuXHRcdFx0aWYgKHRoaXNbdHlwZV0ud2VpZ2h0ICE9PSBkZWZhdWx0Rm9udHNbdHlwZV0ud2VpZ2h0KSByZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFkZEZvcm1hdHRpbmdPcHRpb25zOiBmdW5jdGlvbihlbCwgZGVmYXVsdEZvbnRzLCBlbFR5cGUpIHtcblx0XHRcdGlmIChlbFR5cGUgPT09ICdub3RlJykge1xuXHRcdFx0XHRpZiAodGhpcy52b2NhbFBvc2l0aW9uICE9PSAnYXV0bycpIGFkZFBvc2l0aW9uaW5nKGVsLCAndm9jYWxQb3NpdGlvbicsIHRoaXMudm9jYWxQb3NpdGlvbik7XG5cdFx0XHRcdGlmICh0aGlzLmR5bmFtaWNQb3NpdGlvbiAhPT0gJ2F1dG8nKSBhZGRQb3NpdGlvbmluZyhlbCwgJ2R5bmFtaWNQb3NpdGlvbicsIHRoaXMuZHluYW1pY1Bvc2l0aW9uKTtcblx0XHRcdFx0aWYgKHRoaXMuY2hvcmRQb3NpdGlvbiAhPT0gJ2F1dG8nKSBhZGRQb3NpdGlvbmluZyhlbCwgJ2Nob3JkUG9zaXRpb24nLCB0aGlzLmNob3JkUG9zaXRpb24pO1xuXHRcdFx0XHRpZiAodGhpcy5vcm5hbWVudFBvc2l0aW9uICE9PSAnYXV0bycpIGFkZFBvc2l0aW9uaW5nKGVsLCAnb3JuYW1lbnRQb3NpdGlvbicsIHRoaXMub3JuYW1lbnRQb3NpdGlvbik7XG5cdFx0XHRcdGlmICh0aGlzLnZvbHVtZVBvc2l0aW9uICE9PSAnYXV0bycpIGFkZFBvc2l0aW9uaW5nKGVsLCAndm9sdW1lUG9zaXRpb24nLCB0aGlzLnZvbHVtZVBvc2l0aW9uKTtcblx0XHRcdFx0aWYgKHRoaXMuZGlmZmVyZW50Rm9udChcImFubm90YXRpb25mb250XCIsIGRlZmF1bHRGb250cykpIGFkZEZvbnQoZWwsICdhbm5vdGF0aW9uZm9udCcsIHRoaXMuYW5ub3RhdGlvbmZvbnQpO1xuXHRcdFx0XHRpZiAodGhpcy5kaWZmZXJlbnRGb250KFwiZ2Nob3JkZm9udFwiLCBkZWZhdWx0Rm9udHMpKSBhZGRGb250KGVsLCAnZ2Nob3JkZm9udCcsIHRoaXMuZ2Nob3JkZm9udCk7XG5cdFx0XHRcdGlmICh0aGlzLmRpZmZlcmVudEZvbnQoXCJ2b2NhbGZvbnRcIiwgZGVmYXVsdEZvbnRzKSkgYWRkRm9udChlbCwgJ3ZvY2FsZm9udCcsIHRoaXMudm9jYWxmb250KTtcblx0XHRcdFx0aWYgKHRoaXMuZGlmZmVyZW50Rm9udChcInRyaXBsZXRmb250XCIsIGRlZmF1bHRGb250cykpIGFkZEZvbnQoZWwsICd0cmlwbGV0Zm9udCcsIHRoaXMudHJpcGxldGZvbnQpO1xuXHRcdFx0fSBlbHNlIGlmIChlbFR5cGUgPT09ICdiYXInKSB7XG5cdFx0XHRcdGlmICh0aGlzLmR5bmFtaWNQb3NpdGlvbiAhPT0gJ2F1dG8nKSBhZGRQb3NpdGlvbmluZyhlbCwgJ2R5bmFtaWNQb3NpdGlvbicsIHRoaXMuZHluYW1pY1Bvc2l0aW9uKTtcblx0XHRcdFx0aWYgKHRoaXMuY2hvcmRQb3NpdGlvbiAhPT0gJ2F1dG8nKSBhZGRQb3NpdGlvbmluZyhlbCwgJ2Nob3JkUG9zaXRpb24nLCB0aGlzLmNob3JkUG9zaXRpb24pO1xuXHRcdFx0XHRpZiAodGhpcy5vcm5hbWVudFBvc2l0aW9uICE9PSAnYXV0bycpIGFkZFBvc2l0aW9uaW5nKGVsLCAnb3JuYW1lbnRQb3NpdGlvbicsIHRoaXMub3JuYW1lbnRQb3NpdGlvbik7XG5cdFx0XHRcdGlmICh0aGlzLnZvbHVtZVBvc2l0aW9uICE9PSAnYXV0bycpIGFkZFBvc2l0aW9uaW5nKGVsLCAndm9sdW1lUG9zaXRpb24nLCB0aGlzLnZvbHVtZVBvc2l0aW9uKTtcblx0XHRcdFx0aWYgKHRoaXMuZGlmZmVyZW50Rm9udChcIm1lYXN1cmVmb250XCIsIGRlZmF1bHRGb250cykpIGFkZEZvbnQoZWwsICdtZWFzdXJlZm9udCcsIHRoaXMubWVhc3VyZWZvbnQpO1xuXHRcdFx0XHRpZiAodGhpcy5kaWZmZXJlbnRGb250KFwicmVwZWF0Zm9udFwiLCBkZWZhdWx0Rm9udHMpKSBhZGRGb250KGVsLCAncmVwZWF0Zm9udCcsIHRoaXMucmVwZWF0Zm9udCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBhZGRXYXJuaW5nID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0aWYgKCFtdWx0aWxpbmVWYXJzLndhcm5pbmdzKVxuXHRcdFx0bXVsdGlsaW5lVmFycy53YXJuaW5ncyA9IFtdO1xuXHRcdG11bHRpbGluZVZhcnMud2FybmluZ3MucHVzaChzdHIpO1xuXHR9O1xuXG5cdHZhciBhZGRXYXJuaW5nT2JqZWN0ID0gZnVuY3Rpb24od2FybmluZ09iamVjdCkge1xuXHRcdGlmICghbXVsdGlsaW5lVmFycy53YXJuaW5nT2JqZWN0cylcblx0XHRcdG11bHRpbGluZVZhcnMud2FybmluZ09iamVjdHMgPSBbXTtcblx0XHRtdWx0aWxpbmVWYXJzLndhcm5pbmdPYmplY3RzLnB1c2god2FybmluZ09iamVjdCk7XG5cdH07XG5cblx0dmFyIGVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciByZXQgPSBwYXJzZUNvbW1vbi5nc3ViKHN0ciwgJ1xceDEyJywgJyAnKTtcblx0XHRyZXQgPSBwYXJzZUNvbW1vbi5nc3ViKHJldCwgJyYnLCAnJmFtcDsnKTtcblx0XHRyZXQgPSBwYXJzZUNvbW1vbi5nc3ViKHJldCwgJzwnLCAnJmx0OycpO1xuXHRcdHJldHVybiBwYXJzZUNvbW1vbi5nc3ViKHJldCwgJz4nLCAnJmd0OycpO1xuXHR9O1xuXG5cdHZhciB3YXJuID0gZnVuY3Rpb24oc3RyLCBsaW5lLCBjb2xfbnVtKSB7XG5cdFx0aWYgKCFsaW5lKSBsaW5lID0gXCIgXCI7XG5cdFx0dmFyIGJhZF9jaGFyID0gbGluZS5jaGFyQXQoY29sX251bSk7XG5cdFx0aWYgKGJhZF9jaGFyID09PSAnICcpXG5cdFx0XHRiYWRfY2hhciA9IFwiU1BBQ0VcIjtcblx0XHR2YXIgY2xlYW5fbGluZSA9IGVuY29kZShsaW5lLnN1YnN0cmluZygwLCBjb2xfbnVtKSkgK1xuXHRcdFx0JzxzcGFuIHN0eWxlPVwidGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtmb250LXNpemU6MS4zZW07Zm9udC13ZWlnaHQ6Ym9sZDtcIj4nICsgYmFkX2NoYXIgKyAnPC9zcGFuPicgK1xuXHRcdFx0ZW5jb2RlKGxpbmUuc3Vic3RyaW5nKGNvbF9udW0rMSkpO1xuXHRcdGFkZFdhcm5pbmcoXCJNdXNpYyBMaW5lOlwiICsgdHVuZS5nZXROdW1MaW5lcygpICsgXCI6XCIgKyAoY29sX251bSsxKSArICc6ICcgKyBzdHIgKyBcIjogIFwiICsgY2xlYW5fbGluZSk7XG5cdFx0YWRkV2FybmluZ09iamVjdCh7bWVzc2FnZTpzdHIsIGxpbmU6bGluZSwgc3RhcnRDaGFyOiBtdWx0aWxpbmVWYXJzLmlDaGFyICsgY29sX251bSwgY29sdW1uOiBjb2xfbnVtfSk7XG5cdH07XG5cdHZhciBoZWFkZXIgPSBuZXcgUGFyc2VIZWFkZXIodG9rZW5pemVyLCB3YXJuLCBtdWx0aWxpbmVWYXJzLCB0dW5lKTtcblxuXHR0aGlzLmdldFdhcm5pbmdzID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG11bHRpbGluZVZhcnMud2FybmluZ3M7XG5cdH07XG5cdHRoaXMuZ2V0V2FybmluZ09iamVjdHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbXVsdGlsaW5lVmFycy53YXJuaW5nT2JqZWN0cztcblx0fTtcblxuXHR2YXIgbGV0dGVyX3RvX2Nob3JkID0gZnVuY3Rpb24obGluZSwgaSlcblx0e1xuXHRcdGlmIChsaW5lLmNoYXJBdChpKSA9PT0gJ1wiJylcblx0XHR7XG5cdFx0XHR2YXIgY2hvcmQgPSB0b2tlbml6ZXIuZ2V0QnJhY2tldHRlZFN1YnN0cmluZyhsaW5lLCBpLCA1KTtcblx0XHRcdGlmICghY2hvcmRbMl0pXG5cdFx0XHRcdHdhcm4oXCJNaXNzaW5nIHRoZSBjbG9zaW5nIHF1b3RlIHdoaWxlIHBhcnNpbmcgdGhlIGNob3JkIHN5bWJvbFwiLCBsaW5lICwgaSk7XG5cdFx0XHQvLyBJZiBpdCBzdGFydHMgd2l0aCBeLCB0aGVuIHRoZSBjaG9yZCBhcHBlYXJzIGFib3ZlLlxuXHRcdFx0Ly8gSWYgaXQgc3RhcnRzIHdpdGggXyB0aGVuIHRoZSBjaG9yZCBhcHBlYXJzIGJlbG93LlxuXHRcdFx0Ly8gKG5vdGUgdGhhdCB0aGUgMi4wIGRyYWZ0IHN0YW5kYXJkIGRlZmluZXMgdGhlbSBhcyBub3QgY2hvcmRzLCBidXQgYW5ub3RhdGlvbnMgYW5kIGFsc28gZGVmaW5lcyBALilcblx0XHRcdGlmIChjaG9yZFswXSA+IDAgJiYgY2hvcmRbMV0ubGVuZ3RoID4gMCAmJiBjaG9yZFsxXS5jaGFyQXQoMCkgPT09ICdeJykge1xuXHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnN1YnN0cmluZygxKTtcblx0XHRcdFx0Y2hvcmRbMl0gPSAnYWJvdmUnO1xuXHRcdFx0fSBlbHNlIGlmIChjaG9yZFswXSA+IDAgJiYgY2hvcmRbMV0ubGVuZ3RoID4gMCAmJiBjaG9yZFsxXS5jaGFyQXQoMCkgPT09ICdfJykge1xuXHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnN1YnN0cmluZygxKTtcblx0XHRcdFx0Y2hvcmRbMl0gPSAnYmVsb3cnO1xuXHRcdFx0fSBlbHNlIGlmIChjaG9yZFswXSA+IDAgJiYgY2hvcmRbMV0ubGVuZ3RoID4gMCAmJiBjaG9yZFsxXS5jaGFyQXQoMCkgPT09ICc8Jykge1xuXHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnN1YnN0cmluZygxKTtcblx0XHRcdFx0Y2hvcmRbMl0gPSAnbGVmdCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNob3JkWzBdID4gMCAmJiBjaG9yZFsxXS5sZW5ndGggPiAwICYmIGNob3JkWzFdLmNoYXJBdCgwKSA9PT0gJz4nKSB7XG5cdFx0XHRcdGNob3JkWzFdID0gY2hvcmRbMV0uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRjaG9yZFsyXSA9ICdyaWdodCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNob3JkWzBdID4gMCAmJiBjaG9yZFsxXS5sZW5ndGggPiAwICYmIGNob3JkWzFdLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG5cdFx0XHRcdC8vIEAtMTUsNS43XG5cdFx0XHRcdGNob3JkWzFdID0gY2hvcmRbMV0uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHR2YXIgeCA9IHRva2VuaXplci5nZXRGbG9hdChjaG9yZFsxXSk7XG5cdFx0XHRcdGlmICh4LmRpZ2l0cyA9PT0gMClcblx0XHRcdFx0XHR3YXJuKFwiTWlzc2luZyBmaXJzdCBwb3NpdGlvbiBpbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgYW5ub3RhdGlvbi5cIiwgbGluZSAsIGkpO1xuXHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnN1YnN0cmluZyh4LmRpZ2l0cyk7XG5cdFx0XHRcdGlmIChjaG9yZFsxXVswXSAhPT0gJywnKVxuXHRcdFx0XHRcdHdhcm4oXCJNaXNzaW5nIGNvbW1hIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbm5vdGF0aW9uLlwiLCBsaW5lICwgaSk7XG5cdFx0XHRcdGNob3JkWzFdID0gY2hvcmRbMV0uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHR2YXIgeSA9IHRva2VuaXplci5nZXRGbG9hdChjaG9yZFsxXSk7XG5cdFx0XHRcdGlmICh5LmRpZ2l0cyA9PT0gMClcblx0XHRcdFx0XHR3YXJuKFwiTWlzc2luZyBzZWNvbmQgcG9zaXRpb24gaW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFubm90YXRpb24uXCIsIGxpbmUgLCBpKTtcblx0XHRcdFx0Y2hvcmRbMV0gPSBjaG9yZFsxXS5zdWJzdHJpbmcoeS5kaWdpdHMpO1xuXHRcdFx0XHR2YXIgd3MgPSB0b2tlbml6ZXIuc2tpcFdoaXRlU3BhY2UoY2hvcmRbMV0pO1xuXHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnN1YnN0cmluZyh3cyk7XG5cdFx0XHRcdGNob3JkWzJdID0gbnVsbDtcblx0XHRcdFx0Y2hvcmRbM10gPSB7IHg6IHgudmFsdWUsIHk6IHkudmFsdWUgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmZyZWVnY2hvcmQgIT09IHRydWUpIHtcblx0XHRcdFx0XHRjaG9yZFsxXSA9IGNob3JkWzFdLnJlcGxhY2UoLyhbQUJDREVGRzAtOV0pYi9nLCBcIiQx4pmtXCIpO1xuXHRcdFx0XHRcdGNob3JkWzFdID0gY2hvcmRbMV0ucmVwbGFjZSgvKFtBQkNERUZHMC05XSkjL2csIFwiJDHima9cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hvcmRbMl0gPSAnZGVmYXVsdCc7XG5cdFx0XHRcdGNob3JkWzFdID0gdHJhbnNwb3NlLmNob3JkTmFtZShtdWx0aWxpbmVWYXJzLCBjaG9yZFsxXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hvcmQ7XG5cdFx0fVxuXHRcdHJldHVybiBbMCwgXCJcIl07XG5cdH07XG5cblx0dmFyIGxlZ2FsQWNjZW50cyA9IFsgXCJ0cmlsbFwiLCBcImxvd2VybW9yZGVudFwiLCBcInVwcGVybW9yZGVudFwiLCBcIm1vcmRlbnRcIiwgXCJwcmFsbHRyaWxsZXJcIiwgXCJhY2NlbnRcIixcblx0XHRcImZlcm1hdGFcIiwgXCJpbnZlcnRlZGZlcm1hdGFcIiwgXCJ0ZW51dG9cIiwgXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCIrXCIsIFwid2VkZ2VcIixcblx0XHRcIm9wZW5cIiwgXCJ0aHVtYlwiLCBcInNuYXBcIiwgXCJ0dXJuXCIsIFwicm9sbFwiLCBcImJyZWF0aFwiLCBcInNob3J0cGhyYXNlXCIsIFwibWVkaXVtcGhyYXNlXCIsIFwibG9uZ3BocmFzZVwiLFxuXHRcdFwic2Vnbm9cIiwgXCJjb2RhXCIsIFwiRC5TLlwiLCBcIkQuQy5cIiwgXCJmaW5lXCIsXG5cdFx0XCJzbGlkZVwiLCBcIl5cIiwgXCJtYXJjYXRvXCIsXG5cdFx0XCJ1cGJvd1wiLCBcImRvd25ib3dcIiwgXCIvXCIsIFwiLy9cIiwgXCIvLy9cIiwgXCIvLy8vXCIsIFwidHJlbTFcIiwgXCJ0cmVtMlwiLCBcInRyZW0zXCIsIFwidHJlbTRcIixcblx0XHRcInR1cm54XCIsIFwiaW52ZXJ0ZWR0dXJuXCIsIFwiaW52ZXJ0ZWR0dXJueFwiLCBcInRyaWxsKFwiLCBcInRyaWxsKVwiLCBcImFycGVnZ2lvXCIsIFwieHN0ZW1cIiwgXCJtYXJrXCIsIFwidW1hcmNhdG9cIixcblx0XHRcInN0eWxlPW5vcm1hbFwiLCBcInN0eWxlPWhhcm1vbmljXCIsIFwic3R5bGU9cmh5dGhtXCIsIFwic3R5bGU9eFwiXG5cdF07XG5cdHZhciB2b2x1bWVEZWNvcmF0aW9ucyA9IFsgXCJwXCIsIFwicHBcIiwgXCJmXCIsIFwiZmZcIiwgXCJtZlwiLCBcIm1wXCIsIFwicHBwXCIsIFwicHBwcFwiLCAgXCJmZmZcIiwgXCJmZmZmXCIsIFwic2Z6XCIgXTtcblx0dmFyIGR5bmFtaWNEZWNvcmF0aW9ucyA9IFtcImNyZXNjZW5kbyhcIiwgXCJjcmVzY2VuZG8pXCIsIFwiZGltaW51ZW5kbyhcIiwgXCJkaW1pbnVlbmRvKVwiXTtcblxuXHR2YXIgYWNjZW50UHNldWRvbnltcyA9IFsgW1wiPFwiLCBcImFjY2VudFwiXSwgW1wiPlwiLCBcImFjY2VudFwiXSwgW1widHJcIiwgXCJ0cmlsbFwiXSxcblx0XHRbXCJwbHVzXCIsIFwiK1wiXSwgWyBcImVtcGhhc2lzXCIsIFwiYWNjZW50XCJdLFxuXHRcdFsgXCJeXCIsIFwidW1hcmNhdG9cIiBdLCBbIFwibWFyY2F0b1wiLCBcInVtYXJjYXRvXCIgXSBdO1xuXHR2YXIgYWNjZW50RHluYW1pY1BzZXVkb255bXMgPSBbIFtcIjwoXCIsIFwiY3Jlc2NlbmRvKFwiXSwgW1wiPClcIiwgXCJjcmVzY2VuZG8pXCJdLFxuXHRcdFtcIj4oXCIsIFwiZGltaW51ZW5kbyhcIl0sIFtcIj4pXCIsIFwiZGltaW51ZW5kbylcIl0gXTtcblx0dmFyIGxldHRlcl90b19hY2NlbnQgPSBmdW5jdGlvbihsaW5lLCBpKVxuXHR7XG5cdFx0dmFyIG1hY3JvID0gbXVsdGlsaW5lVmFycy5tYWNyb3NbbGluZS5jaGFyQXQoaSldO1xuXG5cdFx0aWYgKG1hY3JvICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChtYWNyby5jaGFyQXQoMCkgPT09ICchJyB8fCBtYWNyby5jaGFyQXQoMCkgPT09ICcrJylcblx0XHRcdFx0bWFjcm8gPSBtYWNyby5zdWJzdHJpbmcoMSk7XG5cdFx0XHRpZiAobWFjcm8uY2hhckF0KG1hY3JvLmxlbmd0aC0xKSA9PT0gJyEnIHx8IG1hY3JvLmNoYXJBdChtYWNyby5sZW5ndGgtMSkgPT09ICcrJylcblx0XHRcdFx0bWFjcm8gPSBtYWNyby5zdWJzdHJpbmcoMCwgbWFjcm8ubGVuZ3RoLTEpO1xuXHRcdFx0aWYgKHBhcnNlQ29tbW9uLmRldGVjdChsZWdhbEFjY2VudHMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRcdHJldHVybiAobWFjcm8gPT09IGFjYyk7XG5cdFx0XHRcdH0pKVxuXHRcdFx0XHRyZXR1cm4gWyAxLCBtYWNybyBdO1xuXHRcdFx0ZWxzZSBpZiAocGFyc2VDb21tb24uZGV0ZWN0KHZvbHVtZURlY29yYXRpb25zLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdFx0XHRyZXR1cm4gKG1hY3JvID09PSBhY2MpO1xuXHRcdFx0XHR9KSkge1xuXHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy52b2x1bWVQb3NpdGlvbiA9PT0gJ2hpZGRlbicpXG5cdFx0XHRcdFx0bWFjcm8gPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gWzEsIG1hY3JvXTtcblx0XHRcdH0gZWxzZSBpZiAocGFyc2VDb21tb24uZGV0ZWN0KGR5bmFtaWNEZWNvcmF0aW9ucywgZnVuY3Rpb24oYWNjKSB7XG5cdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMuZHluYW1pY1Bvc2l0aW9uID09PSAnaGlkZGVuJylcblx0XHRcdFx0XHRcdG1hY3JvID0gXCJcIjtcblx0XHRcdFx0XHRyZXR1cm4gKG1hY3JvID09PSBhY2MpO1xuXHRcdFx0XHR9KSkge1xuXHRcdFx0XHRyZXR1cm4gWzEsIG1hY3JvXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghcGFyc2VDb21tb24uZGV0ZWN0KG11bHRpbGluZVZhcnMuaWdub3JlZERlY29yYXRpb25zLCBmdW5jdGlvbihkZWMpIHtcblx0XHRcdFx0XHRyZXR1cm4gKG1hY3JvID09PSBkZWMpO1xuXHRcdFx0XHR9KSlcblx0XHRcdFx0XHR3YXJuKFwiVW5rbm93biBtYWNybzogXCIgKyBtYWNybywgbGluZSwgaSk7XG5cdFx0XHRcdHJldHVybiBbMSwgJycgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0c3dpdGNoIChsaW5lLmNoYXJBdChpKSlcblx0XHR7XG5cdFx0XHRjYXNlICcuJzpyZXR1cm4gWzEsICdzdGFjY2F0byddO1xuXHRcdFx0Y2FzZSAndSc6cmV0dXJuIFsxLCAndXBib3cnXTtcblx0XHRcdGNhc2UgJ3YnOnJldHVybiBbMSwgJ2Rvd25ib3cnXTtcblx0XHRcdGNhc2UgJ34nOnJldHVybiBbMSwgJ2lyaXNocm9sbCddO1xuXHRcdFx0Y2FzZSAnISc6XG5cdFx0XHRjYXNlICcrJzpcblx0XHRcdFx0dmFyIHJldCA9IHRva2VuaXplci5nZXRCcmFja2V0dGVkU3Vic3RyaW5nKGxpbmUsIGksIDUpO1xuXHRcdFx0XHQvLyBCZSBzdXJlIHRoYXQgdGhlIGFjY2VudCBpcyByZWNvZ25pemFibGUuXG5cdFx0XHRpZiAocmV0WzFdLmxlbmd0aCA+IDAgJiYgKHJldFsxXS5jaGFyQXQoMCkgPT09ICdeJyB8fCByZXRbMV0uY2hhckF0KDApID09PSdfJykpXG5cdFx0XHRcdFx0cmV0WzFdID0gcmV0WzFdLnN1YnN0cmluZygxKTtcdC8vIFRPRE8tUEVSOiBUaGUgdGVzdCBmaWxlcyBoYXZlIGluZGljYXRvcnMgZm9yY2luZyB0aGUgb3JuYW1lbnQgdG8gdGhlIHRvcCBvciBib3R0b20sIGJ1dCB0aGF0IGlzbid0IGluIHRoZSBzdGFuZGFyZC4gV2UnbGwganVzdCBpZ25vcmUgdGhlbS5cblx0XHRcdFx0aWYgKHBhcnNlQ29tbW9uLmRldGVjdChsZWdhbEFjY2VudHMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRcdHJldHVybiAocmV0WzFdID09PSBhY2MpO1xuXHRcdFx0XHR9KSlcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHRpZiAocGFyc2VDb21tb24uZGV0ZWN0KHZvbHVtZURlY29yYXRpb25zLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdFx0XHRcdHJldHVybiAocmV0WzFdID09PSBhY2MpO1xuXHRcdFx0XHRcdH0pKSB7XG5cdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMudm9sdW1lUG9zaXRpb24gPT09ICdoaWRkZW4nIClcblx0XHRcdFx0XHRcdHJldFsxXSA9ICcnO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFyc2VDb21tb24uZGV0ZWN0KGR5bmFtaWNEZWNvcmF0aW9ucywgZnVuY3Rpb24oYWNjKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKHJldFsxXSA9PT0gYWNjKTtcblx0XHRcdFx0XHR9KSkge1xuXHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmR5bmFtaWNQb3NpdGlvbiA9PT0gJ2hpZGRlbicgKVxuXHRcdFx0XHRcdFx0cmV0WzFdID0gJyc7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhcnNlQ29tbW9uLmRldGVjdChhY2NlbnRQc2V1ZG9ueW1zLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdFx0XHRpZiAocmV0WzFdID09PSBhY2NbMF0pIHtcblx0XHRcdFx0XHRcdHJldFsxXSA9IGFjY1sxXTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9KSlcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHRcdGlmIChwYXJzZUNvbW1vbi5kZXRlY3QoYWNjZW50RHluYW1pY1BzZXVkb255bXMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRcdGlmIChyZXRbMV0gPT09IGFjY1swXSkge1xuXHRcdFx0XHRcdFx0cmV0WzFdID0gYWNjWzFdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0pKSB7XG5cdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMuZHluYW1pY1Bvc2l0aW9uID09PSAnaGlkZGVuJyApXG5cdFx0XHRcdFx0XHRyZXRbMV0gPSAnJztcblx0XHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gV2UgZGlkbid0IGZpbmQgdGhlIGFjY2VudCBpbiB0aGUgbGlzdCwgc28gY29uc3VtZSB0aGUgc3BhY2UsIGJ1dCBkb24ndCByZXR1cm4gYW4gYWNjZW50LlxuXHRcdFx0XHQvLyBBbHRob3VnaCBpdCBpcyBwb3NzaWJsZSB0aGF0ICEgd2FzIHVzZWQgYXMgYSBsaW5lIGJyZWFrLCBzbyBhY2NlcHQgdGhhdC5cblx0XHRcdGlmIChsaW5lLmNoYXJBdChpKSA9PT0gJyEnICYmIChyZXRbMF0gPT09IDEgfHwgbGluZS5jaGFyQXQoaStyZXRbMF0tMSkgIT09ICchJykpXG5cdFx0XHRcdFx0cmV0dXJuIFsxLCBudWxsIF07XG5cdFx0XHRcdHdhcm4oXCJVbmtub3duIGRlY29yYXRpb246IFwiICsgcmV0WzFdLCBsaW5lLCBpKTtcblx0XHRcdFx0cmV0WzFdID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdGNhc2UgJ0gnOnJldHVybiBbMSwgJ2Zlcm1hdGEnXTtcblx0XHRcdGNhc2UgJ0onOnJldHVybiBbMSwgJ3NsaWRlJ107XG5cdFx0XHRjYXNlICdMJzpyZXR1cm4gWzEsICdhY2NlbnQnXTtcblx0XHRcdGNhc2UgJ00nOnJldHVybiBbMSwgJ21vcmRlbnQnXTtcblx0XHRcdGNhc2UgJ08nOnJldHVyblsxLCAnY29kYSddO1xuXHRcdFx0Y2FzZSAnUCc6cmV0dXJuWzEsICdwcmFsbHRyaWxsZXInXTtcblx0XHRcdGNhc2UgJ1InOnJldHVybiBbMSwgJ3JvbGwnXTtcblx0XHRcdGNhc2UgJ1MnOnJldHVybiBbMSwgJ3NlZ25vJ107XG5cdFx0XHRjYXNlICdUJzpyZXR1cm4gWzEsICd0cmlsbCddO1xuXHRcdH1cblx0XHRyZXR1cm4gWzAsIDBdO1xuXHR9O1xuXG5cdHZhciBsZXR0ZXJfdG9fc3BhY2VyID0gZnVuY3Rpb24obGluZSwgaSlcblx0e1xuXHRcdHZhciBzdGFydCA9IGk7XG5cdFx0d2hpbGUgKHRva2VuaXplci5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoaSkpKVxuXHRcdFx0aSsrO1xuXHRcdHJldHVybiBbIGktc3RhcnQgXTtcblx0fTtcblxuXHQvLyByZXR1cm5zIHRoZSBjbGFzcyBvZiB0aGUgYmFyIGxpbmVcblx0Ly8gdGhlIG51bWJlciBvZiB0aGUgcmVwZWF0XG5cdC8vIGFuZCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdXNlZCB1cFxuXHQvLyBpZiAwIGlzIHJldHVybmVkLCB0aGVuIHRoZSBuZXh0IGVsZW1lbnQgd2FzIG5vdCBhIGJhciBsaW5lXG5cdHZhciBsZXR0ZXJfdG9fYmFyID0gZnVuY3Rpb24obGluZSwgY3Vycl9wb3MpXG5cdHtcblx0XHR2YXIgcmV0ID0gdG9rZW5pemVyLmdldEJhckxpbmUobGluZSwgY3Vycl9wb3MpO1xuXHRcdGlmIChyZXQubGVuID09PSAwKVxuXHRcdFx0cmV0dXJuIFswLFwiXCJdO1xuXHRcdGlmIChyZXQud2Fybikge1xuXHRcdFx0d2FybihyZXQud2FybiwgbGluZSwgY3Vycl9wb3MpO1xuXHRcdFx0cmV0dXJuIFtyZXQubGVuLFwiXCJdO1xuXHRcdH1cblxuXHRcdC8vIE5vdyBzZWUgaWYgdGhpcyBpcyBhIHJlcGVhdGVkIGVuZGluZ1xuXHRcdC8vIEEgcmVwZWF0ZWQgZW5kaW5nIGlzIGFsbCBvZiB0aGUgY2hhcmFjdGVycyAxLDIsMyw0LDUsNiw3LDgsOSwwLC0sIGFuZCBjb21tYVxuXHRcdC8vIEl0IGNhbiBhbHNvIG9wdGlvbmFsbHkgc3RhcnQgd2l0aCAnWycsIHdoaWNoIGlzIGlnbm9yZWQuXG5cdFx0Ly8gQWxzbywgaXQgY2FuIGhhdmUgd2hpdGUgc3BhY2UgYmVmb3JlIHRoZSAnWycuXG5cdFx0Zm9yICh2YXIgd3MgPSAwOyB3cyA8IGxpbmUubGVuZ3RoOyB3cysrKVxuXHRcdFx0aWYgKGxpbmUuY2hhckF0KGN1cnJfcG9zICsgcmV0LmxlbiArIHdzKSAhPT0gJyAnKVxuXHRcdFx0XHRicmVhaztcblx0XHR2YXIgb3JpZ19iYXJfbGVuID0gcmV0Lmxlbjtcblx0XHRpZiAobGluZS5jaGFyQXQoY3Vycl9wb3MrcmV0Lmxlbit3cykgPT09ICdbJykge1xuXHRcdFx0cmV0LmxlbiArPSB3cyArIDE7XG5cdFx0fVxuXG5cdFx0Ly8gSXQgY2FuIGFsc28gYmUgYSBxdW90ZWQgc3RyaW5nLiBJdCBpcyB1bmNsZWFyIHdoZXRoZXIgdGhhdCBjb25zdHJ1Y3QgcmVxdWlyZXMgJ1snLCBidXQgaXQgc2VlbXMgbGlrZSBpdCB3b3VsZC4gb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2VkIHdpdGggYSByZWd1bGFyIGNob3JkLlxuXHRcdGlmIChsaW5lLmNoYXJBdChjdXJyX3BvcytyZXQubGVuKSA9PT0gJ1wiJyAmJiBsaW5lLmNoYXJBdChjdXJyX3BvcytyZXQubGVuLTEpID09PSAnWycpIHtcblx0XHRcdHZhciBlbmRpbmcgPSB0b2tlbml6ZXIuZ2V0QnJhY2tldHRlZFN1YnN0cmluZyhsaW5lLCBjdXJyX3BvcytyZXQubGVuLCA1KTtcblx0XHRcdHJldHVybiBbcmV0LmxlbitlbmRpbmdbMF0sIHJldC50b2tlbiwgZW5kaW5nWzFdXTtcblx0XHR9XG5cdFx0dmFyIHJldFJlcCA9IHRva2VuaXplci5nZXRUb2tlbk9mKGxpbmUuc3Vic3RyaW5nKGN1cnJfcG9zK3JldC5sZW4pLCBcIjEyMzQ1Njc4OTAtLFwiKTtcblx0XHRpZiAocmV0UmVwLmxlbiA9PT0gMCB8fCByZXRSZXAudG9rZW5bMF0gPT09ICctJylcblx0XHRcdHJldHVybiBbb3JpZ19iYXJfbGVuLCByZXQudG9rZW5dO1xuXG5cdFx0cmV0dXJuIFtyZXQubGVuK3JldFJlcC5sZW4sIHJldC50b2tlbiwgcmV0UmVwLnRva2VuXTtcblx0fTtcblxuXHR2YXIgdHJpcGxldFEgPSB7XG5cdFx0MjogMyxcblx0XHQzOiAyLFxuXHRcdDQ6IDMsXG5cdFx0NTogMiwgLy8gVE9ETy1QRVI6IG5vdCBoYW5kbGluZyA2Lzggcmh5dGhtIHlldFxuXHRcdDY6IDIsXG5cdFx0NzogMiwgLy8gVE9ETy1QRVI6IG5vdCBoYW5kbGluZyA2Lzggcmh5dGhtIHlldFxuXHRcdDg6IDMsXG5cdFx0OTogMiAvLyBUT0RPLVBFUjogbm90IGhhbmRsaW5nIDYvOCByaHl0aG0geWV0XG5cdH07XG5cdHZhciBsZXR0ZXJfdG9fb3Blbl9zbHVyc19hbmRfdHJpcGxldHMgPSAgZnVuY3Rpb24obGluZSwgaSkge1xuXHRcdC8vIGNvbnN1bWUgc3BhY2VzLCBhbmQgbG9vayBmb3IgYWxsIHRoZSBvcGVuIHBhcmVucy4gSWYgdGhlcmUgaXMgYSBudW1iZXIgYWZ0ZXIgdGhlIG9wZW4gcGFyZW4sXG5cdFx0Ly8gdGhhdCBpcyBhIHRyaXBsZXQuIE90aGVyd2lzZSB0aGF0IGlzIGEgc2x1ci4gQ29sbGVjdCBhbGwgdGhlIHNsdXJzIGFuZCB0aGUgZmlyc3QgdHJpcGxldC5cblx0XHR2YXIgcmV0ID0ge307XG5cdFx0dmFyIHN0YXJ0ID0gaTtcblx0XHR3aGlsZSAobGluZS5jaGFyQXQoaSkgPT09ICcoJyB8fCB0b2tlbml6ZXIuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckF0KGkpKSkge1xuXHRcdFx0aWYgKGxpbmUuY2hhckF0KGkpID09PSAnKCcpIHtcblx0XHRcdFx0aWYgKGkrMSA8IGxpbmUubGVuZ3RoICYmIChsaW5lLmNoYXJBdChpKzEpID49ICcyJyAmJiBsaW5lLmNoYXJBdChpKzEpIDw9ICc5JykpIHtcblx0XHRcdFx0XHRpZiAocmV0LnRyaXBsZXQgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHdhcm4oXCJDYW4ndCBuZXN0IHRyaXBsZXRzXCIsIGxpbmUsIGkpO1xuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0LnRyaXBsZXQgPSBsaW5lLmNoYXJBdChpKzEpIC0gJzAnO1xuXHRcdFx0XHRcdFx0cmV0LnRyaXBsZXRRID0gdHJpcGxldFFbcmV0LnRyaXBsZXRdO1xuXHRcdFx0XHRcdFx0cmV0Lm51bV9ub3RlcyA9IHJldC50cmlwbGV0O1xuXHRcdFx0XHRcdFx0aWYgKGkrMiA8IGxpbmUubGVuZ3RoICYmIGxpbmUuY2hhckF0KGkrMikgPT09ICc6Jykge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBhcmUgZXhwZWN0aW5nIFwiKHA6cTpyXCIgb3IgXCIocDpxXCIgb3IgXCIocDo6clwiXG5cdFx0XHRcdFx0XHRcdC8vIFRoYXQgaXM6IFwicHV0IHAgbm90ZXMgaW50byB0aGUgdGltZSBvZiBxIGZvciB0aGUgbmV4dCByIG5vdGVzXCJcblx0XHRcdFx0XHRcdFx0Ly8gaWYgciBpcyBtaXNzaW5nLCB0aGVuIGl0IGlzIGVxdWFsIHRvIHAuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHEgaXMgbWlzc2luZywgaXQgaXMgZGV0ZXJtaW5lZCBmcm9tIHRoaXMgdGFibGU6XG5cdFx0XHRcdFx0XHRcdC8vICgyIG5vdGVzIGluIHRoZSB0aW1lIG9mIDNcblx0XHRcdFx0XHRcdFx0Ly8gKDMgbm90ZXMgaW4gdGhlIHRpbWUgb2YgMlxuXHRcdFx0XHRcdFx0XHQvLyAoNCBub3RlcyBpbiB0aGUgdGltZSBvZiAzXG5cdFx0XHRcdFx0XHRcdC8vICg1IG5vdGVzIGluIHRoZSB0aW1lIG9mIG4gfCBpZiB0aW1lIHNpZyBpcyAoNi84LCA5LzgsIDEyLzgpLCBuPTMsIGVsc2Ugbj0yXG5cdFx0XHRcdFx0XHRcdC8vICg2IG5vdGVzIGluIHRoZSB0aW1lIG9mIDJcblx0XHRcdFx0XHRcdFx0Ly8gKDcgbm90ZXMgaW4gdGhlIHRpbWUgb2YgblxuXHRcdFx0XHRcdFx0XHQvLyAoOCBub3RlcyBpbiB0aGUgdGltZSBvZiAzXG5cdFx0XHRcdFx0XHRcdC8vICg5IG5vdGVzIGluIHRoZSB0aW1lIG9mIG5cblx0XHRcdFx0XHRcdFx0aWYgKGkrMyA8IGxpbmUubGVuZ3RoICYmIGxpbmUuY2hhckF0KGkrMykgPT09ICc6Jykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBzZWNvbmQgbnVtYmVyLCAncScsIGlzIG5vdCBwcmVzZW50LlxuXHRcdFx0XHRcdFx0XHRcdGlmIChpKzQgPCBsaW5lLmxlbmd0aCAmJiAobGluZS5jaGFyQXQoaSs0KSA+PSAnMScgJiYgbGluZS5jaGFyQXQoaSs0KSA8PSAnOScpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXQubnVtX25vdGVzID0gbGluZS5jaGFyQXQoaSs0KSAtICcwJztcblx0XHRcdFx0XHRcdFx0XHRcdGkgKz0gMztcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oXCJleHBlY3RlZCBudW1iZXIgYWZ0ZXIgdGhlIHR3byBjb2xvbnMgYWZ0ZXIgdGhlIHRyaXBsZXQgdG8gbWFyayB0aGUgZHVyYXRpb25cIiwgbGluZSwgaSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSszIDwgbGluZS5sZW5ndGggJiYgKGxpbmUuY2hhckF0KGkrMykgPj0gJzEnICYmIGxpbmUuY2hhckF0KGkrMykgPD0gJzknKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldC50cmlwbGV0USA9IGxpbmUuY2hhckF0KGkrMykgLSAnMCc7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkrNCA8IGxpbmUubGVuZ3RoICYmIGxpbmUuY2hhckF0KGkrNCkgPT09ICc6Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGkrNSA8IGxpbmUubGVuZ3RoICYmIChsaW5lLmNoYXJBdChpKzUpID49ICcxJyAmJiBsaW5lLmNoYXJBdChpKzUpIDw9ICc5JykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0Lm51bV9ub3RlcyA9IGxpbmUuY2hhckF0KGkrNSkgLSAnMCc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGkgKz0gNDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSArPSAyO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdFx0d2FybihcImV4cGVjdGVkIG51bWJlciBhZnRlciB0aGUgdHJpcGxldCB0byBtYXJrIHRoZSBkdXJhdGlvblwiLCBsaW5lLCBpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZXQuc3RhcnRTbHVyID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRyZXQuc3RhcnRTbHVyID0gMTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXQuc3RhcnRTbHVyKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cdFx0cmV0LmNvbnN1bWVkID0gaS1zdGFydDtcblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdHZhciBhZGRXb3JkcyA9IGZ1bmN0aW9uKGxpbmUsIHdvcmRzKSB7XG5cdFx0aWYgKCFsaW5lKSB7IHdhcm4oXCJDYW4ndCBhZGQgd29yZHMgYmVmb3JlIHRoZSBmaXJzdCBsaW5lIG9mIG11c2ljXCIsIGxpbmUsIDApOyByZXR1cm47IH1cblx0XHR3b3JkcyA9IHBhcnNlQ29tbW9uLnN0cmlwKHdvcmRzKTtcblx0XHRpZiAod29yZHMuY2hhckF0KHdvcmRzLmxlbmd0aC0xKSAhPT0gJy0nKVxuXHRcdFx0d29yZHMgPSB3b3JkcyArICcgJztcdC8vIEp1c3QgbWFrZXMgaXQgZWFzaWVyIHRvIHBhcnNlIGJlbG93LCBzaW5jZSBldmVyeSB3b3JkIGhhcyBhIGRpdmlkZXIgYWZ0ZXIgaXQuXG5cdFx0dmFyIHdvcmRfbGlzdCA9IFtdO1xuXHRcdC8vIGZpcnN0IG1ha2UgYSBsaXN0IG9mIHdvcmRzIGZyb20gdGhlIHN0cmluZyB3ZSBhcmUgcGFzc2VkLiBBIHdvcmQgaXMgZGl2aWRlZCBvbiBlaXRoZXIgYSBzcGFjZSBvciBkYXNoLlxuXHRcdHZhciBsYXN0X2RpdmlkZXIgPSAwO1xuXHRcdHZhciByZXBsYWNlID0gZmFsc2U7XG5cdFx0dmFyIGFkZFdvcmQgPSBmdW5jdGlvbihpKSB7XG5cdFx0XHR2YXIgd29yZCA9IHBhcnNlQ29tbW9uLnN0cmlwKHdvcmRzLnN1YnN0cmluZyhsYXN0X2RpdmlkZXIsIGkpKTtcblx0XHRcdGxhc3RfZGl2aWRlciA9IGkrMTtcblx0XHRcdGlmICh3b3JkLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0aWYgKHJlcGxhY2UpXG5cdFx0XHRcdFx0d29yZCA9IHBhcnNlQ29tbW9uLmdzdWIod29yZCwnficsICcgJyk7XG5cdFx0XHRcdHZhciBkaXYgPSB3b3Jkcy5jaGFyQXQoaSk7XG5cdFx0XHRcdGlmIChkaXYgIT09ICdfJyAmJiBkaXYgIT09ICctJylcblx0XHRcdFx0XHRkaXYgPSAnICc7XG5cdFx0XHRcdHdvcmRfbGlzdC5wdXNoKHtzeWxsYWJsZTogdG9rZW5pemVyLnRyYW5zbGF0ZVN0cmluZyh3b3JkKSwgZGl2aWRlcjogZGl2fSk7XG5cdFx0XHRcdHJlcGxhY2UgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzd2l0Y2ggKHdvcmRzLmNoYXJBdChpKSkge1xuXHRcdFx0XHRjYXNlICcgJzpcblx0XHRcdFx0Y2FzZSAnXFx4MTInOlxuXHRcdFx0XHRcdGFkZFdvcmQoaSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJy0nOlxuXHRcdFx0XHRcdGlmICghYWRkV29yZChpKSAmJiB3b3JkX2xpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0cGFyc2VDb21tb24ubGFzdCh3b3JkX2xpc3QpLmRpdmlkZXIgPSAnLSc7XG5cdFx0XHRcdFx0XHR3b3JkX2xpc3QucHVzaCh7c2tpcDogdHJ1ZSwgdG86ICduZXh0J30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXyc6XG5cdFx0XHRcdFx0YWRkV29yZChpKTtcblx0XHRcdFx0XHR3b3JkX2xpc3QucHVzaCh7c2tpcDogdHJ1ZSwgdG86ICdzbHVyJ30pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICcqJzpcblx0XHRcdFx0XHRhZGRXb3JkKGkpO1xuXHRcdFx0XHRcdHdvcmRfbGlzdC5wdXNoKHtza2lwOiB0cnVlLCB0bzogJ25leHQnfSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3wnOlxuXHRcdFx0XHRcdGFkZFdvcmQoaSk7XG5cdFx0XHRcdFx0d29yZF9saXN0LnB1c2goe3NraXA6IHRydWUsIHRvOiAnYmFyJ30pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICd+Jzpcblx0XHRcdFx0XHRyZXBsYWNlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaW5TbHVyID0gZmFsc2U7XG5cdFx0cGFyc2VDb21tb24uZWFjaChsaW5lLCBmdW5jdGlvbihlbCkge1xuXHRcdFx0aWYgKHdvcmRfbGlzdC5sZW5ndGggIT09IDApIHtcblx0XHRcdFx0aWYgKHdvcmRfbGlzdFswXS5za2lwKSB7XG5cdFx0XHRcdFx0c3dpdGNoICh3b3JkX2xpc3RbMF0udG8pIHtcblx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOiBpZiAoZWwuZWxfdHlwZSA9PT0gJ25vdGUnICYmIGVsLnBpdGNoZXMgIT09IG51bGwgJiYgIWluU2x1cikgd29yZF9saXN0LnNoaWZ0KCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnc2x1cic6IGlmIChlbC5lbF90eXBlID09PSAnbm90ZScgJiYgZWwucGl0Y2hlcyAhPT0gbnVsbCkgd29yZF9saXN0LnNoaWZ0KCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmFyJzogaWYgKGVsLmVsX3R5cGUgPT09ICdiYXInKSB3b3JkX2xpc3Quc2hpZnQoKTsgYnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChlbC5lbF90eXBlICE9PSAnYmFyJykge1xuXHRcdFx0XHRcdFx0aWYgKGVsLmx5cmljID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRcdGVsLmx5cmljID0gW3tzeWxsYWJsZTogXCJcIiwgZGl2aWRlcjogXCIgXCJ9XTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0ZWwubHlyaWMucHVzaCh7c3lsbGFibGU6IFwiXCIsIGRpdmlkZXI6IFwiIFwifSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlbC5lbF90eXBlID09PSAnbm90ZScgJiYgZWwucmVzdCA9PT0gdW5kZWZpbmVkICYmICFpblNsdXIpIHtcblx0XHRcdFx0XHRcdHZhciBseXJpYyA9IHdvcmRfbGlzdC5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0aWYgKGx5cmljLnN5bGxhYmxlKVxuXHRcdFx0XHRcdFx0XHRseXJpYy5zeWxsYWJsZSA9IGx5cmljLnN5bGxhYmxlLnJlcGxhY2UoLyArL2csJ1xceEEwJyk7XG5cdFx0XHRcdFx0XHRpZiAoZWwubHlyaWMgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdFx0ZWwubHlyaWMgPSBbIGx5cmljIF07XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGVsLmx5cmljLnB1c2gobHlyaWMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdHZhciBhZGRTeW1ib2xzID0gZnVuY3Rpb24obGluZSwgd29yZHMpIHtcblx0XHQvLyBUT0RPLVBFUjogQ3VycmVudGx5IGNvcGllZCBmcm9tIHc6IGxpbmUuIFRoaXMgbmVlZHMgdG8gYmUgcmVhZCBhcyBzeW1ib2xzIGluc3RlYWQuXG5cdFx0aWYgKCFsaW5lKSB7IHdhcm4oXCJDYW4ndCBhZGQgc3ltYm9scyBiZWZvcmUgdGhlIGZpcnN0IGxpbmUgb2YgbXVzaWNcIiwgbGluZSwgMCk7IHJldHVybjsgfVxuXHRcdHdvcmRzID0gcGFyc2VDb21tb24uc3RyaXAod29yZHMpO1xuXHRcdGlmICh3b3Jkcy5jaGFyQXQod29yZHMubGVuZ3RoLTEpICE9PSAnLScpXG5cdFx0XHR3b3JkcyA9IHdvcmRzICsgJyAnO1x0Ly8gSnVzdCBtYWtlcyBpdCBlYXNpZXIgdG8gcGFyc2UgYmVsb3csIHNpbmNlIGV2ZXJ5IHdvcmQgaGFzIGEgZGl2aWRlciBhZnRlciBpdC5cblx0XHR2YXIgd29yZF9saXN0ID0gW107XG5cdFx0Ly8gZmlyc3QgbWFrZSBhIGxpc3Qgb2Ygd29yZHMgZnJvbSB0aGUgc3RyaW5nIHdlIGFyZSBwYXNzZWQuIEEgd29yZCBpcyBkaXZpZGVkIG9uIGVpdGhlciBhIHNwYWNlIG9yIGRhc2guXG5cdFx0dmFyIGxhc3RfZGl2aWRlciA9IDA7XG5cdFx0dmFyIHJlcGxhY2UgPSBmYWxzZTtcblx0XHR2YXIgYWRkV29yZCA9IGZ1bmN0aW9uKGkpIHtcblx0XHRcdHZhciB3b3JkID0gcGFyc2VDb21tb24uc3RyaXAod29yZHMuc3Vic3RyaW5nKGxhc3RfZGl2aWRlciwgaSkpO1xuXHRcdFx0bGFzdF9kaXZpZGVyID0gaSsxO1xuXHRcdFx0aWYgKHdvcmQubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpZiAocmVwbGFjZSlcblx0XHRcdFx0XHR3b3JkID0gcGFyc2VDb21tb24uZ3N1Yih3b3JkLCAnficsICcgJyk7XG5cdFx0XHRcdHZhciBkaXYgPSB3b3Jkcy5jaGFyQXQoaSk7XG5cdFx0XHRcdGlmIChkaXYgIT09ICdfJyAmJiBkaXYgIT09ICctJylcblx0XHRcdFx0XHRkaXYgPSAnICc7XG5cdFx0XHRcdHdvcmRfbGlzdC5wdXNoKHtzeWxsYWJsZTogdG9rZW5pemVyLnRyYW5zbGF0ZVN0cmluZyh3b3JkKSwgZGl2aWRlcjogZGl2fSk7XG5cdFx0XHRcdHJlcGxhY2UgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzd2l0Y2ggKHdvcmRzLmNoYXJBdChpKSkge1xuXHRcdFx0XHRjYXNlICcgJzpcblx0XHRcdFx0Y2FzZSAnXFx4MTInOlxuXHRcdFx0XHRcdGFkZFdvcmQoaSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJy0nOlxuXHRcdFx0XHRcdGlmICghYWRkV29yZChpKSAmJiB3b3JkX2xpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0cGFyc2VDb21tb24ubGFzdCh3b3JkX2xpc3QpLmRpdmlkZXIgPSAnLSc7XG5cdFx0XHRcdFx0XHR3b3JkX2xpc3QucHVzaCh7c2tpcDogdHJ1ZSwgdG86ICduZXh0J30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXyc6XG5cdFx0XHRcdFx0YWRkV29yZChpKTtcblx0XHRcdFx0XHR3b3JkX2xpc3QucHVzaCh7c2tpcDogdHJ1ZSwgdG86ICdzbHVyJ30pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICcqJzpcblx0XHRcdFx0XHRhZGRXb3JkKGkpO1xuXHRcdFx0XHRcdHdvcmRfbGlzdC5wdXNoKHtza2lwOiB0cnVlLCB0bzogJ25leHQnfSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3wnOlxuXHRcdFx0XHRcdGFkZFdvcmQoaSk7XG5cdFx0XHRcdFx0d29yZF9saXN0LnB1c2goe3NraXA6IHRydWUsIHRvOiAnYmFyJ30pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICd+Jzpcblx0XHRcdFx0XHRyZXBsYWNlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaW5TbHVyID0gZmFsc2U7XG5cdFx0cGFyc2VDb21tb24uZWFjaChsaW5lLCBmdW5jdGlvbihlbCkge1xuXHRcdFx0aWYgKHdvcmRfbGlzdC5sZW5ndGggIT09IDApIHtcblx0XHRcdFx0aWYgKHdvcmRfbGlzdFswXS5za2lwKSB7XG5cdFx0XHRcdFx0c3dpdGNoICh3b3JkX2xpc3RbMF0udG8pIHtcblx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOiBpZiAoZWwuZWxfdHlwZSA9PT0gJ25vdGUnICYmIGVsLnBpdGNoZXMgIT09IG51bGwgJiYgIWluU2x1cikgd29yZF9saXN0LnNoaWZ0KCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnc2x1cic6IGlmIChlbC5lbF90eXBlID09PSAnbm90ZScgJiYgZWwucGl0Y2hlcyAhPT0gbnVsbCkgd29yZF9saXN0LnNoaWZ0KCk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmFyJzogaWYgKGVsLmVsX3R5cGUgPT09ICdiYXInKSB3b3JkX2xpc3Quc2hpZnQoKTsgYnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChlbC5lbF90eXBlID09PSAnbm90ZScgJiYgZWwucmVzdCA9PT0gdW5kZWZpbmVkICYmICFpblNsdXIpIHtcblx0XHRcdFx0XHRcdHZhciBseXJpYyA9IHdvcmRfbGlzdC5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0aWYgKGVsLmx5cmljID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRcdGVsLmx5cmljID0gWyBseXJpYyBdO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRlbC5seXJpYy5wdXNoKGx5cmljKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHR2YXIgZ2V0QnJva2VuUmh5dGhtID0gZnVuY3Rpb24obGluZSwgaW5kZXgpIHtcblx0XHRzd2l0Y2ggKGxpbmUuY2hhckF0KGluZGV4KSkge1xuXHRcdFx0Y2FzZSAnPic6XG5cdFx0XHRpZiAoaW5kZXggPCBsaW5lLmxlbmd0aCAtIDEgJiYgbGluZS5jaGFyQXQoaW5kZXgrMSkgPT09ICc+JylcdC8vIGRvdWJsZSA+PlxuXHRcdFx0XHRcdHJldHVybiBbMiwgMS43NSwgMC4yNV07XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gWzEsIDEuNSwgMC41XTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICc8Jzpcblx0XHRcdGlmIChpbmRleCA8IGxpbmUubGVuZ3RoIC0gMSAmJiBsaW5lLmNoYXJBdChpbmRleCsxKSA9PT0gJzwnKVx0Ly8gZG91YmxlIDw8XG5cdFx0XHRcdFx0cmV0dXJuIFsyLCAwLjI1LCAxLjc1XTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHJldHVybiBbMSwgMC41LCAxLjVdO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0Ly8gVE9ETy1QRVI6IG1ha2UgdGhpcyBhIG1ldGhvZCBpbiBlbC5cblx0dmFyIGFkZEVuZEJlYW0gPSBmdW5jdGlvbihlbCkge1xuXHRcdGlmIChlbC5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGVsLmR1cmF0aW9uIDwgMC4yNSlcblx0XHRcdGVsLmVuZF9iZWFtID0gdHJ1ZTtcblx0XHRyZXR1cm4gZWw7XG5cdH07XG5cblx0dmFyIHBpdGNoZXMgPSB7QTogNSwgQjogNiwgQzogMCwgRDogMSwgRTogMiwgRjogMywgRzogNCwgYTogMTIsIGI6IDEzLCBjOiA3LCBkOiA4LCBlOiA5LCBmOiAxMCwgZzogMTF9O1xuXHR2YXIgcmVzdHMgPSB7eDogJ2ludmlzaWJsZScsIHk6ICdzcGFjZXInLCB6OiAncmVzdCcsIFo6ICdtdWx0aW1lYXN1cmUnIH07XG5cdHZhciBnZXRDb3JlTm90ZSA9IGZ1bmN0aW9uKGxpbmUsIGluZGV4LCBlbCwgY2FuSGF2ZUJyb2tlblJoeXRobSkge1xuXHRcdC8vdmFyIGVsID0geyBzdGFydENoYXI6IGluZGV4IH07XG5cdFx0dmFyIGlzQ29tcGxldGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdFx0cmV0dXJuIChzdGF0ZSA9PT0gJ29jdGF2ZScgfHwgc3RhdGUgPT09ICdkdXJhdGlvbicgfHwgc3RhdGUgPT09ICdaZHVyYXRpb24nIHx8IHN0YXRlID09PSAnYnJva2VuX3JoeXRobScgfHwgc3RhdGUgPT09ICdlbmRfc2x1cicpO1xuXHRcdH07XG5cdFx0dmFyIHN0YXRlID0gJ3N0YXJ0U2x1cic7XG5cdFx0dmFyIGR1cmF0aW9uU2V0QnlQcmV2aW91c05vdGUgPSBmYWxzZTtcblx0XHR3aGlsZSAoMSkge1xuXHRcdFx0c3dpdGNoKGxpbmUuY2hhckF0KGluZGV4KSkge1xuXHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdzdGFydFNsdXInKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWwuc3RhcnRTbHVyID09PSB1bmRlZmluZWQpIGVsLnN0YXJ0U2x1ciA9IDE7IGVsc2UgZWwuc3RhcnRTbHVyKys7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlKHN0YXRlKSkge2VsLmVuZENoYXIgPSBpbmRleDtyZXR1cm4gZWw7fVxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJyknOlxuXHRcdFx0XHRcdGlmIChpc0NvbXBsZXRlKHN0YXRlKSkge1xuXHRcdFx0XHRcdFx0aWYgKGVsLmVuZFNsdXIgPT09IHVuZGVmaW5lZCkgZWwuZW5kU2x1ciA9IDE7IGVsc2UgZWwuZW5kU2x1cisrO1xuXHRcdFx0XHRcdH0gZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnXic6XG5cdFx0XHRcdFx0aWYgKHN0YXRlID09PSAnc3RhcnRTbHVyJykge2VsLmFjY2lkZW50YWwgPSAnc2hhcnAnO3N0YXRlID0gJ3NoYXJwMic7fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHN0YXRlID09PSAnc2hhcnAyJykge2VsLmFjY2lkZW50YWwgPSAnZGJsc2hhcnAnO3N0YXRlID0gJ3BpdGNoJzt9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaXNDb21wbGV0ZShzdGF0ZSkpIHtlbC5lbmRDaGFyID0gaW5kZXg7cmV0dXJuIGVsO31cblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdfJzpcblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdzdGFydFNsdXInKSB7ZWwuYWNjaWRlbnRhbCA9ICdmbGF0JztzdGF0ZSA9ICdmbGF0Mic7fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHN0YXRlID09PSAnZmxhdDInKSB7ZWwuYWNjaWRlbnRhbCA9ICdkYmxmbGF0JztzdGF0ZSA9ICdwaXRjaCc7fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7ZWwuZW5kQ2hhciA9IGluZGV4O3JldHVybiBlbDt9XG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnPSc6XG5cdFx0XHRcdFx0aWYgKHN0YXRlID09PSAnc3RhcnRTbHVyJykge2VsLmFjY2lkZW50YWwgPSAnbmF0dXJhbCc7c3RhdGUgPSAncGl0Y2gnO31cblx0XHRcdFx0XHRlbHNlIGlmIChpc0NvbXBsZXRlKHN0YXRlKSkge2VsLmVuZENoYXIgPSBpbmRleDtyZXR1cm4gZWw7fVxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRjYXNlICdCJzpcblx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdGNhc2UgJ0QnOlxuXHRcdFx0XHRjYXNlICdFJzpcblx0XHRcdFx0Y2FzZSAnRic6XG5cdFx0XHRcdGNhc2UgJ0cnOlxuXHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0Y2FzZSAnZSc6XG5cdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRjYXNlICdnJzpcblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdzdGFydFNsdXInIHx8IHN0YXRlID09PSAnc2hhcnAyJyB8fCBzdGF0ZSA9PT0gJ2ZsYXQyJyB8fCBzdGF0ZSA9PT0gJ3BpdGNoJykge1xuXHRcdFx0XHRcdFx0ZWwucGl0Y2ggPSBwaXRjaGVzW2xpbmUuY2hhckF0KGluZGV4KV07XG5cdFx0XHRcdFx0XHR0cmFuc3Bvc2Uubm90ZShtdWx0aWxpbmVWYXJzLCBlbCk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9ICdvY3RhdmUnO1xuXHRcdFx0XHRcdFx0Ly8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGEgdmFsaWQgbm90ZS4gVGhlIHJlc3QgaXMgb3B0aW9uYWwuIFNldCB0aGUgZHVyYXRpb24gaW4gY2FzZSB3ZSBkb24ndCBnZXQgb25lIGJlbG93XG5cdFx0XHRcdFx0XHRpZiAoY2FuSGF2ZUJyb2tlblJoeXRobSAmJiBtdWx0aWxpbmVWYXJzLm5leHRfbm90ZV9kdXJhdGlvbiAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRlbC5kdXJhdGlvbiA9IG11bHRpbGluZVZhcnMuZGVmYXVsdF9sZW5ndGggKiBtdWx0aWxpbmVWYXJzLm5leHRfbm90ZV9kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5uZXh0X25vdGVfZHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHRkdXJhdGlvblNldEJ5UHJldmlvdXNOb3RlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRlbC5kdXJhdGlvbiA9IG11bHRpbGluZVZhcnMuZGVmYXVsdF9sZW5ndGg7XG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgY2xlZiBpcyBwZXJjdXNzaW9uLCB0aGVyZSBpcyBwcm9iYWJseSBzb21lIHRyYW5zbGF0aW9uIG9mIHRoZSBwaXRjaCB0byBhIHBhcnRpY3VsYXIgZHJ1bSBraXQgaXRlbS5cblx0XHRcdFx0XHRcdGlmICgobXVsdGlsaW5lVmFycy5jbGVmICYmIG11bHRpbGluZVZhcnMuY2xlZi50eXBlID09PSBcInBlcmNcIikgfHxcblx0XHRcdFx0XHRcdFx0KG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlICYmIG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLmNsZWYgPT09IFwicGVyY1wiKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIga2V5ID0gbGluZS5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZWwuYWNjaWRlbnRhbCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBhY2NNYXAgPSB7ICdkYmxmbGF0JzogJ19fJywgJ2ZsYXQnOiAnXycsICduYXR1cmFsJzogJz0nLCAnc2hhcnAnOiAnXicsICdkYmxzaGFycCc6ICdeXid9O1xuXHRcdFx0XHRcdFx0XHRcdGtleSA9IGFjY01hcFtlbC5hY2NpZGVudGFsXSArIGtleTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAodHVuZS5mb3JtYXR0aW5nICYmIHR1bmUuZm9ybWF0dGluZy5taWRpICYmIHR1bmUuZm9ybWF0dGluZy5taWRpLmRydW1tYXApXG5cdFx0XHRcdFx0XHRcdFx0ZWwubWlkaXBpdGNoID0gdHVuZS5mb3JtYXR0aW5nLm1pZGkuZHJ1bW1hcFtrZXldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZShzdGF0ZSkpIHtlbC5lbmRDaGFyID0gaW5kZXg7cmV0dXJuIGVsO31cblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICcsJzpcblx0XHRcdFx0XHRpZiAoc3RhdGUgPT09ICdvY3RhdmUnKSB7ZWwucGl0Y2ggLT0gNzt9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaXNDb21wbGV0ZShzdGF0ZSkpIHtlbC5lbmRDaGFyID0gaW5kZXg7cmV0dXJuIGVsO31cblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdcXCcnOlxuXHRcdFx0XHRcdGlmIChzdGF0ZSA9PT0gJ29jdGF2ZScpIHtlbC5waXRjaCArPSA3O31cblx0XHRcdFx0XHRlbHNlIGlmIChpc0NvbXBsZXRlKHN0YXRlKSkge2VsLmVuZENoYXIgPSBpbmRleDtyZXR1cm4gZWw7fVxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3gnOlxuXHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHRcdGlmIChzdGF0ZSA9PT0gJ3N0YXJ0U2x1cicpIHtcblx0XHRcdFx0XHRcdGVsLnJlc3QgPSB7IHR5cGU6IHJlc3RzW2xpbmUuY2hhckF0KGluZGV4KV0gfTtcblx0XHRcdFx0XHRcdC8vIFRoZXJlIHNob3VsZG4ndCBiZSBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgbm90ZXMgaGF2ZS4gSWYgc29tZSBzbmVhayBpbiBkdWUgdG8gYmFkIHN5bnRheCBpbiB0aGUgYWJjIGZpbGUsXG5cdFx0XHRcdFx0XHQvLyBqdXN0IG5peCB0aGVtIGhlcmUuXG5cdFx0XHRcdFx0XHRkZWxldGUgZWwuYWNjaWRlbnRhbDtcblx0XHRcdFx0XHRcdGRlbGV0ZSBlbC5zdGFydFNsdXI7XG5cdFx0XHRcdFx0XHRkZWxldGUgZWwuc3RhcnRUaWU7XG5cdFx0XHRcdFx0XHRkZWxldGUgZWwuZW5kU2x1cjtcblx0XHRcdFx0XHRcdGRlbGV0ZSBlbC5lbmRUaWU7XG5cdFx0XHRcdFx0XHRkZWxldGUgZWwuZW5kX2JlYW07XG5cdFx0XHRcdFx0XHRkZWxldGUgZWwuZ3JhY2Vfbm90ZXM7XG5cdFx0XHRcdFx0XHQvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSB2YWxpZCBub3RlLiBUaGUgcmVzdCBpcyBvcHRpb25hbC4gU2V0IHRoZSBkdXJhdGlvbiBpbiBjYXNlIHdlIGRvbid0IGdldCBvbmUgYmVsb3dcblx0XHRcdFx0XHRcdGlmIChlbC5yZXN0LnR5cGUgPT09ICdtdWx0aW1lYXN1cmUnKSB7XG5cdFx0XHRcdFx0XHRcdGVsLmR1cmF0aW9uID0gMTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSAnWmR1cmF0aW9uJztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjYW5IYXZlQnJva2VuUmh5dGhtICYmIG11bHRpbGluZVZhcnMubmV4dF9ub3RlX2R1cmF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBtdWx0aWxpbmVWYXJzLmRlZmF1bHRfbGVuZ3RoICogbXVsdGlsaW5lVmFycy5uZXh0X25vdGVfZHVyYXRpb247XG5cdFx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5uZXh0X25vdGVfZHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uU2V0QnlQcmV2aW91c05vdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbC5kdXJhdGlvbiA9IG11bHRpbGluZVZhcnMuZGVmYXVsdF9sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gJ2R1cmF0aW9uJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7ZWwuZW5kQ2hhciA9IGluZGV4O3JldHVybiBlbDt9XG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnMSc6XG5cdFx0XHRcdGNhc2UgJzInOlxuXHRcdFx0XHRjYXNlICczJzpcblx0XHRcdFx0Y2FzZSAnNCc6XG5cdFx0XHRcdGNhc2UgJzUnOlxuXHRcdFx0XHRjYXNlICc2Jzpcblx0XHRcdFx0Y2FzZSAnNyc6XG5cdFx0XHRcdGNhc2UgJzgnOlxuXHRcdFx0XHRjYXNlICc5Jzpcblx0XHRcdFx0Y2FzZSAnMCc6XG5cdFx0XHRcdGNhc2UgJy8nOlxuXHRcdFx0XHRcdGlmIChzdGF0ZSA9PT0gJ29jdGF2ZScgfHwgc3RhdGUgPT09ICdkdXJhdGlvbicpIHtcblx0XHRcdFx0XHRcdHZhciBmcmFjdGlvbiA9IHRva2VuaXplci5nZXRGcmFjdGlvbihsaW5lLCBpbmRleCk7XG5cdFx0XHRcdFx0XHQvL2lmICghZHVyYXRpb25TZXRCeVByZXZpb3VzTm90ZSlcblx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBlbC5kdXJhdGlvbiAqIGZyYWN0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IFdlIGNhbiB0ZXN0IHRoZSByZXR1cm5lZCBkdXJhdGlvbiBoZXJlIGFuZCBnaXZlIGEgd2FybmluZyBpZiBpdCBpc24ndCB0aGUgb25lIGV4cGVjdGVkLlxuXHRcdFx0XHRcdFx0ZWwuZW5kQ2hhciA9IGZyYWN0aW9uLmluZGV4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyYWN0aW9uLmluZGV4IDwgbGluZS5sZW5ndGggJiYgKHRva2VuaXplci5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoZnJhY3Rpb24uaW5kZXgpKSB8fCBsaW5lLmNoYXJBdChmcmFjdGlvbi5pbmRleCkgPT09ICctJykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KGZyYWN0aW9uLmluZGV4KSA9PT0gJy0nKVxuXHRcdFx0XHRcdFx0XHRcdGVsLnN0YXJ0VGllID0ge307XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbCA9IGFkZEVuZEJlYW0oZWwpO1xuXHRcdFx0XHRcdFx0XHRmcmFjdGlvbi5pbmRleCsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5kZXggPSBmcmFjdGlvbi5pbmRleC0xO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSAnYnJva2VuX3JoeXRobSc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gJ3NoYXJwMicpIHtcblx0XHRcdFx0XHRcdGVsLmFjY2lkZW50YWwgPSAncXVhcnRlcnNoYXJwJztzdGF0ZSA9ICdwaXRjaCc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2ZsYXQyJykge1xuXHRcdFx0XHRcdFx0ZWwuYWNjaWRlbnRhbCA9ICdxdWFydGVyZmxhdCc7c3RhdGUgPSAncGl0Y2gnO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09ICdaZHVyYXRpb24nKSB7XG5cdFx0XHRcdFx0XHR2YXIgbnVtID0gdG9rZW5pemVyLmdldE51bWJlcihsaW5lLCBpbmRleCk7XG5cdFx0XHRcdFx0XHRlbC5kdXJhdGlvbiA9IG51bS5udW07XG5cdFx0XHRcdFx0XHRlbC5lbmRDaGFyID0gbnVtLmluZGV4O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHRcdH0gZWxzZSByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnLSc6XG5cdFx0XHRcdFx0aWYgKHN0YXRlID09PSAnc3RhcnRTbHVyJykge1xuXHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyLCBzbyBpdCBtdXN0IGhhdmUgYmVlbiBtZWFudCBmb3IgdGhlIHByZXZpb3VzIG5vdGUuIENvcnJlY3QgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdFx0dHVuZS5hZGRUaWVUb0xhc3ROb3RlKCk7XG5cdFx0XHRcdFx0XHRlbC5lbmRUaWUgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09ICdvY3RhdmUnIHx8IHN0YXRlID09PSAnZHVyYXRpb24nIHx8IHN0YXRlID09PSAnZW5kX3NsdXInKSB7XG5cdFx0XHRcdFx0XHRlbC5zdGFydFRpZSA9IHt9O1xuXHRcdFx0XHRcdFx0aWYgKCFkdXJhdGlvblNldEJ5UHJldmlvdXNOb3RlICYmIGNhbkhhdmVCcm9rZW5SaHl0aG0pXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gJ2Jyb2tlbl9yaHl0aG0nO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFBlZWsgYWhlYWQgdG8gdGhlIG5leHQgY2hhcmFjdGVyLiBJZiBpdCBpcyBhIHNwYWNlLCB0aGVuIHdlIGhhdmUgYW4gZW5kIGJlYW0uXG5cdFx0XHRcdFx0XHRcdGlmICh0b2tlbml6ZXIuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckF0KGluZGV4ICsgMSkpKVxuXHRcdFx0XHRcdFx0XHRcdGFkZEVuZEJlYW0oZWwpO1xuXHRcdFx0XHRcdFx0XHRlbC5lbmRDaGFyID0gaW5kZXgrMTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09ICdicm9rZW5fcmh5dGhtJykge2VsLmVuZENoYXIgPSBpbmRleDtyZXR1cm4gZWw7fVxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJyAnOlxuXHRcdFx0XHRjYXNlICdcXHQnOlxuXHRcdFx0XHRcdGlmIChpc0NvbXBsZXRlKHN0YXRlKSkge1xuXHRcdFx0XHRcdFx0ZWwuZW5kX2JlYW0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0Ly8gbG9vayBhaGVhZCB0byBzZWUgaWYgdGhlcmUgaXMgYSB0aWVcblx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KGluZGV4KSA9PT0gJy0nKVxuXHRcdFx0XHRcdFx0XHRcdGVsLnN0YXJ0VGllID0ge307XG5cdFx0XHRcdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdFx0XHR9IHdoaWxlIChpbmRleCA8IGxpbmUubGVuZ3RoICYmICh0b2tlbml6ZXIuaXNXaGl0ZVNwYWNlKGxpbmUuY2hhckF0KGluZGV4KSkgfHwgbGluZS5jaGFyQXQoaW5kZXgpID09PSAnLScpKTtcblx0XHRcdFx0XHRcdGVsLmVuZENoYXIgPSBpbmRleDtcblx0XHRcdFx0XHRcdGlmICghZHVyYXRpb25TZXRCeVByZXZpb3VzTm90ZSAmJiBjYW5IYXZlQnJva2VuUmh5dGhtICYmIChsaW5lLmNoYXJBdChpbmRleCkgPT09ICc8JyB8fCBsaW5lLmNoYXJBdChpbmRleCkgPT09ICc+JykpIHtcdC8vIFRPRE8tUEVSOiBEb24ndCBuZWVkIHRoZSB0ZXN0IGZvciA8IGFuZCA+LCBidXQgdGhhdCBtYWtlcyB0aGUgZW5kQ2hhciB3b3JrIG91dCBmb3IgdGhlIHJlZ3Jlc3Npb24gdGVzdC5cblx0XHRcdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSAnYnJva2VuX3JoeXRobSc7XG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICc+Jzpcblx0XHRcdFx0Y2FzZSAnPCc6XG5cdFx0XHRcdFx0aWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2FuSGF2ZUJyb2tlblJoeXRobSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYnIyID0gZ2V0QnJva2VuUmh5dGhtKGxpbmUsIGluZGV4KTtcblx0XHRcdFx0XHRcdFx0aW5kZXggKz0gYnIyWzBdIC0gMTtcdC8vIGluZGV4IGdldHMgaW5jcmVtZW50ZWQgYmVsb3csIHNvIHdlJ2xsIGxldCB0aGF0IGhhcHBlblxuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLm5leHRfbm90ZV9kdXJhdGlvbiA9IGJyMlsyXTtcblx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBicjJbMV0qZWwuZHVyYXRpb247XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gJ2VuZF9zbHVyJztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVsLmVuZENoYXIgPSBpbmRleDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7XG5cdFx0XHRcdFx0XHRlbC5lbmRDaGFyID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aW5kZXgrKztcblx0XHRcdGlmIChpbmRleCA9PT0gbGluZS5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUoc3RhdGUpKSB7ZWwuZW5kQ2hhciA9IGluZGV4O3JldHVybiBlbDt9XG5cdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHN0YXJ0TmV3TGluZSgpIHtcblx0XHR2YXIgcGFyYW1zID0geyBzdGFydENoYXI6IC0xLCBlbmRDaGFyOiAtMX07XG5cdFx0aWYgKG11bHRpbGluZVZhcnMucGFydEZvck5leHRMaW5lLnRpdGxlKVxuXHRcdFx0cGFyYW1zLnBhcnQgPSBtdWx0aWxpbmVWYXJzLnBhcnRGb3JOZXh0TGluZTtcblx0XHRwYXJhbXMuY2xlZiA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlICYmIG11bHRpbGluZVZhcnMuc3RhdmVzW211bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtXS5jbGVmICE9PSB1bmRlZmluZWQgPyBwYXJzZUNvbW1vbi5jbG9uZShtdWx0aWxpbmVWYXJzLnN0YXZlc1ttdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGFmZk51bV0uY2xlZikgOiBwYXJzZUNvbW1vbi5jbG9uZShtdWx0aWxpbmVWYXJzLmNsZWYpO1xuXHRcdHZhciBzY29yZVRyYW5zcG9zZSA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlID8gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc2NvcmVUcmFuc3Bvc2UgOiAwO1xuXHRcdHBhcmFtcy5rZXkgPSBwYXJzZUtleVZvaWNlLnN0YW5kYXJkS2V5KG11bHRpbGluZVZhcnMua2V5LnJvb3QrbXVsdGlsaW5lVmFycy5rZXkuYWNjK211bHRpbGluZVZhcnMua2V5Lm1vZGUsIG11bHRpbGluZVZhcnMua2V5LnJvb3QsIG11bHRpbGluZVZhcnMua2V5LmFjYywgc2NvcmVUcmFuc3Bvc2UpO1xuXHRcdHBhcmFtcy5rZXkubW9kZSA9IG11bHRpbGluZVZhcnMua2V5Lm1vZGU7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscylcblx0XHRcdHBhcmFtcy5rZXkuaW1wbGllZE5hdHVyYWxzID0gbXVsdGlsaW5lVmFycy5rZXkuaW1wbGllZE5hdHVyYWxzO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLmtleS5leHBsaWNpdEFjY2lkZW50YWxzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpbGluZVZhcnMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW1zLmtleS5hY2NpZGVudGFscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmIChwYXJhbXMua2V5LmFjY2lkZW50YWxzW2pdLm5vdGUgPT09IG11bHRpbGluZVZhcnMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHNbaV0ubm90ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIG5vdGUgaXMgYWxyZWFkeSBpbiB0aGUgbGlzdCwgb3ZlcnJpZGUgaXQgd2l0aCB0aGUgbmV3IHZhbHVlXG5cdFx0XHRcdFx0XHRwYXJhbXMua2V5LmFjY2lkZW50YWxzW2pdLmFjYyA9IG11bHRpbGluZVZhcnMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHNbaV0uYWNjO1xuXHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWZvdW5kKVxuXHRcdFx0XHRcdHBhcmFtcy5rZXkuYWNjaWRlbnRhbHMucHVzaChtdWx0aWxpbmVWYXJzLmtleS5leHBsaWNpdEFjY2lkZW50YWxzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bXVsdGlsaW5lVmFycy50YXJnZXRLZXkgPSBwYXJhbXMua2V5O1xuXHRcdGlmIChwYXJhbXMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHMpXG5cdFx0XHRkZWxldGUgcGFyYW1zLmtleS5leHBsaWNpdEFjY2lkZW50YWxzO1xuXHRcdHBhcnNlS2V5Vm9pY2UuYWRkUG9zVG9LZXkocGFyYW1zLmNsZWYsIHBhcmFtcy5rZXkpO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLm1ldGVyICE9PSBudWxsKSB7XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UpIHtcblx0XHRcdFx0cGFyc2VDb21tb24uZWFjaChtdWx0aWxpbmVWYXJzLnN0YXZlcywgZnVuY3Rpb24oc3QpIHtcblx0XHRcdFx0XHRzdC5tZXRlciA9IG11bHRpbGluZVZhcnMubWV0ZXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwYXJhbXMubWV0ZXIgPSBtdWx0aWxpbmVWYXJzLnN0YXZlc1ttdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubWV0ZXI7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuc3RhdmVzW211bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtXS5tZXRlciA9IG51bGw7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cGFyYW1zLm1ldGVyID0gbXVsdGlsaW5lVmFycy5tZXRlcjtcblx0XHRcdG11bHRpbGluZVZhcnMubWV0ZXIgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UgJiYgbXVsdGlsaW5lVmFycy5zdGF2ZXNbbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc3RhZmZOdW1dLm1ldGVyKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBlYWNoIHZvaWNlIGdldHMgdGhlIG1ldGVyIG1hcmtpbmcuXG5cdFx0XHRwYXJhbXMubWV0ZXIgPSBtdWx0aWxpbmVWYXJzLnN0YXZlc1ttdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubWV0ZXI7XG5cdFx0XHRtdWx0aWxpbmVWYXJzLnN0YXZlc1ttdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubWV0ZXIgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UgJiYgbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UubmFtZSlcblx0XHRcdHBhcmFtcy5uYW1lID0gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UubmFtZTtcblx0XHRpZiAobXVsdGlsaW5lVmFycy52b2NhbGZvbnQpXG5cdFx0XHRwYXJhbXMudm9jYWxmb250ID0gbXVsdGlsaW5lVmFycy52b2NhbGZvbnQ7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMudHJpcGxldGZvbnQpXG5cdFx0XHRwYXJhbXMudHJpcGxldGZvbnQgPSBtdWx0aWxpbmVWYXJzLnRyaXBsZXRmb250O1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLnN0eWxlKVxuXHRcdFx0cGFyYW1zLnN0eWxlID0gbXVsdGlsaW5lVmFycy5zdHlsZTtcblx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UpIHtcblx0XHRcdHZhciBzdGFmZiA9IG11bHRpbGluZVZhcnMuc3RhdmVzW211bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtXTtcblx0XHRcdGlmIChzdGFmZi5icmFjZSkgcGFyYW1zLmJyYWNlID0gc3RhZmYuYnJhY2U7XG5cdFx0XHRpZiAoc3RhZmYuYnJhY2tldCkgcGFyYW1zLmJyYWNrZXQgPSBzdGFmZi5icmFja2V0O1xuXHRcdFx0aWYgKHN0YWZmLmNvbm5lY3RCYXJMaW5lcykgcGFyYW1zLmNvbm5lY3RCYXJMaW5lcyA9IHN0YWZmLmNvbm5lY3RCYXJMaW5lcztcblx0XHRcdGlmIChzdGFmZi5uYW1lKSBwYXJhbXMubmFtZSA9IHN0YWZmLm5hbWVbbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UuaW5kZXhdO1xuXHRcdFx0aWYgKHN0YWZmLnN1Ym5hbWUpIHBhcmFtcy5zdWJuYW1lID0gc3RhZmYuc3VibmFtZVttdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5pbmRleF07XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc3RlbSlcblx0XHRcdFx0cGFyYW1zLnN0ZW0gPSBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGVtO1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmbGluZXMpXG5cdFx0XHRcdHBhcmFtcy5zdGFmZmxpbmVzID0gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc3RhZmZsaW5lcztcblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdGFmZnNjYWxlKVxuXHRcdFx0XHRwYXJhbXMuc3RhZmZzY2FsZSA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmc2NhbGU7XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc2NhbGUpXG5cdFx0XHRcdHBhcmFtcy5zY2FsZSA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnNjYWxlO1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0eWxlKVxuXHRcdFx0XHRwYXJhbXMuc3R5bGUgPSBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zdHlsZTtcblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS50cmFuc3Bvc2UpXG5cdFx0XHRcdHBhcmFtcy5jbGVmLnRyYW5zcG9zZSA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnRyYW5zcG9zZTtcblx0XHR9XG5cdFx0dmFyIGlzRmlyc3RWb2ljZSA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlID09PSB1bmRlZmluZWQgfHwgKG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtID09PSAgMCAmJiBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5pbmRleCA9PT0gIDApO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLmJhck51bWJlcnMgPT09IDAgJiYgaXNGaXJzdFZvaWNlICYmIG11bHRpbGluZVZhcnMuY3VyckJhck51bWJlciAhPT0gMSlcblx0XHRcdHBhcmFtcy5iYXJOdW1iZXIgPSBtdWx0aWxpbmVWYXJzLmN1cnJCYXJOdW1iZXI7XG5cdFx0dHVuZS5zdGFydE5ld0xpbmUocGFyYW1zKTtcblx0XHRpZiAobXVsdGlsaW5lVmFycy5rZXkuaW1wbGllZE5hdHVyYWxzKVxuXHRcdFx0ZGVsZXRlIG11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscztcblxuXHRcdG11bHRpbGluZVZhcnMucGFydEZvck5leHRMaW5lID0ge307XG5cdH1cblxuXHR2YXIgbGV0dGVyX3RvX2dyYWNlID0gIGZ1bmN0aW9uKGxpbmUsIGkpIHtcblx0XHQvLyBHcmFjZSBub3RlcyBhcmUgYW4gYXJyYXkgb2Y6IHN0YXJ0c2x1ciwgbm90ZSwgZW5kc2x1ciwgc3BhY2U7IHdoZXJlIG5vdGUgaXMgYWNjaWRlbnRhbCwgcGl0Y2gsIGR1cmF0aW9uXG5cdFx0aWYgKGxpbmUuY2hhckF0KGkpID09PSAneycpIHtcblx0XHRcdC8vIGZldGNoIHRoZSBncmFjZW5vdGVzIHN0cmluZyBhbmQgY29uc3VtZSB0aGF0IGludG8gdGhlIGFycmF5XG5cdFx0XHR2YXIgZ3JhID0gdG9rZW5pemVyLmdldEJyYWNrZXR0ZWRTdWJzdHJpbmcobGluZSwgaSwgMSwgJ30nKTtcblx0XHRcdGlmICghZ3JhWzJdKVxuXHRcdFx0XHR3YXJuKFwiTWlzc2luZyB0aGUgY2xvc2luZyAnfScgd2hpbGUgcGFyc2luZyBncmFjZSBub3RlXCIsIGxpbmUsIGkpO1xuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBzbHVyIGFmdGVyIHRoZSBncmFjZSBjb25zdHJ1Y3Rpb24sIHRoZW4gbW92ZSBpdCB0byB0aGUgbGFzdCBub3RlIGluc2lkZSB0aGUgZ3JhY2UgY29uc3RydWN0aW9uXG5cdFx0XHRpZiAobGluZVtpK2dyYVswXV0gPT09ICcpJykge1xuXHRcdFx0XHRncmFbMF0rKztcblx0XHRcdFx0Z3JhWzFdICs9ICcpJztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGdyYWNlbm90ZXMgPSBbXTtcblx0XHRcdHZhciBpaSA9IDA7XG5cdFx0XHR2YXIgaW5UaWUgPSBmYWxzZTtcblx0XHRcdHdoaWxlIChpaSA8IGdyYVsxXS5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGFjY2lhY2NhdHVyYSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoZ3JhWzFdLmNoYXJBdChpaSkgPT09ICcvJykge1xuXHRcdFx0XHRcdGFjY2lhY2NhdHVyYSA9IHRydWU7XG5cdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbm90ZSA9IGdldENvcmVOb3RlKGdyYVsxXSwgaWksIHt9LCBmYWxzZSk7XG5cdFx0XHRcdGlmIChub3RlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gVGhlIGdyYWNlIG5vdGUgZHVyYXRpb25zIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgdGhlIGRlZmF1bHQgbGVuZ3RoOiB0aGV5IHNob3VsZCBiZSBiYXNlZCBvbiAxLzE2LCBzbyBpZiB0aGF0IGlzbid0IHRoZSBkZWZhdWx0LCB0aGVuIG11bHRpcGx5IGhlcmUuXG5cdFx0XHRcdFx0bm90ZS5kdXJhdGlvbiA9IG5vdGUuZHVyYXRpb24gLyAobXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCAqIDgpO1xuXHRcdFx0XHRcdGlmIChhY2NpYWNjYXR1cmEpXG5cdFx0XHRcdFx0XHRub3RlLmFjY2lhY2NhdHVyYSA9IHRydWU7XG5cdFx0XHRcdFx0Z3JhY2Vub3Rlcy5wdXNoKG5vdGUpO1xuXG5cdFx0XHRcdFx0aWYgKGluVGllKSB7XG5cdFx0XHRcdFx0XHRub3RlLmVuZFRpZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpblRpZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobm90ZS5zdGFydFRpZSlcblx0XHRcdFx0XHRcdGluVGllID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlpICA9IG5vdGUuZW5kQ2hhcjtcblx0XHRcdFx0XHRkZWxldGUgbm90ZS5lbmRDaGFyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIFdlIHNob3VsZG4ndCBnZXQgYW55dGhpbmcgYnV0IG5vdGVzIG9yIGEgc3BhY2UgaGVyZSwgc28gcmVwb3J0IGFuIGVycm9yXG5cdFx0XHRcdFx0aWYgKGdyYVsxXS5jaGFyQXQoaWkpID09PSAnICcpIHtcblx0XHRcdFx0XHRcdGlmIChncmFjZW5vdGVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0XHRcdGdyYWNlbm90ZXNbZ3JhY2Vub3Rlcy5sZW5ndGgtMV0uZW5kX2JlYW0gPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0d2FybihcIlVua25vd24gY2hhcmFjdGVyICdcIiArIGdyYVsxXS5jaGFyQXQoaWkpICsgXCInIHdoaWxlIHBhcnNpbmcgZ3JhY2Ugbm90ZVwiLCBsaW5lLCBpKTtcblx0XHRcdFx0XHRpaSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3JhY2Vub3Rlcy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiBbZ3JhWzBdLCBncmFjZW5vdGVzXTtcblx0XHR9XG5cdFx0cmV0dXJuIFsgMCBdO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGxldHRlcl90b19vdmVybGF5KGxpbmUsIGkpIHtcblx0XHRpZiAobGluZS5jaGFyQXQoaSkgPT09ICcmJykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaTtcblx0XHRcdHdoaWxlIChsaW5lLmNoYXJBdChpKSAmJiBsaW5lLmNoYXJBdChpKSAhPT0gJzonICYmIGxpbmUuY2hhckF0KGkpICE9PSAnfCcpXG5cdFx0XHRcdGkrKztcblx0XHRcdHJldHVybiBbIGktc3RhcnQsIGxpbmUuc3Vic3RyaW5nKHN0YXJ0KzEsIGkpIF07XG5cdFx0fVxuXHRcdHJldHVybiBbIDAgXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGR1cmF0aW9uT2ZNZWFzdXJlKG11bHRpbGluZVZhcnMpIHtcblx0XHQvLyBUT0RPLVBFUjogVGhpcyBjb3VsZCBiZSBtb3JlIGNvbXBsaWNhdGVkIGlmIG9uZSBvZiB0aGUgdW51c3VhbCBtZWFzdXJlcyBpcyB1c2VkLlxuXHRcdHZhciBtZXRlciA9IG11bHRpbGluZVZhcnMub3JpZ01ldGVyO1xuXHRcdGlmICghbWV0ZXIgfHwgbWV0ZXIudHlwZSAhPT0gJ3NwZWNpZmllZCcpXG5cdFx0XHRyZXR1cm4gMTtcblx0XHRpZiAoIW1ldGVyLnZhbHVlIHx8IG1ldGVyLnZhbHVlLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAxO1xuXHRcdHJldHVybiBwYXJzZUludChtZXRlci52YWx1ZVswXS5udW0sIDEwKSAvIHBhcnNlSW50KG1ldGVyLnZhbHVlWzBdLmRlbiwgMTApO1xuXHR9XG5cblx0Ly9cblx0Ly8gUGFyc2UgbGluZSBvZiBtdXNpY1xuXHQvL1xuXHQvLyBUaGlzIGlzIGEgc3RyZWFtIG9mIDwoYmFyLW1hcmtpbmd8aGVhZGVyfG5vdGUtZ3JvdXApLi4uPiBpbiBhbnkgb3JkZXIsIHdpdGggb3B0aW9uYWwgc3BhY2VzIGJldHdlZW4gZWFjaCBlbGVtZW50XG5cdC8vIGNvcmUtbm90ZSBpcyA8b3Blbi1zbHVyLCBhY2NpZGVudGFsLCBwaXRjaDpyZXF1aXJlZCwgb2N0YXZlLCBkdXJhdGlvbiwgY2xvc2Utc2x1ciZ8dGllPiB3aXRoIG5vIHNwYWNlcyB3aXRoaW4gdGhhdFxuXHQvLyBjaG9yZCBpcyA8b3Blbi1icmFja2V0OnJlcXVpcmVkLCBjb3JlLW5vdGU6cmVxdWlyZWQuLi4gY2xvc2UtYnJhY2tldDpyZXF1aXJlZCBkdXJhdGlvbj4gd2l0aCBubyBzcGFjZXMgd2l0aGluIHRoYXRcblx0Ly8gZ3JhY2Utbm90ZXMgaXMgPG9wZW4tYnJhY2U6cmVxdWlyZWQsIChvcGVuLXNsdXJ8Y29yZS1ub3RlOnJlcXVpcmVkfGNsb3NlLXNsdXIpLi4uLCBjbG9zZS1icmFjZTpyZXF1aXJlZD4gc3BhY2VzIGFyZSBhbGxvd2VkXG5cdC8vIG5vdGUtZ3JvdXAgaXMgPGdyYWNlLW5vdGVzLCBjaG9yZCBzeW1ib2xzJnxkZWNvcmF0aW9ucy4uLiwgZ3JhY2Utbm90ZXMsIHNsdXImfHRyaXBsZXQsIGNob3JkfGNvcmUtbm90ZSwgZW5kLXNsdXJ8dGllPiBzcGFjZXMgYXJlIGFsbG93ZWQgYmV0d2VlbiBpdGVtc1xuXHQvLyBiYXItbWFya2luZyBpcyA8YW1wZXJzYW5kPiBvciA8Y2hvcmQgc3ltYm9scyZ8ZGVjb3JhdGlvbnMuLi4sIGJhcjpyZXF1aXJlZD4gc3BhY2VzIGFsbG93ZWRcblx0Ly8gaGVhZGVyIGlzIDxvcGVuLWJyYWNrZXQ6cmVxdWlyZWQsIEt8TXxMfFY6cmVxdWlyZWQsIGNvbG9uOnJlcXVpcmVkLCBmaWVsZDpyZXF1aXJlZCwgY2xvc2UtYnJhY2tldDpyZXF1aXJlZD4gc3BhY2VzIGNhbiBvY2N1ciBiZXR3ZWVuIHRoZSBjb2xvbiwgaW4gdGhlIGZpZWxkLCBhbmQgYmVmb3JlIHRoZSBjbG9zZSBicmFja2V0XG5cdC8vIGhlYWRlciBjYW4gYWxzbyBiZSB0aGUgb25seSB0aGluZyBvbiBhIGxpbmUuIFRoaXMgaXMgdHJ1ZSBldmVuIGlmIGl0IGlzIGEgY29udGludWF0aW9uIGxpbmUuIEluIHRoaXMgY2FzZSB0aGUgYnJhY2tldHMgYXJlIG5vdCByZXF1aXJlZC5cblx0Ly8gYSBzcGFjZSBpcyBhIGJhY2stdGljaywgYSBzcGFjZSwgb3IgYSB0YWIuIElmIGl0IGlzIGEgYmFjay10aWNrLCB0aGVuIHRoZXJlIGlzIG5vIGVuZC1iZWFtLlxuXG5cdC8vIExpbmUgcHJlcHJvY2Vzc2luZzogYW55dGhpbmcgYWZ0ZXIgYSAlIGlzIGlnbm9yZWQgKHRoZSBkb3VibGUgJSUgc2hvdWxkIGhhdmUgYmVlbiB0YWtlbiBjYXJlIG9mIGJlZm9yZSB0aGlzKVxuXHQvLyBUaGVuLCBhbGwgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkLlxuXHQvLyBJZiB0aGVyZSB3YXMgYSBsaW5lIGNvbnRpbnVhdGlvbiwgdGhlIFxcbiB3YXMgcmVwbGFjZWQgYnkgYSBcXHIgYW5kIHRoZSBcXCB3YXMgcmVwbGFjZWQgYnkgYSBzcGFjZS4gVGhpcyBhbGxvd3MgdGhlIGNvbnN0cnVjdFxuXHQvLyBvZiBoYXZpbmcgYSBoZWFkZXIgbWlkLWxpbmUgY29uY2VwdHVhbGx5LCBidXQgYWN0dWFsbHkgYmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBUaGlzIGlzIGVxdWl2b2xlbnQgdG8gcHV0dGluZyB0aGUgaGVhZGVyIGluIFsgXS5cblxuXHQvLyBUT0RPLVBFUjogSG93IHRvIGhhbmRsZSAhIGZvciBsaW5lIGJyZWFrP1xuXHQvLyBUT0RPLVBFUjogZG90cyBiZWZvcmUgYmFyLCBkb3RzIGJlZm9yZSBzbHVyXG5cdC8vIFRPRE8tUEVSOiBVOiByZWRlZmluYWJsZSBzeW1ib2xzLlxuXG5cdC8vIEFtYmlndW91cyBzeW1ib2xzOlxuXHQvLyBcIltcIiBjYW4gYmUgdGhlIHN0YXJ0IG9mIGEgY2hvcmQsIHRoZSBzdGFydCBvZiBhIGhlYWRlciBlbGVtZW50IG9yIHBhcnQgb2YgYSBiYXIgbGluZS5cblx0Ly8gLS0tIGlmIGl0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwifFwiLCBpdCBpcyBhIGJhciBsaW5lXG5cdC8vIC0tLSBpZiBpdCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBLOiBMOiBNOiBWOiBpdCBpcyBhIGhlYWRlciAobm90ZTogdGhlcmUgYXJlIG90aGVyIGhlYWRlcnMgbWVudGlvbmVkIGluIHRoZSBzdGFuZGFyZCwgYnV0IEknbSBub3Qgc3VyZSBob3cgdGhleSB3b3VsZCBiZSB1c2VkLilcblx0Ly8gLS0tIG90aGVyd2lzZSBpdCBpcyB0aGUgYmVnaW5uaW5nIG9mIGEgY2hvcmRcblx0Ly8gXCIoXCIgY2FuIGJlIHRoZSBzdGFydCBvZiBhIHNsdXIgb3IgYSB0cmlwbGV0XG5cdC8vIC0tLSBpZiBpdCBpcyBmb2xsb3dlZCBieSBhIG51bWJlciBmcm9tIDItOSwgdGhlbiBpdCBpcyBhIHRyaXBsZXRcblx0Ly8gLS0tIG90aGVyd2lzZSBpdCBpcyBhIHNsdXJcblx0Ly8gXCJdXCJcblx0Ly8gLS0tIGlmIHRoZXJlIGlzIGEgY2hvcmQgb3BlbiwgdGhlbiB0aGlzIGlzIHRoZSBjbG9zZVxuXHQvLyAtLS0gaWYgaXQgaXMgYWZ0ZXIgYSBbfCwgdGhlbiBpdCBpcyBhbiBpbnZpc2libGUgYmFyIGxpbmVcblx0Ly8gLS0tIG90aGVyd2lzZSwgaXQgaXMgcGFyIG9mIGEgYmFyXG5cdC8vIFwiLlwiIGNhbiBiZSBhIGJhciBtb2RpZmllciBvciBhIHNsdXIgbW9kaWZpZXIsIG9yIGEgZGVjb3JhdGlvblxuXHQvLyAtLS0gaWYgaXQgY29tZXMgaW1tZWRpYXRlbHkgYmVmb3JlIGEgYmFyLCBpdCBpcyBhIGJhciBtb2RpZmllclxuXHQvLyAtLS0gaWYgaXQgY29tZXMgaW1tZWRpYXRlbHkgYmVmb3JlIGEgc2x1ciwgaXQgaXMgYSBzbHVyIG1vZGlmaWVyXG5cdC8vIC0tLSBvdGhlcndpc2UgaXQgaXMgYSBkZWNvcmF0aW9uIGZvciB0aGUgbmV4dCBub3RlLlxuXHQvLyBudW1iZXI6XG5cdC8vIC0tLSBpZiBpdCBpcyBhZnRlciBhIGJhciwgd2l0aCBubyBzcGFjZSwgaXQgaXMgYW4gZW5kaW5nIG1hcmtlclxuXHQvLyAtLS0gaWYgaXQgaXMgYWZ0ZXIgYSAoIHdpdGggbm8gc3BhY2UsIGl0IGlzIGEgdHJpcGxldCBjb3VudFxuXHQvLyAtLS0gaWYgaXQgaXMgYWZ0ZXIgYSBwaXRjaCBvciBvY3RhdmUgb3Igc2xhc2gsIHRoZW4gaXQgaXMgYSBkdXJhdGlvblxuXG5cdC8vIFVuYW1iaWd1b3VzIHN5bWJvbHMgKGV4Y2VwdCBpbnNpZGUgcXVvdGVkIHN0cmluZ3MpOlxuXHQvLyB2ZXJ0aWNhbC1iYXIsIGNvbG9uOiBwYXJ0IG9mIGEgYmFyXG5cdC8vIEFCQ0RFRkdhYmNkZWZnOiBwaXRjaFxuXHQvLyB4eXpaOiByZXN0XG5cdC8vIGNvbW1hLCBwcmltZTogb2N0YXZlXG5cdC8vIGNsb3NlLXBhcmVuOiBlbmQtc2x1clxuXHQvLyBoeXBoZW46IHRpZVxuXHQvLyB0aWxkZSwgdiwgdSwgYmFuZywgcGx1cywgVEhMTVBTTzogZGVjb3JhdGlvblxuXHQvLyBjYXJhdCwgdW5kZXJzY29yZSwgZXF1YWw6IGFjY2lkZW50YWxcblx0Ly8gYW1wZXJzYW5kOiB0aW1lIHJlc2V0XG5cdC8vIG9wZW4tY3VybHksIGNsb3NlLWN1cmx5OiBncmFjZSBub3Rlc1xuXHQvLyBkb3VibGUtcXVvdGU6IGNob3JkIHN5bWJvbFxuXHQvLyBsZXNzLXRoYW4sIGdyZWF0ZXItdGhhbiwgc2xhc2g6IGR1cmF0aW9uXG5cdC8vIGJhY2stdGljaywgc3BhY2UsIHRhYjogc3BhY2Vcblx0dmFyIG5vbkRlY29yYXRpb25zID0gXCJBQkNERUZHYWJjZGVmZ3h5elpbXXxeX3tcIjtcdC8vIHVzZSB0aGlzIHRvIHByZXNjcmVlbiBzbyB3ZSBkb24ndCBoYXZlIHRvIGxvb2sgZm9yIGEgZGVjb3JhdGlvbiBhdCBldmVyeSBub3RlLlxuXG5cdHZhciBwYXJzZVJlZ3VsYXJNdXNpY0xpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0aGVhZGVyLnJlc29sdmVUZW1wbygpO1xuXHRcdC8vbXVsdGlsaW5lVmFycy5oYXZlbnRfc2V0X2xlbmd0aCA9IGZhbHNlO1x0Ly8gVG8gbGF0ZSB0byBzZXQgdGhpcyBub3cuXG5cdFx0bXVsdGlsaW5lVmFycy5pc19pbl9oZWFkZXIgPSBmYWxzZTtcdC8vIFdlIHNob3VsZCBoYXZlIGdvdHRlbiBhIGtleSBoZWFkZXIgYnkgbm93LCBidXQganVzdCBpbiBjYXNlLCB0aGlzIGlzIGRlZmluaXRlbHkgb3V0IG9mIHRoZSBoZWFkZXIuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBzdGFydE9mTGluZSA9IG11bHRpbGluZVZhcnMuaUNoYXI7XG5cdFx0Ly8gc2VlIGlmIHRoZXJlIGlzIG5vdGhpbmcgYnV0IGEgY29tbWVudCBvbiB0aGlzIGxpbmUuIElmIHNvLCBqdXN0IGlnbm9yZSBpdC4gQSBmdWxsIGxpbmUgY29tbWVudCBpcyBvcHRpb25hbCB3aGl0ZSBzcGFjZSBmb2xsb3dlZCBieSAlXG5cdFx0d2hpbGUgKHRva2VuaXplci5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoaSkpICYmIGkgPCBsaW5lLmxlbmd0aClcblx0XHRcdGkrKztcblx0XHRpZiAoaSA9PT0gbGluZS5sZW5ndGggfHwgbGluZS5jaGFyQXQoaSkgPT09ICclJylcblx0XHRcdHJldHVybjtcblxuXHRcdC8vIFN0YXJ0IHdpdGggdGhlIHN0YW5kYXJkIHN0YWZmLCBjbGVmIGFuZCBrZXkgc3ltYm9scyBvbiBlYWNoIGxpbmVcblx0XHR2YXIgZGVsYXlTdGFydE5ld0xpbmUgPSBtdWx0aWxpbmVWYXJzLnN0YXJ0X25ld19saW5lO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLmNvbnRpbnVlYWxsID09PSB1bmRlZmluZWQpXG5cdFx0XHRtdWx0aWxpbmVWYXJzLnN0YXJ0X25ld19saW5lID0gdHJ1ZTtcblx0XHRlbHNlXG5cdFx0XHRtdWx0aWxpbmVWYXJzLnN0YXJ0X25ld19saW5lID0gZmFsc2U7XG5cdFx0dmFyIHRyaXBsZXROb3Rlc0xlZnQgPSAwO1xuXG5cdFx0Ly8gU2VlIGlmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgaGVhZGVyIGZpZWxkXG5cdFx0dmFyIHJldEhlYWRlciA9IGhlYWRlci5sZXR0ZXJfdG9fYm9keV9oZWFkZXIobGluZSwgaSk7XG5cdFx0aWYgKHJldEhlYWRlclswXSA+IDApIHtcblx0XHRcdGkgKz0gcmV0SGVhZGVyWzBdO1xuXHRcdFx0aWYgKHJldEhlYWRlclsxXSA9PT0gJ1YnKVxuXHRcdFx0XHRkZWxheVN0YXJ0TmV3TGluZSA9IHRydWU7IC8vIGZpeGVzIGJ1ZyBvbiB0aGlzOiBjW1Y6Ml1kXG5cdFx0XHQvLyBUT0RPLVBFUjogSGFuZGxlIGlubGluZSBoZWFkZXJzXG5cdFx0fVxuXHRcdHZhciBlbCA9IHsgfTtcblxuXHRcdHZhciBvdmVybGF5TGV2ZWwgPSAwO1xuXHRcdHdoaWxlIChpIDwgbGluZS5sZW5ndGgpXG5cdFx0e1xuXHRcdFx0dmFyIHN0YXJ0SSA9IGk7XG5cdFx0XHRpZiAobGluZS5jaGFyQXQoaSkgPT09ICclJylcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdHZhciByZXRJbmxpbmVIZWFkZXIgPSBoZWFkZXIubGV0dGVyX3RvX2lubGluZV9oZWFkZXIobGluZSwgaSk7XG5cdFx0XHRpZiAocmV0SW5saW5lSGVhZGVyWzBdID4gMCkge1xuXHRcdFx0XHRcdGkgKz0gcmV0SW5saW5lSGVhZGVyWzBdO1xuXHRcdFx0XHRcdGlmIChyZXRJbmxpbmVIZWFkZXJbMV0gPT09ICdWJylcblx0XHRcdFx0XHRcdGRlbGF5U3RhcnROZXdMaW5lID0gdHJ1ZTsgLy8gZml4ZXMgYnVnIG9uIHRoaXM6IGNbVjoyXWRcblx0XHRcdFx0XHQvLyBUT0RPLVBFUjogSGFuZGxlIGlubGluZSBoZWFkZXJzXG5cdFx0XHRcdFx0Ly9tdWx0aWxpbmVWYXJzLnN0YXJ0X25ld19saW5lID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IHVudGlsIGhlcmUgdG8gYWN0dWFsbHkgc3RhcnQgdGhlIGxpbmUgYmVjYXVzZSB3ZSBrbm93IHdlJ3JlIHBhc3QgdGhlIGlubGluZSBzdGF0ZW1lbnRzLlxuXHRcdFx0XHRpZiAoZGVsYXlTdGFydE5ld0xpbmUpIHtcblx0XHRcdFx0XHRzdGFydE5ld0xpbmUoKTtcblx0XHRcdFx0XHRkZWxheVN0YXJ0TmV3TGluZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgbmVlZCB0byBkZWNpZGUgaWYgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJzIGFyZSBhIGJhci1tYXJraW5nIG9yIGEgbm90ZS1ncm91cC5cblx0XHRcdFx0Ly8gVW5mb3J0dW5hdGVseSwgdGhhdCBpcyBhbWJpZ3VvdXMuIEJvdGggY2FuIGNvbnRhaW4gY2hvcmQgc3ltYm9scyBhbmQgZGVjb3JhdGlvbnMuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGEgZ3JhY2Ugbm90ZSBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBjaG9yZCBzeW1ib2xzIGFuZCBkZWNvcmF0aW9ucywgdGhlbiBpdCBpcyBkZWZpbml0ZWx5IGEgbm90ZS1ncm91cC5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBiYXIgbWFya2VyLCBpdCBpcyBkZWZpbml0ZWx5IGEgYmFyLW1hcmtpbmcuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGVpdGhlciBhIGNvcmUtbm90ZSBvciBjaG9yZCwgaXQgaXMgZGVmaW5pdGVseSBhIG5vdGUtZ3JvdXAuXG5cdFx0XHRcdC8vIFNvLCBsb29wIHdoaWxlIHdlIGZpbmQgZ3JhY2Utbm90ZXMsIGNob3Jkcy1zeW1ib2xzLCBvciBkZWNvcmF0aW9ucy4gW0l0IGlzIGFuIGVycm9yIHRvIGhhdmUgbW9yZSB0aGFuIG9uZSBncmFjZS1ub3RlIGdyb3VwIGluIGEgcm93OyB0aGUgb3RoZXJzIGNhbiBiZSBtdWx0aXBsZV1cblx0XHRcdFx0Ly8gVGhlbiwgaWYgdGhlcmUgaXMgYSBncmFjZS1ub3RlLCB3ZSBrbm93IHdoZXJlIHRvIGdvLlxuXHRcdFx0XHQvLyBFbHNlIHNlZSBpZiB3ZSBoYXZlIGEgY2hvcmQsIGNvcmUtbm90ZSwgc2x1ciwgdHJpcGxldCwgb3IgYmFyLlxuXG5cdFx0XHRcdHZhciByZXQ7XG5cdFx0XHRcdHdoaWxlICgxKSB7XG5cdFx0XHRcdFx0cmV0ID0gdG9rZW5pemVyLmVhdFdoaXRlU3BhY2UobGluZSwgaSk7XG5cdFx0XHRcdFx0aWYgKHJldCA+IDApIHtcblx0XHRcdFx0XHRcdGkgKz0gcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaSA+IDAgJiYgbGluZS5jaGFyQXQoaS0xKSA9PT0gJ1xceDEyJykge1xuXHRcdFx0XHRcdFx0Ly8gdGhlcmUgaXMgb25lIGNhc2Ugd2hlcmUgYSBsaW5lIGNvbnRpbnVhdGlvbiBpc24ndCB0aGUgc2FtZSBhcyBiZWluZyBvbiB0aGUgc2FtZSBsaW5lLCBhbmQgdGhhdCBpcyBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgYWZ0ZXIgaXQgaXMgYSBoZWFkZXIuXG5cdFx0XHRcdFx0XHRyZXQgPSBoZWFkZXIubGV0dGVyX3RvX2JvZHlfaGVhZGVyKGxpbmUsIGkpO1xuXHRcdFx0XHRcdFx0aWYgKHJldFswXSA+IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJldFsxXSA9PT0gJ1YnKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0TmV3TGluZSgpOyAvLyBmaXhlcyBidWcgb24gdGhpczogY1xcXFxuVjoyXVxcXFxuZFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpbnNlcnQgaGVhZGVyIGhlcmVcblx0XHRcdFx0XHRcdFx0aSA9IHJldFswXTtcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5zdGFydF9uZXdfbGluZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBnYXRoZXIgYWxsIHRoZSBncmFjZSBub3RlcywgY2hvcmQgc3ltYm9scyBhbmQgZGVjb3JhdGlvbnNcblx0XHRcdFx0XHRyZXQgPSBsZXR0ZXJfdG9fc3BhY2VyKGxpbmUsIGkpO1xuXHRcdFx0XHRcdGlmIChyZXRbMF0gPiAwKSB7XG5cdFx0XHRcdFx0XHRpICs9IHJldFswXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXQgPSBsZXR0ZXJfdG9fY2hvcmQobGluZSwgaSk7XG5cdFx0XHRcdFx0aWYgKHJldFswXSA+IDApIHtcblx0XHRcdFx0XHRcdC8vIFRoZXJlIGNvdWxkIGJlIG1vcmUgdGhhbiBvbmUgY2hvcmQgaGVyZSBpZiB0aGV5IGhhdmUgZGlmZmVyZW50IHBvc2l0aW9ucy5cblx0XHRcdFx0XHRcdC8vIElmIHR3byBjaG9yZHMgaGF2ZSB0aGUgc2FtZSBwb3NpdGlvbiwgdGhlbiBjb25uZWN0IHRoZW0gd2l0aCBuZXdsaW5lLlxuXHRcdFx0XHRcdFx0aWYgKCFlbC5jaG9yZClcblx0XHRcdFx0XHRcdFx0ZWwuY2hvcmQgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBjaG9yZE5hbWUgPSB0b2tlbml6ZXIudHJhbnNsYXRlU3RyaW5nKHJldFsxXSk7XG5cdFx0XHRcdFx0XHRjaG9yZE5hbWUgPSBjaG9yZE5hbWUucmVwbGFjZSgvOy9nLCBcIlxcblwiKTtcblx0XHRcdFx0XHRcdHZhciBhZGRlZENob3JkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBjaSA9IDA7IGNpIDwgZWwuY2hvcmQubGVuZ3RoOyBjaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlbC5jaG9yZFtjaV0ucG9zaXRpb24gPT09IHJldFsyXSkge1xuXHRcdFx0XHRcdFx0XHRcdGFkZGVkQ2hvcmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGVsLmNob3JkW2NpXS5uYW1lICs9IFwiXFxuXCIgKyBjaG9yZE5hbWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChhZGRlZENob3JkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocmV0WzJdID09PSBudWxsICYmIHJldFszXSlcblx0XHRcdFx0XHRcdFx0XHRlbC5jaG9yZC5wdXNoKHtuYW1lOiBjaG9yZE5hbWUsIHJlbF9wb3NpdGlvbjogcmV0WzNdfSk7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbC5jaG9yZC5wdXNoKHtuYW1lOiBjaG9yZE5hbWUsIHBvc2l0aW9uOiByZXRbMl19KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aSArPSByZXRbMF07XG5cdFx0XHRcdFx0XHR2YXIgaWkgPSB0b2tlbml6ZXIuc2tpcFdoaXRlU3BhY2UobGluZS5zdWJzdHJpbmcoaSkpO1xuXHRcdFx0XHRcdFx0aWYgKGlpID4gMClcblx0XHRcdFx0XHRcdFx0ZWwuZm9yY2VfZW5kX2JlYW1fbGFzdCA9IHRydWU7XG5cdFx0XHRcdFx0XHRpICs9IGlpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAobm9uRGVjb3JhdGlvbnMuaW5kZXhPZihsaW5lLmNoYXJBdChpKSkgPT09IC0xKVxuXHRcdFx0XHRcdFx0XHRyZXQgPSBsZXR0ZXJfdG9fYWNjZW50KGxpbmUsIGkpO1xuXHRcdFx0XHRcdFx0ZWxzZSByZXQgPSBbIDAgXTtcblx0XHRcdFx0XHRcdGlmIChyZXRbMF0gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyZXRbMV0gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaSArIDEgPCBsaW5lLmxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0TmV3TGluZSgpO1x0Ly8gVGhlcmUgd2FzIGEgISBpbiB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lLiBTdGFydCBhIG5ldyBsaW5lIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIGl0LlxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHJldFsxXS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJldFsxXS5pbmRleE9mKFwic3R5bGU9XCIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbC5zdHlsZSA9IHJldFsxXS5zdWJzdHIoNik7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbC5kZWNvcmF0aW9uID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsLmRlY29yYXRpb24gPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRcdGVsLmRlY29yYXRpb24ucHVzaChyZXRbMV0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpICs9IHJldFswXTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldCA9IGxldHRlcl90b19ncmFjZShsaW5lLCBpKTtcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IEJlIHN1cmUgdGhlcmUgYXJlbid0IGFscmVhZHkgZ3JhY2Ugbm90ZXMgZGVmaW5lZC4gVGhhdCBpcyBhbiBlcnJvci5cblx0XHRcdFx0XHRcdFx0aWYgKHJldFswXSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRlbC5ncmFjZW5vdGVzID0gcmV0WzFdO1xuXHRcdFx0XHRcdFx0XHRcdGkgKz0gcmV0WzBdO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBsZXR0ZXJfdG9fYmFyKGxpbmUsIGkpO1xuXHRcdFx0XHRpZiAocmV0WzBdID4gMCkge1xuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZGVmaW5pdGVseSBhIGJhclxuXHRcdFx0XHRcdG92ZXJsYXlMZXZlbCA9IDA7XG5cdFx0XHRcdFx0aWYgKGVsLmdyYWNlbm90ZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gQXR0YWNoIHRoZSBncmFjZSBub3RlIHRvIGFuIGludmlzaWJsZSBub3RlXG5cdFx0XHRcdFx0XHRlbC5yZXN0ID0geyB0eXBlOiAnc3BhY2VyJyB9O1xuXHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSAwLjEyNTsgLy8gVE9ETy1QRVI6IEkgZG9uJ3QgdGhpbmsgdGhlIGR1cmF0aW9uIG9mIHRoaXMgbWF0dGVycyBtdWNoLCBidXQgZmlndXJlIG91dCBpZiBpdCBkb2VzLlxuXHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5hZGRGb3JtYXR0aW5nT3B0aW9ucyhlbCwgdHVuZS5mb3JtYXR0aW5nLCAnbm90ZScpO1xuXHRcdFx0XHRcdFx0dHVuZS5hcHBlbmRFbGVtZW50KCdub3RlJywgc3RhcnRPZkxpbmUraSwgc3RhcnRPZkxpbmUraStyZXRbMF0sIGVsKTtcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMubWVhc3VyZU5vdEVtcHR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGVsID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBiYXIgPSB7dHlwZTogcmV0WzFdfTtcblx0XHRcdFx0XHRpZiAoYmFyLnR5cGUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdFx0d2FybihcIlVua25vd24gYmFyIHR5cGVcIiwgbGluZSwgaSk7XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5pbkVuZGluZyAmJiBiYXIudHlwZSAhPT0gJ2Jhcl90aGluJykge1xuXHRcdFx0XHRcdFx0XHRiYXIuZW5kRW5kaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5pbkVuZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHJldFsyXSkge1xuXHRcdFx0XHRcdFx0XHRiYXIuc3RhcnRFbmRpbmcgPSByZXRbMl07XG5cdFx0XHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmluRW5kaW5nKVxuXHRcdFx0XHRcdFx0XHRcdGJhci5lbmRFbmRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmluRW5kaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbC5kZWNvcmF0aW9uICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRcdGJhci5kZWNvcmF0aW9uID0gZWwuZGVjb3JhdGlvbjtcblx0XHRcdFx0XHRcdGlmIChlbC5jaG9yZCAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHRiYXIuY2hvcmQgPSBlbC5jaG9yZDtcblx0XHRcdFx0XHRcdGlmIChiYXIuc3RhcnRFbmRpbmcgJiYgbXVsdGlsaW5lVmFycy5iYXJGaXJzdEVuZGluZ051bSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmJhckZpcnN0RW5kaW5nTnVtID0gbXVsdGlsaW5lVmFycy5jdXJyQmFyTnVtYmVyO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoYmFyLnN0YXJ0RW5kaW5nICYmIGJhci5lbmRFbmRpbmcgJiYgbXVsdGlsaW5lVmFycy5iYXJGaXJzdEVuZGluZ051bSlcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5jdXJyQmFyTnVtYmVyID0gbXVsdGlsaW5lVmFycy5iYXJGaXJzdEVuZGluZ051bTtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKGJhci5lbmRFbmRpbmcpXG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuYmFyRmlyc3RFbmRpbmdOdW0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAoYmFyLnR5cGUgIT09ICdiYXJfaW52aXNpYmxlJyAmJiBtdWx0aWxpbmVWYXJzLm1lYXN1cmVOb3RFbXB0eSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaXNGaXJzdFZvaWNlID0gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UgPT09IHVuZGVmaW5lZCB8fCAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2Uuc3RhZmZOdW0gPT09ICAwICYmIG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLmluZGV4ID09PSAgMCk7XG5cdFx0XHRcdFx0XHRcdGlmIChpc0ZpcnN0Vm9pY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmN1cnJCYXJOdW1iZXIrKztcblx0XHRcdFx0XHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5iYXJOdW1iZXJzICYmIG11bHRpbGluZVZhcnMuY3VyckJhck51bWJlciAlIG11bHRpbGluZVZhcnMuYmFyTnVtYmVycyA9PT0gMClcblx0XHRcdFx0XHRcdFx0XHRcdGJhci5iYXJOdW1iZXIgPSBtdWx0aWxpbmVWYXJzLmN1cnJCYXJOdW1iZXI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuYWRkRm9ybWF0dGluZ09wdGlvbnMoZWwsIHR1bmUuZm9ybWF0dGluZywgJ2JhcicpO1xuXHRcdFx0XHRcdFx0dHVuZS5hcHBlbmRFbGVtZW50KCdiYXInLCBzdGFydE9mTGluZStpLCBzdGFydE9mTGluZStpK3JldFswXSwgYmFyKTtcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMubWVhc3VyZU5vdEVtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRlbCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpICs9IHJldFswXTtcblx0XHRcdFx0XHR2YXIgY3YgPSBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZSA/IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtICsgJy0nICsgbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UuaW5kZXggOiAnT05MWSc7XG5cdFx0XHRcdFx0Ly8gaWYgKG11bHRpbGluZVZhcnMubGluZUJyZWFrcykge1xuXHRcdFx0XHRcdC8vIFx0aWYgKCFtdWx0aWxpbmVWYXJzLmJhckNvdW50ZXJbY3ZdKVxuXHRcdFx0XHRcdC8vIFx0XHRtdWx0aWxpbmVWYXJzLmJhckNvdW50ZXJbY3ZdID0gMDtcblx0XHRcdFx0XHQvLyBcdHZhciBicmVha05vdyA9IG11bHRpbGluZVZhcnMubGluZUJyZWFrc1snJyttdWx0aWxpbmVWYXJzLmJhckNvdW50ZXJbY3ZdXTtcblx0XHRcdFx0XHQvLyBcdG11bHRpbGluZVZhcnMuYmFyQ291bnRlcltjdl0rKztcblx0XHRcdFx0XHQvLyBcdGlmIChicmVha05vdylcblx0XHRcdFx0XHQvLyBcdFx0c3RhcnROZXdMaW5lKCk7XG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVbaV0gPT09ICcmJykge1x0Ly8gYmFja3RyYWNrIHRvIGJlZ2lubmluZyBvZiBtZWFzdXJlXG5cdFx0XHRcdFx0cmV0ID0gbGV0dGVyX3RvX292ZXJsYXkobGluZSwgaSk7XG5cdFx0XHRcdFx0aWYgKHJldFswXSA+IDApIHtcblx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kRWxlbWVudCgnb3ZlcmxheScsIHN0YXJ0T2ZMaW5lLCBzdGFydE9mTGluZSsxLCB7fSk7XG5cdFx0XHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdFx0XHRvdmVybGF5TGV2ZWwrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGRlZmluaXRlbHkgYSBub3RlIGdyb3VwXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBMb29rIGZvciBhcyBtYW55IG9wZW4gc2x1cnMgYW5kIHRyaXBsZXRzIGFzIHRoZXJlIGFyZS4gKE5vdGU6IG9ubHkgdGhlIGZpcnN0IHRyaXBsZXQgaXMgdmFsaWQuKVxuXHRcdFx0XHRcdHJldCA9IGxldHRlcl90b19vcGVuX3NsdXJzX2FuZF90cmlwbGV0cyhsaW5lLCBpKTtcblx0XHRcdFx0XHRpZiAocmV0LmNvbnN1bWVkID4gMCkge1xuXHRcdFx0XHRcdFx0aWYgKHJldC5zdGFydFNsdXIgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdFx0ZWwuc3RhcnRTbHVyID0gcmV0LnN0YXJ0U2x1cjtcblx0XHRcdFx0XHRcdGlmIChyZXQudHJpcGxldCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0cmlwbGV0Tm90ZXNMZWZ0ID4gMClcblx0XHRcdFx0XHRcdFx0XHR3YXJuKFwiQ2FuJ3QgbmVzdCB0cmlwbGV0c1wiLCBsaW5lLCBpKTtcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWwuc3RhcnRUcmlwbGV0ID0gcmV0LnRyaXBsZXQ7XG5cdFx0XHRcdFx0XHRcdFx0ZWwudHJpcGxldE11bHRpcGxpZXIgPSByZXQudHJpcGxldFEgLyByZXQudHJpcGxldDtcblx0XHRcdFx0XHRcdFx0XHR0cmlwbGV0Tm90ZXNMZWZ0ID0gcmV0Lm51bV9ub3RlcyA9PT0gdW5kZWZpbmVkID8gcmV0LnRyaXBsZXQgOiByZXQubnVtX25vdGVzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpICs9IHJldC5jb25zdW1lZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgY2hvcmRzLlxuXHRcdFx0XHRcdGlmIChsaW5lLmNoYXJBdChpKSA9PT0gJ1snKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2hvcmRTdGFydENoYXIgPSBpO1xuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0dmFyIGNob3JkRHVyYXRpb24gPSBudWxsO1xuXHRcdFx0XHRcdFx0dmFyIHJlbWVtYmVyRW5kQmVhbSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCFkb25lKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhY2NlbnQgPSBsZXR0ZXJfdG9fYWNjZW50KGxpbmUsIGkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYWNjZW50WzBdID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGkgKz0gYWNjZW50WzBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNob3JkTm90ZSA9IGdldENvcmVOb3RlKGxpbmUsIGksIHt9LCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChjaG9yZE5vdGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYWNjZW50WzBdID4gMCkgeyAvLyBJZiB3ZSBmb3VuZCBhIGRlY29yYXRpb24gYWJvdmUsIGl0IG1vZGlmaWVzIHRoZSBlbnRpcmUgY2hvcmQuIFwic3R5bGVcIiBpcyBoYW5kbGVkIGJlbG93LlxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFjY2VudFsxXS5pbmRleE9mKFwic3R5bGU9XCIpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbC5kZWNvcmF0aW9uID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZWwuZGVjb3JhdGlvbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbC5kZWNvcmF0aW9uLnB1c2goYWNjZW50WzFdKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNob3JkTm90ZS5lbmRfYmVhbSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWwuZW5kX2JlYW0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGNob3JkTm90ZS5lbmRfYmVhbTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsLnBpdGNoZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBjaG9yZE5vdGUuZHVyYXRpb247XG5cdFx0XHRcdFx0XHRcdFx0XHRlbC5waXRjaGVzID0gWyBjaG9yZE5vdGUgXTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2VcdC8vIEp1c3QgaWdub3JlIHRoZSBub3RlIGxlbmd0aHMgb2YgYWxsIGJ1dCB0aGUgZmlyc3Qgbm90ZS4gVGhlIHN0YW5kYXJkIGlzbid0IGNsZWFyIGhlcmUsIGJ1dCB0aGlzIHNlZW1zIGxlc3MgY29uZnVzaW5nLlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWwucGl0Y2hlcy5wdXNoKGNob3JkTm90ZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGNob3JkTm90ZS5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYWNjZW50WzBdID4gMCkgeyAvLyBJZiB3ZSBmb3VuZCBhIHN0eWxlIGFib3ZlLCBpdCBtb2RpZmllcyB0aGUgaW5kaXZpZHVhbCBwaXRjaCwgbm90IHRoZSBlbnRpcmUgY2hvcmQuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYWNjZW50WzFdLmluZGV4T2YoXCJzdHlsZT1cIikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWwucGl0Y2hlc1tlbC5waXRjaGVzLmxlbmd0aC0xXS5zdHlsZSA9IGFjY2VudFsxXS5zdWJzdHIoNik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMuaW5UaWVDaG9yZFtlbC5waXRjaGVzLmxlbmd0aF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNob3JkTm90ZS5lbmRUaWUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5pblRpZUNob3JkW2VsLnBpdGNoZXMubGVuZ3RoXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNob3JkTm90ZS5zdGFydFRpZSlcblx0XHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaW5UaWVDaG9yZFtlbC5waXRjaGVzLmxlbmd0aF0gPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0aSAgPSBjaG9yZE5vdGUuZW5kQ2hhcjtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgY2hvcmROb3RlLmVuZENoYXI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jaGFyQXQoaSkgPT09ICcgJykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFNwYWNlcyBhcmUgbm90IGFsbG93ZWQgaW4gY2hvcmRzLCBidXQgd2UgY2FuIHJlY292ZXIgZnJvbSBpdCBieSBpZ25vcmluZyBpdC5cblx0XHRcdFx0XHRcdFx0XHR3YXJuKFwiU3BhY2VzIGFyZSBub3QgYWxsb3dlZCBpbiBjaG9yZHNcIiwgbGluZSwgaSk7XG5cdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpIDwgbGluZS5sZW5ndGggJiYgbGluZS5jaGFyQXQoaSkgPT09ICddJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY29uc3VtZSB0aGUgY2xvc2UgYnJhY2tldFxuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5uZXh0X25vdGVfZHVyYXRpb24gIT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBlbC5kdXJhdGlvbiAqIG11bHRpbGluZVZhcnMubmV4dF9ub3RlX2R1cmF0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLm5leHRfbm90ZV9kdXJhdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChpc0luVGllKG11bHRpbGluZVZhcnMsICBvdmVybGF5TGV2ZWwsIGVsKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGVsLnBpdGNoZXMsIGZ1bmN0aW9uKHBpdGNoKSB7IHBpdGNoLmVuZFRpZSA9IHRydWU7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRJc0luVGllKG11bHRpbGluZVZhcnMsICBvdmVybGF5TGV2ZWwsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRyaXBsZXROb3Rlc0xlZnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyaXBsZXROb3Rlc0xlZnQtLTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRyaXBsZXROb3Rlc0xlZnQgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbC5lbmRUcmlwbGV0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcG9zdENob3JkRG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsaW5lLmxlbmd0aCAmJiAhcG9zdENob3JkRG9uZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGxpbmUuY2hhckF0KGkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnICc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnXFx0Jzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZEVuZEJlYW0oZWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnKSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWwuZW5kU2x1ciA9PT0gdW5kZWZpbmVkKSBlbC5lbmRTbHVyID0gMTsgZWxzZSBlbC5lbmRTbHVyKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICctJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlQ29tbW9uLmVhY2goZWwucGl0Y2hlcywgZnVuY3Rpb24ocGl0Y2gpIHsgcGl0Y2guc3RhcnRUaWUgPSB7fTsgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRJc0luVGllKG11bHRpbGluZVZhcnMsICBvdmVybGF5TGV2ZWwsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnPic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnPCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgYnIyID0gZ2V0QnJva2VuUmh5dGhtKGxpbmUsIGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aSArPSBicjJbMF0gLSAxO1x0Ly8gaW5kZXggZ2V0cyBpbmNyZW1lbnRlZCBiZWxvdywgc28gd2UnbGwgbGV0IHRoYXQgaGFwcGVuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLm5leHRfbm90ZV9kdXJhdGlvbiA9IGJyMlsyXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjaG9yZER1cmF0aW9uKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaG9yZER1cmF0aW9uID0gY2hvcmREdXJhdGlvbiAqIGJyMlsxXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hvcmREdXJhdGlvbiA9IGJyMlsxXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzEnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzInOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzYnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzcnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzgnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJzknOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJy8nOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZyYWN0aW9uID0gdG9rZW5pemVyLmdldEZyYWN0aW9uKGxpbmUsIGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hvcmREdXJhdGlvbiA9IGZyYWN0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aSA9IGZyYWN0aW9uLmluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KGkpID09PSAnICcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbWVtYmVyRW5kQmVhbSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobGluZS5jaGFyQXQoaSkgPT09ICctJyB8fCBsaW5lLmNoYXJBdChpKSA9PT0gJyknIHx8IGxpbmUuY2hhckF0KGkpID09PSAnICcgfHwgbGluZS5jaGFyQXQoaSkgPT09ICc8JyB8fCBsaW5lLmNoYXJBdChpKSA9PT0gJz4nKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpLS07IC8vIFN1YnRyYWN0aW5nIG9uZSBiZWNhdXNlIG9uZSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIGJlbG93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3RDaG9yZERvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3RDaG9yZERvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFwb3N0Q2hvcmREb25lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgJ10nIHRvIGVuZCB0aGUgY2hvcmRzXCIsIGxpbmUsIGkpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsLnBpdGNoZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGNob3JkRHVyYXRpb24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWwuZHVyYXRpb24gPSBlbC5kdXJhdGlvbiAqIGNob3JkRHVyYXRpb247XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChyZW1lbWJlckVuZEJlYW0pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkRW5kQmVhbShlbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuYWRkRm9ybWF0dGluZ09wdGlvbnMoZWwsIHR1bmUuZm9ybWF0dGluZywgJ25vdGUnKTtcblx0XHRcdFx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kRWxlbWVudCgnbm90ZScsIHN0YXJ0T2ZMaW5lK2Nob3JkU3RhcnRDaGFyLCBzdGFydE9mTGluZStpLCBlbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLm1lYXN1cmVOb3RFbXB0eSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbCA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBwaXRjaFxuXHRcdFx0XHRcdFx0dmFyIGVsMiA9IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGNvcmUgPSBnZXRDb3JlTm90ZShsaW5lLCBpLCBlbDIsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKGVsMi5lbmRUaWUgIT09IHVuZGVmaW5lZCkgc2V0SXNJblRpZShtdWx0aWxpbmVWYXJzLCAgb3ZlcmxheUxldmVsLCB0cnVlKTtcblx0XHRcdFx0XHRcdGlmIChjb3JlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjb3JlLnBpdGNoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRlbC5waXRjaGVzID0gWyB7IH0gXTtcblx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPLVBFUjogc3RyYWlnaHRlbiB0aGlzIG91dCBzbyB0aGVyZSBpcyBub3Qgc28gbXVjaCBjb3B5aW5nOiBnZXRDb3JlTm90ZSBzaG91bGRuJ3QgY2hhbmdlIGUnXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvcmUuYWNjaWRlbnRhbCAhPT0gdW5kZWZpbmVkKSBlbC5waXRjaGVzWzBdLmFjY2lkZW50YWwgPSBjb3JlLmFjY2lkZW50YWw7XG5cdFx0XHRcdFx0XHRcdFx0ZWwucGl0Y2hlc1swXS5waXRjaCA9IGNvcmUucGl0Y2g7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvcmUubWlkaXBpdGNoKVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWwucGl0Y2hlc1swXS5taWRpcGl0Y2ggPSBjb3JlLm1pZGlwaXRjaDtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY29yZS5lbmRTbHVyICE9PSB1bmRlZmluZWQpIGVsLnBpdGNoZXNbMF0uZW5kU2x1ciA9IGNvcmUuZW5kU2x1cjtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY29yZS5lbmRUaWUgIT09IHVuZGVmaW5lZCkgZWwucGl0Y2hlc1swXS5lbmRUaWUgPSBjb3JlLmVuZFRpZTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY29yZS5zdGFydFNsdXIgIT09IHVuZGVmaW5lZCkgZWwucGl0Y2hlc1swXS5zdGFydFNsdXIgPSBjb3JlLnN0YXJ0U2x1cjtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZWwuc3RhcnRTbHVyICE9PSB1bmRlZmluZWQpIGVsLnBpdGNoZXNbMF0uc3RhcnRTbHVyID0gZWwuc3RhcnRTbHVyO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb3JlLnN0YXJ0VGllICE9PSB1bmRlZmluZWQpIGVsLnBpdGNoZXNbMF0uc3RhcnRUaWUgPSBjb3JlLnN0YXJ0VGllO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbC5zdGFydFRpZSAhPT0gdW5kZWZpbmVkKSBlbC5waXRjaGVzWzBdLnN0YXJ0VGllID0gZWwuc3RhcnRUaWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWwucmVzdCA9IGNvcmUucmVzdDtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY29yZS5lbmRTbHVyICE9PSB1bmRlZmluZWQpIGVsLmVuZFNsdXIgPSBjb3JlLmVuZFNsdXI7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvcmUuZW5kVGllICE9PSB1bmRlZmluZWQpIGVsLnJlc3QuZW5kVGllID0gY29yZS5lbmRUaWU7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvcmUuc3RhcnRTbHVyICE9PSB1bmRlZmluZWQpIGVsLnN0YXJ0U2x1ciA9IGNvcmUuc3RhcnRTbHVyO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb3JlLnN0YXJ0VGllICE9PSB1bmRlZmluZWQpIGVsLnJlc3Quc3RhcnRUaWUgPSBjb3JlLnN0YXJ0VGllO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbC5zdGFydFRpZSAhPT0gdW5kZWZpbmVkKSBlbC5yZXN0LnN0YXJ0VGllID0gZWwuc3RhcnRUaWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoY29yZS5jaG9yZCAhPT0gdW5kZWZpbmVkKSBlbC5jaG9yZCA9IGNvcmUuY2hvcmQ7XG5cdFx0XHRcdFx0XHRcdGlmIChjb3JlLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIGVsLmR1cmF0aW9uID0gY29yZS5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0aWYgKGNvcmUuZGVjb3JhdGlvbiAhPT0gdW5kZWZpbmVkKSBlbC5kZWNvcmF0aW9uID0gY29yZS5kZWNvcmF0aW9uO1xuXHRcdFx0XHRcdFx0XHRpZiAoY29yZS5ncmFjZU5vdGVzICE9PSB1bmRlZmluZWQpIGVsLmdyYWNlTm90ZXMgPSBjb3JlLmdyYWNlTm90ZXM7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBlbC5zdGFydFNsdXI7XG5cdFx0XHRcdFx0XHRcdGlmIChpc0luVGllKG11bHRpbGluZVZhcnMsICBvdmVybGF5TGV2ZWwsIGVsKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbC5waXRjaGVzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsLnBpdGNoZXNbMF0uZW5kVGllID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsLnJlc3QudHlwZSAhPT0gJ3NwYWNlcicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsLnJlc3QuZW5kVGllID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0c2V0SXNJblRpZShtdWx0aWxpbmVWYXJzLCAgb3ZlcmxheUxldmVsLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGNvcmUuc3RhcnRUaWUgfHwgZWwuc3RhcnRUaWUpXG5cdFx0XHRcdFx0XHRcdFx0c2V0SXNJblRpZShtdWx0aWxpbmVWYXJzLCAgb3ZlcmxheUxldmVsLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0aSAgPSBjb3JlLmVuZENoYXI7XG5cblx0XHRcdFx0XHRcdFx0aWYgKHRyaXBsZXROb3Rlc0xlZnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJpcGxldE5vdGVzTGVmdC0tO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0cmlwbGV0Tm90ZXNMZWZ0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbC5lbmRUcmlwbGV0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoY29yZS5lbmRfYmVhbSlcblx0XHRcdFx0XHRcdFx0XHRhZGRFbmRCZWFtKGVsKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhIHdob2xlIHJlc3QsIHRoZW4gaXQgc2hvdWxkIGJlIHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVhc3VyZSwgbm90IGl0J3Mgb3duIGR1cmF0aW9uLiBXZSBuZWVkIHRvIHNwZWNpYWwgY2FzZSBpdC5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHRpbWUgc2lnbmF0dXJlIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gNC80LCB0aG91Z2gsIHRoZW4gYSB3aG9sZSByZXN0IGhhcyBubyBzcGVjaWFsIHRyZWF0bWVudC5cblx0XHRcdFx0XHRcdFx0aWYgKGVsLnJlc3QgJiYgZWwucmVzdC50eXBlID09PSAncmVzdCcgJiYgZWwuZHVyYXRpb24gPT09IDEgJiYgZHVyYXRpb25PZk1lYXN1cmUobXVsdGlsaW5lVmFycykgPD0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdGVsLnJlc3QudHlwZSA9ICd3aG9sZSc7XG5cblx0XHRcdFx0XHRcdFx0XHRlbC5kdXJhdGlvbiA9IGR1cmF0aW9uT2ZNZWFzdXJlKG11bHRpbGluZVZhcnMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5hZGRGb3JtYXR0aW5nT3B0aW9ucyhlbCwgdHVuZS5mb3JtYXR0aW5nLCAnbm90ZScpO1xuXHRcdFx0XHRcdFx0XHR0dW5lLmFwcGVuZEVsZW1lbnQoJ25vdGUnLCBzdGFydE9mTGluZStzdGFydEksIHN0YXJ0T2ZMaW5lK2ksIGVsKTtcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5tZWFzdXJlTm90RW1wdHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRlbCA9IHt9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpID09PSBzdGFydEkpIHtcdC8vIGRvbid0IGtub3cgd2hhdCB0aGlzIGlzLCBzbyBpZ25vcmUgaXQuXG5cdFx0XHRcdFx0XHRpZiAobGluZS5jaGFyQXQoaSkgIT09ICcgJyAmJiBsaW5lLmNoYXJBdChpKSAhPT0gJ2AnKVxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiVW5rbm93biBjaGFyYWN0ZXIgaWdub3JlZFwiLCBsaW5lLCBpKTtcblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIGlzSW5UaWUgPSBmdW5jdGlvbihtdWx0aWxpbmVWYXJzLCBvdmVybGF5TGV2ZWwsIGVsKSB7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMuaW5UaWVbb3ZlcmxheUxldmVsXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdC8vIElmIHRoaXMgaXMgc2luZ2xlIHZvaWNlIG11c2ljIHRoZW4gdGhlIHZvaWNlIGluZGV4IGlzbid0IHNldCwgc28gd2UgdXNlIHRoZSBmaXJzdCB2b2ljZS5cblx0XHR2YXIgdm9pY2VJbmRleCA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlID8gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UuaW5kZXggOiAwO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLmluVGllW292ZXJsYXlMZXZlbF1bdm9pY2VJbmRleF0pIHtcblx0XHRcdGlmIChlbC5waXRjaGVzICE9PSB1bmRlZmluZWQgfHwgZWwucmVzdC50eXBlICE9PSAnc3BhY2VyJylcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHR2YXIgc2V0SXNJblRpZSA9ZnVuY3Rpb24obXVsdGlsaW5lVmFycywgb3ZlcmxheUxldmVsLCB2YWx1ZSkge1xuXHRcdC8vIElmIHRoaXMgaXMgc2luZ2xlIHZvaWNlIG11c2ljIHRoZW4gdGhlIHZvaWNlIGluZGV4IGlzbid0IHNldCwgc28gd2UgdXNlIHRoZSBmaXJzdCB2b2ljZS5cblx0XHR2YXIgdm9pY2VJbmRleCA9IG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlID8gbXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UuaW5kZXggOiAwO1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLmluVGllW292ZXJsYXlMZXZlbF0gPT09IHVuZGVmaW5lZClcblx0XHRcdG11bHRpbGluZVZhcnMuaW5UaWVbb3ZlcmxheUxldmVsXSA9IFtdO1xuXHRcdG11bHRpbGluZVZhcnMuaW5UaWVbb3ZlcmxheUxldmVsXVt2b2ljZUluZGV4XSA9IHZhbHVlO1xuXHR9O1xuXG5cdHZhciBwYXJzZUxpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0dmFyIHJldCA9IGhlYWRlci5wYXJzZUhlYWRlcihsaW5lKTtcblx0XHRpZiAocmV0LnJlZ3VsYXIpXG5cdFx0XHRwYXJzZVJlZ3VsYXJNdXNpY0xpbmUocmV0LnN0cik7XG5cdFx0aWYgKHJldC5uZXdsaW5lKVxuXHRcdFx0c3RhcnROZXdMaW5lKCk7XG5cdFx0aWYgKHJldC53b3Jkcylcblx0XHRcdGFkZFdvcmRzKHR1bmUuZ2V0Q3VycmVudFZvaWNlKCksIGxpbmUuc3Vic3RyaW5nKDIpKTtcblx0XHRpZiAocmV0LnN5bWJvbHMpXG5cdFx0XHRhZGRTeW1ib2xzKHR1bmUuZ2V0Q3VycmVudFZvaWNlKCksIGxpbmUuc3Vic3RyaW5nKDIpKTtcblx0XHRpZiAocmV0LnJlY3Vyc2UpXG5cdFx0XHRwYXJzZUxpbmUocmV0LnN0cik7XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwZW5kTGFzdE1lYXN1cmUodm9pY2UsIG5leHRWb2ljZSkge1xuXHRcdHZvaWNlLnB1c2goe1xuXHRcdFx0ZWxfdHlwZTogJ2hpbnQnXG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Vm9pY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlbGVtZW50ID0gbmV4dFZvaWNlW2ldO1xuXHRcdFx0dmFyIGhpbnQgPSBwYXJzZUNvbW1vbi5jbG9uZShlbGVtZW50KTtcblx0XHRcdHZvaWNlLnB1c2goaGludCk7XG5cdFx0XHRpZiAoZWxlbWVudC5lbF90eXBlID09PSAnYmFyJylcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkSGludE1lYXN1cmUoc3RhZmYsIG5leHRTdGFmZikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZmYubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzdGF2ZSA9IHN0YWZmW2ldO1xuXHRcdFx0dmFyIG5leHRTdGF2ZSA9IG5leHRTdGFmZltpXTtcblx0XHRcdGlmIChuZXh0U3RhdmUpIHsgLy8gQmUgc3VyZSB0aGVyZSBpcyB0aGUgc2FtZSBudW1iZXIgb2Ygc3RhdmVzIG9uIHRoZSBuZXh0IGxpbmUuXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbmV4dFN0YXZlLnZvaWNlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBuZXh0Vm9pY2UgPSBuZXh0U3RhdmUudm9pY2VzW2pdO1xuXHRcdFx0XHRcdHZhciB2b2ljZSA9IHN0YXZlLnZvaWNlc1tqXTtcblx0XHRcdFx0XHRpZiAodm9pY2UpIHsgLy8gQmUgc3VyZSB0aGVyZSBhcmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZvaWNlcyBvbiB0aGUgcHJldmlvdXMgbGluZS5cblx0XHRcdFx0XHRcdGFwcGVuZExhc3RNZWFzdXJlKHZvaWNlLCBuZXh0Vm9pY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEhpbnRNZWFzdXJlcygpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR1bmUubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsaW5lID0gdHVuZS5saW5lc1tpXS5zdGFmZjtcblx0XHRcdGlmIChsaW5lKSB7XG5cdFx0XHRcdHZhciBqID0gaSsxO1xuXHRcdFx0XHR3aGlsZSAoaiA8IHR1bmUubGluZXMubGVuZ3RoICYmIHR1bmUubGluZXNbal0uc3RhZmYgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRqKys7XG5cdFx0XHRcdGlmIChqIDwgdHVuZS5saW5lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgbmV4dExpbmUgPSB0dW5lLmxpbmVzW2pdLnN0YWZmO1xuXHRcdFx0XHRcdGFkZEhpbnRNZWFzdXJlKGxpbmUsIG5leHRMaW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMucGFyc2UgPSBmdW5jdGlvbihzdHJUdW5lLCBzd2l0Y2hlcywgc3RhcnRQb3MpIHtcblx0XHQvLyB0aGUgc3dpdGNoZXMgYXJlIG9wdGlvbmFsIGFuZCBjYXVzZSBhIGRpZmZlcmVuY2UgaW4gdGhlIHdheSB0aGUgdHVuZSBpcyBwYXJzZWQuXG5cdFx0Ly8gc3dpdGNoZXMuaGVhZGVyX29ubHkgOiBzdG9wIHBhcnNpbmcgd2hlbiB0aGUgaGVhZGVyIGlzIGZpbmlzaGVkXG5cdFx0Ly8gc3dpdGNoZXMuc3RvcF9vbl93YXJuaW5nIDogc3RvcCBhdCB0aGUgZmlyc3Qgd2FybmluZyBlbmNvdW50ZXJlZC5cblx0XHQvLyBzd2l0Y2hlcy5wcmludDogZm9ybWF0IGZvciB0aGUgcGFnZSBpbnN0ZWFkIG9mIHRoZSBicm93c2VyLlxuXHRcdC8vIHN3aXRjaGVzLmZvcm1hdDogYSBoYXNoIG9mIHRoZSBkZXNpcmVkIGZvcm1hdHRpbmcgY29tbWFuZHMuXG5cdFx0Ly8gc3dpdGNoZXMuaGludF9tZWFzdXJlczogcHV0IHRoZSBuZXh0IG1lYXN1cmUgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBsaW5lLlxuXHRcdC8vIHN3aXRjaGVzLnRyYW5zcG9zZTogY2hhbmdlIHRoZSBrZXkgc2lnbmF0dXJlLCBjaG9yZHMsIGFuZCBub3RlcyBieSBhIG51bWJlciBvZiBoYWxmLXN0ZXBzLlxuXHRcdGlmICghc3dpdGNoZXMpIHN3aXRjaGVzID0ge307XG5cdFx0aWYgKCFzdGFydFBvcykgc3RhcnRQb3MgPSAwO1xuXHRcdHR1bmUucmVzZXQoKTtcblx0XHRpZiAoc3dpdGNoZXMucHJpbnQpXG5cdFx0XHR0dW5lLm1lZGlhID0gJ3ByaW50Jztcblx0XHRtdWx0aWxpbmVWYXJzLnJlc2V0KCk7XG5cdFx0bXVsdGlsaW5lVmFycy5pQ2hhciA9IHN0YXJ0UG9zO1xuXHRcdGlmIChzd2l0Y2hlcy52aXN1YWxUcmFuc3Bvc2UpIHtcblx0XHRcdG11bHRpbGluZVZhcnMuZ2xvYmFsVHJhbnNwb3NlID0gcGFyc2VJbnQoc3dpdGNoZXMudmlzdWFsVHJhbnNwb3NlKTtcblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmdsb2JhbFRyYW5zcG9zZSA9PT0gMClcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5nbG9iYWxUcmFuc3Bvc2UgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlXG5cdFx0XHRtdWx0aWxpbmVWYXJzLmdsb2JhbFRyYW5zcG9zZSA9IHVuZGVmaW5lZDtcblx0XHRpZiAoc3dpdGNoZXMubGluZUJyZWFrcykge1xuXHRcdFx0Ly8gY2hhbmdlIHRoZSBmb3JtYXQgb2YgdGhlIHRoZSBsaW5lIGJyZWFrcyBmb3IgZWFzeSB0ZXN0aW5nLlxuXHRcdFx0Ly8gVGhlIGxpbmUgYnJlYWsgbnVtYmVycyBhcmUgMC1iYXNlZCBhbmQgdGhleSByZWZsZWN0IHRoZSBsYXN0IG1lYXN1cmUgb2YgdGhlIGN1cnJlbnQgbGluZS5cblx0XHRcdG11bHRpbGluZVZhcnMubGluZUJyZWFrcyA9IHt9O1xuXHRcdFx0Ly9tdWx0aWxpbmVWYXJzLmNvbnRpbnVlYWxsID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3dpdGNoZXMubGluZUJyZWFrcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5saW5lQnJlYWtzWycnKyhzd2l0Y2hlcy5saW5lQnJlYWtzW2ldKzEpXSA9IHRydWU7IC8vIEFkZCAxIHNvIHRoYXQgdGhlIGxpbmUgYnJlYWsgaXMgdGhlIGZpcnN0IG1lYXN1cmUgb2YgdGhlIG5leHQgbGluZS5cblx0XHR9XG5cdFx0aGVhZGVyLnJlc2V0KHRva2VuaXplciwgd2FybiwgbXVsdGlsaW5lVmFycywgdHVuZSk7XG5cblx0XHQvLyBUYWtlIGNhcmUgb2Ygd2hhdGV2ZXIgbGluZSBlbmRpbmdzIGNvbWUgb3VyIHdheVxuXHRcdHN0clR1bmUgPSBwYXJzZUNvbW1vbi5nc3ViKHN0clR1bmUsICdcXHJcXG4nLCAnXFxuJyk7XG5cdFx0c3RyVHVuZSA9IHBhcnNlQ29tbW9uLmdzdWIoc3RyVHVuZSwgJ1xccicsICdcXG4nKTtcblx0XHRzdHJUdW5lICs9ICdcXG4nO1x0Ly8gVGFja2VkIG9uIHRlbXBvcmFyaWx5IHRvIG1ha2UgdGhlIGxhc3QgbGluZSBjb250aW51YXRpb24gd29ya1xuXHRcdHN0clR1bmUgPSBzdHJUdW5lLnJlcGxhY2UoL1xcblxcXFwuKlxcbi9nLCBcIlxcblwiKTtcdC8vIGdldCByaWQgb2YgbGF0ZXggY29tbWFuZHMuXG5cdFx0dmFyIGNvbnRpbnVhdGlvblJlcGxhY2VtZW50ID0gZnVuY3Rpb24oYWxsLCBiYWNrc2xhc2gsIGNvbW1lbnQpe1xuXHRcdFx0dmFyIHNwYWNlcyA9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcblx0XHRcdHZhciBwYWRkaW5nID0gY29tbWVudCA/IHNwYWNlcy5zdWJzdHJpbmcoMCwgY29tbWVudC5sZW5ndGgpIDogXCJcIjtcblx0XHRcdHJldHVybiBiYWNrc2xhc2ggKyBcIiBcXHgxMlwiICsgcGFkZGluZztcblx0XHR9O1xuXHRcdHN0clR1bmUgPSBzdHJUdW5lLnJlcGxhY2UoL1xcXFwoWyBcXHRdKikoJS4qKSpcXG4vZywgY29udGludWF0aW9uUmVwbGFjZW1lbnQpO1x0Ly8gdGFrZSBjYXJlIG9mIGxpbmUgY29udGludWF0aW9ucyByaWdodCBhd2F5LCBidXQga2VlcCB0aGUgc2FtZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuXHRcdHZhciBsaW5lcyA9IHN0clR1bmUuc3BsaXQoJ1xcbicpO1xuXHRcdGlmIChwYXJzZUNvbW1vbi5sYXN0KGxpbmVzKS5sZW5ndGggPT09IDApXHQvLyByZW1vdmUgdGhlIGJsYW5rIGxpbmUgd2UgYWRkZWQgYWJvdmUuXG5cdFx0XHRsaW5lcy5wb3AoKTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHN3aXRjaGVzLmZvcm1hdCkge1xuXHRcdFx0XHRwYXJzZURpcmVjdGl2ZS5nbG9iYWxGb3JtYXR0aW5nKHN3aXRjaGVzLmZvcm1hdCk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGxpbmVzLCAgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRpZiAoc3dpdGNoZXMuaGVhZGVyX29ubHkgJiYgbXVsdGlsaW5lVmFycy5pc19pbl9oZWFkZXIgPT09IGZhbHNlKVxuXHRcdFx0XHRcdHRocm93IFwibm9ybWFsX2Fib3J0XCI7XG5cdFx0XHRcdGlmIChzd2l0Y2hlcy5zdG9wX29uX3dhcm5pbmcgJiYgbXVsdGlsaW5lVmFycy53YXJuaW5ncylcblx0XHRcdFx0XHR0aHJvdyBcIm5vcm1hbF9hYm9ydFwiO1xuXHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5pc19pbl9oaXN0b3J5KSB7XG5cdFx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KDEpID09PSAnOicpIHtcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaXNfaW5faGlzdG9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cGFyc2VMaW5lKGxpbmUpO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0dHVuZS5hZGRNZXRhVGV4dChcImhpc3RvcnlcIiwgdG9rZW5pemVyLnRyYW5zbGF0ZVN0cmluZyh0b2tlbml6ZXIuc3RyaXBDb21tZW50KGxpbmUpKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobXVsdGlsaW5lVmFycy5pblRleHRCbG9jaykge1xuXHRcdFx0XHRcdGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKGxpbmUsIFwiJSVlbmR0ZXh0XCIpKSB7XG5cdFx0XHRcdFx0XHQvL3R1bmUuYWRkTWV0YVRleHQoXCJ0ZXh0QmxvY2tcIiwgbXVsdGlsaW5lVmFycy50ZXh0QmxvY2spO1xuXHRcdFx0XHRcdFx0dHVuZS5hZGRUZXh0KG11bHRpbGluZVZhcnMudGV4dEJsb2NrKTtcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaW5UZXh0QmxvY2sgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChsaW5lLCBcIiUlXCIpKVxuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnRleHRCbG9jayArPSAnICcgKyBsaW5lLnN1YnN0cmluZygyKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy50ZXh0QmxvY2sgKz0gJyAnICsgbGluZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAobXVsdGlsaW5lVmFycy5pblBzQmxvY2spIHtcblx0XHRcdFx0XHRpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChsaW5lLCBcIiUlZW5kcHNcIikpIHtcblx0XHRcdFx0XHRcdC8vIEp1c3QgaWdub3JlIHBvc3RzY3JpcHRcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaW5Qc0Jsb2NrID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMudGV4dEJsb2NrICs9ICcgJyArIGxpbmU7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHBhcnNlTGluZShsaW5lKTtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5pQ2hhciArPSBsaW5lLmxlbmd0aCArIDE7XG5cdFx0XHR9KTtcblx0XHRcdHZhciBwaCA9IDExKjcyO1xuXHRcdFx0dmFyIHBsID0gOC41KjcyO1xuXHRcdFx0c3dpdGNoIChtdWx0aWxpbmVWYXJzLnBhcGVyc2l6ZSkge1xuXHRcdFx0XHQvL2Nhc2UgXCJsZXR0ZXJcIjogcGggPSAxMSo3MjsgcGwgPSA4LjUqNzI7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibGVnYWxcIjogcGggPSAxNCo3MjsgcGwgPSA4LjUqNzI7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiQTRcIjogcGggPSAxMS43KjcyOyBwbCA9IDguMyo3MjsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5sYW5kc2NhcGUpIHtcblx0XHRcdFx0dmFyIHggPSBwaDtcblx0XHRcdFx0cGggPSBwbDtcblx0XHRcdFx0cGwgPSB4O1xuXHRcdFx0fVxuXHRcdFx0bXVsdGlsaW5lVmFycy5vcGVuU2x1cnMgPSB0dW5lLmNsZWFuVXAocGwsIHBoLCBtdWx0aWxpbmVWYXJzLmJhcnNwZXJzdGFmZiwgbXVsdGlsaW5lVmFycy5zdGFmZm5vbm90ZSwgbXVsdGlsaW5lVmFycy5vcGVuU2x1cnMpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aWYgKGVyciAhPT0gXCJub3JtYWxfYWJvcnRcIilcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdH1cblx0XHRpZiAoc3dpdGNoZXMuaGludF9tZWFzdXJlcykge1xuXHRcdFx0YWRkSGludE1lYXN1cmVzKCk7XG5cdFx0fVxuXG5cdFx0d3JhcC53cmFwTGluZXModHVuZSwgbXVsdGlsaW5lVmFycy5saW5lQnJlYWtzKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2U7XG4iLCIvKmdsb2JhbCB3aW5kb3cgKi9cblxudmFyIHBhcnNlQ29tbW9uID0gcmVxdWlyZSgnLi9hYmNfY29tbW9uJyk7XG5cbnZhciBwYXJzZURpcmVjdGl2ZSA9IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgdG9rZW5pemVyO1xuXHR2YXIgd2Fybjtcblx0dmFyIG11bHRpbGluZVZhcnM7XG5cdHZhciB0dW5lO1xuXHRwYXJzZURpcmVjdGl2ZS5pbml0aWFsaXplID0gZnVuY3Rpb24odG9rZW5pemVyXywgd2Fybl8sIG11bHRpbGluZVZhcnNfLCB0dW5lXykge1xuXHRcdHRva2VuaXplciA9IHRva2VuaXplcl87XG5cdFx0d2FybiA9IHdhcm5fO1xuXHRcdG11bHRpbGluZVZhcnMgPSBtdWx0aWxpbmVWYXJzXztcblx0XHR0dW5lID0gdHVuZV87XG5cdFx0aW5pdGlhbGl6ZUZvbnRzKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdGlhbGl6ZUZvbnRzKCkge1xuXHRcdG11bHRpbGluZVZhcnMuYW5ub3RhdGlvbmZvbnQgID0geyBmYWNlOiBcIkhlbHZldGljYVwiLCBzaXplOiAxMiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLmdjaG9yZGZvbnQgID0geyBmYWNlOiBcIkhlbHZldGljYVwiLCBzaXplOiAxMiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLmhpc3Rvcnlmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLmluZm9mb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNCwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLm1lYXN1cmVmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNCwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLnBhcnRzZm9udCAgPSB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgc2l6ZTogMTUsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0bXVsdGlsaW5lVmFycy5yZXBlYXRmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxMywgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLnRleHRmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRtdWx0aWxpbmVWYXJzLnRyaXBsZXRmb250ID0ge2ZhY2U6IFwiVGltZXNcIiwgc2l6ZTogMTEsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwifTtcblx0XHRtdWx0aWxpbmVWYXJzLnZvY2FsZm9udCAgPSB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgc2l6ZTogMTMsIHdlaWdodDogXCJib2xkXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdG11bHRpbGluZVZhcnMud29yZHNmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblxuXHRcdC8vIFRoZXNlIGZvbnRzIGFyZSBnbG9iYWwgZm9yIHRoZSBlbnRpcmUgdHVuZS5cblx0XHR0dW5lLmZvcm1hdHRpbmcuY29tcG9zZXJmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNCwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHR0dW5lLmZvcm1hdHRpbmcuc3VidGl0bGVmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHR0dW5lLmZvcm1hdHRpbmcudGVtcG9mb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxNSwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0dHVuZS5mb3JtYXR0aW5nLnRpdGxlZm9udCAgPSB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgc2l6ZTogMjAsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0dHVuZS5mb3JtYXR0aW5nLmZvb3RlcmZvbnQgID0geyBmYWNlOiBcIlxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiXCIsIHNpemU6IDEyLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdHR1bmUuZm9ybWF0dGluZy5oZWFkZXJmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxMiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHR0dW5lLmZvcm1hdHRpbmcudm9pY2Vmb250ICA9IHsgZmFjZTogXCJcXFwiVGltZXMgTmV3IFJvbWFuXFxcIlwiLCBzaXplOiAxMywgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cblx0XHQvLyB0aGVzZSBhcmUgdGhlIGRlZmF1bHQgZm9udHMgZm9yIHRoZXNlIGVsZW1lbnQgdHlwZXMuIEluIHRoZSBwcmludGVyLCB0aGVzZSBmb250cyBtaWdodCBjaGFuZ2UgYXMgdGhlIHR1bmUgcHJvZ3Jlc3Nlcy5cblx0XHR0dW5lLmZvcm1hdHRpbmcuYW5ub3RhdGlvbmZvbnQgID0gbXVsdGlsaW5lVmFycy5hbm5vdGF0aW9uZm9udDtcblx0XHR0dW5lLmZvcm1hdHRpbmcuZ2Nob3JkZm9udCAgPSBtdWx0aWxpbmVWYXJzLmdjaG9yZGZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLmhpc3Rvcnlmb250ICA9IG11bHRpbGluZVZhcnMuaGlzdG9yeWZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLmluZm9mb250ICA9IG11bHRpbGluZVZhcnMuaW5mb2ZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLm1lYXN1cmVmb250ICA9IG11bHRpbGluZVZhcnMubWVhc3VyZWZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLnBhcnRzZm9udCAgPSBtdWx0aWxpbmVWYXJzLnBhcnRzZm9udDtcblx0XHR0dW5lLmZvcm1hdHRpbmcucmVwZWF0Zm9udCAgPSBtdWx0aWxpbmVWYXJzLnJlcGVhdGZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLnRleHRmb250ICA9IG11bHRpbGluZVZhcnMudGV4dGZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLnRyaXBsZXRmb250ICA9IG11bHRpbGluZVZhcnMudHJpcGxldGZvbnQ7XG5cdFx0dHVuZS5mb3JtYXR0aW5nLnZvY2FsZm9udCAgPSBtdWx0aWxpbmVWYXJzLnZvY2FsZm9udDtcblx0XHR0dW5lLmZvcm1hdHRpbmcud29yZHNmb250ICA9IG11bHRpbGluZVZhcnMud29yZHNmb250O1xuXHR9XG5cblx0dmFyIGZvbnRUeXBlQ2FuSGF2ZUJveCA9IHsgZ2Nob3JkZm9udDogdHJ1ZSwgbWVhc3VyZWZvbnQ6IHRydWUsIHBhcnRzZm9udDogdHJ1ZSB9O1xuXG5cdHZhciBmb250VHJhbnNsYXRpb24gPSBmdW5jdGlvbihmb250RmFjZSkge1xuXHRcdC8vIFRoaXMgdHJhbnNsYXRlcyBQb3N0c2NyaXB0IGZvbnRzIGZvciBhIHdlYiBhbHRlcm5hdGl2ZS5cblx0XHQvLyBOb3RlIHRoYXQgdGhlIHBvc3RzY3JpcHQgZm9udHMgY29udGFpbiBpdGFsaWMgYW5kIGJvbGQgaW5mbyBpbiB0aGVtLCBzbyB3aGF0IGlzIHJldHVybmVkIGlzIGEgaGFzaC5cblxuXHRcdHN3aXRjaCAoZm9udEZhY2UpIHtcblx0XHRcdGNhc2UgXCJBcmlhbC1JdGFsaWNcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJBcmlhbFwiLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIkFyaWFsLUJvbGRcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJBcmlhbFwiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJCb29rbWFuLURlbWlcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJCb29rbWFuLHNlcmlmXCIsIHdlaWdodDogXCJib2xkXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIkJvb2ttYW4tRGVtaUl0YWxpY1wiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIkJvb2ttYW4sc2VyaWZcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQm9va21hbi1MaWdodFwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIkJvb2ttYW4sc2VyaWZcIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJCb29rbWFuLUxpZ2h0SXRhbGljXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiQm9va21hbixzZXJpZlwiLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIkNvdXJpZXJcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiQ291cmllciBOZXdcXFwiXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQ291cmllci1PYmxpcXVlXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIkNvdXJpZXIgTmV3XFxcIlwiLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIkNvdXJpZXItQm9sZFwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlxcXCJDb3VyaWVyIE5ld1xcXCJcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQ291cmllci1Cb2xkT2JsaXF1ZVwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlxcXCJDb3VyaWVyIE5ld1xcXCJcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQXZhbnRHYXJkZS1Cb29rXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiQXZhbnRHYXJkZSxBcmlhbFwiLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIkF2YW50R2FyZGUtQm9va09ibGlxdWVcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJBdmFudEdhcmRlLEFyaWFsXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQXZhbnRHYXJkZS1EZW1pXCI6XG5cdFx0XHRjYXNlIFwiQXZhbnQtR2FyZGUtRGVtaVwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIkF2YW50R2FyZGUsQXJpYWxcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiQXZhbnRHYXJkZS1EZW1pT2JsaXF1ZVwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIkF2YW50R2FyZGUsQXJpYWxcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiSGVsdmV0aWNhLU9ibGlxdWVcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJIZWx2ZXRpY2FcIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJIZWx2ZXRpY2EtQm9sZFwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIkhlbHZldGljYVwiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJIZWx2ZXRpY2EtQm9sZE9ibGlxdWVcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJIZWx2ZXRpY2FcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiSGVsdmV0aWNhLU5hcnJvd1wiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlxcXCJIZWx2ZXRpY2EgTmFycm93XFxcIixIZWx2ZXRpY2FcIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJIZWx2ZXRpY2EtTmFycm93LU9ibGlxdWVcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiSGVsdmV0aWNhIE5hcnJvd1xcXCIsSGVsdmV0aWNhXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiSGVsdmV0aWNhLU5hcnJvdy1Cb2xkXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIkhlbHZldGljYSBOYXJyb3dcXFwiLEhlbHZldGljYVwiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJIZWx2ZXRpY2EtTmFycm93LUJvbGRPYmxpcXVlXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIkhlbHZldGljYSBOYXJyb3dcXFwiLEhlbHZldGljYVwiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJQYWxhdGluby1Sb21hblwiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlBhbGF0aW5vXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiUGFsYXRpbm8tSXRhbGljXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiUGFsYXRpbm9cIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJQYWxhdGluby1Cb2xkXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiUGFsYXRpbm9cIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiUGFsYXRpbm8tQm9sZEl0YWxpY1wiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlBhbGF0aW5vXCIsIHdlaWdodDogXCJib2xkXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIk5ld0NlbnR1cnlTY2hsYmstUm9tYW5cIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiTmV3IENlbnR1cnlcXFwiLHNlcmlmXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiTmV3Q2VudHVyeVNjaGxiay1JdGFsaWNcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiTmV3IENlbnR1cnlcXFwiLHNlcmlmXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwiaXRhbGljXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiTmV3Q2VudHVyeVNjaGxiay1Cb2xkXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIk5ldyBDZW50dXJ5XFxcIixzZXJpZlwiLCB3ZWlnaHQ6IFwiYm9sZFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJOZXdDZW50dXJ5U2NobGJrLUJvbGRJdGFsaWNcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiTmV3IENlbnR1cnlcXFwiLHNlcmlmXCIsIHdlaWdodDogXCJib2xkXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIlRpbWVzXCI6XG5cdFx0XHRjYXNlIFwiVGltZXMtUm9tYW5cIjpcblx0XHRcdGNhc2UgXCJUaW1lcy1OYXJyb3dcIjpcblx0XHRcdGNhc2UgXCJUaW1lcy1Db3VyaWVyXCI6XG5cdFx0XHRjYXNlIFwiVGltZXMtTmV3LVJvbWFuXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJub3JtYWxcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJUaW1lcy1JdGFsaWNcIjpcblx0XHRcdGNhc2UgXCJUaW1lcy1JdGFsaWNzXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgd2VpZ2h0OiBcIm5vcm1hbFwiLCBzdHlsZTogXCJpdGFsaWNcIiwgZGVjb3JhdGlvbjogXCJub25lXCIgfTtcblx0XHRcdGNhc2UgXCJUaW1lcy1Cb2xkXCI6XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IFwiXFxcIlRpbWVzIE5ldyBSb21hblxcXCJcIiwgd2VpZ2h0OiBcImJvbGRcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiIH07XG5cdFx0XHRjYXNlIFwiVGltZXMtQm9sZEl0YWxpY1wiOlxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiXCIsIHdlaWdodDogXCJib2xkXCIsIHN0eWxlOiBcIml0YWxpY1wiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0Y2FzZSBcIlphcGZDaGFuY2VyeS1NZWRpdW1JdGFsaWNcIjpcblx0XHRcdFx0cmV0dXJuIHsgZmFjZTogXCJcXFwiWmFwZiBDaGFuY2VyeVxcXCIsY3Vyc2l2ZSxzZXJpZlwiLCB3ZWlnaHQ6IFwibm9ybWFsXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCBkZWNvcmF0aW9uOiBcIm5vbmVcIiB9O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBnZXRGb250UGFyYW1ldGVyID0gZnVuY3Rpb24odG9rZW5zLCBjdXJyZW50U2V0dGluZywgc3RyLCBwb3NpdGlvbiwgY21kKSB7XG5cdFx0Ly8gRXZlcnkgZm9udCBwYXJhbWV0ZXIgaGFzIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuXHRcdC8vIDxmYWNlPiA8dXRmOD4gPHNpemU+IDxtb2RpZmllcnM+IDxib3g+XG5cdFx0Ly8gV2hlcmU6XG5cdFx0Ly8gZmFjZTogZWl0aGVyIGEgc3RhbmRhcmQgd2ViIGZvbnQgbmFtZSwgb3IgYSBwb3N0c2NyaXB0IGZvbnQsIGVudW1lcmF0ZWQgaW4gZm9udFRyYW5zbGF0aW9uLiBUaGlzIGNvdWxkIGFsc28gYmUgYW4gKiBvciBiZSBtaXNzaW5nIGlmIHRoZSBmYWNlIHNob3VsZG4ndCBjaGFuZ2UuXG5cdFx0Ly8gdXRmODogVGhpcyBpcyBvcHRpb25hbCwgYW5kIHNwZWNpZmllcyB1dGY4LiBUaGF0J3MgYWxsIHRoYXQgaXMgc3VwcG9ydGVkIHNvIHRoZSBmaWVsZCBpcyBqdXN0IHNpbGVudGx5IGlnbm9yZWQuXG5cdFx0Ly8gc2l6ZTogVGhlIHNpemUsIGluIHBpeGVscy4gVGhpcyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgc2l6ZSBpcyBub3QgY2hhbmdpbmcuXG5cdFx0Ly8gbW9kaWZpZXJzOiB6ZXJvIG9yIG1vcmUgb2YgXCJib2xkXCIsIFwiaXRhbGljXCIsIFwidW5kZXJsaW5lXCJcblx0XHQvLyBib3g6IE9ubHkgYXBwbGllcyB0byB0aGUgbWVhc3VyZSBudW1iZXJzLCBnY2hvcmRzLCBhbmQgdGhlIHBhcnRzLiBJZiBwcmVzZW50LCB0aGVuIGEgYm94IGlzIGRyYXduIGFyb3VuZCB0aGUgY2hhcmFjdGVycy5cblx0XHQvLyBJZiBmYWNlIGlzIHByZXNlbnQsIHRoZW4gYWxsIHRoZSBtb2RpZmllcnMgYXJlIGNsZWFyZWQuIElmIGZhY2UgaXMgYWJzZW50LCB0aGVuIHRoZSBtb2RpZmllcnMgYXJlIGlsbGVnYWwuXG5cdFx0Ly8gVGhlIGZhY2UgY2FuIGJlIGEgc2luZ2xlIHdvcmQsIGEgc2V0IG9mIHdvcmRzIHNlcGFyYXRlZCBieSBoeXBoZW5zLCBvciBhIHF1b3RlZCBzdHJpbmcuXG5cdFx0Ly9cblx0XHQvLyBTbywgaW4gcHJhY3RpY2FsaXR5LCB0aGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgZm9udCBkZWZpbml0aW9uczogYSBudW1iZXIgb25seSwgYW4gYXN0ZXJpc2sgYW5kIGEgbnVtYmVyIG9ubHksIG9yIHRoZSBmdWxsIGRlZmluaXRpb24gKHdpdGggYW4gb3B0aW9uYWwgc2l6ZSkuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc051bWJlck9ubHkoKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IHBhcnNlSW50KHRva2Vuc1swXS50b2tlbik7XG5cdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdGlmICghY3VycmVudFNldHRpbmcpIHtcblx0XHRcdFx0d2FybihcIkNhbid0IHNldCBqdXN0IHRoZSBzaXplIG9mIHRoZSBmb250IHNpbmNlIHRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUuXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBcIlxcXCJUaW1lcyBOZXcgUm9tYW5cXFwiXCIsIHdlaWdodDogXCJub3JtYWxcIiwgc3R5bGU6IFwibm9ybWFsXCIsIGRlY29yYXRpb246IFwibm9uZVwiLCBzaXplOiBzaXplfTtcblx0XHRcdH1cblx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiB7IGZhY2U6IGN1cnJlbnRTZXR0aW5nLmZhY2UsIHdlaWdodDogY3VycmVudFNldHRpbmcud2VpZ2h0LCBzdHlsZTogY3VycmVudFNldHRpbmcuc3R5bGUsIGRlY29yYXRpb246IGN1cnJlbnRTZXR0aW5nLmRlY29yYXRpb24sIHNpemU6IHNpemV9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDEgJiYgdG9rZW5zWzBdLnRva2VuID09PSBcImJveFwiICYmIGZvbnRUeXBlQ2FuSGF2ZUJveFtjbWRdKVxuXHRcdFx0XHRyZXR1cm4geyBmYWNlOiBjdXJyZW50U2V0dGluZy5mYWNlLCB3ZWlnaHQ6IGN1cnJlbnRTZXR0aW5nLndlaWdodCwgc3R5bGU6IGN1cnJlbnRTZXR0aW5nLnN0eWxlLCBkZWNvcmF0aW9uOiBjdXJyZW50U2V0dGluZy5kZWNvcmF0aW9uLCBzaXplOiBzaXplLCBib3g6IHRydWV9O1xuXHRcdFx0d2FybihcIkV4dHJhIHBhcmFtZXRlcnMgaW4gZm9udCBkZWZpbml0aW9uLlwiLCBzdHIsIHBvc2l0aW9uKTtcblx0XHRcdHJldHVybiB7IGZhY2U6IGN1cnJlbnRTZXR0aW5nLmZhY2UsIHdlaWdodDogY3VycmVudFNldHRpbmcud2VpZ2h0LCBzdHlsZTogY3VycmVudFNldHRpbmcuc3R5bGUsIGRlY29yYXRpb246IGN1cnJlbnRTZXR0aW5nLmRlY29yYXRpb24sIHNpemU6IHNpemV9O1xuXHRcdH1cblxuXHRcdC8vIGZvcm1hdCAxOiBhc3RlcmlzayBhbmQgbnVtYmVyIG9ubHlcblx0XHRpZiAodG9rZW5zWzBdLnRva2VuID09PSAnKicpIHtcblx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0aWYgKHRva2Vuc1swXS50eXBlID09PSAnbnVtYmVyJylcblx0XHRcdFx0cmV0dXJuIHByb2Nlc3NOdW1iZXJPbmx5KCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIGZvbnQgc2l6ZSBudW1iZXIgYWZ0ZXIgKi5cIiwgc3RyLCBwb3NpdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZm9ybWF0IDI6IG51bWJlciBvbmx5XG5cdFx0aWYgKHRva2Vuc1swXS50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NOdW1iZXJPbmx5KCk7XG5cdFx0fVxuXG5cdFx0Ly8gZm9ybWF0IDM6IHdob2xlIGRlZmluaXRpb25cblx0XHR2YXIgZmFjZSA9IFtdO1xuXHRcdHZhciBzaXplO1xuXHRcdHZhciB3ZWlnaHQgPSBcIm5vcm1hbFwiO1xuXHRcdHZhciBzdHlsZSA9IFwibm9ybWFsXCI7XG5cdFx0dmFyIGRlY29yYXRpb24gPSBcIm5vbmVcIjtcblx0XHR2YXIgYm94ID0gZmFsc2U7XG5cdFx0dmFyIHN0YXRlID0gJ2ZhY2UnO1xuXHRcdHZhciBoeXBoZW5MYXN0ID0gZmFsc2U7XG5cdFx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcblx0XHRcdHZhciBjdXJyVG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdHZhciB3b3JkID0gY3VyclRva2VuLnRva2VuLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRzd2l0Y2ggKHN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgJ2ZhY2UnOlxuXHRcdFx0XHRcdGlmIChoeXBoZW5MYXN0IHx8ICh3b3JkICE9PSAndXRmJyAmJiBjdXJyVG9rZW4udHlwZSAhPT0gJ251bWJlcicgJiYgd29yZCAhPT0gXCJib2xkXCIgJiYgd29yZCAhPT0gXCJpdGFsaWNcIiAmJiB3b3JkICE9PSBcInVuZGVybGluZVwiICYmIHdvcmQgIT09IFwiYm94XCIpKSB7XG5cdFx0XHRcdFx0XHRpZiAoZmFjZS5sZW5ndGggPiAwICYmIGN1cnJUb2tlbi50b2tlbiA9PT0gJy0nKSB7XG5cdFx0XHRcdFx0XHRcdGh5cGhlbkxhc3QgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRmYWNlW2ZhY2UubGVuZ3RoLTFdID0gZmFjZVtmYWNlLmxlbmd0aC0xXSArIGN1cnJUb2tlbi50b2tlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaHlwaGVuTGFzdCkge1xuXHRcdFx0XHRcdFx0XHRcdGh5cGhlbkxhc3QgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRmYWNlW2ZhY2UubGVuZ3RoLTFdID0gZmFjZVtmYWNlLmxlbmd0aC0xXSArIGN1cnJUb2tlbi50b2tlbjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZS5wdXNoKGN1cnJUb2tlbi50b2tlbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyVG9rZW4udHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNpemUpIHtcblx0XHRcdFx0XHRcdFx0XHR3YXJuKFwiRm9udCBzaXplIHNwZWNpZmllZCB0d2ljZSBpbiBmb250IGRlZmluaXRpb24uXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNpemUgPSBjdXJyVG9rZW4udG9rZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0c3RhdGUgPSAnbW9kaWZpZXInO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh3b3JkID09PSBcImJvbGRcIilcblx0XHRcdFx0XHRcdFx0d2VpZ2h0ID0gXCJib2xkXCI7XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh3b3JkID09PSBcIml0YWxpY1wiKVxuXHRcdFx0XHRcdFx0XHRzdHlsZSA9IFwiaXRhbGljXCI7XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh3b3JkID09PSBcInVuZGVybGluZVwiKVxuXHRcdFx0XHRcdFx0XHRkZWNvcmF0aW9uID0gXCJ1bmRlcmxpbmVcIjtcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHdvcmQgPT09IFwiYm94XCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGZvbnRUeXBlQ2FuSGF2ZUJveFtjbWRdKVxuXHRcdFx0XHRcdFx0XHRcdGJveCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHR3YXJuKFwiVGhpcyBmb250IHN0eWxlIGRvZXNuJ3Qgc3VwcG9ydCBcXFwiYm94XFxcIlwiLCBzdHIsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBcImZpbmlzaGVkXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHdvcmQgPT09IFwidXRmXCIpIHtcblx0XHRcdFx0XHRcdFx0Y3VyclRva2VuID0gdG9rZW5zLnNoaWZ0KCk7IC8vIHRoaXMgZ2V0cyByaWQgb2YgdGhlIFwiOFwiIGFmdGVyIFwidXRmXCJcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBcInNpemVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiVW5rbm93biBwYXJhbWV0ZXIgXCIgKyBjdXJyVG9rZW4udG9rZW4gKyBcIiBpbiBmb250IGRlZmluaXRpb24uXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNpemVcIjpcblx0XHRcdFx0XHRpZiAoY3VyclRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRpZiAoc2l6ZSkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKFwiRm9udCBzaXplIHNwZWNpZmllZCB0d2ljZSBpbiBmb250IGRlZmluaXRpb24uXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2l6ZSA9IGN1cnJUb2tlbi50b2tlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2FybihcIkV4cGVjdGVkIGZvbnQgc2l6ZSBpbiBmb250IGRlZmluaXRpb24uXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGF0ZSA9ICdtb2RpZmllcic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJtb2RpZmllclwiOlxuXHRcdFx0XHRcdGlmICh3b3JkID09PSBcImJvbGRcIilcblx0XHRcdFx0XHRcdHdlaWdodCA9IFwiYm9sZFwiO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHdvcmQgPT09IFwiaXRhbGljXCIpXG5cdFx0XHRcdFx0XHRzdHlsZSA9IFwiaXRhbGljXCI7XG5cdFx0XHRcdFx0ZWxzZSBpZiAod29yZCA9PT0gXCJ1bmRlcmxpbmVcIilcblx0XHRcdFx0XHRcdGRlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xuXHRcdFx0XHRcdGVsc2UgaWYgKHdvcmQgPT09IFwiYm94XCIpIHtcblx0XHRcdFx0XHRcdGlmIChmb250VHlwZUNhbkhhdmVCb3hbY21kXSlcblx0XHRcdFx0XHRcdFx0Ym94ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0d2FybihcIlRoaXMgZm9udCBzdHlsZSBkb2Vzbid0IHN1cHBvcnQgXFxcImJveFxcXCJcIiwgc3RyLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiZmluaXNoZWRcIjtcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHdhcm4oXCJVbmtub3duIHBhcmFtZXRlciBcIiArIGN1cnJUb2tlbi50b2tlbiArIFwiIGluIGZvbnQgZGVmaW5pdGlvbi5cIiwgc3RyLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmaW5pc2hlZFwiOlxuXHRcdFx0XHRcdHdhcm4oXCJFeHRyYSBjaGFyYWN0ZXJzIGZvdW5kIGFmdGVyIFxcXCJib3hcXFwiIGluIGZvbnQgZGVmaW5pdGlvbi5cIiwgc3RyLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKCFjdXJyZW50U2V0dGluZykge1xuXHRcdFx0XHR3YXJuKFwiTXVzdCBzcGVjaWZ5IHRoZSBzaXplIG9mIHRoZSBmb250IHNpbmNlIHRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUuXCIsIHN0ciwgcG9zaXRpb24pO1xuXHRcdFx0XHRzaXplID0gMTI7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0c2l6ZSA9IGN1cnJlbnRTZXR0aW5nLnNpemU7XG5cdFx0fSBlbHNlXG5cdFx0XHRzaXplID0gcGFyc2VGbG9hdChzaXplKTtcblxuXHRcdGZhY2UgPSBmYWNlLmpvaW4oJyAnKTtcblx0XHR2YXIgcHNGb250ID0gZm9udFRyYW5zbGF0aW9uKGZhY2UpO1xuXHRcdHZhciBmb250ID0ge307XG5cdFx0aWYgKHBzRm9udCkge1xuXHRcdFx0Zm9udC5mYWNlID0gcHNGb250LmZhY2U7XG5cdFx0XHRmb250LndlaWdodCA9IHBzRm9udC53ZWlnaHQ7XG5cdFx0XHRmb250LnN0eWxlID0gcHNGb250LnN0eWxlO1xuXHRcdFx0Zm9udC5kZWNvcmF0aW9uID0gcHNGb250LmRlY29yYXRpb247XG5cdFx0XHRmb250LnNpemUgPSBzaXplO1xuXHRcdFx0aWYgKGJveClcblx0XHRcdFx0Zm9udC5ib3ggPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGZvbnQ7XG5cdFx0fVxuXHRcdGZvbnQuZmFjZSA9IGZhY2U7XG5cdFx0Zm9udC53ZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0Zm9udC5zdHlsZSA9IHN0eWxlO1xuXHRcdGZvbnQuZGVjb3JhdGlvbiA9IGRlY29yYXRpb247XG5cdFx0Zm9udC5zaXplID0gc2l6ZTtcblx0XHRpZiAoYm94KVxuXHRcdFx0Zm9udC5ib3ggPSB0cnVlO1xuXHRcdHJldHVybiBmb250O1xuXHR9O1xuXG5cdHZhciBnZXRDaGFuZ2luZ0ZvbnQgPSBmdW5jdGlvbihjbWQsIHRva2Vucywgc3RyKSB7XG5cdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIGEgZm9udCBhcyBhIHBhcmFtZXRlci5cIjtcblx0XHRtdWx0aWxpbmVWYXJzW2NtZF0gPSBnZXRGb250UGFyYW1ldGVyKHRva2VucywgbXVsdGlsaW5lVmFyc1tjbWRdLCBzdHIsIDAsIGNtZCk7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMuaXNfaW5faGVhZGVyKSAvLyBJZiB0aGUgZm9udCBhcHBlYXJzIGluIHRoZSBoZWFkZXIsIHRoZW4gaXQgYmVjb21lcyB0aGUgZGVmYXVsdCBmb250LlxuXHRcdFx0dHVuZS5mb3JtYXR0aW5nW2NtZF0gPSBtdWx0aWxpbmVWYXJzW2NtZF07XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cdHZhciBnZXRHbG9iYWxGb250ID0gZnVuY3Rpb24oY21kLCB0b2tlbnMsIHN0cikge1xuXHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIFxcXCJcIiArIGNtZCArIFwiXFxcIiByZXF1aXJlcyBhIGZvbnQgYXMgYSBwYXJhbWV0ZXIuXCI7XG5cdFx0dHVuZS5mb3JtYXR0aW5nW2NtZF0gPSBnZXRGb250UGFyYW1ldGVyKHRva2VucywgdHVuZS5mb3JtYXR0aW5nW2NtZF0sIHN0ciwgMCwgY21kKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHR2YXIgc2V0U2NhbGUgPSBmdW5jdGlvbihjbWQsIHRva2Vucykge1xuXHRcdHZhciBzY3JhdGNoID0gXCJcIjtcblx0XHRwYXJzZUNvbW1vbi5lYWNoKHRva2VucywgZnVuY3Rpb24odG9rKSB7XG5cdFx0XHRzY3JhdGNoICs9IHRvay50b2tlbjtcblx0XHR9KTtcblx0XHR2YXIgbnVtID0gcGFyc2VGbG9hdChzY3JhdGNoKTtcblx0XHRpZiAoaXNOYU4obnVtKSB8fCBudW0gPT09IDApXG5cdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGEgcGFyYW1ldGVyLlwiO1xuXHRcdHR1bmUuZm9ybWF0dGluZy5zY2FsZSA9IG51bTtcblxuXHR9O1xuXG5cdHZhciBnZXRSZXF1aXJlZE1lYXN1cmVtZW50ID0gZnVuY3Rpb24oY21kLCB0b2tlbnMpIHtcblx0XHR2YXIgcG9pbnRzID0gdG9rZW5pemVyLmdldE1lYXN1cmVtZW50KHRva2Vucyk7XG5cdFx0aWYgKHBvaW50cy51c2VkID09PSAwIHx8IHRva2Vucy5sZW5ndGggIT09IDApXG5cdFx0XHRyZXR1cm4geyBlcnJvcjogXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIGEgbWVhc3VyZW1lbnQgYXMgYSBwYXJhbWV0ZXIuXCJ9O1xuXHRcdHJldHVybiBwb2ludHMudmFsdWU7XG5cdH07XG5cdHZhciBvbmVQYXJhbWV0ZXJNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKGNtZCwgdG9rZW5zKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRva2VuaXplci5nZXRNZWFzdXJlbWVudCh0b2tlbnMpO1xuXHRcdGlmIChwb2ludHMudXNlZCA9PT0gMCB8fCB0b2tlbnMubGVuZ3RoICE9PSAwKVxuXHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIFxcXCJcIiArIGNtZCArIFwiXFxcIiByZXF1aXJlcyBhIG1lYXN1cmVtZW50IGFzIGEgcGFyYW1ldGVyLlwiO1xuXHRcdHR1bmUuZm9ybWF0dGluZ1tjbWRdID0gcG9pbnRzLnZhbHVlO1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdHZhciBhZGRNdWx0aWxpbmVWYXIgPSBmdW5jdGlvbihrZXksIGNtZCwgdG9rZW5zLCBtaW4sIG1heCkge1xuXHRcdGlmICh0b2tlbnMubGVuZ3RoICE9PSAxIHx8IHRva2Vuc1swXS50eXBlICE9PSAnbnVtYmVyJylcblx0XHRcdHJldHVybiBcIkRpcmVjdGl2ZSBcXFwiXCIgKyBjbWQgKyBcIlxcXCIgcmVxdWlyZXMgYSBudW1iZXIgYXMgYSBwYXJhbWV0ZXIuXCI7XG5cdFx0dmFyIGkgPSB0b2tlbnNbMF0uaW50dDtcblx0XHRpZiAobWluICE9PSB1bmRlZmluZWQgJiYgaSA8IG1pbilcblx0XHRcdHJldHVybiBcIkRpcmVjdGl2ZSBcXFwiXCIgKyBjbWQgKyBcIlxcXCIgcmVxdWlyZXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiICsgbWluICsgXCIgYXMgYSBwYXJhbWV0ZXIuXCI7XG5cdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIGkgPiBtYXgpXG5cdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIGEgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byBcIiArIG1heCArIFwiIGFzIGEgcGFyYW1ldGVyLlwiO1xuXHRcdG11bHRpbGluZVZhcnNba2V5XSA9IGk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0dmFyIGFkZE11bHRpbGluZVZhckJvb2wgPSBmdW5jdGlvbihrZXksIGNtZCwgdG9rZW5zKSB7XG5cdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDEgJiYgKHRva2Vuc1swXS50b2tlbiA9PT0gJ3RydWUnIHx8IHRva2Vuc1swXS50b2tlbiA9PT0gJ2ZhbHNlJykpIHtcblx0XHRcdG11bHRpbGluZVZhcnNba2V5XSA9IHRva2Vuc1swXS50b2tlbiA9PT0gJ3RydWUnO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHZhciBzdHIgPSBhZGRNdWx0aWxpbmVWYXIoa2V5LCBjbWQsIHRva2VucywgMCwgMSk7XG5cdFx0aWYgKHN0ciAhPT0gbnVsbCkgcmV0dXJuIHN0cjtcblx0XHRtdWx0aWxpbmVWYXJzW2tleV0gPSAobXVsdGlsaW5lVmFyc1trZXldID09PSAxKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHR2YXIgYWRkTXVsdGlsaW5lVmFyT25lUGFyYW1DaG9pY2UgPSBmdW5jdGlvbihrZXksIGNtZCwgdG9rZW5zLCBjaG9pY2VzKSB7XG5cdFx0aWYgKHRva2Vucy5sZW5ndGggIT09IDEpXG5cdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIG9uZSBvZiBbIFwiICsgY2hvaWNlcy5qb2luKFwiLCBcIikgKyBcIiBdIGFzIGEgcGFyYW1ldGVyLlwiO1xuXHRcdHZhciBjaG9pY2UgPSB0b2tlbnNbMF0udG9rZW47XG5cdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdFx0Zm9yICh2YXIgaSA9IDA7ICFmb3VuZCAmJiBpIDwgY2hvaWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGNob2ljZXNbaV0gPT09IGNob2ljZSlcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIWZvdW5kKVxuXHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIFxcXCJcIiArIGNtZCArIFwiXFxcIiByZXF1aXJlcyBvbmUgb2YgWyBcIiArIGNob2ljZXMuam9pbihcIiwgXCIpICsgXCIgXSBhcyBhIHBhcmFtZXRlci5cIjtcblx0XHRtdWx0aWxpbmVWYXJzW2tleV0gPSBjaG9pY2U7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0dmFyIG1pZGlDbWRQYXJhbTAgPSBbXG5cdFx0XCJub2JhcmxpbmVzXCIsXG5cdFx0XCJiYXJsaW5lc1wiLFxuXHRcdFwiYmVhdGFjY2VudHNcIixcblx0XHRcIm5vYmVhdGFjY2VudHNcIixcblx0XHRcImRyb25lb25cIixcblx0XHRcImRyb25lb2ZmXCIsXG5cdFx0XCJkcnVtb25cIixcblx0XHRcImRydW1vZmZcIixcblx0XHRcImZlcm1hdGFmaXhlZFwiLFxuXHRcdFwiZmVybWF0YXByb3BvcnRpb25hbFwiLFxuXHRcdFwiZ2Nob3Jkb25cIixcblx0XHRcImdjaG9yZG9mZlwiLFxuXHRcdFwiY29udHJvbGNvbWJvXCIsXG5cdFx0XCJ0ZW1wZXJhbWVudG5vcm1hbFwiLFxuXHRcdFwibm9wb3J0YW1lbnRvXCJcblx0XTtcblx0dmFyIG1pZGlDbWRQYXJhbTFTdHJpbmcgPSBbXG5cdFx0XCJnY2hvcmRcIixcblx0XHRcInB0c3RyZXNzXCIsXG5cdFx0XCJiZWF0c3RyaW5nXCJcblx0XTtcblx0dmFyIG1pZGlDbWRQYXJhbTFJbnRlZ2VyID0gW1xuXHRcdFwiYmFzc3ZvbFwiLFxuXHRcdFwiY2hvcmR2b2xcIixcblx0XHRcImNcIixcblx0XHRcImNoYW5uZWxcIixcblx0XHRcImJlYXRtb2RcIixcblx0XHRcImRlbHRhbG91ZG5lc3NcIixcblx0XHRcImRydW1iYXJzXCIsXG5cdFx0XCJncmFjZWRpdmlkZXJcIixcblx0XHRcIm1ha2VjaG9yZGNoYW5uZWxzXCIsXG5cdFx0XCJyYW5kb21jaG9yZGF0dGFja1wiLFxuXHRcdFwiY2hvcmRhdHRhY2tcIixcblx0XHRcInN0cmVzc21vZGVsXCIsXG5cdFx0XCJ0cmFuc3Bvc2VcIixcblx0XHRcInJ0cmFuc3Bvc2VcIixcblx0XHRcInZvbFwiLFxuXHRcdFwidm9saW5jXCJcblx0XTtcblx0dmFyIG1pZGlDbWRQYXJhbTFJbnRlZ2VyMU9wdGlvbmFsSW50ZWdlciA9IFtcblx0XHRcInByb2dyYW1cIlxuXHRdO1xuXHR2YXIgbWlkaUNtZFBhcmFtMkludGVnZXIgPSBbXG5cdFx0XCJyYXRpb1wiLFxuXHRcdFwic250XCIsXG5cdFx0XCJiZW5kdmVsb2NpdHlcIixcblx0XHRcInBpdGNoYmVuZFwiLFxuXHRcdFwiY29udHJvbFwiLFxuXHRcdFwidGVtcGVyYW1lbnRsaW5lYXJcIlxuXHRdO1xuXHR2YXIgbWlkaUNtZFBhcmFtNEludGVnZXIgPSBbXG5cdFx0XCJiZWF0XCJcblx0XTtcblx0dmFyIG1pZGlDbWRQYXJhbTVJbnRlZ2VyID0gW1xuXHRcdFwiZHJvbmVcIlxuXHRdO1xuXHR2YXIgbWlkaUNtZFBhcmFtMUludGVnZXJPcHRpb25hbE9jdGF2ZSA9IFtcblx0XHRcImJhc3Nwcm9nXCIsXG5cdFx0XCJjaG9yZHByb2dcIlxuXHRdO1xuXHR2YXIgbWlkaUNtZFBhcmFtMVN0cmluZzFJbnRlZ2VyID0gW1xuXHRcdFwicG9ydGFtZW50b1wiXG5cdF07XG5cdHZhciBtaWRpQ21kUGFyYW1GcmFjdGlvbiA9IFtcblx0XHRcImV4cGFuZFwiLFxuXHRcdFwiZ3JhY2VcIixcblx0XHRcInRyaW1cIlxuXHRdO1xuXHR2YXIgbWlkaUNtZFBhcmFtMVN0cmluZ1ZhcmlhYmxlSW50ZWdlcnMgPSBbXG5cdFx0XCJkcnVtXCIsXG5cdFx0XCJjaG9yZG5hbWVcIlxuXHRdO1xuXG5cdHZhciBwYXJzZU1pZGlDb21tYW5kID0gZnVuY3Rpb24obWlkaSwgdHVuZSwgcmVzdE9mU3RyaW5nKSB7XG5cdFx0dmFyIG1pZGlfY21kID0gbWlkaS5zaGlmdCgpLnRva2VuO1xuXHRcdHZhciBtaWRpX3BhcmFtcyA9IFtdO1xuXHRcdGlmIChtaWRpQ21kUGFyYW0wLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIE5PIFBBUkFNRVRFUlNcblx0XHRcdGlmIChtaWRpLmxlbmd0aCAhPT0gMClcblx0XHRcdFx0d2FybihcIlVuZXhwZWN0ZWQgcGFyYW1ldGVyIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHR9IGVsc2UgaWYgKG1pZGlDbWRQYXJhbTFTdHJpbmcuaW5kZXhPZihtaWRpX2NtZCkgPj0gMCkge1xuXHRcdFx0Ly8gT05FIFNUUklORyBQQVJBTUVURVJcblx0XHRcdGlmIChtaWRpLmxlbmd0aCAhPT0gMSlcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbMF0udG9rZW4pO1xuXHRcdH0gZWxzZSBpZiAobWlkaUNtZFBhcmFtMUludGVnZXIuaW5kZXhPZihtaWRpX2NtZCkgPj0gMCkge1xuXHRcdFx0Ly8gT05FIElOVCBQQVJBTUVURVJcblx0XHRcdGlmIChtaWRpLmxlbmd0aCAhPT0gMSlcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgb25lIGludGVnZXIgcGFyYW1ldGVyIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzBdLmludHQpO1xuXHRcdH0gZWxzZSBpZiAobWlkaUNtZFBhcmFtMUludGVnZXIxT3B0aW9uYWxJbnRlZ2VyLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIE9ORSBJTlQgUEFSQU1FVEVSLCBPTkUgT1BUSU9OQUwgUEFSQU1FVEVSXG5cdFx0XHRpZiAobWlkaS5sZW5ndGggIT09IDEgJiYgbWlkaS5sZW5ndGggIT09IDIpXG5cdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBvbmUgb3IgdHdvIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgaW50ZWdlciBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaS5sZW5ndGggPT09IDIgJiYgbWlkaVsxXS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgaW50ZWdlciBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVswXS5pbnR0KTtcblx0XHRcdFx0aWYgKG1pZGkubGVuZ3RoID09PSAyKVxuXHRcdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVsxXS5pbnR0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1pZGlDbWRQYXJhbTJJbnRlZ2VyLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIFRXTyBJTlQgUEFSQU1FVEVSU1xuXHRcdFx0aWYgKG1pZGkubGVuZ3RoICE9PSAyKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgdHdvIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcIm51bWJlclwiIHx8IG1pZGlbMV0udHlwZSAhPT0gXCJudW1iZXJcIilcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHR3byBpbnRlZ2VyIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVswXS5pbnR0KTtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzFdLmludHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWlkaUNtZFBhcmFtMVN0cmluZzFJbnRlZ2VyLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIE9ORSBTVFJJTkcgUEFSQU1FVEVSLCBPTkUgSU5UIFBBUkFNRVRFUlxuXHRcdFx0aWYgKG1pZGkubGVuZ3RoICE9PSAyKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgdHdvIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcImFscGhhXCIgfHwgbWlkaVsxXS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgb25lIHN0cmluZyBhbmQgb25lIGludGVnZXIgcGFyYW1ldGVycyBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzBdLnRva2VuKTtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzFdLmludHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWlkaV9jbWQgPT09ICdkcnVtbWFwJykge1xuXHRcdFx0Ly8gQlVJTEQgQU4gT0JKRUNUIE9GIEFCQyBOT1RFID0+IE1JREkgTk9URVxuXHRcdFx0aWYgKG1pZGkubGVuZ3RoID09PSAyICYmIG1pZGlbMF0udHlwZSA9PT0gJ2FscGhhJyAmJiBtaWRpWzFdLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmICghdHVuZS5mb3JtYXR0aW5nKSB0dW5lLmZvcm1hdHRpbmcgPSB7fTtcblx0XHRcdFx0aWYgKCF0dW5lLmZvcm1hdHRpbmcubWlkaSkgdHVuZS5mb3JtYXR0aW5nLm1pZGkgPSB7fTtcblx0XHRcdFx0aWYgKCF0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtbWFwKSB0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtbWFwID0ge307XG5cdFx0XHRcdHR1bmUuZm9ybWF0dGluZy5taWRpLmRydW1tYXBbbWlkaVswXS50b2tlbl0gPSBtaWRpWzFdLmludHQ7XG5cdFx0XHRcdG1pZGlfcGFyYW1zID0gdHVuZS5mb3JtYXR0aW5nLm1pZGkuZHJ1bW1hcDtcblx0XHRcdH0gZWxzZSBpZiAobWlkaS5sZW5ndGggPT09IDMgJiYgbWlkaVswXS50eXBlID09PSAncHVuY3QnICYmIG1pZGlbMV0udHlwZSA9PT0gJ2FscGhhJyAmJiBtaWRpWzJdLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmICghdHVuZS5mb3JtYXR0aW5nKSB0dW5lLmZvcm1hdHRpbmcgPSB7fTtcblx0XHRcdFx0aWYgKCF0dW5lLmZvcm1hdHRpbmcubWlkaSkgdHVuZS5mb3JtYXR0aW5nLm1pZGkgPSB7fTtcblx0XHRcdFx0aWYgKCF0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtbWFwKSB0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtbWFwID0ge307XG5cdFx0XHRcdHR1bmUuZm9ybWF0dGluZy5taWRpLmRydW1tYXBbbWlkaVswXS50b2tlbittaWRpWzFdLnRva2VuXSA9IG1pZGlbMl0uaW50dDtcblx0XHRcdFx0bWlkaV9wYXJhbXMgPSB0dW5lLmZvcm1hdHRpbmcubWlkaS5kcnVtbWFwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBub3RlIG5hbWUgYW5kIG9uZSBpbnRlZ2VyIHBhcmFtZXRlciBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtaWRpQ21kUGFyYW1GcmFjdGlvbi5pbmRleE9mKG1pZGlfY21kKSA+PSAwKSB7XG5cdFx0XHQvLyBPTkUgRlJBQ1RJT04gUEFSQU1FVEVSXG5cdFx0XHRpZiAobWlkaS5sZW5ndGggIT09IDMpXG5cdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBmcmFjdGlvbiBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcIm51bWJlclwiIHx8IG1pZGlbMV0udG9rZW4gIT09IFwiL1wiIHx8IG1pZGlbMl0udHlwZSAhPT0gXCJudW1iZXJcIilcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIGZyYWN0aW9uIHBhcmFtZXRlciBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzBdLmludHQpO1xuXHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbMl0uaW50dCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtaWRpQ21kUGFyYW00SW50ZWdlci5pbmRleE9mKG1pZGlfY21kKSA+PSAwKSB7XG5cdFx0XHQvLyBGT1VSIElOVCBQQVJBTUVURVJTXG5cdFx0XHRpZiAobWlkaS5sZW5ndGggIT09IDQpXG5cdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBmb3VyIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSBpZiAobWlkaVswXS50eXBlICE9PSBcIm51bWJlclwiIHx8IG1pZGlbMV0udHlwZSAhPT0gXCJudW1iZXJcIiB8fCBtaWRpWzJdLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgbWlkaVszXS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgZm91ciBpbnRlZ2VyIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVswXS5pbnR0KTtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzFdLmludHQpO1xuXHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbMl0uaW50dCk7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVszXS5pbnR0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1pZGlDbWRQYXJhbTVJbnRlZ2VyLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIEZJVkUgSU5UIFBBUkFNRVRFUlNcblx0XHRcdGlmIChtaWRpLmxlbmd0aCAhPT0gNSlcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIGZpdmUgcGFyYW1ldGVycyBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHRlbHNlIGlmIChtaWRpWzBdLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgbWlkaVsxXS50eXBlICE9PSBcIm51bWJlclwiIHx8IG1pZGlbMl0udHlwZSAhPT0gXCJudW1iZXJcIiB8fCBtaWRpWzNdLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgbWlkaVs0XS50eXBlICE9PSBcIm51bWJlclwiKVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgZml2ZSBpbnRlZ2VyIHBhcmFtZXRlcnMgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVswXS5pbnR0KTtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzFdLmludHQpO1xuXHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbMl0uaW50dCk7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gobWlkaVszXS5pbnR0KTtcblx0XHRcdFx0bWlkaV9wYXJhbXMucHVzaChtaWRpWzRdLmludHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWlkaUNtZFBhcmFtMUludGVnZXIxT3B0aW9uYWxJbnRlZ2VyLmluZGV4T2YobWlkaV9jbWQpID49IDApIHtcblx0XHRcdC8vIE9ORSBJTlQgUEFSQU1FVEVSLCBPTkUgT1BUSU9OQUwgT0NUQVZFIFBBUkFNRVRFUlxuXHRcdFx0aWYgKG1pZGkubGVuZ3RoICE9PSAxIHx8IG1pZGkubGVuZ3RoICE9PSA0KVxuXHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgb25lIG9yIHR3byBwYXJhbWV0ZXJzIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdGVsc2UgaWYgKG1pZGlbMF0udHlwZSAhPT0gXCJudW1iZXJcIilcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIGludGVnZXIgcGFyYW1ldGVyIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdGVsc2UgaWYgKG1pZGkubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdGlmIChtaWRpWzFdLnRva2VuICE9PSBcIm9jdGF2ZVwiKVxuXHRcdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBvY3RhdmUgcGFyYW1ldGVyIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdFx0aWYgKG1pZGlbMl0udG9rZW4gIT09IFwiPVwiKVxuXHRcdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBvY3RhdmUgcGFyYW1ldGVyIGluIE1JREkgXCIgKyBtaWRpX2NtZCwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdFx0aWYgKG1pZGlbM10udHlwZSAhPT0gXCJudW1iZXJcIilcblx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgaW50ZWdlciBwYXJhbWV0ZXIgZm9yIG9jdGF2ZSBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbMF0uaW50dCk7XG5cdFx0XHRcdGlmIChtaWRpLmxlbmd0aCA9PT0gNClcblx0XHRcdFx0XHRtaWRpX3BhcmFtcy5wdXNoKG1pZGlbM10uaW50dCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtaWRpQ21kUGFyYW0xU3RyaW5nVmFyaWFibGVJbnRlZ2Vycy5pbmRleE9mKG1pZGlfY21kKSA+PSAwKSB7XG5cdFx0XHQvLyBPTkUgU1RSSU5HLCBWQVJJQUJMRSBJTlQgUEFSQU1FVEVSU1xuXHRcdFx0aWYgKG1pZGkubGVuZ3RoIDwgMilcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHN0cmluZyBwYXJhbWV0ZXIgYW5kIGF0IGxlYXN0IG9uZSBpbnRlZ2VyIHBhcmFtZXRlciBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHRlbHNlIGlmIChtaWRpWzBdLnR5cGUgIT09IFwiYWxwaGFcIilcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHN0cmluZyBwYXJhbWV0ZXIgYW5kIGF0IGxlYXN0IG9uZSBpbnRlZ2VyIHBhcmFtZXRlciBpbiBNSURJIFwiICsgbWlkaV9jbWQsIHJlc3RPZlN0cmluZywgMCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIHAgPSBtaWRpLnNoaWZ0KCk7XG5cdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gocC50b2tlbik7XG5cdFx0XHRcdHdoaWxlIChtaWRpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRwID0gbWlkaS5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmIChwLnR5cGUgIT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgaW50ZWdlciBwYXJhbWV0ZXIgaW4gTUlESSBcIiArIG1pZGlfY21kLCByZXN0T2ZTdHJpbmcsIDApO1xuXHRcdFx0XHRcdG1pZGlfcGFyYW1zLnB1c2gocC5pbnR0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0dW5lLmhhc0JlZ2luTXVzaWMoKSlcblx0XHRcdHR1bmUuYXBwZW5kRWxlbWVudCgnbWlkaScsIC0xLCAtMSwgeyBjbWQ6IG1pZGlfY21kLCBwYXJhbXM6IG1pZGlfcGFyYW1zIH0pO1xuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR1bmUuZm9ybWF0dGluZ1snbWlkaSddID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHR1bmUuZm9ybWF0dGluZ1snbWlkaSddID0ge307XG5cdFx0XHR0dW5lLmZvcm1hdHRpbmdbJ21pZGknXVttaWRpX2NtZF0gPSBtaWRpX3BhcmFtcztcblx0XHR9XG5cdH07XG5cblx0cGFyc2VEaXJlY3RpdmUucGFyc2VGb250Q2hhbmdlTGluZSA9IGZ1bmN0aW9uKHRleHRzdHIpIHtcblx0XHR2YXIgdGV4dFBhcnRzID0gdGV4dHN0ci5zcGxpdCgnJCcpO1xuXHRcdGlmICh0ZXh0UGFydHMubGVuZ3RoID4gMSAmJiBtdWx0aWxpbmVWYXJzLnNldGZvbnQpIHtcblx0XHRcdHZhciB0ZXh0YXJyID0gWyB7IHRleHQ6IHRleHRQYXJ0c1swXSB9XTtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdGV4dFBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0ZXh0UGFydHNbaV0uY2hhckF0KDApID09PSAnMCcpXG5cdFx0XHRcdFx0dGV4dGFyci5wdXNoKHsgdGV4dDogdGV4dFBhcnRzW2ldLnN1YnN0cmluZygxKSB9KTtcblx0XHRcdFx0ZWxzZSBpZiAodGV4dFBhcnRzW2ldLmNoYXJBdCgwKSA9PT0gJzEnICYmIG11bHRpbGluZVZhcnMuc2V0Zm9udFsxXSlcblx0XHRcdFx0XHR0ZXh0YXJyLnB1c2goe2ZvbnQ6IG11bHRpbGluZVZhcnMuc2V0Zm9udFsxXSwgdGV4dDogdGV4dFBhcnRzW2ldLnN1YnN0cmluZygxKSB9KTtcblx0XHRcdFx0ZWxzZSBpZiAodGV4dFBhcnRzW2ldLmNoYXJBdCgwKSA9PT0gJzInICYmIG11bHRpbGluZVZhcnMuc2V0Zm9udFsyXSlcblx0XHRcdFx0XHR0ZXh0YXJyLnB1c2goe2ZvbnQ6IG11bHRpbGluZVZhcnMuc2V0Zm9udFsyXSwgdGV4dDogdGV4dFBhcnRzW2ldLnN1YnN0cmluZygxKSB9KTtcblx0XHRcdFx0ZWxzZSBpZiAodGV4dFBhcnRzW2ldLmNoYXJBdCgwKSA9PT0gJzMnICYmIG11bHRpbGluZVZhcnMuc2V0Zm9udFszXSlcblx0XHRcdFx0XHR0ZXh0YXJyLnB1c2goe2ZvbnQ6IG11bHRpbGluZVZhcnMuc2V0Zm9udFszXSwgdGV4dDogdGV4dFBhcnRzW2ldLnN1YnN0cmluZygxKSB9KTtcblx0XHRcdFx0ZWxzZSBpZiAodGV4dFBhcnRzW2ldLmNoYXJBdCgwKSA9PT0gJzQnICYmIG11bHRpbGluZVZhcnMuc2V0Zm9udFs0XSlcblx0XHRcdFx0XHR0ZXh0YXJyLnB1c2goe2ZvbnQ6IG11bHRpbGluZVZhcnMuc2V0Zm9udFs0XSwgdGV4dDogdGV4dFBhcnRzW2ldLnN1YnN0cmluZygxKSB9KTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHRleHRhcnJbdGV4dGFyci5sZW5ndGgtMV0udGV4dCArPSAnJCcgKyB0ZXh0UGFydHNbaV07XG5cdFx0XHR9XG5cdFx0XHRpZiAodGV4dGFyci5sZW5ndGggPiAxKVxuXHRcdFx0XHRyZXR1cm4gdGV4dGFycjtcblx0XHR9XG5cdFx0cmV0dXJuIHRleHRzdHI7XG5cdH07XG5cblx0dmFyIHBvc2l0aW9uQ2hvaWNlcyA9IFsgJ2F1dG8nLCAnYWJvdmUnLCAnYmVsb3cnLCAnaGlkZGVuJyBdO1xuXHRwYXJzZURpcmVjdGl2ZS5hZGREaXJlY3RpdmUgPSBmdW5jdGlvbihzdHIpIHtcblx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKHN0ciwgMCwgc3RyLmxlbmd0aCk7XHQvLyAzIG9yIG1vcmUgJSBpbiBhIHJvdywgb3IganVzdCBzcGFjZXMgYWZ0ZXIgJSUgaXMganVzdCBhIGNvbW1lbnRcblx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJ2FscGhhJykgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHJlc3RPZlN0cmluZyA9IHN0ci5zdWJzdHJpbmcoc3RyLmluZGV4T2YodG9rZW5zWzBdLnRva2VuKSt0b2tlbnNbMF0udG9rZW4ubGVuZ3RoKTtcblx0XHRyZXN0T2ZTdHJpbmcgPSB0b2tlbml6ZXIuc3RyaXBDb21tZW50KHJlc3RPZlN0cmluZyk7XG5cdFx0dmFyIGNtZCA9IHRva2Vucy5zaGlmdCgpLnRva2VuLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIHNjcmF0Y2ggPSBcIlwiO1xuXHRcdHN3aXRjaCAoY21kKVxuXHRcdHtcblx0XHRcdC8vIFRoZSBmb2xsb3dpbmcgZGlyZWN0aXZlcyB3ZXJlIGFkZGVkIHRvIGFiY19wYXJzZXJfbGludCwgYnV0IGhhdmVuJ3QgYmVlbiBpbXBsZW1lbnRlZCBoZXJlLlxuXHRcdFx0Ly8gTW9zdCBvZiB0aGVtIGFyZSBkaXJlY3QgdHJhbnNsYXRpb25zIGZyb20gdGhlIGRpcmVjdGl2ZXMgdGhhdCB3aWxsIGJlIHBhcnNlZCBpbi4gU2VlIGFiY20ycHMncyBmb3JtYXQudHh0IGZvciBpbmZvIG9uIGVhY2ggb2YgdGhlc2UuXG5cdFx0XHQvL1x0XHRcdFx0XHRhbGlnbmJhcnM6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdGFsaWduY29tcG9zZXI6IHsgdHlwZTogXCJzdHJpbmdcIiwgRW51bTogWyAnbGVmdCcsICdjZW50ZXInLCdyaWdodCcgXSwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdGJzdGVtZG93bjogeyB0eXBlOiBcImJvb2xlYW5cIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdGNvbnRpbnVlYWxsOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0ZHluYWxpZ246IHsgdHlwZTogXCJib29sZWFuXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRleHByYWJvdmU6IHsgdHlwZTogXCJib29sZWFuXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRleHByYmVsb3c6IHsgdHlwZTogXCJib29sZWFuXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRnY2hvcmRib3g6IHsgdHlwZTogXCJib29sZWFuXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRncmFjZXNsdXJzOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0Z3JhY2VzcGFjZWJlZm9yZTogeyB0eXBlOiBcIm51bWJlclwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0Z3JhY2VzcGFjZWluc2lkZTogeyB0eXBlOiBcIm51bWJlclwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0Z3JhY2VzcGFjZWFmdGVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRpbmZvc3BhY2U6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdGxpbmVza2lwZmFjOiB7IHR5cGU6IFwibnVtYmVyXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRtYXhzaHJpbms6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdG1heHN0YWZmc2VwOiB7IHR5cGU6IFwibnVtYmVyXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHQvL1x0XHRcdFx0XHRtYXhzeXNzdGFmZnNlcDogeyB0eXBlOiBcIm51bWJlclwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0bm90ZXNwYWNpbmdmYWN0b3I6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHBhcnNraXBmYWM6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHNsdXJoZWlnaHQ6IHsgdHlwZTogXCJudW1iZXJcIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHNwbGl0dHVuZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHNxdWFyZWJyZXZlOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0c3RlbWhlaWdodDogeyB0eXBlOiBcIm51bWJlclwiLCBvcHRpb25hbDogdHJ1ZSB9LFxuXHRcdFx0Ly9cdFx0XHRcdFx0c3RyYWlnaHRmbGFnczogeyB0eXBlOiBcImJvb2xlYW5cIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHN0cmV0Y2hzdGFmZjogeyB0eXBlOiBcImJvb2xlYW5cIiwgb3B0aW9uYWw6IHRydWUgfSxcblx0XHRcdC8vXHRcdFx0XHRcdHRpdGxlZm9ybWF0OiB7IHR5cGU6IFwic3RyaW5nXCIsIG9wdGlvbmFsOiB0cnVlIH0sXG5cdFx0XHRjYXNlIFwiYmFncGlwZXNcIjp0dW5lLmZvcm1hdHRpbmcuYmFncGlwZXMgPSB0cnVlO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsYXRiZWFtc1wiOnR1bmUuZm9ybWF0dGluZy5mbGF0YmVhbXMgPSB0cnVlO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImxhbmRzY2FwZVwiOm11bHRpbGluZVZhcnMubGFuZHNjYXBlID0gdHJ1ZTticmVhaztcblx0XHRcdGNhc2UgXCJwYXBlcnNpemVcIjptdWx0aWxpbmVWYXJzLnBhcGVyc2l6ZSA9IHJlc3RPZlN0cmluZzticmVhaztcblx0XHRcdGNhc2UgXCJzbHVyZ3JhY2VzXCI6dHVuZS5mb3JtYXR0aW5nLnNsdXJncmFjZXMgPSB0cnVlO2JyZWFrO1xuXHRcdFx0Y2FzZSBcInN0cmV0Y2hsYXN0XCI6dHVuZS5mb3JtYXR0aW5nLnN0cmV0Y2hsYXN0ID0gdHJ1ZTticmVhaztcblx0XHRcdGNhc2UgXCJ0aXRsZWNhcHNcIjptdWx0aWxpbmVWYXJzLnRpdGxlY2FwcyA9IHRydWU7YnJlYWs7XG5cdFx0XHRjYXNlIFwidGl0bGVsZWZ0XCI6dHVuZS5mb3JtYXR0aW5nLnRpdGxlbGVmdCA9IHRydWU7YnJlYWs7XG5cdFx0XHRjYXNlIFwibWVhc3VyZWJveFwiOnR1bmUuZm9ybWF0dGluZy5tZWFzdXJlYm94ID0gdHJ1ZTticmVhaztcblxuXHRcdFx0Y2FzZSBcInZvY2FsXCI6IHJldHVybiBhZGRNdWx0aWxpbmVWYXJPbmVQYXJhbUNob2ljZShcInZvY2FsUG9zaXRpb25cIiwgY21kLCB0b2tlbnMsIHBvc2l0aW9uQ2hvaWNlcyk7XG5cdFx0XHRjYXNlIFwiZHluYW1pY1wiOiByZXR1cm4gYWRkTXVsdGlsaW5lVmFyT25lUGFyYW1DaG9pY2UoXCJkeW5hbWljUG9zaXRpb25cIiwgY21kLCB0b2tlbnMsIHBvc2l0aW9uQ2hvaWNlcyk7XG5cdFx0XHRjYXNlIFwiZ2Nob3JkXCI6IHJldHVybiBhZGRNdWx0aWxpbmVWYXJPbmVQYXJhbUNob2ljZShcImNob3JkUG9zaXRpb25cIiwgY21kLCB0b2tlbnMsIHBvc2l0aW9uQ2hvaWNlcyk7XG5cdFx0XHRjYXNlIFwib3JuYW1lbnRcIjogcmV0dXJuIGFkZE11bHRpbGluZVZhck9uZVBhcmFtQ2hvaWNlKFwib3JuYW1lbnRQb3NpdGlvblwiLCBjbWQsIHRva2VucywgcG9zaXRpb25DaG9pY2VzKTtcblx0XHRcdGNhc2UgXCJ2b2x1bWVcIjogcmV0dXJuIGFkZE11bHRpbGluZVZhck9uZVBhcmFtQ2hvaWNlKFwidm9sdW1lUG9zaXRpb25cIiwgY21kLCB0b2tlbnMsIHBvc2l0aW9uQ2hvaWNlcyk7XG5cblx0XHRcdGNhc2UgXCJib3RtYXJnaW5cIjpcblx0XHRcdGNhc2UgXCJib3RzcGFjZVwiOlxuXHRcdFx0Y2FzZSBcImNvbXBvc2Vyc3BhY2VcIjpcblx0XHRcdGNhc2UgXCJpbmRlbnRcIjpcblx0XHRcdGNhc2UgXCJsZWZ0bWFyZ2luXCI6XG5cdFx0XHRjYXNlIFwibGluZXNlcFwiOlxuXHRcdFx0Y2FzZSBcIm11c2ljc3BhY2VcIjpcblx0XHRcdGNhc2UgXCJwYXJ0c3NwYWNlXCI6XG5cdFx0XHRjYXNlIFwicGFnZWhlaWdodFwiOlxuXHRcdFx0Y2FzZSBcInBhZ2V3aWR0aFwiOlxuXHRcdFx0Y2FzZSBcInJpZ2h0bWFyZ2luXCI6XG5cdFx0XHRjYXNlIFwic3RhZmZzZXBcIjpcblx0XHRcdGNhc2UgXCJzdGFmZndpZHRoXCI6XG5cdFx0XHRjYXNlIFwic3VidGl0bGVzcGFjZVwiOlxuXHRcdFx0Y2FzZSBcInN5c3N0YWZmc2VwXCI6XG5cdFx0XHRjYXNlIFwic3lzdGVtc2VwXCI6XG5cdFx0XHRjYXNlIFwidGV4dHNwYWNlXCI6XG5cdFx0XHRjYXNlIFwidGl0bGVzcGFjZVwiOlxuXHRcdFx0Y2FzZSBcInRvcG1hcmdpblwiOlxuXHRcdFx0Y2FzZSBcInRvcHNwYWNlXCI6XG5cdFx0XHRjYXNlIFwidm9jYWxzcGFjZVwiOlxuXHRcdFx0Y2FzZSBcIndvcmRzc3BhY2VcIjpcblx0XHRcdFx0cmV0dXJuIG9uZVBhcmFtZXRlck1lYXN1cmVtZW50KGNtZCwgdG9rZW5zKTtcblx0XHRcdGNhc2UgXCJ2b2ljZXNjYWxlXCI6XG5cdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoICE9PSAxIHx8IHRva2Vuc1swXS50eXBlICE9PSAnbnVtYmVyJylcblx0XHRcdFx0XHRyZXR1cm4gXCJ2b2ljZXNjYWxlIHJlcXVpcmVzIG9uZSBmbG9hdCBhcyBhIHBhcmFtZXRlclwiO1xuXHRcdFx0XHR2YXIgdm9pY2VTY2FsZSA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5jdXJyZW50Vm9pY2UpIHtcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zY2FsZSA9IHZvaWNlU2NhbGUuZmxvYXR0O1xuXHRcdFx0XHRcdHR1bmUuY2hhbmdlVm9pY2VTY2FsZShtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5zY2FsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRjYXNlIFwidnNraXBcIjpcblx0XHRcdFx0dmFyIHZza2lwID0gZ2V0UmVxdWlyZWRNZWFzdXJlbWVudChjbWQsIHRva2Vucyk7XG5cdFx0XHRcdGlmICh2c2tpcC5lcnJvcilcblx0XHRcdFx0XHRyZXR1cm4gdnNraXAuZXJyb3I7XG5cdFx0XHRcdHR1bmUuYWRkU3BhY2luZyh2c2tpcCk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSBcInNjYWxlXCI6XG5cdFx0XHRcdHNldFNjYWxlKGNtZCwgdG9rZW5zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwic2VwXCI6XG5cdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHR1bmUuYWRkU2VwYXJhdG9yKCk7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBwb2ludHMgPSB0b2tlbml6ZXIuZ2V0TWVhc3VyZW1lbnQodG9rZW5zKTtcblx0XHRcdFx0XHRpZiAocG9pbnRzLnVzZWQgPT09IDApXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgXFxcIlwiICsgY21kICsgXCJcXFwiIHJlcXVpcmVzIDMgbnVtYmVyczogc3BhY2UgYWJvdmUsIHNwYWNlIGJlbG93LCBsZW5ndGggb2YgbGluZVwiO1xuXHRcdFx0XHRcdHZhciBzcGFjZUFib3ZlID0gcG9pbnRzLnZhbHVlO1xuXG5cdFx0XHRcdFx0cG9pbnRzID0gdG9rZW5pemVyLmdldE1lYXN1cmVtZW50KHRva2Vucyk7XG5cdFx0XHRcdFx0aWYgKHBvaW50cy51c2VkID09PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIFxcXCJcIiArIGNtZCArIFwiXFxcIiByZXF1aXJlcyAzIG51bWJlcnM6IHNwYWNlIGFib3ZlLCBzcGFjZSBiZWxvdywgbGVuZ3RoIG9mIGxpbmVcIjtcblx0XHRcdFx0XHR2YXIgc3BhY2VCZWxvdyA9IHBvaW50cy52YWx1ZTtcblxuXHRcdFx0XHRcdHBvaW50cyA9IHRva2VuaXplci5nZXRNZWFzdXJlbWVudCh0b2tlbnMpO1xuXHRcdFx0XHRcdGlmIChwb2ludHMudXNlZCA9PT0gMCB8fCB0b2tlbnMubGVuZ3RoICE9PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIFxcXCJcIiArIGNtZCArIFwiXFxcIiByZXF1aXJlcyAzIG51bWJlcnM6IHNwYWNlIGFib3ZlLCBzcGFjZSBiZWxvdywgbGVuZ3RoIG9mIGxpbmVcIjtcblx0XHRcdFx0XHR2YXIgbGVuTGluZSA9IHBvaW50cy52YWx1ZTtcblx0XHRcdFx0XHR0dW5lLmFkZFNlcGFyYXRvcihzcGFjZUFib3ZlLCBzcGFjZUJlbG93LCBsZW5MaW5lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJiYXJzcGVyc3RhZmZcIjpcblx0XHRcdFx0c2NyYXRjaCA9IGFkZE11bHRpbGluZVZhcignYmFyc3BlcnN0YWZmJywgY21kLCB0b2tlbnMpO1xuXHRcdFx0XHRpZiAoc2NyYXRjaCAhPT0gbnVsbCkgcmV0dXJuIHNjcmF0Y2g7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInN0YWZmbm9ub3RlXCI6XG5cdFx0XHRcdC8vIFRoZSBzZW5zZSBvZiB0aGUgYm9vbGVhbiBpcyBvcHBvc2l0ZSBoZXJlLiBcIjBcIiBtZWFucyB0cnVlLlxuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCAhPT0gMSlcblx0XHRcdFx0XHRyZXR1cm4gXCJEaXJlY3RpdmUgc3RhZmZub25vdGUgcmVxdWlyZXMgb25lIHBhcmFtZXRlcjogMCBvciAxXCI7XG5cdFx0XHRcdGlmICh0b2tlbnNbMF0udG9rZW4gPT09ICcwJylcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnN0YWZmbm9ub3RlID0gdHJ1ZTtcblx0XHRcdFx0ZWxzZSBpZiAodG9rZW5zWzBdLnRva2VuID09PSAnMScpXG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5zdGFmZm5vbm90ZSA9IGZhbHNlO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0dXJuIFwiRGlyZWN0aXZlIHN0YWZmbm9ub3RlIHJlcXVpcmVzIG9uZSBwYXJhbWV0ZXI6IDAgb3IgMSAocmVjZWl2ZWQgXCIgKyB0b2tlbnNbMF0udG9rZW4gKyAnKSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInByaW50dGVtcG9cIjpcblx0XHRcdFx0c2NyYXRjaCA9IGFkZE11bHRpbGluZVZhckJvb2woJ3ByaW50VGVtcG8nLCBjbWQsIHRva2Vucyk7XG5cdFx0XHRcdGlmIChzY3JhdGNoICE9PSBudWxsKSByZXR1cm4gc2NyYXRjaDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicGFydHNib3hcIjpcblx0XHRcdFx0c2NyYXRjaCA9IGFkZE11bHRpbGluZVZhckJvb2woJ3BhcnRzQm94JywgY21kLCB0b2tlbnMpO1xuXHRcdFx0XHRpZiAoc2NyYXRjaCAhPT0gbnVsbCkgcmV0dXJuIHNjcmF0Y2g7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMucGFydHNmb250LmJveCA9IG11bHRpbGluZVZhcnMucGFydHNCb3g7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImZyZWVnY2hvcmRcIjpcblx0XHRcdFx0c2NyYXRjaCA9IGFkZE11bHRpbGluZVZhckJvb2woJ2ZyZWVnY2hvcmQnLCBjbWQsIHRva2Vucyk7XG5cdFx0XHRcdGlmIChzY3JhdGNoICE9PSBudWxsKSByZXR1cm4gc2NyYXRjaDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibWVhc3VyZW5iXCI6XG5cdFx0XHRjYXNlIFwiYmFybnVtYmVyc1wiOlxuXHRcdFx0XHRzY3JhdGNoID0gYWRkTXVsdGlsaW5lVmFyKCdiYXJOdW1iZXJzJywgY21kLCB0b2tlbnMpO1xuXHRcdFx0XHRpZiAoc2NyYXRjaCAhPT0gbnVsbCkgcmV0dXJuIHNjcmF0Y2g7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInNldGJhcm5iXCI6XG5cdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoICE9PSAxIHx8IHRva2Vuc1swXS50eXBlICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHJldHVybiAnRGlyZWN0aXZlIHNldGJhcm5iIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGEgcGFyYW1ldGVyLic7XG5cdFx0XHRcdH1cblx0XHRcdFx0bXVsdGlsaW5lVmFycy5jdXJyQmFyTnVtYmVyID0gdHVuZS5zZXRCYXJOdW1iZXJJbW1lZGlhdGUodG9rZW5zWzBdLmludHQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJiZWdpbnRleHRcIjpcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5pblRleHRCbG9jayA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImNvbnRpbnVlYWxsXCI6XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuY29udGludWVhbGwgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJiZWdpbnBzXCI6XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuaW5Qc0Jsb2NrID0gdHJ1ZTtcblx0XHRcdFx0d2FybihcIlBvc3RzY3JpcHQgaWdub3JlZFwiLCBzdHIsIDApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJkZWNvXCI6XG5cdFx0XHRcdGlmIChyZXN0T2ZTdHJpbmcubGVuZ3RoID4gMClcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmlnbm9yZWREZWNvcmF0aW9ucy5wdXNoKHJlc3RPZlN0cmluZy5zdWJzdHJpbmcoMCwgcmVzdE9mU3RyaW5nLmluZGV4T2YoJyAnKSkpO1xuXHRcdFx0XHR3YXJuKFwiRGVjb3JhdGlvbiByZWRlZmluaXRpb24gaWdub3JlZFwiLCBzdHIsIDApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ0ZXh0XCI6XG5cdFx0XHRcdHZhciB0ZXh0c3RyID0gdG9rZW5pemVyLnRyYW5zbGF0ZVN0cmluZyhyZXN0T2ZTdHJpbmcpO1xuXHRcdFx0XHR0dW5lLmFkZFRleHQocGFyc2VEaXJlY3RpdmUucGFyc2VGb250Q2hhbmdlTGluZSh0ZXh0c3RyKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImNlbnRlclwiOlxuXHRcdFx0XHR2YXIgY2VudGVyc3RyID0gdG9rZW5pemVyLnRyYW5zbGF0ZVN0cmluZyhyZXN0T2ZTdHJpbmcpO1xuXHRcdFx0XHR0dW5lLmFkZENlbnRlcmVkKHBhcnNlRGlyZWN0aXZlLnBhcnNlRm9udENoYW5nZUxpbmUoY2VudGVyc3RyKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImZvbnRcIjpcblx0XHRcdFx0Ly8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBmb3IgdGhpczsgaXQgaXMgYSB1c2VsZXNzIGRpcmVjdGl2ZVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJzZXRmb250XCI6XG5cdFx0XHRcdHZhciBzZlRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShyZXN0T2ZTdHJpbmcsIDAsIHJlc3RPZlN0cmluZy5sZW5ndGgpO1xuLy9cdFx0XHRcdHZhciBzZkRvbmUgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHNmVG9rZW5zLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHRcdFx0aWYgKHNmVG9rZW5zWzBdLnRva2VuID09PSAnLScgJiYgc2ZUb2tlbnNbMV0udHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdHZhciBzZk51bSA9IHBhcnNlSW50KHNmVG9rZW5zWzFdLnRva2VuKTtcblx0XHRcdFx0XHRcdGlmIChzZk51bSA+PSAxICYmIHNmTnVtIDw9IDQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFtdWx0aWxpbmVWYXJzLnNldGZvbnQpXG5cdFx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5zZXRmb250ID0gW107XG5cdFx0XHRcdFx0XHRcdHNmVG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHNmVG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuc2V0Zm9udFtzZk51bV0gPSBnZXRGb250UGFyYW1ldGVyKHNmVG9rZW5zLCBtdWx0aWxpbmVWYXJzLnNldGZvbnRbc2ZOdW1dLCBzdHIsIDAsICdzZXRmb250Jyk7XG4vL1x0XHRcdFx0XHRcdFx0dmFyIHNmU2l6ZSA9IHNmVG9rZW5zLnBvcCgpO1xuLy9cdFx0XHRcdFx0XHRcdGlmIChzZlNpemUudHlwZSA9PT0gJ251bWJlcicpIHtcbi8vXHRcdFx0XHRcdFx0XHRcdHNmU2l6ZSA9IHBhcnNlSW50KHNmU2l6ZS50b2tlbik7XG4vL1x0XHRcdFx0XHRcdFx0XHR2YXIgc2ZGb250TmFtZSA9ICcnO1xuLy9cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgc2ZpID0gMjsgc2ZpIDwgc2ZUb2tlbnMubGVuZ3RoOyBzZmkrKylcbi8vXHRcdFx0XHRcdFx0XHRcdFx0c2ZGb250TmFtZSArPSBzZlRva2Vuc1tzZmldLnRva2VuO1xuLy9cdFx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5zZXRmb250W3NmTnVtXSA9IHsgZmFjZTogc2ZGb250TmFtZSwgc2l6ZTogc2ZTaXplIH07XG4vL1x0XHRcdFx0XHRcdFx0XHRzZkRvbmUgPSB0cnVlO1xuLy9cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cbi8vXHRcdFx0XHRpZiAoIXNmRG9uZSlcbi8vXHRcdFx0XHRcdHJldHVybiBcIkJhZCBwYXJhbWV0ZXJzOiBcIiArIGNtZDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZ2Nob3JkZm9udFwiOlxuXHRcdFx0Y2FzZSBcInBhcnRzZm9udFwiOlxuXHRcdFx0Y2FzZSBcInRyaXBsZXRmb250XCI6XG5cdFx0XHRjYXNlIFwidm9jYWxmb250XCI6XG5cdFx0XHRjYXNlIFwidGV4dGZvbnRcIjpcblx0XHRcdGNhc2UgXCJhbm5vdGF0aW9uZm9udFwiOlxuXHRcdFx0Y2FzZSBcImhpc3Rvcnlmb250XCI6XG5cdFx0XHRjYXNlIFwiaW5mb2ZvbnRcIjpcblx0XHRcdGNhc2UgXCJtZWFzdXJlZm9udFwiOlxuXHRcdFx0Y2FzZSBcInJlcGVhdGZvbnRcIjpcblx0XHRcdGNhc2UgXCJ3b3Jkc2ZvbnRcIjpcblx0XHRcdFx0cmV0dXJuIGdldENoYW5naW5nRm9udChjbWQsIHRva2Vucywgc3RyKTtcblx0XHRcdGNhc2UgXCJjb21wb3NlcmZvbnRcIjpcblx0XHRcdGNhc2UgXCJzdWJ0aXRsZWZvbnRcIjpcblx0XHRcdGNhc2UgXCJ0ZW1wb2ZvbnRcIjpcblx0XHRcdGNhc2UgXCJ0aXRsZWZvbnRcIjpcblx0XHRcdGNhc2UgXCJ2b2ljZWZvbnRcIjpcblx0XHRcdGNhc2UgXCJmb290ZXJmb250XCI6XG5cdFx0XHRjYXNlIFwiaGVhZGVyZm9udFwiOlxuXHRcdFx0XHRyZXR1cm4gZ2V0R2xvYmFsRm9udChjbWQsIHRva2Vucywgc3RyKTtcblx0XHRcdGNhc2UgXCJiYXJsYWJlbGZvbnRcIjpcblx0XHRcdGNhc2UgXCJiYXJudW1iZXJmb250XCI6XG5cdFx0XHRjYXNlIFwiYmFybnVtZm9udFwiOlxuXHRcdFx0XHRyZXR1cm4gZ2V0Q2hhbmdpbmdGb250KFwibWVhc3VyZWZvbnRcIiwgdG9rZW5zLCBzdHIpO1xuXHRcdFx0Y2FzZSBcInN0YXZlc1wiOlxuXHRcdFx0Y2FzZSBcInNjb3JlXCI6XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuc2NvcmVfaXNfcHJlc2VudCA9IHRydWU7XG5cdFx0XHRcdHZhciBhZGRWb2ljZSA9IGZ1bmN0aW9uKGlkLCBuZXdTdGFmZiwgYnJhY2tldCwgYnJhY2UsIGNvbnRpbnVlQmFyKSB7XG5cdFx0XHRcdFx0aWYgKG5ld1N0YWZmIHx8IG11bHRpbGluZVZhcnMuc3RhdmVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5zdGF2ZXMucHVzaCh7aW5kZXg6IG11bHRpbGluZVZhcnMuc3RhdmVzLmxlbmd0aCwgbnVtVm9pY2VzOiAwfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBzdGFmZiA9IHBhcnNlQ29tbW9uLmxhc3QobXVsdGlsaW5lVmFycy5zdGF2ZXMpO1xuXHRcdFx0XHRcdGlmIChicmFja2V0ICE9PSB1bmRlZmluZWQpIHN0YWZmLmJyYWNrZXQgPSBicmFja2V0O1xuXHRcdFx0XHRcdGlmIChicmFjZSAhPT0gdW5kZWZpbmVkKSBzdGFmZi5icmFjZSA9IGJyYWNlO1xuXHRcdFx0XHRcdGlmIChjb250aW51ZUJhcikgc3RhZmYuY29ubmVjdEJhckxpbmVzID0gJ2VuZCc7XG5cdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMudm9pY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0gPSB7c3RhZmZOdW06IHN0YWZmLmluZGV4LCBpbmRleDogc3RhZmYubnVtVm9pY2VzfTtcblx0XHRcdFx0XHRcdHN0YWZmLm51bVZvaWNlcysrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2YXIgb3BlblBhcmVuID0gZmFsc2U7XG5cdFx0XHRcdHZhciBvcGVuQnJhY2tldCA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgb3BlbkJyYWNlID0gZmFsc2U7XG5cdFx0XHRcdHZhciBqdXN0T3BlblBhcmVuID0gZmFsc2U7XG5cdFx0XHRcdHZhciBqdXN0T3BlbkJyYWNrZXQgPSBmYWxzZTtcblx0XHRcdFx0dmFyIGp1c3RPcGVuQnJhY2UgPSBmYWxzZTtcblx0XHRcdFx0dmFyIGNvbnRpbnVlQmFyID0gZmFsc2U7XG5cdFx0XHRcdHZhciBsYXN0Vm9pY2U7XG5cdFx0XHRcdHZhciBhZGRDb250aW51ZUJhciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlQmFyID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAobGFzdFZvaWNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdHkgPSAnc3RhcnQnO1xuXHRcdFx0XHRcdFx0aWYgKGxhc3RWb2ljZS5zdGFmZk51bSA+IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMuc3RhdmVzW2xhc3RWb2ljZS5zdGFmZk51bS0xXS5jb25uZWN0QmFyTGluZXMgPT09ICdzdGFydCcgfHxcblx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnN0YXZlc1tsYXN0Vm9pY2Uuc3RhZmZOdW0tMV0uY29ubmVjdEJhckxpbmVzID09PSAnY29udGludWUnKVxuXHRcdFx0XHRcdFx0XHRcdHR5ID0gJ2NvbnRpbnVlJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuc3RhdmVzW2xhc3RWb2ljZS5zdGFmZk51bV0uY29ubmVjdEJhckxpbmVzID0gdHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdHZhciB0ID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0c3dpdGNoICh0LnRva2VuKSB7XG5cdFx0XHRcdFx0XHRjYXNlICcoJzpcblx0XHRcdFx0XHRcdFx0aWYgKG9wZW5QYXJlbikgd2FybihcIkNhbid0IG5lc3QgcGFyZW50aGVzaXMgaW4gJSVzY29yZVwiLCBzdHIsIHQuc3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIHtvcGVuUGFyZW4gPSB0cnVlO2p1c3RPcGVuUGFyZW4gPSB0cnVlO31cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICcpJzpcblx0XHRcdFx0XHRcdFx0aWYgKCFvcGVuUGFyZW4gfHwganVzdE9wZW5QYXJlbikgd2FybihcIlVuZXhwZWN0ZWQgY2xvc2UgcGFyZW50aGVzaXMgaW4gJSVzY29yZVwiLCBzdHIsIHQuc3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIG9wZW5QYXJlbiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1snOlxuXHRcdFx0XHRcdFx0XHRpZiAob3BlbkJyYWNrZXQpIHdhcm4oXCJDYW4ndCBuZXN0IGJyYWNrZXRzIGluICUlc2NvcmVcIiwgc3RyLCB0LnN0YXJ0KTtcblx0XHRcdFx0XHRcdFx0ZWxzZSB7b3BlbkJyYWNrZXQgPSB0cnVlO2p1c3RPcGVuQnJhY2tldCA9IHRydWU7fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ10nOlxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wZW5CcmFja2V0IHx8IGp1c3RPcGVuQnJhY2tldCkgd2FybihcIlVuZXhwZWN0ZWQgY2xvc2UgYnJhY2tldCBpbiAlJXNjb3JlXCIsIHN0ciwgdC5zdGFydCk7XG5cdFx0XHRcdFx0XHRcdGVsc2Uge29wZW5CcmFja2V0ID0gZmFsc2U7bXVsdGlsaW5lVmFycy5zdGF2ZXNbbGFzdFZvaWNlLnN0YWZmTnVtXS5icmFja2V0ID0gJ2VuZCc7fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3snOlxuXHRcdFx0XHRcdFx0XHRpZiAob3BlbkJyYWNlICkgd2FybihcIkNhbid0IG5lc3QgYnJhY2VzIGluICUlc2NvcmVcIiwgc3RyLCB0LnN0YXJ0KTtcblx0XHRcdFx0XHRcdFx0ZWxzZSB7b3BlbkJyYWNlID0gdHJ1ZTtqdXN0T3BlbkJyYWNlID0gdHJ1ZTt9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnfSc6XG5cdFx0XHRcdFx0XHRcdGlmICghb3BlbkJyYWNlIHx8IGp1c3RPcGVuQnJhY2UpIHdhcm4oXCJVbmV4cGVjdGVkIGNsb3NlIGJyYWNlIGluICUlc2NvcmVcIiwgc3RyLCB0LnN0YXJ0KTtcblx0XHRcdFx0XHRcdFx0ZWxzZSB7b3BlbkJyYWNlID0gZmFsc2U7bXVsdGlsaW5lVmFycy5zdGF2ZXNbbGFzdFZvaWNlLnN0YWZmTnVtXS5icmFjZSA9ICdlbmQnO31cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd8Jzpcblx0XHRcdFx0XHRcdFx0YWRkQ29udGludWVCYXIoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR2YXIgdmMgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAodC50eXBlID09PSAnYWxwaGEnIHx8IHQudHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdFx0XHR2YyArPSB0LnRva2VuO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0LmNvbnRpbnVlSWQpXG5cdFx0XHRcdFx0XHRcdFx0XHR0ID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFyIG5ld1N0YWZmID0gIW9wZW5QYXJlbiB8fCBqdXN0T3BlblBhcmVuO1xuXHRcdFx0XHRcdFx0XHR2YXIgYnJhY2tldCA9IGp1c3RPcGVuQnJhY2tldCA/ICdzdGFydCcgOiBvcGVuQnJhY2tldCA/ICdjb250aW51ZScgOiB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdHZhciBicmFjZSA9IGp1c3RPcGVuQnJhY2UgPyAnc3RhcnQnIDogb3BlbkJyYWNlID8gJ2NvbnRpbnVlJyA6IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0YWRkVm9pY2UodmMsIG5ld1N0YWZmLCBicmFja2V0LCBicmFjZSwgY29udGludWVCYXIpO1xuXHRcdFx0XHRcdFx0XHRqdXN0T3BlblBhcmVuID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGp1c3RPcGVuQnJhY2tldCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRqdXN0T3BlbkJyYWNlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlQmFyID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGxhc3RWb2ljZSA9IG11bHRpbGluZVZhcnMudm9pY2VzW3ZjXTtcblx0XHRcdFx0XHRcdFx0aWYgKGNtZCA9PT0gJ3N0YXZlcycpXG5cdFx0XHRcdFx0XHRcdFx0YWRkQ29udGludWVCYXIoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwibmV3cGFnZVwiOlxuXHRcdFx0XHR2YXIgcGdOdW0gPSB0b2tlbml6ZXIuZ2V0SW50KHJlc3RPZlN0cmluZyk7XG5cdFx0XHRcdHR1bmUuYWRkTmV3UGFnZShwZ051bS5kaWdpdHMgPT09IDAgPyAtMSA6IHBnTnVtLnZhbHVlKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJhYmNcIjpcblx0XHRcdFx0dmFyIGFyciA9IHJlc3RPZlN0cmluZy5zcGxpdCgnICcpO1xuXHRcdFx0XHRzd2l0Y2ggKGFyclswXSkge1xuXHRcdFx0XHRcdGNhc2UgXCItY29weXJpZ2h0XCI6XG5cdFx0XHRcdFx0Y2FzZSBcIi1jcmVhdG9yXCI6XG5cdFx0XHRcdFx0Y2FzZSBcIi1lZGl0ZWQtYnlcIjpcblx0XHRcdFx0XHRjYXNlIFwiLXZlcnNpb25cIjpcblx0XHRcdFx0XHRjYXNlIFwiLWNoYXJzZXRcIjpcblx0XHRcdFx0XHRcdHZhciBzdWJDbWQgPSBhcnIuc2hpZnQoKTtcblx0XHRcdFx0XHRcdHR1bmUuYWRkTWV0YVRleHQoY21kK3N1YkNtZCwgYXJyLmpvaW4oJyAnKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiVW5rbm93biBkaXJlY3RpdmU6IFwiICsgY21kK2FyclswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJoZWFkZXJcIjpcblx0XHRcdGNhc2UgXCJmb290ZXJcIjpcblx0XHRcdFx0dmFyIGZvb3RlclN0ciA9IHRva2VuaXplci5nZXRNZWF0KHJlc3RPZlN0cmluZywgMCwgcmVzdE9mU3RyaW5nLmxlbmd0aCk7XG5cdFx0XHRcdGZvb3RlclN0ciA9IHJlc3RPZlN0cmluZy5zdWJzdHJpbmcoZm9vdGVyU3RyLnN0YXJ0LCBmb290ZXJTdHIuZW5kKTtcblx0XHRcdFx0aWYgKGZvb3RlclN0ci5jaGFyQXQoMCkgPT09ICdcIicgJiYgZm9vdGVyU3RyLmNoYXJBdChmb290ZXJTdHIubGVuZ3RoLTEpID09PSAnXCInIClcblx0XHRcdFx0XHRmb290ZXJTdHIgPSBmb290ZXJTdHIuc3Vic3RyaW5nKDEsIGZvb3RlclN0ci5sZW5ndGgtMSk7XG5cdFx0XHRcdHZhciBmb290ZXJBcnIgPSBmb290ZXJTdHIuc3BsaXQoJ1xcdCcpO1xuXHRcdFx0XHR2YXIgZm9vdGVyID0ge307XG5cdFx0XHRcdGlmIChmb290ZXJBcnIubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdGZvb3RlciA9IHsgbGVmdDogXCJcIiwgY2VudGVyOiBmb290ZXJBcnJbMF0sIHJpZ2h0OiBcIlwiIH07XG5cdFx0XHRcdGVsc2UgaWYgKGZvb3RlckFyci5sZW5ndGggPT09IDIpXG5cdFx0XHRcdFx0Zm9vdGVyID0geyBsZWZ0OiBmb290ZXJBcnJbMF0sIGNlbnRlcjogZm9vdGVyQXJyWzFdLCByaWdodDogXCJcIiB9O1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Zm9vdGVyID0geyBsZWZ0OiBmb290ZXJBcnJbMF0sIGNlbnRlcjogZm9vdGVyQXJyWzFdLCByaWdodDogZm9vdGVyQXJyWzJdIH07XG5cdFx0XHRcdGlmIChmb290ZXJBcnIubGVuZ3RoID4gMylcblx0XHRcdFx0XHR3YXJuKFwiVG9vIG1hbnkgdGFicyBpbiBcIiArIGNtZCArIFwiOiBcIiArIGZvb3RlckFyci5sZW5ndGggKyBcIiBmb3VuZC5cIiwgcmVzdE9mU3RyaW5nLCAwKTtcblxuXHRcdFx0XHR0dW5lLmFkZE1ldGFUZXh0T2JqKGNtZCwgZm9vdGVyKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJtaWRpXCI6XG5cdFx0XHRcdHZhciBtaWRpID0gdG9rZW5pemVyLnRva2VuaXplKHJlc3RPZlN0cmluZywgMCwgcmVzdE9mU3RyaW5nLmxlbmd0aCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChtaWRpLmxlbmd0aCA+IDAgJiYgbWlkaVswXS50b2tlbiA9PT0gJz0nKVxuXHRcdFx0XHRcdG1pZGkuc2hpZnQoKTtcblx0XHRcdFx0aWYgKG1pZGkubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBtaWRpIGNvbW1hbmRcIiwgcmVzdE9mU3RyaW5nLCAwKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHBhcnNlTWlkaUNvbW1hbmQobWlkaSwgdHVuZSwgcmVzdE9mU3RyaW5nKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJtYXBcIjpcblx0XHRcdGNhc2UgXCJwZXJjbWFwXCI6XG5cdFx0XHRjYXNlIFwicGxheXRlbXBvXCI6XG5cdFx0XHRjYXNlIFwiYXVxdWFsaXR5XCI6XG5cdFx0XHRjYXNlIFwiY29udGludW91c1wiOlxuXHRcdFx0Y2FzZSBcIm5vYmFyY2hlY2tcIjpcblx0XHRcdFx0Ly8gVE9ETy1QRVI6IEFjdHVhbGx5IGhhbmRsZSB0aGUgcGFyYW1ldGVycyBvZiB0aGVzZVxuXHRcdFx0XHR0dW5lLmZvcm1hdHRpbmdbY21kXSA9IHJlc3RPZlN0cmluZztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gXCJVbmtub3duIGRpcmVjdGl2ZTogXCIgKyBjbWQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXHRwYXJzZURpcmVjdGl2ZS5nbG9iYWxGb3JtYXR0aW5nID0gZnVuY3Rpb24oZm9ybWF0SGFzaCkge1xuXHRcdGZvciAodmFyIGNtZCBpbiBmb3JtYXRIYXNoKSB7XG5cdFx0XHRpZiAoZm9ybWF0SGFzaC5oYXNPd25Qcm9wZXJ0eShjbWQpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICcnK2Zvcm1hdEhhc2hbY21kXTtcblx0XHRcdFx0dmFyIHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZSh2YWx1ZSwgMCwgdmFsdWUubGVuZ3RoKTtcblx0XHRcdFx0dmFyIHNjcmF0Y2g7XG5cdFx0XHRcdHN3aXRjaCAoY21kKSB7XG5cdFx0XHRcdFx0Y2FzZSBcInRpdGxlZm9udFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJnY2hvcmRmb250XCI6XG5cdFx0XHRcdFx0Y2FzZSBcImNvbXBvc2VyZm9udFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJmb290ZXJmb250XCI6XG5cdFx0XHRcdFx0Y2FzZSBcImhlYWRlcmZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwiaGlzdG9yeWZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwiaW5mb2ZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwibWVhc3VyZWZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwicGFydHNmb250XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInJlcGVhdGZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwic3VidGl0bGVmb250XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInRlbXBvZm9udFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJ0ZXh0Zm9udFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJ2b2ljZWZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwidHJpcGxldGZvbnRcIjpcblx0XHRcdFx0XHRjYXNlIFwidm9jYWxmb250XCI6XG5cdFx0XHRcdFx0Y2FzZSBcIndvcmRzZm9udFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJhbm5vdGF0aW9uZm9udFwiOlxuXHRcdFx0XHRcdFx0Z2V0Q2hhbmdpbmdGb250KGNtZCwgdG9rZW5zLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic2NhbGVcIjpcblx0XHRcdFx0XHRcdHNldFNjYWxlKGNtZCwgdG9rZW5zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJwYXJ0c2JveFwiOlxuXHRcdFx0XHRcdFx0c2NyYXRjaCA9IGFkZE11bHRpbGluZVZhckJvb2woJ3BhcnRzQm94JywgY21kLCB0b2tlbnMpO1xuXHRcdFx0XHRcdFx0aWYgKHNjcmF0Y2ggIT09IG51bGwpIHdhcm4oc2NyYXRjaCk7XG5cdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnBhcnRzZm9udC5ib3ggPSBtdWx0aWxpbmVWYXJzLnBhcnRzQm94O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImZyZWVnY2hvcmRcIjpcblx0XHRcdFx0XHRcdHNjcmF0Y2ggPSBhZGRNdWx0aWxpbmVWYXJCb29sKCdmcmVlZ2Nob3JkJywgY21kLCB0b2tlbnMpO1xuXHRcdFx0XHRcdFx0aWYgKHNjcmF0Y2ggIT09IG51bGwpIHdhcm4oc2NyYXRjaCk7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHdhcm4oXCJGb3JtYXR0aW5nIGRpcmVjdGl2ZSB1bnJlY29nbml6ZWQ6IFwiLCBjbWQsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZURpcmVjdGl2ZTtcbiIsIi8vICAgIGFiY19wYXJzZV9oZWFkZXIuanM6IHBhcnNlcyBhIHRoZSBoZWFkZXIgZmllbGRzIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50aW5nIEFCQyBNdXNpYyBOb3RhdGlvbiBpbnRvIGEgdXNhYmxlIGludGVybmFsIHN0cnVjdHVyZS5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IFBhdWwgUm9zZW4gKHBhdWwgYXQgcGF1bHJvc2VuIGRvdCBuZXQpXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8qZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgcGFyc2VDb21tb24gPSByZXF1aXJlKCcuL2FiY19jb21tb24nKTtcbnZhciBwYXJzZURpcmVjdGl2ZSA9IHJlcXVpcmUoJy4vYWJjX3BhcnNlX2RpcmVjdGl2ZScpO1xudmFyIHBhcnNlS2V5Vm9pY2UgPSByZXF1aXJlKCcuL2FiY19wYXJzZV9rZXlfdm9pY2UnKTtcblxudmFyIFBhcnNlSGVhZGVyID0gZnVuY3Rpb24odG9rZW5pemVyLCB3YXJuLCBtdWx0aWxpbmVWYXJzLCB0dW5lKSB7XG5cdHRoaXMucmVzZXQgPSBmdW5jdGlvbih0b2tlbml6ZXIsIHdhcm4sIG11bHRpbGluZVZhcnMsIHR1bmUpIHtcblx0XHRwYXJzZUtleVZvaWNlLmluaXRpYWxpemUodG9rZW5pemVyLCB3YXJuLCBtdWx0aWxpbmVWYXJzLCB0dW5lKTtcblx0XHRwYXJzZURpcmVjdGl2ZS5pbml0aWFsaXplKHRva2VuaXplciwgd2FybiwgbXVsdGlsaW5lVmFycywgdHVuZSk7XG5cdH07XG5cdHRoaXMucmVzZXQodG9rZW5pemVyLCB3YXJuLCBtdWx0aWxpbmVWYXJzLCB0dW5lKTtcblxuXHR0aGlzLnNldFRpdGxlID0gZnVuY3Rpb24odGl0bGUpIHtcblx0XHRpZiAobXVsdGlsaW5lVmFycy5oYXNNYWluVGl0bGUpXG5cdFx0XHR0dW5lLmFkZFN1YnRpdGxlKHRva2VuaXplci50cmFuc2xhdGVTdHJpbmcodG9rZW5pemVyLnN0cmlwQ29tbWVudCh0aXRsZSkpKTtcdC8vIGRpc3BsYXkgc2Vjb25kYXJ5IHRpdGxlXG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHZhciB0aXRsZVN0ciA9IHRva2VuaXplci50cmFuc2xhdGVTdHJpbmcodG9rZW5pemVyLnRoZVJldmVyc2VyKHRva2VuaXplci5zdHJpcENvbW1lbnQodGl0bGUpKSk7XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy50aXRsZWNhcHMpXG5cdFx0XHRcdHRpdGxlU3RyID0gdGl0bGVTdHIudG9VcHBlckNhc2UoKTtcblx0XHRcdHR1bmUuYWRkTWV0YVRleHQoXCJ0aXRsZVwiLCB0aXRsZVN0cik7XG5cdFx0XHRtdWx0aWxpbmVWYXJzLmhhc01haW5UaXRsZSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdHRoaXMuc2V0TWV0ZXIgPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0bGluZSA9IHRva2VuaXplci5zdHJpcENvbW1lbnQobGluZSk7XG5cdFx0aWYgKGxpbmUgPT09ICdDJykge1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPT09IHRydWUpIHtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IDAuMTI1O1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge3R5cGU6ICdjb21tb25fdGltZSd9O1xuXHRcdH0gZWxzZSBpZiAobGluZSA9PT0gJ0N8Jykge1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPT09IHRydWUpIHtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IDAuMTI1O1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge3R5cGU6ICdjdXRfdGltZSd9O1xuXHRcdH0gZWxzZSBpZiAobGluZSA9PT0gJ28nKSB7XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5oYXZlbnRfc2V0X2xlbmd0aCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmRlZmF1bHRfbGVuZ3RoID0gMC4xMjU7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7dHlwZTogJ3RlbXB1c19wZXJmZWN0dW0nfTtcblx0XHR9IGVsc2UgaWYgKGxpbmUgPT09ICdjJykge1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPT09IHRydWUpIHtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IDAuMTI1O1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge3R5cGU6ICd0ZW1wdXNfaW1wZXJmZWN0dW0nfTtcblx0XHR9IGVsc2UgaWYgKGxpbmUgPT09ICdvLicpIHtcblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID09PSB0cnVlKSB7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuZGVmYXVsdF9sZW5ndGggPSAwLjEyNTtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5oYXZlbnRfc2V0X2xlbmd0aCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHt0eXBlOiAndGVtcHVzX3BlcmZlY3R1bV9wcm9sYXRpbyd9O1xuXHRcdH0gZWxzZSBpZiAobGluZSA9PT0gJ2MuJykge1xuXHRcdFx0aWYgKG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPT09IHRydWUpIHtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IDAuMTI1O1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge3R5cGU6ICd0ZW1wdXNfaW1wZXJmZWN0dW1fcHJvbGF0aW8nfTtcblx0XHR9IGVsc2UgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUudG9Mb3dlckNhc2UoKSA9PT0gJ25vbmUnKSB7XG5cdFx0XHRpZiAobXVsdGlsaW5lVmFycy5oYXZlbnRfc2V0X2xlbmd0aCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmRlZmF1bHRfbGVuZ3RoID0gMC4xMjU7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dmFyIHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShsaW5lLCAwLCBsaW5lLmxlbmd0aCk7XG5cdFx0XHQvLyB0aGUgZm9ybSBpcyBbb3Blbl9wYXJlbl0gZGVjaW1hbCBbIHBsdXN8ZG90IGRlY2ltYWwgXS4uLiBbY2xvc2VfcGFyZW5dIHNsYXNoIGRlY2ltYWwgW3BsdXMgc2FtZV9hc19iZWZvcmVdXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgcGFyc2VOdW0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBoYW5kbGVzIHRoaXMgbXVjaDogW29wZW5fcGFyZW5dIGRlY2ltYWwgWyBwbHVzfGRvdCBkZWNpbWFsIF0uLi4gW2Nsb3NlX3BhcmVuXVxuXHRcdFx0XHRcdHZhciByZXQgPSB7dmFsdWU6IDAsIG51bTogXCJcIn07XG5cblx0XHRcdFx0XHR2YXIgdG9rID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRvay50b2tlbiA9PT0gJygnKVxuXHRcdFx0XHRcdFx0dG9rID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0d2hpbGUgKDEpIHtcblx0XHRcdFx0XHRcdGlmICh0b2sudHlwZSAhPT0gJ251bWJlcicpIHRocm93IFwiRXhwZWN0ZWQgdG9wIG51bWJlciBvZiBtZXRlclwiO1xuXHRcdFx0XHRcdFx0cmV0LnZhbHVlICs9IHBhcnNlSW50KHRvay50b2tlbik7XG5cdFx0XHRcdFx0XHRyZXQubnVtICs9IHRvay50b2tlbjtcblx0XHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1swXS50b2tlbiA9PT0gJy8nKSByZXR1cm4gcmV0O1xuXHRcdFx0XHRcdFx0dG9rID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRpZiAodG9rLnRva2VuID09PSAnKScpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zWzBdLnRva2VuID09PSAnLycpIHJldHVybiByZXQ7XG5cdFx0XHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBwYXJlbiBpbiBtZXRlclwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRvay50b2tlbiAhPT0gJy4nICYmIHRvay50b2tlbiAhPT0gJysnKSB0aHJvdyBcIkV4cGVjdGVkIHRvcCBudW1iZXIgb2YgbWV0ZXJcIjtcblx0XHRcdFx0XHRcdHJldC5udW0gKz0gdG9rLnRva2VuO1xuXHRcdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHRocm93IFwiRXhwZWN0ZWQgdG9wIG51bWJlciBvZiBtZXRlclwiO1xuXHRcdFx0XHRcdFx0dG9rID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXQ7XHQvLyBqdXN0IHRvIHN1cHByZXNzIHdhcm5pbmdcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2YXIgcGFyc2VGcmFjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIGhhbmRsZXMgdGhpcyBtdWNoOiBwYXJzZU51bSBzbGFzaCBkZWNpbWFsXG5cdFx0XHRcdFx0dmFyIHJldCA9IHBhcnNlTnVtKCk7XG5cdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG5cdFx0XHRcdFx0dmFyIHRvayA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2sudG9rZW4gIT09ICcvJykgdGhyb3cgXCJFeHBlY3RlZCBzbGFzaCBpbiBtZXRlclwiO1xuXHRcdFx0XHRcdHRvayA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2sudHlwZSAhPT0gJ251bWJlcicpIHRocm93IFwiRXhwZWN0ZWQgYm90dG9tIG51bWJlciBvZiBtZXRlclwiO1xuXHRcdFx0XHRcdHJldC5kZW4gPSB0b2sudG9rZW47XG5cdFx0XHRcdFx0cmV0LnZhbHVlID0gcmV0LnZhbHVlIC8gcGFyc2VJbnQocmV0LmRlbik7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgdGhyb3cgXCJFeHBlY3RlZCBtZXRlciBkZWZpbml0aW9uIGluIE06IGxpbmVcIjtcblx0XHRcdFx0dmFyIG1ldGVyID0ge3R5cGU6ICdzcGVjaWZpZWQnLCB2YWx1ZTogWyBdfTtcblx0XHRcdFx0dmFyIHRvdGFsTGVuZ3RoID0gMDtcblx0XHRcdFx0d2hpbGUgKDEpIHtcblx0XHRcdFx0XHR2YXIgcmV0ID0gcGFyc2VGcmFjdGlvbigpO1xuXHRcdFx0XHRcdHRvdGFsTGVuZ3RoICs9IHJldC52YWx1ZTtcblx0XHRcdFx0XHR2YXIgbXYgPSB7IG51bTogcmV0Lm51bSB9O1xuXHRcdFx0XHRcdGlmIChyZXQuZGVuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRtdi5kZW4gPSByZXQuZGVuO1xuXHRcdFx0XHRcdG1ldGVyLnZhbHVlLnB1c2gobXYpO1xuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSBicmVhaztcblx0XHRcdFx0XHQvL3ZhciB0b2sgPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHQvL2lmICh0b2sudG9rZW4gIT09ICcrJykgdGhyb3cgXCJFeHRyYSBjaGFyYWN0ZXJzIGluIE06IGxpbmVcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmhhdmVudF9zZXRfbGVuZ3RoID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IHRvdGFsTGVuZ3RoIDwgMC43NSA/IDAuMDYyNSA6IDAuMTI1O1xuXHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWV0ZXI7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHdhcm4oZSwgbGluZSwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdHRoaXMuY2FsY1RlbXBvID0gZnVuY3Rpb24ocmVsVGVtcG8pIHtcblx0XHR2YXIgZHVyID0gMS80O1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLm1ldGVyICYmIG11bHRpbGluZVZhcnMubWV0ZXIudHlwZSA9PT0gJ3NwZWNpZmllZCcpIHtcblx0XHRcdGR1ciA9IDEgLyBwYXJzZUludChtdWx0aWxpbmVWYXJzLm1ldGVyLnZhbHVlWzBdLmRlbik7XG5cdFx0fSBlbHNlIGlmIChtdWx0aWxpbmVWYXJzLm9yaWdNZXRlciAmJiBtdWx0aWxpbmVWYXJzLm9yaWdNZXRlci50eXBlID09PSAnc3BlY2lmaWVkJykge1xuXHRcdFx0ZHVyID0gMSAvIHBhcnNlSW50KG11bHRpbGluZVZhcnMub3JpZ01ldGVyLnZhbHVlWzBdLmRlbik7XG5cdFx0fVxuXHRcdC8vdmFyIGR1ciA9IG11bHRpbGluZVZhcnMuZGVmYXVsdF9sZW5ndGggPyBtdWx0aWxpbmVWYXJzLmRlZmF1bHRfbGVuZ3RoIDogMTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJlbFRlbXBvLmR1cmF0aW9uOyBpKyspXG5cdFx0XHRyZWxUZW1wby5kdXJhdGlvbltpXSA9IGR1ciAqIHJlbFRlbXBvLmR1cmF0aW9uW2ldO1xuXHRcdHJldHVybiByZWxUZW1wbztcblx0fTtcblxuXHR0aGlzLnJlc29sdmVUZW1wbyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChtdWx0aWxpbmVWYXJzLnRlbXBvKSB7XHQvLyBJZiB0aGVyZSdzIGEgdGVtcG8gd2FpdGluZyB0byBiZSByZXNvbHZlZFxuXHRcdFx0dGhpcy5jYWxjVGVtcG8obXVsdGlsaW5lVmFycy50ZW1wbyk7XG5cdFx0XHR0dW5lLm1ldGFUZXh0LnRlbXBvID0gbXVsdGlsaW5lVmFycy50ZW1wbztcblx0XHRcdGRlbGV0ZSBtdWx0aWxpbmVWYXJzLnRlbXBvO1xuXHRcdH1cblx0fTtcblxuXHR0aGlzLmFkZFVzZXJEZWZpbml0aW9uID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGVuZCkge1xuXHRcdHZhciBlcXVhbHMgPSBsaW5lLmluZGV4T2YoJz0nLCBzdGFydCk7XG5cdFx0aWYgKGVxdWFscyA9PT0gLTEpIHtcblx0XHRcdHdhcm4oXCJOZWVkIGFuID0gaW4gYSBtYWNybyBkZWZpbml0aW9uXCIsIGxpbmUsIHN0YXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgYmVmb3JlID0gcGFyc2VDb21tb24uc3RyaXAobGluZS5zdWJzdHJpbmcoc3RhcnQsIGVxdWFscykpO1xuXHRcdHZhciBhZnRlciA9IHBhcnNlQ29tbW9uLnN0cmlwKGxpbmUuc3Vic3RyaW5nKGVxdWFscysxKSk7XG5cblx0XHRpZiAoYmVmb3JlLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0d2FybihcIk1hY3JvIGRlZmluaXRpb25zIGNhbiBvbmx5IGJlIG9uZSBjaGFyYWN0ZXJcIiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbGVnYWxDaGFycyA9IFwiSElKS0xNTk9QUVJTVFVWV1hZaGlqa2xtbm9wcXJzdHV2d35cIjtcblx0XHRpZiAobGVnYWxDaGFycy5pbmRleE9mKGJlZm9yZSkgPT09IC0xKSB7XG5cdFx0XHR3YXJuKFwiTWFjcm8gZGVmaW5pdGlvbnMgbXVzdCBiZSBILVksIGgtdywgb3IgdGlsZGVcIiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoYWZ0ZXIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR3YXJuKFwiTWlzc2luZyBtYWNybyBkZWZpbml0aW9uXCIsIGxpbmUsIHN0YXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG11bHRpbGluZVZhcnMubWFjcm9zID09PSB1bmRlZmluZWQpXG5cdFx0XHRtdWx0aWxpbmVWYXJzLm1hY3JvcyA9IHt9O1xuXHRcdG11bHRpbGluZVZhcnMubWFjcm9zW2JlZm9yZV0gPSBhZnRlcjtcblx0fTtcblxuXHR0aGlzLnNldERlZmF1bHRMZW5ndGggPSBmdW5jdGlvbihsaW5lLCBzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGxlbiA9IHBhcnNlQ29tbW9uLmdzdWIobGluZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCksIFwiIFwiLCBcIlwiKTtcblx0XHR2YXIgbGVuX2FyciA9IGxlbi5zcGxpdCgnLycpO1xuXHRcdGlmIChsZW5fYXJyLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dmFyIG4gPSBwYXJzZUludChsZW5fYXJyWzBdKTtcblx0XHRcdHZhciBkID0gcGFyc2VJbnQobGVuX2FyclsxXSk7XG5cdFx0XHRpZiAoZCA+IDApIHtcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5kZWZhdWx0X2xlbmd0aCA9IG4gLyBkO1x0Ly8gYSB3aG9sZSBub3RlIGlzIDFcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5oYXZlbnRfc2V0X2xlbmd0aCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVuX2Fyci5sZW5ndGggPT09IDEgJiYgbGVuX2FyclswXSA9PT0gJzEnKSB7XG5cdFx0XHRtdWx0aWxpbmVWYXJzLmRlZmF1bHRfbGVuZ3RoID0gMTtcblx0XHRcdG11bHRpbGluZVZhcnMuaGF2ZW50X3NldF9sZW5ndGggPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblxuXHR2YXIgdGVtcG9TdHJpbmcgPSB7XG5cblx0XHRsYXJnaGlzc2ltbzogMjAsXG5cdFx0YWRhZ2lzc2ltbzogMjQsXG5cdFx0c29zdGVudXRvOiAyOCxcblx0XHRncmF2ZTogMzIsXG5cdFx0bGFyZ286IDQwLFxuXHRcdGxlbnRvOiA1MCxcblx0XHRsYXJnaGV0dG86IDYwLFxuXHRcdGFkYWdpbzogNjgsXG5cdFx0YWRhZ2lldHRvOiA3NCxcblx0XHRhbmRhbnRlOiA4MCxcblx0XHRhbmRhbnRpbm86IDg4LFxuXHRcdFwibWFyY2lhIG1vZGVyYXRvXCI6IDg0LFxuXHRcdFwiYW5kYW50ZSBtb2RlcmF0b1wiOiAxMDAsXG5cdFx0bW9kZXJhdG86IDExMixcblx0XHRhbGxlZ3JldHRvOiAxMTYsXG5cdFx0XCJhbGxlZ3JvIG1vZGVyYXRvXCI6IDEyMCxcblx0XHRhbGxlZ3JvOiAxMjYsXG5cdFx0YW5pbWF0bzogMTMyLFxuXHRcdGFnaXRhdG86IDE0MCxcblx0XHR2ZWxvY2U6IDE0OCxcblx0XHRcIm1vc3NvIHZpdm9cIjogMTU2LFxuXHRcdHZpdmFjZTogMTY0LFxuXHRcdHZpdmFjaXNzaW1vOiAxNzIsXG5cdFx0YWxsZWdyaXNzaW1vOiAxNzYsXG5cdFx0cHJlc3RvOiAxODQsXG5cdFx0cHJlc3Rpc3NpbW86IDIxMCxcblx0fTtcblxuXHR0aGlzLnNldFRlbXBvID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGVuZCkge1xuXHRcdC8vUSAtIHRlbXBvOyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBub3RlcyBwZXIgbWludXRlLCBlLmcuIElmXG5cdFx0Ly90aGUgbWV0ZXIgZGVub21pbmF0b3IgaXMgYSA0IG5vdGUgdGhlbiBROjEyMCBvciBROkM9MTIwXG5cdFx0Ly9pcyAxMjAgcXVhcnRlciBub3RlcyBwZXIgbWludXRlLiBTaW1pbGFybHkgIFE6QzM9NDAgd291bGQgYmUgNDBcblx0XHQvL2RvdHRlZCBoYWxmIG5vdGVzIHBlciBtaW51dGUuIEFuIGFic29sdXRlIHRlbXBvIG1heSBhbHNvIGJlXG5cdFx0Ly9zZXQsIGUuZy4gUToxLzg9MTIwIGlzIDEyMCBlaWdodGggbm90ZXMgcGVyIG1pbnV0ZSxcblx0XHQvL2lycmVzcGVjdGl2ZSBvZiB0aGUgbWV0ZXIncyBkZW5vbWluYXRvci5cblx0XHQvL1xuXHRcdC8vIFRoaXMgaXMgZWl0aGVyIGEgbnVtYmVyLCBcIkM9bnVtYmVyXCIsIFwiQ251bWJlcj1udW1iZXJcIiwgb3IgZnJhY3Rpb24gW2ZyYWN0aW9uLi4uXT1udW1iZXJcblx0XHQvLyBJdCBkZXBlbmRzIG9uIHRoZSBNOiBmaWVsZCwgd2hpY2ggbWF5IGVpdGhlciBub3QgYmUgcHJlc2VudCwgb3IgbWF5IGFwcGVhciBhZnRlciB0aGlzLlxuXHRcdC8vIElmIE06IGlzIG5vdCBwcmVzZW50LCBhbiBlaWdodGggbm90ZSBpcyB1c2VkLlxuXHRcdC8vIFRoYXQgbWVhbnMgdGhhdCB0aGlzIGZpZWxkIGNhbid0IGJlIGNhbGN1bGF0ZWQgdW50aWwgdGhlIGVuZCwgaWYgaXQgaXMgdGhlIGZpcnN0IHRocmVlIHR5cGVzLCBzaW5jZSB3ZSBkb24ndCBrbm93IGlmIHdlJ2xsIHNlZSBhbiBNOiBmaWVsZC5cblx0XHQvLyBTbywgaWYgaXQgaXMgdGhlIGZvdXJ0aCB0eXBlLCBzZXQgaXQgaGVyZSwgb3RoZXJ3aXNlLCBzYXZlIHRoZSBpbmZvIGluIHRoZSBtdWx0aWxpbmVWYXJzLlxuXHRcdC8vIFRoZSB0ZW1wb3JhcnkgdmFyaWFibGVzIHdlIGtlZXAgYXJlIHRoZSBkdXJhdGlvbiBhbmQgdGhlIGJwbS4gSW4gdGhlIGZpcnN0IHR3byBmb3JtcywgdGhlIGR1cmF0aW9uIGlzIDEuXG5cdFx0Ly8gSW4gYWRkaXRpb24sIGEgcXVvdGVkIHN0cmluZyBtYXkgYm90aCBwcmVjZWRlIGFuZCBmb2xsb3cuIElmIGEgcXVvdGVkIHN0cmluZyBpcyBwcmVzZW50LCB0aGVuIHRoZSBkdXJhdGlvbiBwYXJ0IGlzIG9wdGlvbmFsLlxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKGxpbmUsIHN0YXJ0LCBlbmQpO1xuXG5cdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgdGhyb3cgXCJNaXNzaW5nIHBhcmFtZXRlciBpbiBROiBmaWVsZFwiO1xuXG5cdFx0XHR2YXIgdGVtcG8gPSB7fTtcblx0XHRcdHZhciBkZWxheVNldCA9IHRydWU7XG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSAncXVvdGUnKSB7XG5cdFx0XHRcdHRlbXBvLnByZVN0cmluZyA9IHRva2VuLnRva2VuO1xuXHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1x0Ly8gSXQncyBvayB0byBqdXN0IGdldCBhIHN0cmluZyBmb3IgdGhlIHRlbXBvXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHN0cmluZyBpcyBhIHdlbGwta25vd24gdGVtcG8sIHB1dCBpbiB0aGUgYnBtXG5cdFx0XHRcdFx0aWYgKHRlbXBvU3RyaW5nW3RlbXBvLnByZVN0cmluZy50b0xvd2VyQ2FzZSgpXSkge1xuXHRcdFx0XHRcdFx0dGVtcG8uYnBtID0gdGVtcG9TdHJpbmdbdGVtcG8ucHJlU3RyaW5nLnRvTG93ZXJDYXNlKCldO1xuXHRcdFx0XHRcdFx0dGVtcG8uc3VwcHJlc3NCcG0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6ICdpbW1lZGlhdGUnLCB0ZW1wbzogdGVtcG99O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ2FscGhhJyAmJiB0b2tlbi50b2tlbiA9PT0gJ0MnKVx0IHsgLy8gZWl0aGVyIHR5cGUgMiBvciB0eXBlIDNcblx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHRocm93IFwiTWlzc2luZyB0ZW1wbyBhZnRlciBDIGluIFE6IGZpZWxkXCI7XG5cdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdGlmICh0b2tlbi50eXBlID09PSAncHVuY3QnICYmIHRva2VuLnRva2VuID09PSAnPScpIHtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgdHlwZSAyIGZvcm1hdC4gVGhlIGR1cmF0aW9uIGlzIGFuIGltcGxpZWQgMVxuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB0aHJvdyBcIk1pc3NpbmcgdGVtcG8gYWZ0ZXIgPSBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdudW1iZXInKSB0aHJvdyBcIkV4cGVjdGVkIG51bWJlciBhZnRlciA9IGluIFE6IGZpZWxkXCI7XG5cdFx0XHRcdFx0dGVtcG8uZHVyYXRpb24gPSBbMV07XG5cdFx0XHRcdFx0dGVtcG8uYnBtID0gcGFyc2VJbnQodG9rZW4udG9rZW4pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHR5cGUgMyBmb3JtYXQuXG5cdFx0XHRcdFx0dGVtcG8uZHVyYXRpb24gPSBbcGFyc2VJbnQodG9rZW4udG9rZW4pXTtcblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgdGhyb3cgXCJNaXNzaW5nID0gYWZ0ZXIgZHVyYXRpb24gaW4gUTogZmllbGRcIjtcblx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2tlbi50eXBlICE9PSAncHVuY3QnIHx8IHRva2VuLnRva2VuICE9PSAnPScpIHRocm93IFwiRXhwZWN0ZWQgPSBhZnRlciBkdXJhdGlvbiBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB0aHJvdyBcIk1pc3NpbmcgdGVtcG8gYWZ0ZXIgPSBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdudW1iZXInKSB0aHJvdyBcIkV4cGVjdGVkIG51bWJlciBhZnRlciA9IGluIFE6IGZpZWxkXCI7XG5cdFx0XHRcdFx0dGVtcG8uYnBtID0gcGFyc2VJbnQodG9rZW4udG9rZW4pO1xuXHRcdFx0XHR9IGVsc2UgdGhyb3cgXCJFeHBlY3RlZCBudW1iZXIgb3IgZXF1YWwgYWZ0ZXIgQyBpbiBROiBmaWVsZFwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XHQvLyBlaXRoZXIgdHlwZSAxIG9yIHR5cGUgNFxuXHRcdFx0XHR2YXIgbnVtID0gcGFyc2VJbnQodG9rZW4udG9rZW4pO1xuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSA9PT0gJ3F1b3RlJykge1xuXHRcdFx0XHRcdC8vIFRoaXMgaXMgdHlwZSAxXG5cdFx0XHRcdFx0dGVtcG8uZHVyYXRpb24gPSBbMV07XG5cdFx0XHRcdFx0dGVtcG8uYnBtID0gbnVtO1xuXHRcdFx0XHR9IGVsc2Uge1x0Ly8gVGhpcyBpcyB0eXBlIDRcblx0XHRcdFx0XHRkZWxheVNldCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdCcgJiYgdG9rZW4udG9rZW4gIT09ICcvJykgdGhyb3cgXCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdudW1iZXInKSB0aHJvdyBcIkV4cGVjdGVkIGZyYWN0aW9uIGluIFE6IGZpZWxkXCI7XG5cdFx0XHRcdFx0dmFyIGRlbiA9IHBhcnNlSW50KHRva2VuLnRva2VuKTtcblx0XHRcdFx0XHR0ZW1wby5kdXJhdGlvbiA9IFtudW0vZGVuXTtcblx0XHRcdFx0XHQvLyBXZSBnb3QgdGhlIGZpcnN0IGZyYWN0aW9uLCBrZWVwIGdldHRpbmcgbW9yZSBhcyBsb25nIGFzIHdlIGZpbmQgdGhlbS5cblx0XHRcdFx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDAgICYmIHRva2Vuc1swXS50b2tlbiAhPT0gJz0nICYmIHRva2Vuc1swXS50eXBlICE9PSAncXVvdGUnKSB7XG5cdFx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdudW1iZXInKSB0aHJvdyBcIkV4cGVjdGVkIGZyYWN0aW9uIGluIFE6IGZpZWxkXCI7XG5cdFx0XHRcdFx0XHRudW0gPSBwYXJzZUludCh0b2tlbi50b2tlbik7XG5cdFx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdCcgJiYgdG9rZW4udG9rZW4gIT09ICcvJykgdGhyb3cgXCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRcdGlmICh0b2tlbi50eXBlICE9PSAnbnVtYmVyJykgdGhyb3cgXCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdFx0ZGVuID0gcGFyc2VJbnQodG9rZW4udG9rZW4pO1xuXHRcdFx0XHRcdFx0dGVtcG8uZHVyYXRpb24ucHVzaChudW0vZGVuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW4udHlwZSAhPT0gJ3B1bmN0JyAmJiB0b2tlbi50b2tlbiAhPT0gJz0nKSB0aHJvdyBcIkV4cGVjdGVkID0gaW4gUTogZmllbGRcIjtcblx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2tlbi50eXBlICE9PSAnbnVtYmVyJykgdGhyb3cgXCJFeHBlY3RlZCB0ZW1wbyBpbiBROiBmaWVsZFwiO1xuXHRcdFx0XHRcdHRlbXBvLmJwbSA9IHBhcnNlSW50KHRva2VuLnRva2VuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHRocm93IFwiVW5rbm93biB2YWx1ZSBpbiBROiBmaWVsZFwiO1xuXHRcdFx0aWYgKHRva2Vucy5sZW5ndGggIT09IDApIHtcblx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0aWYgKHRva2VuLnR5cGUgPT09ICdxdW90ZScpIHtcblx0XHRcdFx0XHR0ZW1wby5wb3N0U3RyaW5nID0gdG9rZW4udG9rZW47XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCAhPT0gMCkgdGhyb3cgXCJVbmV4cGVjdGVkIHN0cmluZyBhdCBlbmQgb2YgUTogZmllbGRcIjtcblx0XHRcdH1cblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLnByaW50VGVtcG8gPT09IGZhbHNlKVxuXHRcdFx0XHR0ZW1wby5zdXBwcmVzcyA9IHRydWU7XG5cdFx0XHRyZXR1cm4ge3R5cGU6IGRlbGF5U2V0PydkZWxheVNldCc6J2ltbWVkaWF0ZScsIHRlbXBvOiB0ZW1wb307XG5cdFx0fSBjYXRjaCAobXNnKSB7XG5cdFx0XHR3YXJuKG1zZywgbGluZSwgc3RhcnQpO1xuXHRcdFx0cmV0dXJuIHt0eXBlOiAnbm9uZSd9O1xuXHRcdH1cblx0fTtcblxuXHR0aGlzLmxldHRlcl90b19pbmxpbmVfaGVhZGVyID0gZnVuY3Rpb24obGluZSwgaSlcblx0e1xuXHRcdHZhciB3cyA9IHRva2VuaXplci5lYXRXaGl0ZVNwYWNlKGxpbmUsIGkpO1xuXHRcdGkgKz13cztcblx0XHRpZiAobGluZS5sZW5ndGggPj0gaSs1ICYmIGxpbmUuY2hhckF0KGkpID09PSAnWycgJiYgbGluZS5jaGFyQXQoaSsyKSA9PT0gJzonKSB7XG5cdFx0XHR2YXIgZSA9IGxpbmUuaW5kZXhPZignXScsIGkpO1xuXHRcdFx0dmFyIHN0YXJ0Q2hhciA9IG11bHRpbGluZVZhcnMuaUNoYXIgKyBpO1xuXHRcdFx0dmFyIGVuZENoYXIgPSBtdWx0aWxpbmVWYXJzLmlDaGFyICsgZSArIDE7XG5cdFx0XHRzd2l0Y2gobGluZS5zdWJzdHJpbmcoaSwgaSszKSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSBcIltJOlwiOlxuXHRcdFx0XHRcdHZhciBlcnIgPSBwYXJzZURpcmVjdGl2ZS5hZGREaXJlY3RpdmUobGluZS5zdWJzdHJpbmcoaSszLCBlKSk7XG5cdFx0XHRcdFx0aWYgKGVycikgd2FybihlcnIsIGxpbmUsIGkpO1xuXHRcdFx0XHRcdHJldHVybiBbIGUtaSsxK3dzIF07XG5cdFx0XHRcdGNhc2UgXCJbTTpcIjpcblx0XHRcdFx0XHR2YXIgbWV0ZXIgPSB0aGlzLnNldE1ldGVyKGxpbmUuc3Vic3RyaW5nKGkrMywgZSkpO1xuXHRcdFx0XHRcdGlmICh0dW5lLmhhc0JlZ2luTXVzaWMoKSAmJiBtZXRlcilcblx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kU3RhcnRpbmdFbGVtZW50KCdtZXRlcicsIHN0YXJ0Q2hhciwgZW5kQ2hhciwgbWV0ZXIpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMubWV0ZXIgPSBtZXRlcjtcblx0XHRcdFx0XHRyZXR1cm4gWyBlLWkrMSt3cyBdO1xuXHRcdFx0XHRjYXNlIFwiW0s6XCI6XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHBhcnNlS2V5Vm9pY2UucGFyc2VLZXkobGluZS5zdWJzdHJpbmcoaSszLCBlKSk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdC5mb3VuZENsZWYgJiYgdHVuZS5oYXNCZWdpbk11c2ljKCkpXG5cdFx0XHRcdFx0XHR0dW5lLmFwcGVuZFN0YXJ0aW5nRWxlbWVudCgnY2xlZicsIHN0YXJ0Q2hhciwgZW5kQ2hhciwgbXVsdGlsaW5lVmFycy5jbGVmKTtcblx0XHRcdFx0XHRpZiAocmVzdWx0LmZvdW5kS2V5ICYmIHR1bmUuaGFzQmVnaW5NdXNpYygpKVxuXHRcdFx0XHRcdFx0dHVuZS5hcHBlbmRTdGFydGluZ0VsZW1lbnQoJ2tleScsIHN0YXJ0Q2hhciwgZW5kQ2hhciwgcGFyc2VLZXlWb2ljZS5maXhLZXkobXVsdGlsaW5lVmFycy5jbGVmLCBtdWx0aWxpbmVWYXJzLmtleSkpO1xuXHRcdFx0XHRcdHJldHVybiBbIGUtaSsxK3dzIF07XG5cdFx0XHRcdGNhc2UgXCJbUDpcIjpcblx0XHRcdFx0XHRpZiAodHVuZS5saW5lcy5sZW5ndGggPD0gdHVuZS5saW5lTnVtKVxuXHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5wYXJ0Rm9yTmV4dExpbmUgPSB7IHRpdGxlOiBsaW5lLnN1YnN0cmluZyhpKzMsIGUpLCBzdGFydENoYXI6IHN0YXJ0Q2hhciwgZW5kQ2hhcjogZW5kQ2hhciB9O1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kRWxlbWVudCgncGFydCcsIHN0YXJ0Q2hhciwgZW5kQ2hhciwge3RpdGxlOiBsaW5lLnN1YnN0cmluZyhpKzMsIGUpfSk7XG5cdFx0XHRcdFx0cmV0dXJuIFsgZS1pKzErd3MgXTtcblx0XHRcdFx0Y2FzZSBcIltMOlwiOlxuXHRcdFx0XHRcdHRoaXMuc2V0RGVmYXVsdExlbmd0aChsaW5lLCBpKzMsIGUpO1xuXHRcdFx0XHRcdHJldHVybiBbIGUtaSsxK3dzIF07XG5cdFx0XHRcdGNhc2UgXCJbUTpcIjpcblx0XHRcdFx0XHRpZiAoZSA+IDApIHtcblx0XHRcdFx0XHRcdHZhciB0ZW1wbyA9IHRoaXMuc2V0VGVtcG8obGluZSwgaSszLCBlKTtcblx0XHRcdFx0XHRcdGlmICh0ZW1wby50eXBlID09PSAnZGVsYXlTZXQnKSB0dW5lLmFwcGVuZEVsZW1lbnQoJ3RlbXBvJywgc3RhcnRDaGFyLCBlbmRDaGFyLCB0aGlzLmNhbGNUZW1wbyh0ZW1wby50ZW1wbykpO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodGVtcG8udHlwZSA9PT0gJ2ltbWVkaWF0ZScpIHR1bmUuYXBwZW5kRWxlbWVudCgndGVtcG8nLCBzdGFydENoYXIsIGVuZENoYXIsIHRlbXBvLnRlbXBvKTtcblx0XHRcdFx0XHRcdHJldHVybiBbIGUtaSsxK3dzLCBsaW5lLmNoYXJBdChpKzEpLCBsaW5lLnN1YnN0cmluZyhpKzMsIGUpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJbVjpcIjpcblx0XHRcdFx0XHRpZiAoZSA+IDApIHtcblx0XHRcdFx0XHRcdHBhcnNlS2V5Vm9pY2UucGFyc2VWb2ljZShsaW5lLCBpKzMsIGUpO1xuXHRcdFx0XHRcdFx0Ly9zdGFydE5ld0xpbmUoKTtcblx0XHRcdFx0XHRcdHJldHVybiBbIGUtaSsxK3dzLCBsaW5lLmNoYXJBdChpKzEpLCBsaW5lLnN1YnN0cmluZyhpKzMsIGUpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBUT0RPOiBjb21wbGFpbiBhYm91dCB1bmhhbmRsZWQgaGVhZGVyXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBbIDAgXTtcblx0fTtcblxuXHR0aGlzLmxldHRlcl90b19ib2R5X2hlYWRlciA9IGZ1bmN0aW9uKGxpbmUsIGkpXG5cdHtcblx0XHRpZiAobGluZS5sZW5ndGggPj0gaSszKSB7XG5cdFx0XHRzd2l0Y2gobGluZS5zdWJzdHJpbmcoaSwgaSsyKSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSBcIkk6XCI6XG5cdFx0XHRcdFx0dmFyIGVyciA9IHBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZShsaW5lLnN1YnN0cmluZyhpKzIpKTtcblx0XHRcdFx0XHRpZiAoZXJyKSB3YXJuKGVyciwgbGluZSwgaSk7XG5cdFx0XHRcdFx0cmV0dXJuIFsgbGluZS5sZW5ndGggXTtcblx0XHRcdFx0Y2FzZSBcIk06XCI6XG5cdFx0XHRcdFx0dmFyIG1ldGVyID0gdGhpcy5zZXRNZXRlcihsaW5lLnN1YnN0cmluZyhpKzIpKTtcblx0XHRcdFx0XHRpZiAodHVuZS5oYXNCZWdpbk11c2ljKCkgJiYgbWV0ZXIpXG5cdFx0XHRcdFx0XHR0dW5lLmFwcGVuZFN0YXJ0aW5nRWxlbWVudCgnbWV0ZXInLCBtdWx0aWxpbmVWYXJzLmlDaGFyICsgaSwgbXVsdGlsaW5lVmFycy5pQ2hhciArIGxpbmUubGVuZ3RoLCBtZXRlcik7XG5cdFx0XHRcdFx0cmV0dXJuIFsgbGluZS5sZW5ndGggXTtcblx0XHRcdFx0Y2FzZSBcIks6XCI6XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHBhcnNlS2V5Vm9pY2UucGFyc2VLZXkobGluZS5zdWJzdHJpbmcoaSsyKSk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdC5mb3VuZENsZWYgJiYgdHVuZS5oYXNCZWdpbk11c2ljKCkpXG5cdFx0XHRcdFx0XHR0dW5lLmFwcGVuZFN0YXJ0aW5nRWxlbWVudCgnY2xlZicsIG11bHRpbGluZVZhcnMuaUNoYXIgKyBpLCBtdWx0aWxpbmVWYXJzLmlDaGFyICsgbGluZS5sZW5ndGgsIG11bHRpbGluZVZhcnMuY2xlZik7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdC5mb3VuZEtleSAmJiB0dW5lLmhhc0JlZ2luTXVzaWMoKSlcblx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kU3RhcnRpbmdFbGVtZW50KCdrZXknLCBtdWx0aWxpbmVWYXJzLmlDaGFyICsgaSwgbXVsdGlsaW5lVmFycy5pQ2hhciArIGxpbmUubGVuZ3RoLCBwYXJzZUtleVZvaWNlLmZpeEtleShtdWx0aWxpbmVWYXJzLmNsZWYsIG11bHRpbGluZVZhcnMua2V5KSk7XG5cdFx0XHRcdFx0cmV0dXJuIFsgbGluZS5sZW5ndGggXTtcblx0XHRcdFx0Y2FzZSBcIlA6XCI6XG5cdFx0XHRcdFx0aWYgKHR1bmUuaGFzQmVnaW5NdXNpYygpKVxuXHRcdFx0XHRcdFx0dHVuZS5hcHBlbmRFbGVtZW50KCdwYXJ0JywgbXVsdGlsaW5lVmFycy5pQ2hhciArIGksIG11bHRpbGluZVZhcnMuaUNoYXIgKyBsaW5lLmxlbmd0aCwge3RpdGxlOiBsaW5lLnN1YnN0cmluZyhpKzIpfSk7XG5cdFx0XHRcdFx0cmV0dXJuIFsgbGluZS5sZW5ndGggXTtcblx0XHRcdFx0Y2FzZSBcIkw6XCI6XG5cdFx0XHRcdFx0dGhpcy5zZXREZWZhdWx0TGVuZ3RoKGxpbmUsIGkrMiwgbGluZS5sZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVybiBbIGxpbmUubGVuZ3RoIF07XG5cdFx0XHRcdGNhc2UgXCJROlwiOlxuXHRcdFx0XHRcdHZhciBlID0gbGluZS5pbmRleE9mKCdcXHgxMicsIGkrMik7XG5cdFx0XHRcdFx0aWYgKGUgPT09IC0xKSBlID0gbGluZS5sZW5ndGg7XG5cdFx0XHRcdFx0dmFyIHRlbXBvID0gdGhpcy5zZXRUZW1wbyhsaW5lLCBpKzIsIGUpO1xuXHRcdFx0XHRcdGlmICh0ZW1wby50eXBlID09PSAnZGVsYXlTZXQnKSB0dW5lLmFwcGVuZEVsZW1lbnQoJ3RlbXBvJywgbXVsdGlsaW5lVmFycy5pQ2hhciArIGksIG11bHRpbGluZVZhcnMuaUNoYXIgKyBsaW5lLmxlbmd0aCwgdGhpcy5jYWxjVGVtcG8odGVtcG8udGVtcG8pKTtcblx0XHRcdFx0XHRlbHNlIGlmICh0ZW1wby50eXBlID09PSAnaW1tZWRpYXRlJykgdHVuZS5hcHBlbmRFbGVtZW50KCd0ZW1wbycsIG11bHRpbGluZVZhcnMuaUNoYXIgKyBpLCBtdWx0aWxpbmVWYXJzLmlDaGFyICsgbGluZS5sZW5ndGgsIHRlbXBvLnRlbXBvKTtcblx0XHRcdFx0cmV0dXJuIFsgZSwgbGluZS5jaGFyQXQoaSksIHBhcnNlQ29tbW9uLnN0cmlwKGxpbmUuc3Vic3RyaW5nKGkrMikpXTtcblx0XHRcdFx0Y2FzZSBcIlY6XCI6XG5cdFx0XHRcdFx0cGFyc2VLZXlWb2ljZS5wYXJzZVZvaWNlKGxpbmUsIGkrMiwgbGluZS5sZW5ndGgpO1xuLy9cdFx0XHRcdFx0XHRzdGFydE5ld0xpbmUoKTtcblx0XHRcdFx0XHRyZXR1cm4gWyBsaW5lLmxlbmd0aCwgbGluZS5jaGFyQXQoaSksIHBhcnNlQ29tbW9uLnN0cmlwKGxpbmUuc3Vic3RyaW5nKGkrMikpXTtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBUT0RPOiBjb21wbGFpbiBhYm91dCB1bmhhbmRsZWQgaGVhZGVyXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBbIDAgXTtcblx0fTtcblxuXHR2YXIgbWV0YVRleHRIZWFkZXJzID0ge1xuXHRcdEE6ICdhdXRob3InLFxuXHRcdEI6ICdib29rJyxcblx0XHRDOiAnY29tcG9zZXInLFxuXHRcdEQ6ICdkaXNjb2dyYXBoeScsXG5cdFx0RjogJ3VybCcsXG5cdFx0RzogJ2dyb3VwJyxcblx0XHRJOiAnaW5zdHJ1Y3Rpb24nLFxuXHRcdE46ICdub3RlcycsXG5cdFx0TzogJ29yaWdpbicsXG5cdFx0UjogJ3JoeXRobScsXG5cdFx0UzogJ3NvdXJjZScsXG5cdFx0VzogJ3VuYWxpZ25lZFdvcmRzJyxcblx0XHRaOiAndHJhbnNjcmlwdGlvbidcblx0fTtcblxuXHR0aGlzLnBhcnNlSGVhZGVyID0gZnVuY3Rpb24obGluZSkge1xuXHRcdGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKGxpbmUsICclJScpKSB7XG5cdFx0XHR2YXIgZXJyID0gcGFyc2VEaXJlY3RpdmUuYWRkRGlyZWN0aXZlKGxpbmUuc3Vic3RyaW5nKDIpKTtcblx0XHRcdGlmIChlcnIpIHdhcm4oZXJyLCBsaW5lLCAyKTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdFx0dmFyIGkgPSBsaW5lLmluZGV4T2YoJyUnKTtcblx0XHRpZiAoaSA+PSAwKVxuXHRcdFx0bGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpO1xuXHRcdGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xccyskLywgJycpO1xuXG5cdFx0aWYgKGxpbmUubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIHt9O1xuXG5cdFx0aWYgKGxpbmUubGVuZ3RoID49IDIpIHtcblx0XHRcdGlmIChsaW5lLmNoYXJBdCgxKSA9PT0gJzonKSB7XG5cdFx0XHRcdHZhciBuZXh0TGluZSA9IFwiXCI7XG5cdFx0XHRcdGlmIChsaW5lLmluZGV4T2YoJ1xceDEyJykgPj0gMCAmJiBsaW5lLmNoYXJBdCgwKSAhPT0gJ3cnKSB7XHQvLyB3OiBpcyB0aGUgb25seSBoZWFkZXIgZmllbGQgdGhhdCBjYW4gaGF2ZSBhIGNvbnRpbnVhdGlvbi5cblx0XHRcdFx0XHRuZXh0TGluZSA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignXFx4MTInKSsxKTtcblx0XHRcdFx0XHRsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGluZS5pbmRleE9mKCdcXHgxMicpKTtcdC8vVGhpcyBoYW5kbGVzIGEgY29udGludWF0aW9uIG1hcmsgb24gYSBoZWFkZXIgZmllbGRcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmllbGQgPSBtZXRhVGV4dEhlYWRlcnNbbGluZS5jaGFyQXQoMCldO1xuXHRcdFx0XHRpZiAoZmllbGQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmIChmaWVsZCA9PT0gJ3VuYWxpZ25lZFdvcmRzJylcblx0XHRcdFx0XHRcdHR1bmUuYWRkTWV0YVRleHRBcnJheShmaWVsZCwgcGFyc2VEaXJlY3RpdmUucGFyc2VGb250Q2hhbmdlTGluZSh0b2tlbml6ZXIudHJhbnNsYXRlU3RyaW5nKHRva2VuaXplci5zdHJpcENvbW1lbnQobGluZS5zdWJzdHJpbmcoMikpKSkpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHR1bmUuYWRkTWV0YVRleHQoZmllbGQsIHRva2VuaXplci50cmFuc2xhdGVTdHJpbmcodG9rZW5pemVyLnN0cmlwQ29tbWVudChsaW5lLnN1YnN0cmluZygyKSkpKTtcblx0XHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0Q2hhciA9IG11bHRpbGluZVZhcnMuaUNoYXI7XG5cdFx0XHRcdFx0dmFyIGVuZENoYXIgPSBzdGFydENoYXIgKyBsaW5lLmxlbmd0aDtcblx0XHRcdFx0XHRzd2l0Y2gobGluZS5jaGFyQXQoMCkpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2FzZSAgJ0gnOlxuXHRcdFx0XHRcdFx0XHR0dW5lLmFkZE1ldGFUZXh0KFwiaGlzdG9yeVwiLCB0b2tlbml6ZXIudHJhbnNsYXRlU3RyaW5nKHRva2VuaXplci5zdHJpcENvbW1lbnQobGluZS5zdWJzdHJpbmcoMikpKSk7XG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuaXNfaW5faGlzdG9yeSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAgJ0snOlxuXHRcdFx0XHRcdFx0XHQvLyBzaW5jZSB0aGUga2V5IGlzIHRoZSBsYXN0IHRoaW5nIHRoYXQgY2FuIGhhcHBlbiBpbiB0aGUgaGVhZGVyLCB3ZSBjYW4gcmVzb2x2ZSB0aGUgdGVtcG8gbm93XG5cdFx0XHRcdFx0XHRcdHRoaXMucmVzb2x2ZVRlbXBvKCk7XG5cdFx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBwYXJzZUtleVZvaWNlLnBhcnNlS2V5KGxpbmUuc3Vic3RyaW5nKDIpKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFtdWx0aWxpbmVWYXJzLmlzX2luX2hlYWRlciAmJiB0dW5lLmhhc0JlZ2luTXVzaWMoKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQuZm91bmRDbGVmKVxuXHRcdFx0XHRcdFx0XHRcdFx0dHVuZS5hcHBlbmRTdGFydGluZ0VsZW1lbnQoJ2NsZWYnLCBzdGFydENoYXIsIGVuZENoYXIsIG11bHRpbGluZVZhcnMuY2xlZik7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5mb3VuZEtleSlcblx0XHRcdFx0XHRcdFx0XHRcdHR1bmUuYXBwZW5kU3RhcnRpbmdFbGVtZW50KCdrZXknLCBzdGFydENoYXIsIGVuZENoYXIsIHBhcnNlS2V5Vm9pY2UuZml4S2V5KG11bHRpbGluZVZhcnMuY2xlZiwgbXVsdGlsaW5lVmFycy5rZXkpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmlzX2luX2hlYWRlciA9IGZhbHNlO1x0Ly8gVGhlIGZpcnN0IGtleSBzaWduaWZpZXMgdGhlIGVuZCBvZiB0aGUgaGVhZGVyLlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgICdMJzpcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXREZWZhdWx0TGVuZ3RoKGxpbmUsIDIsIGxpbmUubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICAnTSc6XG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMub3JpZ01ldGVyID0gbXVsdGlsaW5lVmFycy5tZXRlciA9IHRoaXMuc2V0TWV0ZXIobGluZS5zdWJzdHJpbmcoMikpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgICdQJzpcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IFRoZXJlIGlzIG1vcmUgdG8gZG8gd2l0aCBwYXJ0cywgYnV0IHRoZSB3cml0ZXIgZG9lc24ndCBjYXJlLlxuXHRcdFx0XHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5pc19pbl9oZWFkZXIpXG5cdFx0XHRcdFx0XHRcdFx0dHVuZS5hZGRNZXRhVGV4dChcInBhcnRPcmRlclwiLCB0b2tlbml6ZXIudHJhbnNsYXRlU3RyaW5nKHRva2VuaXplci5zdHJpcENvbW1lbnQobGluZS5zdWJzdHJpbmcoMikpKSk7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnBhcnRGb3JOZXh0TGluZSA9IHsgdGl0bGU6IHRva2VuaXplci50cmFuc2xhdGVTdHJpbmcodG9rZW5pemVyLnN0cmlwQ29tbWVudChsaW5lLnN1YnN0cmluZygyKSkpLCBzdGFydENoYXI6IHN0YXJ0Q2hhciwgZW5kQ2hhcjogZW5kQ2hhcn07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAgJ1EnOlxuXHRcdFx0XHRcdFx0XHR2YXIgdGVtcG8gPSB0aGlzLnNldFRlbXBvKGxpbmUsIDIsIGxpbmUubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRlbXBvLnR5cGUgPT09ICdkZWxheVNldCcpIG11bHRpbGluZVZhcnMudGVtcG8gPSB0ZW1wby50ZW1wbztcblx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGVtcG8udHlwZSA9PT0gJ2ltbWVkaWF0ZScpIHR1bmUubWV0YVRleHQudGVtcG8gPSB0ZW1wby50ZW1wbztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICAnVCc6XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VGl0bGUobGluZS5zdWJzdHJpbmcoMikpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1UnOlxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZFVzZXJEZWZpbml0aW9uKGxpbmUsIDIsIGxpbmUubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICAnVic6XG5cdFx0XHRcdFx0XHRcdHBhcnNlS2V5Vm9pY2UucGFyc2VWb2ljZShsaW5lLCAyLCBsaW5lLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdGlmICghbXVsdGlsaW5lVmFycy5pc19pbl9oZWFkZXIpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtuZXdsaW5lOiB0cnVlfTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICAncyc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7c3ltYm9sczogdHJ1ZX07XG5cdFx0XHRcdFx0XHRjYXNlICAndyc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7d29yZHM6IHRydWV9O1xuXHRcdFx0XHRcdFx0Y2FzZSAnWCc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnRSc6XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0d2FybihcIklnbm9yZWQgaGVhZGVyXCIsIGxpbmUsIDApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8vIEl0IHdhc24ndCBhIHJlY29nbml6ZWQgaGVhZGVyIHZhbHVlLCBzbyBwYXJzZSBpdCBhcyBtdXNpYy5cblx0XHRcdFx0XHRcdFx0aWYgKG5leHRMaW5lLmxlbmd0aClcblx0XHRcdFx0XHRcdFx0XHRuZXh0TGluZSA9IFwiXFx4MTJcIiArIG5leHRMaW5lO1xuXHRcdFx0XHRcdFx0XHQvL3BhcnNlUmVndWxhck11c2ljTGluZShsaW5lK25leHRMaW5lKTtcblx0XHRcdFx0XHRcdFx0Ly9uZXh0TGluZSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7cmVndWxhcjogdHJ1ZSwgc3RyOiBsaW5lK25leHRMaW5lfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5leHRMaW5lLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0cmV0dXJuIHtyZWN1cnNlOiB0cnVlLCBzdHI6IG5leHRMaW5lfTtcblx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdvdCB0aGlzIGZhciwgd2UgaGF2ZSBhIHJlZ3VsYXIgbGluZSBvZiBtdWxzaWNcblx0XHRyZXR1cm4ge3JlZ3VsYXI6IHRydWUsIHN0cjogbGluZX07XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlSGVhZGVyO1xuIiwiLypnbG9iYWwgd2luZG93ICovXG5cbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4vYWJjX2NvbW1vbicpO1xudmFyIHBhcnNlRGlyZWN0aXZlID0gcmVxdWlyZSgnLi9hYmNfcGFyc2VfZGlyZWN0aXZlJyk7XG52YXIgdHJhbnNwb3NlID0gcmVxdWlyZSgnLi9hYmNfdHJhbnNwb3NlJyk7XG5cbnZhciBwYXJzZUtleVZvaWNlID0ge307XG5cbihmdW5jdGlvbigpIHtcblx0dmFyIHRva2VuaXplcjtcblx0dmFyIHdhcm47XG5cdHZhciBtdWx0aWxpbmVWYXJzO1xuXHR2YXIgdHVuZTtcblx0cGFyc2VLZXlWb2ljZS5pbml0aWFsaXplID0gZnVuY3Rpb24odG9rZW5pemVyXywgd2Fybl8sIG11bHRpbGluZVZhcnNfLCB0dW5lXykge1xuXHRcdHRva2VuaXplciA9IHRva2VuaXplcl87XG5cdFx0d2FybiA9IHdhcm5fO1xuXHRcdG11bHRpbGluZVZhcnMgPSBtdWx0aWxpbmVWYXJzXztcblx0XHR0dW5lID0gdHVuZV87XG5cdH07XG5cblx0cGFyc2VLZXlWb2ljZS5zdGFuZGFyZEtleSA9IGZ1bmN0aW9uKGtleU5hbWUsIHJvb3QsIGFjYywgbG9jYWxUcmFuc3Bvc2UpIHtcblx0XHR2YXIga2V5MXNoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ2YnfTtcblx0XHR2YXIga2V5MnNoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ2MnfTtcblx0XHR2YXIga2V5M3NoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ2cnfTtcblx0XHR2YXIga2V5NHNoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ2QnfTtcblx0XHR2YXIga2V5NXNoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ0EnfTtcblx0XHR2YXIga2V5NnNoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ2UnfTtcblx0XHR2YXIga2V5N3NoYXJwID0ge2FjYzogJ3NoYXJwJywgbm90ZTogJ0InfTtcblx0XHR2YXIga2V5MWZsYXQgPSB7YWNjOiAnZmxhdCcsIG5vdGU6ICdCJ307XG5cdFx0dmFyIGtleTJmbGF0ID0ge2FjYzogJ2ZsYXQnLCBub3RlOiAnZSd9O1xuXHRcdHZhciBrZXkzZmxhdCA9IHthY2M6ICdmbGF0Jywgbm90ZTogJ0EnfTtcblx0XHR2YXIga2V5NGZsYXQgPSB7YWNjOiAnZmxhdCcsIG5vdGU6ICdkJ307XG5cdFx0dmFyIGtleTVmbGF0ID0ge2FjYzogJ2ZsYXQnLCBub3RlOiAnRyd9O1xuXHRcdHZhciBrZXk2ZmxhdCA9IHthY2M6ICdmbGF0Jywgbm90ZTogJ2MnfTtcblx0XHR2YXIga2V5N2ZsYXQgPSB7YWNjOiAnZmxhdCcsIG5vdGU6ICdGJ307XG5cblx0XHR2YXIga2V5cyA9IHtcblx0XHRcdCdDIyc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwLCBrZXk1c2hhcnAsIGtleTZzaGFycCwga2V5N3NoYXJwIF0sXG5cdFx0XHQnQSNtJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCwga2V5NnNoYXJwLCBrZXk3c2hhcnAgXSxcblx0XHRcdCdHI01peCc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwLCBrZXk1c2hhcnAsIGtleTZzaGFycCwga2V5N3NoYXJwIF0sXG5cdFx0XHQnRCNEb3InOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAsIGtleTdzaGFycCBdLFxuXHRcdFx0J0UjUGhyJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCwga2V5NnNoYXJwLCBrZXk3c2hhcnAgXSxcblx0XHRcdCdGI0x5ZCc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwLCBrZXk1c2hhcnAsIGtleTZzaGFycCwga2V5N3NoYXJwIF0sXG5cdFx0XHQnQiNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAsIGtleTdzaGFycCBdLFxuXG5cdFx0XHQnRiMnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAgXSxcblx0XHRcdCdEI20nOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAgXSxcblx0XHRcdCdDI01peCc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwLCBrZXk1c2hhcnAsIGtleTZzaGFycCBdLFxuXHRcdFx0J0cjRG9yJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCwga2V5NnNoYXJwIF0sXG5cdFx0XHQnQSNQaHInOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAgXSxcblx0XHRcdCdCTHlkJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCwga2V5NnNoYXJwIF0sXG5cdFx0XHQnRSNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAgXSxcblxuXHRcdFx0J0InOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwIF0sXG5cdFx0XHQnRyNtJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCBdLFxuXHRcdFx0J0YjTWl4JzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCBdLFxuXHRcdFx0J0MjRG9yJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCBdLFxuXHRcdFx0J0QjUGhyJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAsIGtleTVzaGFycCBdLFxuXHRcdFx0J0VMeWQnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwIF0sXG5cdFx0XHQnQSNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwIF0sXG5cblx0XHRcdCdFJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAgXSxcblx0XHRcdCdDI20nOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCBdLFxuXHRcdFx0J0JNaXgnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCBdLFxuXHRcdFx0J0YjRG9yJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwLCBrZXk0c2hhcnAgXSxcblx0XHRcdCdHI1Bocic6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwIF0sXG5cdFx0XHQnQUx5ZCc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCwga2V5NHNoYXJwIF0sXG5cdFx0XHQnRCNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCBdLFxuXG5cdFx0XHQnQSc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCBdLFxuXHRcdFx0J0YjbSc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAsIGtleTNzaGFycCBdLFxuXHRcdFx0J0VNaXgnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAgXSxcblx0XHRcdCdCRG9yJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwIF0sXG5cdFx0XHQnQyNQaHInOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAgXSxcblx0XHRcdCdETHlkJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCwga2V5M3NoYXJwIF0sXG5cdFx0XHQnRyNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAgXSxcblxuXHRcdFx0J0QnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwIF0sXG5cdFx0XHQnQm0nOiBbIGtleTFzaGFycCwga2V5MnNoYXJwIF0sXG5cdFx0XHQnQU1peCc6IFsga2V5MXNoYXJwLCBrZXkyc2hhcnAgXSxcblx0XHRcdCdFRG9yJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCBdLFxuXHRcdFx0J0YjUGhyJzogWyBrZXkxc2hhcnAsIGtleTJzaGFycCBdLFxuXHRcdFx0J0dMeWQnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwIF0sXG5cdFx0XHQnQyNMb2MnOiBbIGtleTFzaGFycCwga2V5MnNoYXJwIF0sXG5cblx0XHRcdCdHJzogWyBrZXkxc2hhcnAgXSxcblx0XHRcdCdFbSc6IFsga2V5MXNoYXJwIF0sXG5cdFx0XHQnRE1peCc6IFsga2V5MXNoYXJwIF0sXG5cdFx0XHQnQURvcic6IFsga2V5MXNoYXJwIF0sXG5cdFx0XHQnQlBocic6IFsga2V5MXNoYXJwIF0sXG5cdFx0XHQnQ0x5ZCc6IFsga2V5MXNoYXJwIF0sXG5cdFx0XHQnRiNMb2MnOiBbIGtleTFzaGFycCBdLFxuXG5cdFx0XHQnQyc6IFtdLFxuXHRcdFx0J0FtJzogW10sXG5cdFx0XHQnR01peCc6IFtdLFxuXHRcdFx0J0REb3InOiBbXSxcblx0XHRcdCdFUGhyJzogW10sXG5cdFx0XHQnRkx5ZCc6IFtdLFxuXHRcdFx0J0JMb2MnOiBbXSxcblxuXHRcdFx0J0YnOiBbIGtleTFmbGF0IF0sXG5cdFx0XHQnRG0nOiBbIGtleTFmbGF0IF0sXG5cdFx0XHQnQ01peCc6IFsga2V5MWZsYXQgXSxcblx0XHRcdCdHRG9yJzogWyBrZXkxZmxhdCBdLFxuXHRcdFx0J0FQaHInOiBbIGtleTFmbGF0IF0sXG5cdFx0XHQnQmJMeWQnOiBbIGtleTFmbGF0IF0sXG5cdFx0XHQnRUxvYyc6IFsga2V5MWZsYXQgXSxcblxuXHRcdFx0J0JiJzogWyBrZXkxZmxhdCwga2V5MmZsYXQgXSxcblx0XHRcdCdHbSc6IFsga2V5MWZsYXQsIGtleTJmbGF0IF0sXG5cdFx0XHQnRk1peCc6IFsga2V5MWZsYXQsIGtleTJmbGF0IF0sXG5cdFx0XHQnQ0Rvcic6IFsga2V5MWZsYXQsIGtleTJmbGF0IF0sXG5cdFx0XHQnRFBocic6IFsga2V5MWZsYXQsIGtleTJmbGF0IF0sXG5cdFx0XHQnRWJMeWQnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCBdLFxuXHRcdFx0J0FMb2MnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCBdLFxuXG5cdFx0XHQnRWInOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQgXSxcblx0XHRcdCdDbSc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCBdLFxuXHRcdFx0J0JiTWl4JzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0IF0sXG5cdFx0XHQnRkRvcic6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCBdLFxuXHRcdFx0J0dQaHInOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQgXSxcblx0XHRcdCdBYkx5ZCc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCBdLFxuXHRcdFx0J0RMb2MnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQgXSxcblxuXHRcdFx0J0FiJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCBdLFxuXHRcdFx0J0ZtJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCBdLFxuXHRcdFx0J0ViTWl4JzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCBdLFxuXHRcdFx0J0JiRG9yJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCBdLFxuXHRcdFx0J0NQaHInOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0IF0sXG5cdFx0XHQnRGJMeWQnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0IF0sXG5cdFx0XHQnR0xvYyc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQgXSxcblxuXHRcdFx0J0RiJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCwga2V5NWZsYXQgXSxcblx0XHRcdCdCYm0nOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCBdLFxuXHRcdFx0J0FiTWl4JzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCwga2V5NWZsYXQgXSxcblx0XHRcdCdFYkRvcic6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0IF0sXG5cdFx0XHQnRlBocic6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0IF0sXG5cdFx0XHQnR2JMeWQnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCBdLFxuXHRcdFx0J0NMb2MnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCBdLFxuXG5cdFx0XHQnR2InOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCwga2V5NmZsYXQgXSxcblx0XHRcdCdFYm0nOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCwga2V5NmZsYXQgXSxcblx0XHRcdCdEYk1peCc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCBdLFxuXHRcdFx0J0FiRG9yJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCwga2V5NWZsYXQsIGtleTZmbGF0IF0sXG5cdFx0XHQnQmJQaHInOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCwga2V5NmZsYXQgXSxcblx0XHRcdCdDYkx5ZCc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCBdLFxuXHRcdFx0J0ZMb2MnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQsIGtleTRmbGF0LCBrZXk1ZmxhdCwga2V5NmZsYXQgXSxcblxuXHRcdFx0J0NiJzogWyBrZXkxZmxhdCwga2V5MmZsYXQsIGtleTNmbGF0LCBrZXk0ZmxhdCwga2V5NWZsYXQsIGtleTZmbGF0LCBrZXk3ZmxhdCBdLFxuXHRcdFx0J0FibSc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblx0XHRcdCdHYk1peCc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblx0XHRcdCdEYkRvcic6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblx0XHRcdCdFYlBocic6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblx0XHRcdCdGYkx5ZCc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblx0XHRcdCdCYkxvYyc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQsIGtleTVmbGF0LCBrZXk2ZmxhdCwga2V5N2ZsYXQgXSxcblxuXHRcdFx0Ly8gVGhlIGZvbGxvd2luZyBhcmUgbm90IGluIHRoZSAyLjAgc3BlYywgYnV0IHNlZW0gbm9ybWFsIGVub3VnaC5cblx0XHRcdC8vIFRPRE8tUEVSOiBUaGVzZSBTT1VORCB0aGUgc2FtZSBhcyB3aGF0J3Mgd3JpdHRlbiwgYnV0IHRoZXkgYXJlbid0IHJpZ2h0XG5cdFx0XHQnQSMnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCBdLFxuXHRcdFx0J0IjJzogW10sXG5cdFx0XHQnRCMnOiBbIGtleTFmbGF0LCBrZXkyZmxhdCwga2V5M2ZsYXQgXSxcblx0XHRcdCdFIyc6IFsga2V5MWZsYXQgXSxcblx0XHRcdCdHIyc6IFsga2V5MWZsYXQsIGtleTJmbGF0LCBrZXkzZmxhdCwga2V5NGZsYXQgXSxcblx0XHRcdCdHYm0nOiBbIGtleTFzaGFycCwga2V5MnNoYXJwLCBrZXkzc2hhcnAsIGtleTRzaGFycCwga2V5NXNoYXJwLCBrZXk2c2hhcnAsIGtleTdzaGFycCBdXG5cdFx0fTtcblxuXHRcdHJldHVybiB0cmFuc3Bvc2Uua2V5U2lnbmF0dXJlKG11bHRpbGluZVZhcnMsIGtleXMsIGtleU5hbWUsIHJvb3QsIGFjYywgbG9jYWxUcmFuc3Bvc2UpO1xuXHR9O1xuXG5cdHZhciBjbGVmTGluZXMgPSB7XG5cdFx0J3RyZWJsZSc6IHsgY2xlZjogJ3RyZWJsZScsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlKzgnOiB7IGNsZWY6ICd0cmVibGUrOCcsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlLTgnOiB7IGNsZWY6ICd0cmVibGUtOCcsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlXjgnOiB7IGNsZWY6ICd0cmVibGUrOCcsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlXzgnOiB7IGNsZWY6ICd0cmVibGUtOCcsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlMSc6IHsgY2xlZjogJ3RyZWJsZScsIHBpdGNoOiAyLCBtaWQ6IDIgfSxcblx0XHQndHJlYmxlMic6IHsgY2xlZjogJ3RyZWJsZScsIHBpdGNoOiA0LCBtaWQ6IDAgfSxcblx0XHQndHJlYmxlMyc6IHsgY2xlZjogJ3RyZWJsZScsIHBpdGNoOiA2LCBtaWQ6IC0yIH0sXG5cdFx0J3RyZWJsZTQnOiB7IGNsZWY6ICd0cmVibGUnLCBwaXRjaDogOCwgbWlkOiAtNCB9LFxuXHRcdCd0cmVibGU1JzogeyBjbGVmOiAndHJlYmxlJywgcGl0Y2g6IDEwLCBtaWQ6IC02IH0sXG5cdFx0J3BlcmMnOiB7IGNsZWY6ICdwZXJjJywgcGl0Y2g6IDYsIG1pZDogMCB9LFxuXHRcdCdub25lJzogeyBjbGVmOiAnbm9uZScsIG1pZDogMCB9LFxuXHRcdCdiYXNzJzogeyBjbGVmOiAnYmFzcycsIHBpdGNoOiA4LCBtaWQ6IC0xMiB9LFxuXHRcdCdiYXNzKzgnOiB7IGNsZWY6ICdiYXNzKzgnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzcy04JzogeyBjbGVmOiAnYmFzcy04JywgcGl0Y2g6IDgsIG1pZDogLTEyIH0sXG5cdFx0J2Jhc3NeOCc6IHsgY2xlZjogJ2Jhc3MrOCcsIHBpdGNoOiA4LCBtaWQ6IC0xMiB9LFxuXHRcdCdiYXNzXzgnOiB7IGNsZWY6ICdiYXNzLTgnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzcysxNic6IHsgY2xlZjogJ2Jhc3MnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzcy0xNic6IHsgY2xlZjogJ2Jhc3MnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzc14xNic6IHsgY2xlZjogJ2Jhc3MnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzc18xNic6IHsgY2xlZjogJ2Jhc3MnLCBwaXRjaDogOCwgbWlkOiAtMTIgfSxcblx0XHQnYmFzczEnOiB7IGNsZWY6ICdiYXNzJywgcGl0Y2g6IDIsIG1pZDogLTYgfSxcblx0XHQnYmFzczInOiB7IGNsZWY6ICdiYXNzJywgcGl0Y2g6IDQsIG1pZDogLTggfSxcblx0XHQnYmFzczMnOiB7IGNsZWY6ICdiYXNzJywgcGl0Y2g6IDYsIG1pZDogLTEwIH0sXG5cdFx0J2Jhc3M0JzogeyBjbGVmOiAnYmFzcycsIHBpdGNoOiA4LCBtaWQ6IC0xMiB9LFxuXHRcdCdiYXNzNSc6IHsgY2xlZjogJ2Jhc3MnLCBwaXRjaDogMTAsIG1pZDogLTE0IH0sXG5cdFx0J3Rlbm9yJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA4LCBtaWQ6IC04IH0sXG5cdFx0J3Rlbm9yMSc6IHsgY2xlZjogJ2FsdG8nLCBwaXRjaDogMiwgbWlkOiAtMiB9LFxuXHRcdCd0ZW5vcjInOiB7IGNsZWY6ICdhbHRvJywgcGl0Y2g6IDQsIG1pZDogLTQgfSxcblx0XHQndGVub3IzJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA2LCBtaWQ6IC02IH0sXG5cdFx0J3Rlbm9yNCc6IHsgY2xlZjogJ2FsdG8nLCBwaXRjaDogOCwgbWlkOiAtOCB9LFxuXHRcdCd0ZW5vcjUnOiB7IGNsZWY6ICdhbHRvJywgcGl0Y2g6IDEwLCBtaWQ6IC0xMCB9LFxuXHRcdCdhbHRvJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA2LCBtaWQ6IC02IH0sXG5cdFx0J2FsdG8xJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiAyLCBtaWQ6IC0yIH0sXG5cdFx0J2FsdG8yJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA0LCBtaWQ6IC00IH0sXG5cdFx0J2FsdG8zJzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA2LCBtaWQ6IC02IH0sXG5cdFx0J2FsdG80JzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiA4LCBtaWQ6IC04IH0sXG5cdFx0J2FsdG81JzogeyBjbGVmOiAnYWx0bycsIHBpdGNoOiAxMCwgbWlkOiAtMTAgfSxcblx0XHQnYWx0bys4JzogeyBjbGVmOiAnYWx0bys4JywgcGl0Y2g6IDYsIG1pZDogLTYgfSxcblx0XHQnYWx0by04JzogeyBjbGVmOiAnYWx0by04JywgcGl0Y2g6IDYsIG1pZDogLTYgfSxcblx0XHQnYWx0b144JzogeyBjbGVmOiAnYWx0bys4JywgcGl0Y2g6IDYsIG1pZDogLTYgfSxcblx0XHQnYWx0b184JzogeyBjbGVmOiAnYWx0by04JywgcGl0Y2g6IDYsIG1pZDogLTYgfVxuXHR9O1xuXG5cdHZhciBjYWxjTWlkZGxlID0gZnVuY3Rpb24oY2xlZiwgb2N0KSB7XG5cdFx0dmFyIHZhbHVlID0gY2xlZkxpbmVzW2NsZWZdO1xuXHRcdHZhciBtaWQgPSB2YWx1ZSA/IHZhbHVlLm1pZCA6IDA7XG5cdFx0cmV0dXJuIG1pZCtvY3Q7XG5cdH07XG5cblx0cGFyc2VLZXlWb2ljZS5maXhDbGVmID0gZnVuY3Rpb24oY2xlZikge1xuXHRcdHZhciB2YWx1ZSA9IGNsZWZMaW5lc1tjbGVmLnR5cGVdO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0Y2xlZi5jbGVmUG9zID0gdmFsdWUucGl0Y2g7XG5cdFx0XHRjbGVmLnR5cGUgPSB2YWx1ZS5jbGVmO1xuXHRcdH1cblx0fTtcblxuXHRwYXJzZUtleVZvaWNlLmRlZXBDb3B5S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHJldCA9IHsgYWNjaWRlbnRhbHM6IFtdLCByb290OiBrZXkucm9vdCwgYWNjOiBrZXkuYWNjLCBtb2RlOiBrZXkubW9kZSB9O1xuXHRcdHBhcnNlQ29tbW9uLmVhY2goa2V5LmFjY2lkZW50YWxzLCBmdW5jdGlvbihrKSB7XG5cdFx0cmV0LmFjY2lkZW50YWxzLnB1c2gocGFyc2VDb21tb24uY2xvbmUoaykpO1xuXHRcdH0pO1xuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cblx0dmFyIHBpdGNoZXMgPSB7QTogNSwgQjogNiwgQzogMCwgRDogMSwgRTogMiwgRjogMywgRzogNCwgYTogMTIsIGI6IDEzLCBjOiA3LCBkOiA4LCBlOiA5LCBmOiAxMCwgZzogMTF9O1xuXG5cdHBhcnNlS2V5Vm9pY2UuYWRkUG9zVG9LZXkgPSBmdW5jdGlvbihjbGVmLCBrZXkpIHtcblx0XHQvLyBTaGlmdCB0aGUga2V5IHNpZ25hdHVyZSBmcm9tIHRoZSB0cmVibGUgcG9zaXRpb25zIHRvIHdoYXRldmVyIHBvc2l0aW9uIGlzIG5lZWRlZCBmb3IgdGhlIGNsZWYuXG5cdFx0Ly8gVGhpcyBtYXkgcHV0IHRoZSBrZXkgc2lnbmF0dXJlIHVubmF0dXJhbGx5IGhpZ2ggb3IgbG93LCBzbyBpZiBpdCBkb2VzLCB0aGVuIHNoaWZ0IGl0LlxuXHRcdHZhciBtaWQgPSBjbGVmLnZlcnRpY2FsUG9zO1xuXHRcdHBhcnNlQ29tbW9uLmVhY2goa2V5LmFjY2lkZW50YWxzLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdHZhciBwaXRjaCA9IHBpdGNoZXNbYWNjLm5vdGVdO1xuXHRcdFx0cGl0Y2ggPSBwaXRjaCAtIG1pZDtcblx0XHRcdGFjYy52ZXJ0aWNhbFBvcyA9IHBpdGNoO1xuXHRcdH0pO1xuXHRcdGlmIChrZXkuaW1wbGllZE5hdHVyYWxzKVxuXHRcdFx0cGFyc2VDb21tb24uZWFjaChrZXkuaW1wbGllZE5hdHVyYWxzLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdFx0dmFyIHBpdGNoID0gcGl0Y2hlc1thY2Mubm90ZV07XG5cdFx0XHRcdHBpdGNoID0gcGl0Y2ggLSBtaWQ7XG5cdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyA9IHBpdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAobWlkIDwgLTEwKSB7XG5cdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGtleS5hY2NpZGVudGFscywgZnVuY3Rpb24oYWNjKSB7XG5cdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPSA3O1xuXHRcdFx0XHRpZiAoYWNjLnZlcnRpY2FsUG9zID49IDExIHx8IChhY2MudmVydGljYWxQb3MgPT09IDEwICYmIGFjYy5hY2MgPT09ICdmbGF0JykpXG5cdFx0XHRcdFx0YWNjLnZlcnRpY2FsUG9zIC09IDc7XG5cdFx0XHRcdGlmIChhY2Mubm90ZSA9PT0gJ0EnICYmIGFjYy5hY2MgPT09ICdzaGFycCcgKVxuXHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPTc7XG5cdFx0XHRcdGlmICgoYWNjLm5vdGUgPT09ICdHJyB8fCBhY2Mubm90ZSA9PT0gJ0YnKSAmJiBhY2MuYWNjID09PSAnZmxhdCcgKVxuXHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPTc7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChrZXkuaW1wbGllZE5hdHVyYWxzKVxuXHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGtleS5pbXBsaWVkTmF0dXJhbHMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPSA3O1xuXHRcdFx0XHRcdGlmIChhY2MudmVydGljYWxQb3MgPj0gMTEgfHwgKGFjYy52ZXJ0aWNhbFBvcyA9PT0gMTAgJiYgYWNjLmFjYyA9PT0gJ2ZsYXQnKSlcblx0XHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPSA3O1xuXHRcdFx0XHRcdGlmIChhY2Mubm90ZSA9PT0gJ0EnICYmIGFjYy5hY2MgPT09ICdzaGFycCcgKVxuXHRcdFx0XHRcdFx0YWNjLnZlcnRpY2FsUG9zIC09Nztcblx0XHRcdFx0XHRpZiAoKGFjYy5ub3RlID09PSAnRycgfHwgYWNjLm5vdGUgPT09ICdGJykgJiYgYWNjLmFjYyA9PT0gJ2ZsYXQnIClcblx0XHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPTc7XG5cdFx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAobWlkIDwgLTQpIHtcblx0XHRcdHBhcnNlQ29tbW9uLmVhY2goa2V5LmFjY2lkZW50YWxzLCBmdW5jdGlvbihhY2MpIHtcblx0XHRcdFx0YWNjLnZlcnRpY2FsUG9zIC09IDc7XG5cdFx0XHRcdGlmIChtaWQgPT09IC04ICYmIChhY2Mubm90ZSA9PT0gJ2YnIHx8IGFjYy5ub3RlID09PSAnZycpICYmIGFjYy5hY2MgPT09ICdzaGFycCcgKVxuXHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPTc7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChrZXkuaW1wbGllZE5hdHVyYWxzKVxuXHRcdFx0XHRwYXJzZUNvbW1vbi5lYWNoKGtleS5pbXBsaWVkTmF0dXJhbHMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRcdGFjYy52ZXJ0aWNhbFBvcyAtPSA3O1xuXHRcdFx0XHRcdGlmIChtaWQgPT09IC04ICYmIChhY2Mubm90ZSA9PT0gJ2YnIHx8IGFjYy5ub3RlID09PSAnZycpICYmIGFjYy5hY2MgPT09ICdzaGFycCcgKVxuXHRcdFx0XHRcdFx0YWNjLnZlcnRpY2FsUG9zIC09Nztcblx0XHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChtaWQgPj0gNykge1xuXHRcdFx0cGFyc2VDb21tb24uZWFjaChrZXkuYWNjaWRlbnRhbHMsIGZ1bmN0aW9uKGFjYykge1xuXHRcdFx0XHRhY2MudmVydGljYWxQb3MgKz0gNztcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGtleS5pbXBsaWVkTmF0dXJhbHMpXG5cdFx0XHRcdHBhcnNlQ29tbW9uLmVhY2goa2V5LmltcGxpZWROYXR1cmFscywgZnVuY3Rpb24oYWNjKSB7XG5cdFx0XHRcdFx0YWNjLnZlcnRpY2FsUG9zICs9IDc7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRwYXJzZUtleVZvaWNlLmZpeEtleSA9IGZ1bmN0aW9uKGNsZWYsIGtleSkge1xuXHRcdHZhciBmaXhlZEtleSA9IHBhcnNlQ29tbW9uLmNsb25lKGtleSk7XG5cdFx0cGFyc2VLZXlWb2ljZS5hZGRQb3NUb0tleShjbGVmLCBmaXhlZEtleSk7XG5cdFx0cmV0dXJuIGZpeGVkS2V5O1xuXHR9O1xuXG5cdHZhciBwYXJzZU1pZGRsZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcCA9IHN0ci5jaGFyQXQoaSsrKTtcblx0XHRpZiAocCA9PT0gJ14nIHx8IHAgPT09ICdfJylcblx0XHRcdHAgPSBzdHIuY2hhckF0KGkrKyk7XG5cdCAgdmFyIG1pZCA9IHBpdGNoZXNbcF07XG5cdFx0aWYgKG1pZCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bWlkID0gNjsgLy8gSWYgYSBsZWdhbCBtaWRkbGUgbm90ZSB3YXNuJ3QgcmVjZWl2ZWQsIGp1c3QgaWdub3JlIGl0LlxuXHRcdGZvciAoIDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHN0ci5jaGFyQXQoaSkgPT09ICcsJykgbWlkIC09IDc7XG5cdFx0XHRlbHNlIGlmIChzdHIuY2hhckF0KGkpID09PSBcIidcIikgbWlkICs9IDc7XG5cdFx0XHRlbHNlIGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4geyBtaWQ6IG1pZCAtIDYsIHN0cjogc3RyLnN1YnN0cmluZyhpKSB9O1x0Ly8gV2UgZ2V0IHRoZSBub3RlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHN0YWZmLiBXZSB3YW50IHRoZSBub3RlIHRoYXQgYXBwZWFycyBhcyB0aGUgZmlyc3QgbGVkZ2VyIGxpbmUgYmVsb3cgdGhlIHN0YWZmLlxuXHR9O1xuXG5cdHZhciBub3JtYWxpemVBY2NpZGVudGFscyA9IGZ1bmN0aW9uKGFjY3MpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFjY3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhY2NzW2ldLm5vdGUgPT09ICdiJylcblx0XHRcdFx0YWNjc1tpXS5ub3RlID0gJ0InO1xuXHRcdFx0ZWxzZSBpZiAoYWNjc1tpXS5ub3RlID09PSAnYScpXG5cdFx0XHRcdGFjY3NbaV0ubm90ZSA9ICdBJztcblx0XHRcdGVsc2UgaWYgKGFjY3NbaV0ubm90ZSA9PT0gJ0YnKVxuXHRcdFx0XHRhY2NzW2ldLm5vdGUgPSAnZic7XG5cdFx0XHRlbHNlIGlmIChhY2NzW2ldLm5vdGUgPT09ICdFJylcblx0XHRcdFx0YWNjc1tpXS5ub3RlID0gJ2UnO1xuXHRcdFx0ZWxzZSBpZiAoYWNjc1tpXS5ub3RlID09PSAnRCcpXG5cdFx0XHRcdGFjY3NbaV0ubm90ZSA9ICdkJztcblx0XHRcdGVsc2UgaWYgKGFjY3NbaV0ubm90ZSA9PT0gJ0MnKVxuXHRcdFx0XHRhY2NzW2ldLm5vdGUgPSAnYyc7XG5cdFx0XHRlbHNlIGlmIChhY2NzW2ldLm5vdGUgPT09ICdHJyAmJiBhY2NzW2ldLmFjYyA9PT0gJ3NoYXJwJylcblx0XHRcdFx0YWNjc1tpXS5ub3RlID0gJ2cnO1xuXHRcdFx0ZWxzZSBpZiAoYWNjc1tpXS5ub3RlID09PSAnZycgJiYgYWNjc1tpXS5hY2MgPT09ICdmbGF0Jylcblx0XHRcdFx0YWNjc1tpXS5ub3RlID0gJ0cnO1xuXHRcdH1cblx0fTtcblxuXHRwYXJzZUtleVZvaWNlLnBhcnNlS2V5ID0gZnVuY3Rpb24oc3RyKVx0Ly8gKGFuZCBjbGVmKVxuXHR7XG5cdFx0Ly8gcmV0dXJuczpcblx0XHQvL1x0XHR7IGZvdW5kQ2xlZjogdHJ1ZSwgZm91bmRLZXk6IHRydWUgfVxuXHRcdC8vIFNpZGUgZWZmZWN0czpcblx0XHQvL1x0XHRjYWxscyB3YXJuKCkgd2hlbiB0aGVyZSBpcyBhIHN5bnRheCBlcnJvclxuXHRcdC8vXHRcdHNldHMgdGhlc2UgbWVtYmVycyBvZiBtdWx0aWxpbmVWYXJzOlxuXHRcdC8vXHRcdFx0Y2xlZlxuXHRcdC8vXHRcdFx0a2V5XG5cdFx0Ly9cdFx0XHRzdHlsZVxuXHRcdC8vXG5cdFx0Ly8gVGhlIGZvcm1hdCBpczpcblx0XHQvLyBLOiBb4p+oa2V54p+pXSBb4p+obW9kaWZpZXJz4p+pKl1cblx0XHQvLyBtb2RpZmllcnMgYXJlIGFueSBvZiB0aGUgZm9sbG93aW5nIGluIGFueSBvcmRlcjpcblx0XHQvLyAgW+KfqGNsZWbin6ldIFttaWRkbGU94p+ocGl0Y2jin6ldIFt0cmFuc3Bvc2U9Wy1d4p+obnVtYmVy4p+pXSBbc3RhZmZsaW5lcz3in6hudW1iZXLin6ldIFtzdGFmZnNjYWxlPeKfqG51bWJlcuKfqV1bc3R5bGU94p+oc3R5bGXin6ldXG5cdFx0Ly8ga2V5IGlzIG5vbmV8SFB8SHB84p+oc3BlY2lmaWVkX2tleeKfqVxuXHRcdC8vIGNsZWYgaXMgW2NsZWY9XSBb4p+oY2xlZiB0eXBl4p+pXSBb4p+obGluZSBudW1iZXLin6ldIFsrOHwtOF1cblx0XHQvLyBzcGVjaWZpZWRfa2V5IGlzIOKfqHBpdGNo4p+pWyN8Yl1bbW9kZShmaXJzdCB0aHJlZSBjaGFycyBhcmUgc2lnbmlmaWNhbnQpXVthY2NpZGVudGFscypdXG5cdFx0aWYgKHN0ci5sZW5ndGggPT09IDApIHtcblx0XHRcdC8vIGFuIGVtcHR5IEs6IGZpZWxkIGlzIHRoZSBzYW1lIGFzIEs6bm9uZVxuXHRcdFx0c3RyID0gJ25vbmUnO1xuXHRcdH1cblx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKHN0ciwgMCwgc3RyLmxlbmd0aCk7XG5cdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0Ly8gZmlyc3QgdGhlIGtleVxuXHRcdHN3aXRjaCAodG9rZW5zWzBdLnRva2VuKSB7XG5cdFx0XHRjYXNlICdIUCc6XG5cdFx0XHRcdHBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZShcImJhZ3BpcGVzXCIpO1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleSA9IHsgcm9vdDogXCJIUFwiLCBhY2NpZGVudGFsczogW10sIGFjYzogXCJcIiwgbW9kZTogXCJcIiB9O1xuXHRcdFx0XHRyZXQuZm91bmRLZXkgPSB0cnVlO1xuXHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdIcCc6XG5cdFx0XHRcdHBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZShcImJhZ3BpcGVzXCIpO1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleSA9IHsgcm9vdDogXCJIcFwiLCBhY2NpZGVudGFsczogW3thY2M6ICduYXR1cmFsJywgbm90ZTogJ2cnfSwge2FjYzogJ3NoYXJwJywgbm90ZTogJ2YnfSwge2FjYzogJ3NoYXJwJywgbm90ZTogJ2MnfV0sIGFjYzogXCJcIiwgbW9kZTogXCJcIiB9O1xuXHRcdFx0XHRyZXQuZm91bmRLZXkgPSB0cnVlO1xuXHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdub25lJzpcblx0XHRcdFx0Ly8gd2UgZ290IHRoZSBub25lIGtleSAtIHRoYXQncyB0aGUgc2FtZSBhcyBDIHRvIHVzXG5cdFx0XHRcdG11bHRpbGluZVZhcnMua2V5ID0geyByb290OiBcIm5vbmVcIiwgYWNjaWRlbnRhbHM6IFtdLCBhY2M6IFwiXCIsIG1vZGU6IFwiXCIgfTtcblx0XHRcdFx0cmV0LmZvdW5kS2V5ID0gdHJ1ZTtcblx0XHRcdFx0dG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dmFyIHJldFBpdGNoID0gdG9rZW5pemVyLmdldEtleVBpdGNoKHRva2Vuc1swXS50b2tlbik7XG5cdFx0XHRcdGlmIChyZXRQaXRjaC5sZW4gPiAwKSB7XG5cdFx0XHRcdFx0cmV0LmZvdW5kS2V5ID0gdHJ1ZTtcblx0XHRcdFx0XHR2YXIgYWNjID0gXCJcIjtcblx0XHRcdFx0XHR2YXIgbW9kZSA9IFwiXCI7XG5cdFx0XHRcdFx0Ly8gVGhlIGFjY2lkZW50YWwgYW5kIG1vZGUgbWlnaHQgYmUgYXR0YWNoZWQgdG8gdGhlIHBpdGNoLCBzbyB3ZSBtaWdodCB3YW50IHRvIGp1c3QgcmVtb3ZlIHRoZSBmaXJzdCBjaGFyYWN0ZXIuXG5cdFx0XHRcdFx0aWYgKHRva2Vuc1swXS50b2tlbi5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdFx0dG9rZW5zWzBdLnRva2VuID0gdG9rZW5zWzBdLnRva2VuLnN1YnN0cmluZygxKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHR2YXIga2V5ID0gcmV0UGl0Y2gudG9rZW47XG5cdFx0XHRcdFx0Ly8gV2UgZ290IGEgcGl0Y2ggdG8gc3RhcnQgd2l0aCwgc28gd2UgbWlnaHQgYWxzbyBoYXZlIGFuIGFjY2lkZW50YWwgYW5kIGEgbW9kZVxuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0dmFyIHJldEFjYyA9IHRva2VuaXplci5nZXRTaGFycEZsYXQodG9rZW5zWzBdLnRva2VuKTtcblx0XHRcdFx0XHRcdGlmIChyZXRBY2MubGVuID4gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAodG9rZW5zWzBdLnRva2VuLmxlbmd0aCA+IDEpXG5cdFx0XHRcdFx0XHRcdFx0dG9rZW5zWzBdLnRva2VuID0gdG9rZW5zWzBdLnRva2VuLnN1YnN0cmluZygxKTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHRrZXkgKz0gcmV0QWNjLnRva2VuO1xuXHRcdFx0XHRcdFx0XHRhY2MgPSByZXRBY2MudG9rZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJldE1vZGUgPSB0b2tlbml6ZXIuZ2V0TW9kZSh0b2tlbnNbMF0udG9rZW4pO1xuXHRcdFx0XHRcdFx0XHRpZiAocmV0TW9kZS5sZW4gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdFx0a2V5ICs9IHJldE1vZGUudG9rZW47XG5cdFx0XHRcdFx0XHRcdFx0bW9kZSA9IHJldE1vZGUudG9rZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIEJlIHN1cmUgdGhhdCB0aGUga2V5IHNwZWNpZmllZCBpcyBpbiB0aGUgbGlzdDogbm90IGFsbCBrZXlzIGFyZSBwaHlzaWNhbGx5IHBvc3NpYmxlLCBsaWtlIENibWluLlxuXHRcdFx0XHRcdFx0aWYgKHBhcnNlS2V5Vm9pY2Uuc3RhbmRhcmRLZXkoa2V5LCByZXRQaXRjaC50b2tlbiwgYWNjLCAwKSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm4oXCJVbnN1cHBvcnRlZCBrZXkgc2lnbmF0dXJlOiBcIiArIGtleSwgc3RyLCAwKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBkbyBhIGRlZXAgY29weSBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBtb2RpZnkgaXRcblx0XHRcdFx0XHR2YXIgb2xkS2V5ID0gcGFyc2VLZXlWb2ljZS5kZWVwQ29weUtleShtdWx0aWxpbmVWYXJzLmtleSk7XG5cdFx0XHRcdFx0Ly9UT0RPLVBFUjogSEFDSyEgVG8gZ2V0IHRoZSBsb2NhbCB0cmFuc3Bvc2UgdG8gd29yaywgdGhlIHRyYW5zcG9zaXRpb24gaXMgZG9uZSBmb3IgZWFjaCBsaW5lLiBUaGlzIGNhdXNlZCB0aGUgZ2xvYmFsIHRyYW5zcG9zaXRpb24gdmFyaWFibGUgdG8gYmUgZmFjdG9yZWQgaW4gdHdpY2UsIHNvLCBpbnN0ZWFkIG9mIHJld3JpdGluZyB0aGF0IHJpZ2h0IG5vdywgSSdtIGp1c3Qgc3VidHJhY3Rpbmcgb25lIG9mIHRoZW0gaGVyZS5cblx0XHRcdFx0XHR2YXIga2V5Q29tcGVuc2F0ZSA9IG11bHRpbGluZVZhcnMuZ2xvYmFsVHJhbnNwb3NlID8gLW11bHRpbGluZVZhcnMuZ2xvYmFsVHJhbnNwb3NlIDogMDtcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleSA9IHBhcnNlS2V5Vm9pY2UuZGVlcENvcHlLZXkocGFyc2VLZXlWb2ljZS5zdGFuZGFyZEtleShrZXksIHJldFBpdGNoLnRva2VuLCBhY2MsIGtleUNvbXBlbnNhdGUpKTtcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleS5tb2RlID0gbW9kZTtcblx0XHRcdFx0XHRpZiAob2xkS2V5KSB7XG5cdFx0XHRcdFx0XHQvLyBBZGQgbmF0dXJhbCBpbiBhbGwgcGxhY2VzIHRoYXQgdGhlIG9sZCBrZXkgaGFkIGFuIGFjY2lkZW50YWwuXG5cdFx0XHRcdFx0XHR2YXIga2s7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG11bHRpbGluZVZhcnMua2V5LmFjY2lkZW50YWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoa2sgPSAwOyBrayA8IG9sZEtleS5hY2NpZGVudGFscy5sZW5ndGg7IGtrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAob2xkS2V5LmFjY2lkZW50YWxzW2trXS5ub3RlICYmIG11bHRpbGluZVZhcnMua2V5LmFjY2lkZW50YWxzW2tdLm5vdGUudG9Mb3dlckNhc2UoKSA9PT0gb2xkS2V5LmFjY2lkZW50YWxzW2trXS5ub3RlLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdFx0XHRcdFx0XHRvbGRLZXkuYWNjaWRlbnRhbHNba2tdLm5vdGUgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKGtrID0gMDsga2sgPCBvbGRLZXkuYWNjaWRlbnRhbHMubGVuZ3RoOyBraysrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvbGRLZXkuYWNjaWRlbnRhbHNba2tdLm5vdGUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIW11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscylcblx0XHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscy5wdXNoKHsgYWNjOiAnbmF0dXJhbCcsIG5vdGU6IG9sZEtleS5hY2NpZGVudGFsc1tra10ubm90ZSB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHQvLyBUaGVyZSBhcmUgdHdvIHNwZWNpYWwgY2FzZXMgb2YgZGVwcmVjYXRlZCBzeW50YXguIElnbm9yZSB0aGVtIGlmIHRoZXkgb2NjdXJcblx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcblx0XHRpZiAodG9rZW5zWzBdLnRva2VuID09PSAnZXhwJykgdG9rZW5zLnNoaWZ0KCk7XG5cdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG5cdFx0aWYgKHRva2Vuc1swXS50b2tlbiA9PT0gJ29jdCcpIHRva2Vucy5zaGlmdCgpO1xuXG5cdFx0Ly8gbm93IHNlZSBpZiB0aGVyZSBhcmUgZXh0cmEgYWNjaWRlbnRhbHNcblx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcblx0XHR2YXIgYWNjcyA9IHRva2VuaXplci5nZXRLZXlBY2NpZGVudGFsczIodG9rZW5zKTtcblx0XHRpZiAoYWNjcy53YXJuKVxuXHRcdFx0d2FybihhY2NzLndhcm4sIHN0ciwgMCk7XG5cdFx0Ly8gSWYgd2UgaGF2ZSBleHRyYSBhY2NpZGVudGFscywgZmlyc3QgcmVwbGFjZSBvbmVzIHRoYXQgYXJlIG9mIHRoZSBzYW1lIHBpdGNoIGJlZm9yZSBhZGRpbmcgdGhlbSB0byB0aGUgZW5kLlxuXHRcdGlmIChhY2NzLmFjY3MpIHtcblx0XHRcdGlmICghcmV0LmZvdW5kS2V5KSB7XHRcdC8vIGlmIHRoZXJlIGFyZSBvbmx5IGV4dHJhIGFjY2lkZW50YWxzLCBtYWtlIHN1cmUgdGhpcyBpcyBzZXQuXG5cdFx0XHRcdHJldC5mb3VuZEtleSA9IHRydWU7XG5cdFx0XHRcdG11bHRpbGluZVZhcnMua2V5ID0geyByb290OiBcIm5vbmVcIiwgYWNjOiBcIlwiLCBtb2RlOiBcIlwiLCBhY2NpZGVudGFsczogW10gfTtcblx0XHRcdH1cblx0XHRcdG5vcm1hbGl6ZUFjY2lkZW50YWxzKGFjY3MuYWNjcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFjY3MuYWNjcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtdWx0aWxpbmVWYXJzLmtleS5hY2NpZGVudGFscy5sZW5ndGggJiYgIWZvdW5kOyBqKyspIHtcblx0XHRcdFx0XHRpZiAobXVsdGlsaW5lVmFycy5rZXkuYWNjaWRlbnRhbHNbal0ubm90ZSA9PT0gYWNjcy5hY2NzW2ldLm5vdGUpIHtcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmtleS5hY2NpZGVudGFsc1tqXS5hY2MgIT09IGFjY3MuYWNjc1tpXS5hY2MpIHtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGFjY2lkZW50YWwgaXMgZGlmZmVyZW50LCB0aGVuIHJlcGxhY2UgaXQuIElmIGl0IGlzIHRoZSBzYW1lLCB0aGVuIHRoZSBkZWNsYXJhdGlvbiB3YXMgcmVkdW5kYW50LCBzbyBqdXN0IGlnbm9yZSBpdC5cblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5rZXkuYWNjaWRlbnRhbHNbal0uYWNjID0gYWNjcy5hY2NzW2ldLmFjYztcblx0XHRcdFx0XHRcdFx0aWYgKCFtdWx0aWxpbmVWYXJzLmtleS5leHBsaWNpdEFjY2lkZW50YWxzKVxuXHRcdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHMgPSBbXTtcblx0XHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5rZXkuZXhwbGljaXRBY2NpZGVudGFscy5wdXNoKGFjY3MuYWNjc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZm91bmQpIHtcblx0XHRcdFx0XHRpZiAoIW11bHRpbGluZVZhcnMua2V5LmV4cGxpY2l0QWNjaWRlbnRhbHMpXG5cdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleS5leHBsaWNpdEFjY2lkZW50YWxzID0gW107XG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5rZXkuZXhwbGljaXRBY2NpZGVudGFscy5wdXNoKGFjY3MuYWNjc1tpXSk7XG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5rZXkuYWNjaWRlbnRhbHMucHVzaChhY2NzLmFjY3NbaV0pO1xuXHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmtleS5pbXBsaWVkTmF0dXJhbHMpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGtrayA9IDA7IGtrayA8IG11bHRpbGluZVZhcnMua2V5LmltcGxpZWROYXR1cmFscy5sZW5ndGg7IGtraysrKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmtleS5pbXBsaWVkTmF0dXJhbHNba2trXS5ub3RlID09PSBhY2NzLmFjY3NbaV0ubm90ZSlcblx0XHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmtleS5pbXBsaWVkTmF0dXJhbHMuc3BsaWNlKGtraywgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHNlZSBpZiBhbnkgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgcHJlc2VudC4gVGhleSBoYXZlIHRoZSBmb3JtIFwia2V5PXZhbHVlXCIsIGV4Y2VwdCB0aGF0IFwiY2xlZj1cIiBpcyBvcHRpb25hbFxuXHRcdHZhciB0b2tlbjtcblx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdHN3aXRjaCAodG9rZW5zWzBdLnRva2VuKSB7XG5cdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdGNhc2UgXCJtaWRkbGVcIjpcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgPSBhZnRlciBtaWRkbGVcIiwgc3RyLCAwKTsgcmV0dXJuIHJldDsgfVxuXHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2VuLnRva2VuICE9PSBcIj1cIikgeyB3YXJuKFwiRXhwZWN0ZWQgPSBhZnRlciBtaWRkbGVcIiwgc3RyLCB0b2tlbi5zdGFydCk7IGJyZWFrOyB9XG5cdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHsgd2FybihcIkV4cGVjdGVkIHBhcmFtZXRlciBhZnRlciBtaWRkbGU9XCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHR2YXIgcGl0Y2ggPSB0b2tlbml6ZXIuZ2V0UGl0Y2hGcm9tVG9rZW5zKHRva2Vucyk7XG5cdFx0XHRcdFx0aWYgKHBpdGNoLndhcm4pXG5cdFx0XHRcdFx0XHR3YXJuKHBpdGNoLndhcm4sIHN0ciwgMCk7XG5cdFx0XHRcdFx0aWYgKHBpdGNoLnBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5jbGVmLnZlcnRpY2FsUG9zID0gcGl0Y2gucG9zaXRpb24gLSA2O1x0Ly8gd2UgZ2V0IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBtaWRkbGUgbGluZSwgYnV0IHdhbnQgdG8gb2Zmc2V0IGl0IHRvIHRoZSBmaXJzdCBsZWRnZXIgbGluZS5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInRyYW5zcG9zZVwiOlxuXHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7IHdhcm4oXCJFeHBlY3RlZCA9IGFmdGVyIHRyYW5zcG9zZVwiLCBzdHIsIDApOyByZXR1cm4gcmV0OyB9XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW4udG9rZW4gIT09IFwiPVwiKSB7IHdhcm4oXCJFeHBlY3RlZCA9IGFmdGVyIHRyYW5zcG9zZVwiLCBzdHIsIHRva2VuLnN0YXJ0KTsgYnJlYWs7IH1cblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIHRyYW5zcG9zZT1cIiwgc3RyLCAwKTsgcmV0dXJuIHJldDsgfVxuXHRcdFx0XHRcdGlmICh0b2tlbnNbMF0udHlwZSAhPT0gJ251bWJlcicpIHsgd2FybihcIkV4cGVjdGVkIG51bWJlciBhZnRlciB0cmFuc3Bvc2VcIiwgc3RyLCB0b2tlbnNbMF0uc3RhcnQpOyBicmVhazsgfVxuXHRcdFx0XHRcdG11bHRpbGluZVZhcnMuY2xlZi50cmFuc3Bvc2UgPSB0b2tlbnNbMF0uaW50dDtcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInN0YWZmbGluZXNcIjpcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgPSBhZnRlciBzdGFmZmxpbmVzXCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2tlbi50b2tlbiAhPT0gXCI9XCIpIHsgd2FybihcIkV4cGVjdGVkID0gYWZ0ZXIgc3RhZmZsaW5lc1wiLCBzdHIsIHRva2VuLnN0YXJ0KTsgYnJlYWs7IH1cblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIHN0YWZmbGluZXM9XCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHRpZiAodG9rZW5zWzBdLnR5cGUgIT09ICdudW1iZXInKSB7IHdhcm4oXCJFeHBlY3RlZCBudW1iZXIgYWZ0ZXIgc3RhZmZsaW5lc1wiLCBzdHIsIHRva2Vuc1swXS5zdGFydCk7IGJyZWFrOyB9XG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5jbGVmLnN0YWZmbGluZXMgPSB0b2tlbnNbMF0uaW50dDtcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInN0YWZmc2NhbGVcIjpcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgPSBhZnRlciBzdGFmZnNjYWxlXCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGlmICh0b2tlbi50b2tlbiAhPT0gXCI9XCIpIHsgd2FybihcIkV4cGVjdGVkID0gYWZ0ZXIgc3RhZmZzY2FsZVwiLCBzdHIsIHRva2VuLnN0YXJ0KTsgYnJlYWs7IH1cblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIHN0YWZmc2NhbGU9XCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHRpZiAodG9rZW5zWzBdLnR5cGUgIT09ICdudW1iZXInKSB7IHdhcm4oXCJFeHBlY3RlZCBudW1iZXIgYWZ0ZXIgc3RhZmZzY2FsZVwiLCBzdHIsIHRva2Vuc1swXS5zdGFydCk7IGJyZWFrOyB9XG5cdFx0XHRcdFx0bXVsdGlsaW5lVmFycy5jbGVmLnN0YWZmc2NhbGUgPSB0b2tlbnNbMF0uZmxvYXR0O1xuXHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwic3R5bGVcIjpcblx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgeyB3YXJuKFwiRXhwZWN0ZWQgPSBhZnRlciBzdHlsZVwiLCBzdHIsIDApOyByZXR1cm4gcmV0OyB9XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW4udG9rZW4gIT09IFwiPVwiKSB7IHdhcm4oXCJFeHBlY3RlZCA9IGFmdGVyIHN0eWxlXCIsIHN0ciwgdG9rZW4uc3RhcnQpOyBicmVhazsgfVxuXHRcdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7IHdhcm4oXCJFeHBlY3RlZCBwYXJhbWV0ZXIgYWZ0ZXIgc3R5bGU9XCIsIHN0ciwgMCk7IHJldHVybiByZXQ7IH1cblx0XHRcdFx0XHRzd2l0Y2ggKHRva2Vuc1swXS50b2tlbikge1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm5vcm1hbFwiOlxuXHRcdFx0XHRcdFx0Y2FzZSBcImhhcm1vbmljXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwicmh5dGhtXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwieFwiOlxuXHRcdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnN0eWxlID0gdG9rZW5zWzBdLnRva2VuO1xuXHRcdFx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiZXJyb3IgcGFyc2luZyBzdHlsZSBlbGVtZW50OiBcIiArIHRva2Vuc1swXS50b2tlbiwgc3RyLCB0b2tlbnNbMF0uc3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJjbGVmXCI6XG5cdFx0XHRcdFx0dG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHsgd2FybihcIkV4cGVjdGVkID0gYWZ0ZXIgY2xlZlwiLCBzdHIsIDApOyByZXR1cm4gcmV0OyB9XG5cdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAodG9rZW4udG9rZW4gIT09IFwiPVwiKSB7IHdhcm4oXCJFeHBlY3RlZCA9IGFmdGVyIGNsZWZcIiwgc3RyLCB0b2tlbi5zdGFydCk7IGJyZWFrOyB9XG5cdFx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHsgd2FybihcIkV4cGVjdGVkIHBhcmFtZXRlciBhZnRlciBjbGVmPVwiLCBzdHIsIDApOyByZXR1cm4gcmV0OyB9XG5cdFx0XHRcdFx0Ly9icmVhazsgeWVzLCB3ZSB3YW50IHRvIGZhbGwgdGhyb3VnaC4gVGhhdCBhbGxvd3MgXCJjbGVmPVwiIHRvIGJlIG9wdGlvbmFsLlxuXHRcdFx0XHRjYXNlIFwidHJlYmxlXCI6XG5cdFx0XHRcdGNhc2UgXCJiYXNzXCI6XG5cdFx0XHRcdGNhc2UgXCJhbHRvXCI6XG5cdFx0XHRcdGNhc2UgXCJ0ZW5vclwiOlxuXHRcdFx0XHRjYXNlIFwicGVyY1wiOlxuXHRcdFx0XHRcdC8vIGNsZWYgaXMgW2NsZWY9XSBb4p+oY2xlZiB0eXBl4p+pXSBb4p+obGluZSBudW1iZXLin6ldIFsrOHwtOF1cblx0XHRcdFx0XHR2YXIgY2xlZiA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdHN3aXRjaCAoY2xlZi50b2tlbikge1xuXHRcdFx0XHRcdFx0Y2FzZSAndHJlYmxlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ3Rlbm9yJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2FsdG8nOlxuXHRcdFx0XHRcdFx0Y2FzZSAnYmFzcyc6XG5cdFx0XHRcdFx0XHRjYXNlICdwZXJjJzpcblx0XHRcdFx0XHRcdGNhc2UgJ25vbmUnOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0MnOiBjbGVmLnRva2VuID0gJ2FsdG8nOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0YnOiBjbGVmLnRva2VuID0gJ2Jhc3MnOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0cnOiBjbGVmLnRva2VuID0gJ3RyZWJsZSc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYyc6IGNsZWYudG9rZW4gPSAnYWx0byc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZic6IGNsZWYudG9rZW4gPSAnYmFzcyc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZyc6IGNsZWYudG9rZW4gPSAndHJlYmxlJzsgYnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgY2xlZiBuYW1lLiBGb3VuZCBcIiArIGNsZWYudG9rZW4sIHN0ciwgY2xlZi5zdGFydCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zWzBdLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRjbGVmLnRva2VuICs9IHRva2Vuc1swXS50b2tlbjtcblx0XHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA+IDEgJiYgKHRva2Vuc1swXS50b2tlbiA9PT0gJy0nIHx8IHRva2Vuc1swXS50b2tlbiA9PT0gJysnIHx8IHRva2Vuc1swXS50b2tlbiA9PT0gJ14nIHx8IHRva2Vuc1swXS50b2tlbiA9PT0gJ18nKSAmJiB0b2tlbnNbMV0udG9rZW4gPT09ICc4Jykge1xuXHRcdFx0XHRcdFx0Y2xlZi50b2tlbiArPSB0b2tlbnNbMF0udG9rZW4gKyB0b2tlbnNbMV0udG9rZW47XG5cdFx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLmNsZWYgPSB7dHlwZTogY2xlZi50b2tlbiwgdmVydGljYWxQb3M6IGNhbGNNaWRkbGUoY2xlZi50b2tlbiwgMCl9O1xuXHRcdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZSAmJiBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS50cmFuc3Bvc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMuY2xlZi50cmFuc3Bvc2UgPSBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS50cmFuc3Bvc2U7XG5cdFx0XHRcdFx0cmV0LmZvdW5kQ2xlZiA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0d2FybihcIlVua25vd24gcGFyYW1ldGVyOiBcIiArIHRva2Vuc1swXS50b2tlbiwgc3RyLCB0b2tlbnNbMF0uc3RhcnQpO1xuXHRcdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdHZhciBzZXRDdXJyZW50Vm9pY2UgPSBmdW5jdGlvbihpZCkge1xuXHRcdG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlID0gbXVsdGlsaW5lVmFycy52b2ljZXNbaWRdO1xuXHRcdHR1bmUuc2V0Q3VycmVudFZvaWNlKG11bHRpbGluZVZhcnMuY3VycmVudFZvaWNlLnN0YWZmTnVtLCBtdWx0aWxpbmVWYXJzLmN1cnJlbnRWb2ljZS5pbmRleCk7XG5cdH07XG5cblx0cGFyc2VLZXlWb2ljZS5wYXJzZVZvaWNlID0gZnVuY3Rpb24obGluZSwgaSwgZSkge1xuXHRcdC8vRmlyc3QgdHJ1bmNhdGUgdGhlIHN0cmluZyB0byB0aGUgZmlyc3Qgbm9uLXNwYWNlIGNoYXJhY3RlciBhZnRlciBWOiB0aHJvdWdoIGVpdGhlciB0aGVcblx0XHQvL2VuZCBvZiB0aGUgbGluZSBvciBhICUgY2hhcmFjdGVyLiBUaGVuIHJlbW92ZSB0cmFpbGluZyBzcGFjZXMsIHRvby5cblx0XHR2YXIgcmV0ID0gdG9rZW5pemVyLmdldE1lYXQobGluZSwgaSwgZSk7XG5cdFx0dmFyIHN0YXJ0ID0gcmV0LnN0YXJ0O1xuXHRcdHZhciBlbmQgPSByZXQuZW5kO1xuXHRcdC8vVGhlIGZpcnN0IHRoaW5nIG9uIHRoZSBsaW5lIGlzIHRoZSBJRC4gSXQgY2FuIGJlIGFueSBub24tc3BhY2Ugc3RyaW5nIGFuZCB0ZXJtaW5hdGVzIGF0IHRoZVxuXHRcdC8vZmlyc3Qgc3BhY2UuXG5cdFx0dmFyIGlkID0gdG9rZW5pemVyLmdldFRva2VuKGxpbmUsIHN0YXJ0LCBlbmQpO1xuXHRcdGlmIChpZC5sZW5ndGggPT09IDApIHtcblx0XHRcdHdhcm4oXCJFeHBlY3RlZCBhIHZvaWNlIGlkXCIsIGxpbmUsIHN0YXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGlzTmV3ID0gZmFsc2U7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMudm9pY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0gPSB7fTtcblx0XHRcdGlzTmV3ID0gdHJ1ZTtcblx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLnNjb3JlX2lzX3ByZXNlbnQpXG5cdFx0XHRcdHdhcm4oXCJDYW4ndCBoYXZlIGFuIHVua25vd24gVjogaWQgd2hlbiB0aGUgJXNjb3JlIGRpcmVjdGl2ZSBpcyBwcmVzZW50XCIsIGxpbmUsIHN0YXJ0KTtcblx0XHR9XG5cdFx0c3RhcnQgKz0gaWQubGVuZ3RoO1xuXHRcdHN0YXJ0ICs9IHRva2VuaXplci5lYXRXaGl0ZVNwYWNlKGxpbmUsIHN0YXJ0KTtcblxuXHRcdHZhciBzdGFmZkluZm8gPSB7c3RhcnRTdGFmZjogaXNOZXd9O1xuXHRcdHZhciBhZGROZXh0VG9rZW5Ub1N0YWZmSW5mbyA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBhdHRyID0gdG9rZW5pemVyLmdldFZvaWNlVG9rZW4obGluZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRpZiAoYXR0ci53YXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCB2YWx1ZSBmb3IgXCIgKyBuYW1lICsgXCIgaW4gdm9pY2U6IFwiICsgYXR0ci53YXJuLCBsaW5lLCBzdGFydCk7XG5cdFx0XHRlbHNlIGlmIChhdHRyLnRva2VuLmxlbmd0aCA9PT0gMCAmJiBsaW5lLmNoYXJBdChzdGFydCkgIT09ICdcIicpXG5cdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCB2YWx1ZSBmb3IgXCIgKyBuYW1lICsgXCIgaW4gdm9pY2VcIiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzdGFmZkluZm9bbmFtZV0gPSBhdHRyLnRva2VuO1xuXHRcdFx0c3RhcnQgKz0gYXR0ci5sZW47XG5cdFx0fTtcblx0XHR2YXIgYWRkTmV4dFRva2VuVG9Wb2ljZUluZm8gPSBmdW5jdGlvbihpZCwgbmFtZSwgdHlwZSkge1xuXHRcdFx0dmFyIGF0dHIgPSB0b2tlbml6ZXIuZ2V0Vm9pY2VUb2tlbihsaW5lLCBzdGFydCwgZW5kKTtcblx0XHRcdGlmIChhdHRyLndhcm4gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHZhbHVlIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZTogXCIgKyBhdHRyLndhcm4sIGxpbmUsIHN0YXJ0KTtcblx0XHRcdGVsc2UgaWYgKGF0dHIudG9rZW4ubGVuZ3RoID09PSAwICYmIGxpbmUuY2hhckF0KHN0YXJ0KSAhPT0gJ1wiJylcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHZhbHVlIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZVwiLCBsaW5lLCBzdGFydCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdGF0dHIudG9rZW4gPSBwYXJzZUZsb2F0KGF0dHIudG9rZW4pO1xuXHRcdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF1bbmFtZV0gPSBhdHRyLnRva2VuO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgKz0gYXR0ci5sZW47XG5cdFx0fTtcblx0XHR2YXIgZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuXHRcdFx0dmFyIGF0dHIgPSB0b2tlbml6ZXIuZ2V0Vm9pY2VUb2tlbihsaW5lLCBzdGFydCwgZW5kKTtcblx0XHRcdGlmIChhdHRyLndhcm4gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHZhbHVlIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZTogXCIgKyBhdHRyLndhcm4sIGxpbmUsIHN0YXJ0KTtcblx0XHRcdGVsc2UgaWYgKGF0dHIudG9rZW4ubGVuZ3RoID09PSAwICYmIGxpbmUuY2hhckF0KHN0YXJ0KSAhPT0gJ1wiJylcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHZhbHVlIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZVwiLCBsaW5lLCBzdGFydCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdGF0dHIudG9rZW4gPSBwYXJzZUZsb2F0KGF0dHIudG9rZW4pO1xuXHRcdFx0XHRyZXR1cm4gYXR0ci50b2tlbjtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ICs9IGF0dHIubGVuO1xuXHRcdH07XG5cdFx0dmFyIGFkZE5leHROb3RlVG9rZW5Ub1ZvaWNlSW5mbyA9IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG5cdFx0XHR2YXIgbm90ZVRvVHJhbnNwb3NpdGlvbiA9IHtcblx0XHRcdFx0XCJfQlwiOiAyLFxuXHRcdFx0XHRcIl9FXCI6IDksXG5cdFx0XHRcdFwiX2JcIjogLTEwLFxuXHRcdFx0XHRcIl9lXCI6IC0zXG5cdFx0XHR9O1xuXHRcdFx0dmFyIGF0dHIgPSB0b2tlbml6ZXIuZ2V0Vm9pY2VUb2tlbihsaW5lLCBzdGFydCwgZW5kKTtcblx0XHRcdGlmIChhdHRyLndhcm4gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBvZiAoX0IsIF9FLCBfYiwgX2UpIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZTogXCIgKyBhdHRyLndhcm4sIGxpbmUsIHN0YXJ0KTtcblx0XHRcdGVsc2UgaWYgKGF0dHIudG9rZW4ubGVuZ3RoID09PSAwICYmIGxpbmUuY2hhckF0KHN0YXJ0KSAhPT0gJ1wiJylcblx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBvZiAoX0IsIF9FLCBfYiwgX2UpIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZVwiLCBsaW5lLCBzdGFydCk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIHQgPSBub3RlVG9UcmFuc3Bvc2l0aW9uW2F0dHIudG9rZW5dO1xuXHRcdFx0XHRpZiAoIXQpXG5cdFx0XHRcdFx0d2FybihcIkV4cGVjdGVkIG9uZSBvZiAoX0IsIF9FLCBfYiwgX2UpIGZvciBcIiArIG5hbWUgKyBcIiBpbiB2b2ljZVwiLCBsaW5lLCBzdGFydCk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF1bbmFtZV0gPSB0O1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgKz0gYXR0ci5sZW47XG5cdFx0fTtcblxuXHRcdC8vVGhlbiB0aGUgZm9sbG93aW5nIGl0ZW1zIGNhbiBvY2N1ciBpbiBhbnkgb3JkZXI6XG5cdFx0d2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbml6ZXIuZ2V0Vm9pY2VUb2tlbihsaW5lLCBzdGFydCwgZW5kKTtcblx0XHRcdHN0YXJ0ICs9IHRva2VuLmxlbjtcblxuXHRcdFx0aWYgKHRva2VuLndhcm4pIHtcblx0XHRcdFx0d2FybihcIkVycm9yIHBhcnNpbmcgdm9pY2U6IFwiICsgdG9rZW4ud2FybiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGF0dHIgPSBudWxsO1xuXHRcdFx0XHRzd2l0Y2ggKHRva2VuLnRva2VuKSB7XG5cdFx0XHRcdFx0Y2FzZSAnY2xlZic6XG5cdFx0XHRcdFx0Y2FzZSAnY2wnOlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9TdGFmZkluZm8oJ2NsZWYnKTtcblx0XHRcdFx0XHRcdC8vIFRPRE8tUEVSOiBjaGVjayBmb3IgYSBsZWdhbCBjbGVmOyBkbyBvY3Rhdml6aW5nXG5cdFx0XHRcdFx0XHR2YXIgb2N0ID0gMDtcblx0Ly9cdFx0XHRcdFx0XHRcdGZvciAodmFyIGlpID0gMDsgaWkgPCBzdGFmZkluZm8uY2xlZi5sZW5ndGg7IGlpKyspIHtcblx0Ly9cdFx0XHRcdFx0XHRcdFx0aWYgKHN0YWZmSW5mby5jbGVmW2lpXSA9PT0gJywnKSBvY3QgLT0gNztcblx0Ly9cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoc3RhZmZJbmZvLmNsZWZbaWldID09PSBcIidcIikgb2N0ICs9IDc7XG5cdC8vXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoc3RhZmZJbmZvLmNsZWYgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0ICBzdGFmZkluZm8uY2xlZiA9IHN0YWZmSW5mby5jbGVmLnJlcGxhY2UoL1snLF0vZywgXCJcIik7IC8vJy8vY29tbWVudCBmb3IgZW1hY3MgZm9ybWF0dGluZyBvZiByZWdleHBcblx0XHRcdFx0XHRcdFx0aWYgKHN0YWZmSW5mby5jbGVmLmluZGV4T2YoJysxNicpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdG9jdCArPSAxNDtcblx0XHRcdFx0XHRcdFx0XHRzdGFmZkluZm8uY2xlZiA9IHN0YWZmSW5mby5jbGVmLnJlcGxhY2UoJysxNicsICcnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzdGFmZkluZm8udmVydGljYWxQb3MgPSBjYWxjTWlkZGxlKHN0YWZmSW5mby5jbGVmLCBvY3QpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndHJlYmxlJzpcblx0XHRcdFx0XHRjYXNlICdiYXNzJzpcblx0XHRcdFx0XHRjYXNlICd0ZW5vcic6XG5cdFx0XHRcdFx0Y2FzZSAnYWx0byc6XG5cdFx0XHRcdFx0Y2FzZSAncGVyYyc6XG5cdFx0XHRcdFx0Y2FzZSAnbm9uZSc6XG5cdFx0XHRcdFx0Y2FzZSAndHJlYmxlXFwnJzpcblx0XHRcdFx0XHRjYXNlICdiYXNzXFwnJzpcblx0XHRcdFx0XHRjYXNlICd0ZW5vclxcJyc6XG5cdFx0XHRcdFx0Y2FzZSAnYWx0b1xcJyc6XG5cdFx0XHRcdFx0Y2FzZSAnbm9uZVxcJyc6XG5cdFx0XHRcdFx0Y2FzZSAndHJlYmxlXFwnXFwnJzpcblx0XHRcdFx0XHRjYXNlICdiYXNzXFwnXFwnJzpcblx0XHRcdFx0XHRjYXNlICd0ZW5vclxcJ1xcJyc6XG5cdFx0XHRcdFx0Y2FzZSAnYWx0b1xcJ1xcJyc6XG5cdFx0XHRcdFx0Y2FzZSAnbm9uZVxcJ1xcJyc6XG5cdFx0XHRcdFx0Y2FzZSAndHJlYmxlLCc6XG5cdFx0XHRcdFx0Y2FzZSAnYmFzcywnOlxuXHRcdFx0XHRcdGNhc2UgJ3Rlbm9yLCc6XG5cdFx0XHRcdFx0Y2FzZSAnYWx0bywnOlxuXHRcdFx0XHRcdGNhc2UgJ25vbmUsJzpcblx0XHRcdFx0XHRjYXNlICd0cmVibGUsLCc6XG5cdFx0XHRcdFx0Y2FzZSAnYmFzcywsJzpcblx0XHRcdFx0XHRjYXNlICd0ZW5vciwsJzpcblx0XHRcdFx0XHRjYXNlICdhbHRvLCwnOlxuXHRcdFx0XHRcdGNhc2UgJ25vbmUsLCc6XG5cdFx0XHRcdFx0XHQvLyBUT0RPLVBFUjogaGFuZGxlIHRoZSBvY3RhdmUgaW5kaWNhdG9ycyBvbiB0aGUgY2xlZiBieSBjaGFuZ2luZyB0aGUgbWlkZGxlIHByb3BlcnR5XG5cdFx0XHRcdFx0XHR2YXIgb2N0MiA9IDA7XG5cdC8vXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpaWkgPSAwOyBpaWkgPCB0b2tlbi50b2tlbi5sZW5ndGg7IGlpaSsrKSB7XG5cdC8vXHRcdFx0XHRcdFx0XHRcdGlmICh0b2tlbi50b2tlbltpaWldID09PSAnLCcpIG9jdDIgLT0gNztcblx0Ly9cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodG9rZW4udG9rZW5baWlpXSA9PT0gXCInXCIpIG9jdDIgKz0gNztcblx0Ly9cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIHN0YWZmSW5mby5jbGVmID0gdG9rZW4udG9rZW4ucmVwbGFjZSgvWycsXS9nLCBcIlwiKTsgLy8nLy9jb21tZW50IGZvciBlbWFjcyBmb3JtYXR0aW5nIG9mIHJlZ2V4cFxuXHRcdFx0XHRcdFx0c3RhZmZJbmZvLnZlcnRpY2FsUG9zID0gY2FsY01pZGRsZShzdGFmZkluZm8uY2xlZiwgb2N0Mik7XG5cdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0uY2xlZiA9IHRva2VuLnRva2VuO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3RhdmVzJzpcblx0XHRcdFx0XHRjYXNlICdzdGF2ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc3R2Jzpcblx0XHRcdFx0XHRcdGFkZE5leHRUb2tlblRvU3RhZmZJbmZvKCdzdGF2ZXMnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2JyYWNlJzpcblx0XHRcdFx0XHRjYXNlICdicmMnOlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9TdGFmZkluZm8oJ2JyYWNlJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdicmFja2V0Jzpcblx0XHRcdFx0XHRjYXNlICdicmsnOlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9TdGFmZkluZm8oJ2JyYWNrZXQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ25hbWUnOlxuXHRcdFx0XHRcdGNhc2UgJ25tJzpcblx0XHRcdFx0XHRcdGFkZE5leHRUb2tlblRvU3RhZmZJbmZvKCduYW1lJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzdWJuYW1lJzpcblx0XHRcdFx0XHRjYXNlICdzbmFtZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc25tJzpcblx0XHRcdFx0XHRcdGFkZE5leHRUb2tlblRvU3RhZmZJbmZvKCdzdWJuYW1lJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtZXJnZSc6XG5cdFx0XHRcdFx0XHRzdGFmZkluZm8uc3RhcnRTdGFmZiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3RlbSc6XG5cdFx0XHRcdFx0Y2FzZSAnc3RlbXMnOlxuXHRcdFx0XHRcdFx0YXR0ciA9IHRva2VuaXplci5nZXRWb2ljZVRva2VuKGxpbmUsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHRcdFx0aWYgKGF0dHIud2FybiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgdmFsdWUgZm9yIHN0ZW1zIGluIHZvaWNlOiBcIiArIGF0dHIud2FybiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoYXR0ci50b2tlbiA9PT0gJ3VwJyB8fCBhdHRyLnRva2VuID09PSAnZG93bicpXG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMudm9pY2VzW2lkXS5zdGVtID0gYXR0ci50b2tlbjtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0d2FybihcIkV4cGVjdGVkIHVwIG9yIGRvd24gZm9yIHZvaWNlIHN0ZW1cIiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0XHRcdFx0c3RhcnQgKz0gYXR0ci5sZW47XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd1cCc6XG5cdFx0XHRcdFx0Y2FzZSAnZG93bic6XG5cdFx0XHRcdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0uc3RlbSA9IHRva2VuLnRva2VuO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWlkZGxlJzpcblx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdGFkZE5leHRUb2tlblRvU3RhZmZJbmZvKCd2ZXJ0aWNhbFBvcycpO1xuXHRcdFx0XHRcdFx0c3RhZmZJbmZvLnZlcnRpY2FsUG9zID0gcGFyc2VNaWRkbGUoc3RhZmZJbmZvLnZlcnRpY2FsUG9zKS5taWQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdnY2hvcmRzJzpcblx0XHRcdFx0XHRjYXNlICdnY2gnOlxuXHRcdFx0XHRcdFx0bXVsdGlsaW5lVmFycy52b2ljZXNbaWRdLnN1cHByZXNzQ2hvcmRzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdC8vIGdjaG9yZHMgY2FuIHN0YW5kIG9uIGl0cyBvd24sIG9yIGl0IGNvdWxkIGJlIGdjaG9yZHM9MC5cblx0XHRcdFx0XHRcdGF0dHIgPSB0b2tlbml6ZXIuZ2V0Vm9pY2VUb2tlbihsaW5lLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0XHRcdGlmIChhdHRyLnRva2VuID09PSBcIjBcIilcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSBzdGFydCArIGF0dHIubGVuO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3BhY2UnOlxuXHRcdFx0XHRcdGNhc2UgJ3NwYyc6XG5cdFx0XHRcdFx0XHRhZGROZXh0VG9rZW5Ub1N0YWZmSW5mbygnc3BhY2luZycpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9Wb2ljZUluZm8oaWQsICdzY2FsZScsICdudW1iZXInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3Njb3JlJzpcblx0XHRcdFx0XHRcdGFkZE5leHROb3RlVG9rZW5Ub1ZvaWNlSW5mbyhpZCwgJ3Njb3JlVHJhbnNwb3NlJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd0cmFuc3Bvc2UnOlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9Wb2ljZUluZm8oaWQsICd0cmFuc3Bvc2UnLCAnbnVtYmVyJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzdGFmZmxpbmVzJzpcblx0XHRcdFx0XHRcdGFkZE5leHRUb2tlblRvVm9pY2VJbmZvKGlkLCAnc3RhZmZsaW5lcycsICdudW1iZXInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3N0YWZmc2NhbGUnOlxuXHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IFRoaXMgaXMgcGFzc2VkIHRvIHRoZSBlbmdyYXZlciwgYnV0IHRoZSBlbmdyYXZlciBpZ25vcmVzIGl0LlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9Wb2ljZUluZm8oaWQsICdzdGFmZnNjYWxlJywgJ251bWJlcicpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnb2N0YXZlJzpcblx0XHRcdFx0XHRcdC8vIFRPRE8tUEVSOiBUaGlzIGlzIGFjY2VwdGVkLCBidXQgbm90IGltcGxlbWVudGVkLCB5ZXQuXG5cdFx0XHRcdFx0XHRhZGROZXh0VG9rZW5Ub1ZvaWNlSW5mbyhpZCwgJ29jdGF2ZScsICdudW1iZXInKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3ZvbHVtZSc6XG5cdFx0XHRcdFx0XHQvLyBUT0RPLVBFUjogVGhpcyBpcyBhY2NlcHRlZCwgYnV0IG5vdCBpbXBsZW1lbnRlZCwgeWV0LlxuXHRcdFx0XHRcdFx0YWRkTmV4dFRva2VuVG9Wb2ljZUluZm8oaWQsICd2b2x1bWUnLCAnbnVtYmVyJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjdWUnOlxuXHRcdFx0XHRcdFx0Ly8gVE9ETy1QRVI6IFRoaXMgaXMgYWNjZXB0ZWQsIGJ1dCBub3QgaW1wbGVtZW50ZWQsIHlldC5cblx0XHRcdFx0XHRcdHZhciBjdWUgPSBnZXROZXh0VG9rZW4oJ2N1ZScsICdzdHJpbmcnKTtcblx0XHRcdFx0XHRcdGlmIChjdWUgPT09ICdvbicpXG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMudm9pY2VzW2lkXS5zY2FsZSA9IDAuNjtcblx0XHRcdFx0XHRcdGVsc2UgbXVsdGlsaW5lVmFycy52b2ljZXNbaWRdLnNjYWxlID0gMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJzdHlsZVwiOlxuXHRcdFx0XHRcdFx0YXR0ciA9IHRva2VuaXplci5nZXRWb2ljZVRva2VuKGxpbmUsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHRcdFx0aWYgKGF0dHIud2FybiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0XHR3YXJuKFwiRXhwZWN0ZWQgdmFsdWUgZm9yIHN0eWxlIGluIHZvaWNlOiBcIiArIGF0dHIud2FybiwgbGluZSwgc3RhcnQpO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoYXR0ci50b2tlbiA9PT0gJ25vcm1hbCcgfHwgYXR0ci50b2tlbiA9PT0gJ2hhcm1vbmljJyB8fCBhdHRyLnRva2VuID09PSAncmh5dGhtJyB8fCBhdHRyLnRva2VuID09PSAneCcpXG5cdFx0XHRcdFx0XHRcdG11bHRpbGluZVZhcnMudm9pY2VzW2lkXS5zdHlsZSA9IGF0dHIudG9rZW47XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdHdhcm4oXCJFeHBlY3RlZCBvbmUgb2YgW25vcm1hbCwgaGFybW9uaWMsIHJoeXRobSwgeF0gZm9yIHZvaWNlIHN0eWxlXCIsIGxpbmUsIHN0YXJ0KTtcblx0XHRcdFx0XHRcdHN0YXJ0ICs9IGF0dHIubGVuO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBVc2UgdGhpcyB0byBmaW5kIFY6IHVzYWdlcyB0aGF0IGFyZW4ndCBoYW5kbGVkLlxuXHRcdFx0XHRcdC8vIFx0Y29uc29sZS5sb2coXCJwYXJzZSB2b2ljZVwiLCB0b2tlbiwgdHVuZS5tZXRhVGV4dC50aXRsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN0YXJ0ICs9IHRva2VuaXplci5lYXRXaGl0ZVNwYWNlKGxpbmUsIHN0YXJ0KTtcblx0XHR9XG5cblx0XHQvLyBub3cgd2UndmUgZmlsbGVkIHVwIHN0YWZmSW5mbywgZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggdGhpcyB2b2ljZVxuXHRcdC8vIFRPRE8tUEVSOiBJdCBpcyB1bmNsZWFyIGZyb20gdGhlIHN0YW5kYXJkIGFuZCB0aGUgZXhhbXBsZXMgd2hhdCB0byBkbyB3aXRoIGJyYWNlLCBicmFja2V0LCBhbmQgc3RhdmVzLCBzbyB0aGV5IGFyZSBpZ25vcmVkIGZvciBub3cuXG5cdFx0aWYgKHN0YWZmSW5mby5zdGFydFN0YWZmIHx8IG11bHRpbGluZVZhcnMuc3RhdmVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0bXVsdGlsaW5lVmFycy5zdGF2ZXMucHVzaCh7aW5kZXg6IG11bHRpbGluZVZhcnMuc3RhdmVzLmxlbmd0aCwgbWV0ZXI6IG11bHRpbGluZVZhcnMub3JpZ01ldGVyfSk7XG5cdFx0XHRpZiAoIW11bHRpbGluZVZhcnMuc2NvcmVfaXNfcHJlc2VudClcblx0XHRcdFx0bXVsdGlsaW5lVmFycy5zdGF2ZXNbbXVsdGlsaW5lVmFycy5zdGF2ZXMubGVuZ3RoLTFdLm51bVZvaWNlcyA9IDA7XG5cdFx0fVxuXHRcdGlmIChtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0uc3RhZmZOdW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gc3RvcmUgd2hlcmUgdG8gd3JpdGUgdGhpcyBmb3IgcXVpY2sgYWNjZXNzIGxhdGVyLlxuXHRcdFx0bXVsdGlsaW5lVmFycy52b2ljZXNbaWRdLnN0YWZmTnVtID0gbXVsdGlsaW5lVmFycy5zdGF2ZXMubGVuZ3RoLTE7XG5cdFx0XHR2YXIgdmkgPSAwO1xuXHRcdFx0Zm9yKHZhciB2IGluIG11bHRpbGluZVZhcnMudm9pY2VzKSB7XG5cdFx0XHRcdGlmKG11bHRpbGluZVZhcnMudm9pY2VzLmhhc093blByb3BlcnR5KHYpKSB7XG5cdFx0XHRcdFx0aWYgKG11bHRpbGluZVZhcnMudm9pY2VzW3ZdLnN0YWZmTnVtID09PSBtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0uc3RhZmZOdW0pXG5cdFx0XHRcdFx0XHR2aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtdWx0aWxpbmVWYXJzLnZvaWNlc1tpZF0uaW5kZXggPSB2aS0xO1xuXHRcdH1cblx0XHR2YXIgcyA9IG11bHRpbGluZVZhcnMuc3RhdmVzW211bHRpbGluZVZhcnMudm9pY2VzW2lkXS5zdGFmZk51bV07XG5cdFx0aWYgKCFtdWx0aWxpbmVWYXJzLnNjb3JlX2lzX3ByZXNlbnQpXG5cdFx0XHRzLm51bVZvaWNlcysrO1xuXHRcdGlmIChzdGFmZkluZm8uY2xlZikgcy5jbGVmID0ge3R5cGU6IHN0YWZmSW5mby5jbGVmLCB2ZXJ0aWNhbFBvczogc3RhZmZJbmZvLnZlcnRpY2FsUG9zfTtcblx0XHRpZiAoc3RhZmZJbmZvLnNwYWNpbmcpIHMuc3BhY2luZ19iZWxvd19vZmZzZXQgPSBzdGFmZkluZm8uc3BhY2luZztcblx0XHRpZiAoc3RhZmZJbmZvLnZlcnRpY2FsUG9zKSBzLnZlcnRpY2FsUG9zID0gc3RhZmZJbmZvLnZlcnRpY2FsUG9zO1xuXG5cdFx0aWYgKHN0YWZmSW5mby5uYW1lKSB7aWYgKHMubmFtZSkgcy5uYW1lLnB1c2goc3RhZmZJbmZvLm5hbWUpOyBlbHNlIHMubmFtZSA9IFsgc3RhZmZJbmZvLm5hbWUgXTt9XG5cdFx0aWYgKHN0YWZmSW5mby5zdWJuYW1lKSB7aWYgKHMuc3VibmFtZSkgcy5zdWJuYW1lLnB1c2goc3RhZmZJbmZvLnN1Ym5hbWUpOyBlbHNlIHMuc3VibmFtZSA9IFsgc3RhZmZJbmZvLnN1Ym5hbWUgXTt9XG5cblx0XHRzZXRDdXJyZW50Vm9pY2UoaWQpO1xuXHR9O1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlS2V5Vm9pY2U7XG4iLCIvLyAgICBhYmNfdG9rZW5pemVyLmpzOiB0b2tlbml6ZXMgYW4gQUJDIE11c2ljIE5vdGF0aW9uIHN0cmluZyB0byBzdXBwb3J0IGFiY19wYXJzZS5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IFBhdWwgUm9zZW4gKHBhdWwgYXQgcGF1bHJvc2VuIGRvdCBuZXQpXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4vYWJjX2NvbW1vbicpO1xuXG4vLyB0aGlzIGlzIGEgc2VyaWVzIG9mIGZ1bmN0aW9ucyB0aGF0IGdldCBhIHBhcnRpY3VsYXIgZWxlbWVudCBvdXQgb2YgdGhlIHBhc3NlZCBzdHJlYW0uXG4vLyB0aGUgcmV0dXJuIGlzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb25zdW1lZCwgc28gMCBtZWFucyB0aGF0IHRoZSBlbGVtZW50IHdhc24ndCBmb3VuZC5cbi8vIGFsc28gcmV0dXJuZWQgaXMgdGhlIGVsZW1lbnQgZm91bmQuIFRoaXMgbWF5IGJlIGEgZGlmZmVyZW50IGxlbmd0aCBiZWNhdXNlIHNwYWNlcyBtYXkgYmUgY29uc3VtZWQgdGhhdCBhcmVuJ3QgcGFydCBvZiB0aGUgc3RyaW5nLlxuLy8gVGhlIHJldHVybiBzdHJ1Y3R1cmUgZm9yIG1vc3QgY2FsbHMgaXMgeyBsZW46IG51bV9jaGFyc19jb25zdW1lZCwgdG9rZW46IHN0ciB9XG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2tpcFdoaXRlU3BhY2UgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdCAgaWYgKCF0aGlzLmlzV2hpdGVTcGFjZShzdHIuY2hhckF0KGkpKSlcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHIubGVuZ3RoO1x0Ly8gSXQgbXVzdCBoYXZlIGJlZW4gYWxsIHdoaXRlIHNwYWNlXG5cdH07XG5cdHZhciBmaW5pc2hlZCA9IGZ1bmN0aW9uKHN0ciwgaSkge1xuXHRcdHJldHVybiBpID49IHN0ci5sZW5ndGg7XG5cdH07XG5cdHRoaXMuZWF0V2hpdGVTcGFjZSA9IGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG5cdFx0Zm9yICh2YXIgaSA9IGluZGV4OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuXHRcdCAgaWYgKCF0aGlzLmlzV2hpdGVTcGFjZShsaW5lLmNoYXJBdChpKSkpXG5cdFx0XHRcdHJldHVybiBpLWluZGV4O1xuXHRcdH1cblx0XHRyZXR1cm4gaS1pbmRleDtcblx0fTtcblxuXHQvLyBUaGlzIGp1c3QgZ2V0cyB0aGUgYmFzaWMgcGl0Y2ggbGV0dGVyLCBpZ25vcmluZyBsZWFkaW5nIHNwYWNlcywgYW5kIG5vcm1hbGl6aW5nIGl0IHRvIGEgY2FwaXRhbFxuXHR0aGlzLmdldEtleVBpdGNoID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIGkgPSB0aGlzLnNraXBXaGl0ZVNwYWNlKHN0cik7XG5cdFx0aWYgKGZpbmlzaGVkKHN0ciwgaSkpXG5cdFx0XHRyZXR1cm4ge2xlbjogMH07XG5cdFx0c3dpdGNoIChzdHIuY2hhckF0KGkpKSB7XG5cdFx0XHRjYXNlICdBJzpyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjogJ0EnfTtcblx0XHRcdGNhc2UgJ0InOnJldHVybiB7bGVuOiBpKzEsIHRva2VuOiAnQid9O1xuXHRcdFx0Y2FzZSAnQyc6cmV0dXJuIHtsZW46IGkrMSwgdG9rZW46ICdDJ307XG5cdFx0XHRjYXNlICdEJzpyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjogJ0QnfTtcblx0XHRcdGNhc2UgJ0UnOnJldHVybiB7bGVuOiBpKzEsIHRva2VuOiAnRSd9O1xuXHRcdFx0Y2FzZSAnRic6cmV0dXJuIHtsZW46IGkrMSwgdG9rZW46ICdGJ307XG5cdFx0XHRjYXNlICdHJzpyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjogJ0cnfTtcbi8vXHRcdFx0Y2FzZSAnYSc6cmV0dXJuIHtsZW46IGkrMSwgdG9rZW46ICdBJ307XG4vL1x0XHRcdGNhc2UgJ2InOnJldHVybiB7bGVuOiBpKzEsIHRva2VuOiAnQid9O1xuLy9cdFx0XHRjYXNlICdjJzpyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjogJ0MnfTtcbi8vXHRcdFx0Y2FzZSAnZCc6cmV0dXJuIHtsZW46IGkrMSwgdG9rZW46ICdEJ307XG4vL1x0XHRcdGNhc2UgJ2UnOnJldHVybiB7bGVuOiBpKzEsIHRva2VuOiAnRSd9O1xuLy9cdFx0XHRjYXNlICdmJzpyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjogJ0YnfTtcbi8vXHRcdFx0Y2FzZSAnZyc6cmV0dXJuIHtsZW46IGkrMSwgdG9rZW46ICdHJ307XG5cdFx0fVxuXHRcdHJldHVybiB7bGVuOiAwfTtcblx0fTtcblxuXHQvLyBUaGlzIGp1c3QgZ2V0cyB0aGUgYmFzaWMgYWNjaWRlbnRhbCwgaWdub3JpbmcgbGVhZGluZyBzcGFjZXMsIGFuZCBvbmx5IHRoZSBvbmVzIHRoYXQgYXBwZWFyIGluIGEga2V5XG5cdHRoaXMuZ2V0U2hhcnBGbGF0ID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0aWYgKHN0ciA9PT0gJ2Jhc3MnKVxuXHRcdFx0cmV0dXJuIHtsZW46IDB9O1xuXHRcdHN3aXRjaCAoc3RyLmNoYXJBdCgwKSkge1xuXHRcdFx0Y2FzZSAnIyc6cmV0dXJuIHtsZW46IDEsIHRva2VuOiAnIyd9O1xuXHRcdFx0Y2FzZSAnYic6cmV0dXJuIHtsZW46IDEsIHRva2VuOiAnYid9O1xuXHRcdH1cblx0XHRyZXR1cm4ge2xlbjogMH07XG5cdH07XG5cblx0dGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0dmFyIHNraXBBbHBoYSA9IGZ1bmN0aW9uKHN0ciwgc3RhcnQpIHtcblx0XHRcdC8vIFRoaXMgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG5leHQgbm9uLWFscGhhYmV0aWMgY2hhciwgb3IgdGhlIGVudGlyZSBsZW5ndGggb2YgdGhlIHN0cmluZyBpZiBub3QgZm91bmQuXG5cdFx0ICB3aGlsZSAoc3RhcnQgPCBzdHIubGVuZ3RoICYmICgoc3RyLmNoYXJBdChzdGFydCkgPj0gJ2EnICYmIHN0ci5jaGFyQXQoc3RhcnQpIDw9ICd6JykgfHwgKHN0ci5jaGFyQXQoc3RhcnQpID49ICdBJyAmJiBzdHIuY2hhckF0KHN0YXJ0KSA8PSAnWicpKSlcblx0XHRcdFx0c3RhcnQrKztcblx0XHRcdHJldHVybiBzdGFydDtcblx0XHR9O1xuXG5cdFx0dmFyIGkgPSB0aGlzLnNraXBXaGl0ZVNwYWNlKHN0cik7XG5cdFx0aWYgKGZpbmlzaGVkKHN0ciwgaSkpXG5cdFx0XHRyZXR1cm4ge2xlbjogMH07XG5cdFx0dmFyIGZpcnN0VGhyZWUgPSBzdHIuc3Vic3RyaW5nKGksaSszKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmIChmaXJzdFRocmVlLmxlbmd0aCA+IDEgJiYgZmlyc3RUaHJlZS5jaGFyQXQoMSkgPT09ICcgJyB8fCBmaXJzdFRocmVlLmNoYXJBdCgxKSA9PT0gJ14nIHx8IGZpcnN0VGhyZWUuY2hhckF0KDEpID09PSAnXycgfHwgZmlyc3RUaHJlZS5jaGFyQXQoMSkgPT09ICc9JykgZmlyc3RUaHJlZSA9IGZpcnN0VGhyZWUuY2hhckF0KDApO1x0Ly8gVGhpcyB3aWxsIGhhbmRsZSB0aGUgY2FzZSBvZiAnbSdcblx0XHRzd2l0Y2ggKGZpcnN0VGhyZWUpIHtcblx0XHRcdGNhc2UgJ21peCc6cmV0dXJuIHtsZW46IHNraXBBbHBoYShzdHIsIGkpLCB0b2tlbjogJ01peCd9O1xuXHRcdFx0Y2FzZSAnZG9yJzpyZXR1cm4ge2xlbjogc2tpcEFscGhhKHN0ciwgaSksIHRva2VuOiAnRG9yJ307XG5cdFx0XHRjYXNlICdwaHInOnJldHVybiB7bGVuOiBza2lwQWxwaGEoc3RyLCBpKSwgdG9rZW46ICdQaHInfTtcblx0XHRcdGNhc2UgJ2x5ZCc6cmV0dXJuIHtsZW46IHNraXBBbHBoYShzdHIsIGkpLCB0b2tlbjogJ0x5ZCd9O1xuXHRcdFx0Y2FzZSAnbG9jJzpyZXR1cm4ge2xlbjogc2tpcEFscGhhKHN0ciwgaSksIHRva2VuOiAnTG9jJ307XG5cdFx0XHRjYXNlICdhZW8nOnJldHVybiB7bGVuOiBza2lwQWxwaGEoc3RyLCBpKSwgdG9rZW46ICdtJ307XG5cdFx0XHRjYXNlICdtYWonOnJldHVybiB7bGVuOiBza2lwQWxwaGEoc3RyLCBpKSwgdG9rZW46ICcnfTtcblx0XHRcdGNhc2UgJ2lvbic6cmV0dXJuIHtsZW46IHNraXBBbHBoYShzdHIsIGkpLCB0b2tlbjogJyd9O1xuXHRcdFx0Y2FzZSAnbWluJzpyZXR1cm4ge2xlbjogc2tpcEFscGhhKHN0ciwgaSksIHRva2VuOiAnbSd9O1xuXHRcdFx0Y2FzZSAnbSc6cmV0dXJuIHtsZW46IHNraXBBbHBoYShzdHIsIGkpLCB0b2tlbjogJ20nfTtcblx0XHR9XG5cdFx0cmV0dXJuIHtsZW46IDB9O1xuXHR9O1xuXG5cdHRoaXMuZ2V0Q2xlZiA9IGZ1bmN0aW9uKHN0ciwgYkV4cGxpY2l0T25seSkge1xuXHRcdHZhciBzdHJPcmlnID0gc3RyO1xuXHRcdHZhciBpID0gdGhpcy5za2lwV2hpdGVTcGFjZShzdHIpO1xuXHRcdGlmIChmaW5pc2hlZChzdHIsIGkpKVxuXHRcdFx0cmV0dXJuIHtsZW46IDB9O1xuXHRcdC8vIFRoZSB3b3JkICdjbGVmJyBpcyBvcHRpb25hbCwgYnV0IGlmIGl0IGFwcGVhcnMsIGEgY2xlZiBNVVNUIGFwcGVhclxuXHRcdHZhciBuZWVkc0NsZWYgPSBmYWxzZTtcblx0XHR2YXIgc3RyQ2xlZiA9IHN0ci5zdWJzdHJpbmcoaSk7XG5cdFx0aWYgKHBhcnNlQ29tbW9uLnN0YXJ0c1dpdGgoc3RyQ2xlZiwgJ2NsZWY9JykpIHtcblx0XHRcdG5lZWRzQ2xlZiA9IHRydWU7XG5cdFx0XHRzdHJDbGVmID0gc3RyQ2xlZi5zdWJzdHJpbmcoNSk7XG5cdFx0XHRpICs9IDU7XG5cdFx0fVxuXHRcdGlmIChzdHJDbGVmLmxlbmd0aCA9PT0gMCAmJiBuZWVkc0NsZWYpXG5cdFx0XHRyZXR1cm4ge2xlbjogaSs1LCB3YXJuOiBcIk5vIGNsZWYgc3BlY2lmaWVkOiBcIiArIHN0ck9yaWd9O1xuXG5cdFx0dmFyIGogPSB0aGlzLnNraXBXaGl0ZVNwYWNlKHN0ckNsZWYpO1xuXHRcdGlmIChmaW5pc2hlZChzdHJDbGVmLCBqKSlcblx0XHRcdHJldHVybiB7bGVuOiAwfTtcblx0XHRpZiAoaiA+IDApIHtcblx0XHRcdGkgKz0gajtcblx0XHRcdHN0ckNsZWYgPSBzdHJDbGVmLnN1YnN0cmluZyhqKTtcblx0XHR9XG5cdFx0dmFyIG5hbWUgPSBudWxsO1xuXHRcdGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKHN0ckNsZWYsICd0cmVibGUnKSlcblx0XHRcdG5hbWUgPSAndHJlYmxlJztcblx0XHRlbHNlIGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKHN0ckNsZWYsICdiYXNzMycpKVxuXHRcdFx0bmFtZSA9ICdiYXNzMyc7XG5cdFx0ZWxzZSBpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChzdHJDbGVmLCAnYmFzcycpKVxuXHRcdFx0bmFtZSA9ICdiYXNzJztcblx0XHRlbHNlIGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKHN0ckNsZWYsICd0ZW5vcicpKVxuXHRcdFx0bmFtZSA9ICd0ZW5vcic7XG5cdFx0ZWxzZSBpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChzdHJDbGVmLCAnYWx0bzInKSlcblx0XHRcdG5hbWUgPSAnYWx0bzInO1xuXHRcdGVsc2UgaWYgKHBhcnNlQ29tbW9uLnN0YXJ0c1dpdGgoc3RyQ2xlZiwgJ2FsdG8xJykpXG5cdFx0XHRuYW1lID0gJ2FsdG8xJztcblx0XHRlbHNlIGlmIChwYXJzZUNvbW1vbi5zdGFydHNXaXRoKHN0ckNsZWYsICdhbHRvJykpXG5cdFx0XHRuYW1lID0gJ2FsdG8nO1xuXHRcdGVsc2UgaWYgKCFiRXhwbGljaXRPbmx5ICYmIChuZWVkc0NsZWYgJiYgcGFyc2VDb21tb24uc3RhcnRzV2l0aChzdHJDbGVmLCAnbm9uZScpKSlcblx0XHRcdG5hbWUgPSAnbm9uZSc7XG5cdFx0ZWxzZSBpZiAocGFyc2VDb21tb24uc3RhcnRzV2l0aChzdHJDbGVmLCAncGVyYycpKVxuXHRcdFx0bmFtZSA9ICdwZXJjJztcblx0XHRlbHNlIGlmICghYkV4cGxpY2l0T25seSAmJiAobmVlZHNDbGVmICYmIHBhcnNlQ29tbW9uLnN0YXJ0c1dpdGgoc3RyQ2xlZiwgJ0MnKSkpXG5cdFx0XHRuYW1lID0gJ3Rlbm9yJztcblx0XHRlbHNlIGlmICghYkV4cGxpY2l0T25seSAmJiAobmVlZHNDbGVmICYmIHBhcnNlQ29tbW9uLnN0YXJ0c1dpdGgoc3RyQ2xlZiwgJ0YnKSkpXG5cdFx0XHRuYW1lID0gJ2Jhc3MnO1xuXHRcdGVsc2UgaWYgKCFiRXhwbGljaXRPbmx5ICYmIChuZWVkc0NsZWYgJiYgcGFyc2VDb21tb24uc3RhcnRzV2l0aChzdHJDbGVmLCAnRycpKSlcblx0XHRcdG5hbWUgPSAndHJlYmxlJztcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4ge2xlbjogaSs1LCB3YXJuOiBcIlVua25vd24gY2xlZiBzcGVjaWZpZWQ6IFwiICsgc3RyT3JpZ307XG5cblx0XHRzdHJDbGVmID0gc3RyQ2xlZi5zdWJzdHJpbmcobmFtZS5sZW5ndGgpO1xuXHRcdGogPSB0aGlzLmlzTWF0Y2goc3RyQ2xlZiwgJys4Jyk7XG5cdFx0aWYgKGogPiAwKVxuXHRcdFx0bmFtZSArPSBcIis4XCI7XG5cdFx0ZWxzZSB7XG5cdFx0XHRqID0gdGhpcy5pc01hdGNoKHN0ckNsZWYsICctOCcpO1xuXHRcdFx0aWYgKGogPiAwKVxuXHRcdFx0XHRuYW1lICs9IFwiLThcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHtsZW46IGkrbmFtZS5sZW5ndGgsIHRva2VuOiBuYW1lLCBleHBsaWNpdDogbmVlZHNDbGVmfTtcblx0fTtcblxuXHQvLyBUaGlzIHJldHVybnMgb25lIG9mIHRoZSBsZWdhbCBiYXIgbGluZXNcblx0Ly8gVGhpcyBpcyBjYWxsZWQgYWxvdCBhbmQgdGhlcmUgaXMgbm8gb2J2aW91cyB0b2tlbmFibGUgaXRlbXMsIHNvIHRoaXMgaXMgYnJva2VuIGFwYXJ0LlxuXHR0aGlzLmdldEJhckxpbmUgPSBmdW5jdGlvbihsaW5lLCBpKSB7XG5cdFx0c3dpdGNoIChsaW5lLmNoYXJBdChpKSkge1xuXHRcdFx0Y2FzZSAnXSc6XG5cdFx0XHRcdCsraTtcblx0XHRcdFx0c3dpdGNoIChsaW5lLmNoYXJBdChpKSkge1xuXHRcdFx0XHRcdGNhc2UgJ3wnOiByZXR1cm4ge2xlbjogMiwgdG9rZW46IFwiYmFyX3RoaWNrX3RoaW5cIn07XG5cdFx0XHRcdFx0Y2FzZSAnWyc6XG5cdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRpZiAoKGxpbmUuY2hhckF0KGkpID49ICcxJyAmJiBsaW5lLmNoYXJBdChpKSA8PSAnOScpIHx8IGxpbmUuY2hhckF0KGkpID09PSAnXCInKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge2xlbjogMiwgdG9rZW46IFwiYmFyX2ludmlzaWJsZVwifTtcblx0XHRcdFx0XHRcdHJldHVybiB7bGVuOiAxLCB3YXJuOiBcIlVua25vd24gYmFyIHN5bWJvbFwifTtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHtsZW46IDEsIHRva2VuOiBcImJhcl9pbnZpc2libGVcIn07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICc6Jzpcblx0XHRcdFx0KytpO1xuXHRcdFx0XHRzd2l0Y2ggKGxpbmUuY2hhckF0KGkpKSB7XG5cdFx0XHRcdFx0Y2FzZSAnOic6IHJldHVybiB7bGVuOiAyLCB0b2tlbjogXCJiYXJfZGJsX3JlcGVhdFwifTtcblx0XHRcdFx0XHRjYXNlICd8JzpcdC8vIDp8XG5cdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGxpbmUuY2hhckF0KGkpKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ10nOlx0Ly8gOnxdXG5cdFx0XHRcdFx0XHRcdFx0KytpO1xuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAobGluZS5jaGFyQXQoaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3wnOlx0Ly8gOnxdfFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lLmNoYXJBdChpKSA9PT0gJzonKSAgcmV0dXJuIHtsZW46IDUsIHRva2VuOiBcImJhcl9kYmxfcmVwZWF0XCJ9O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4ge2xlbjogMywgdG9rZW46IFwiYmFyX3JpZ2h0X3JlcGVhdFwifTtcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB7bGVuOiAzLCB0b2tlbjogXCJiYXJfcmlnaHRfcmVwZWF0XCJ9O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnfCc6XHQvLyA6fHxcblx0XHRcdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KGkpID09PSAnOicpICByZXR1cm4ge2xlbjogNCwgdG9rZW46IFwiYmFyX2RibF9yZXBlYXRcIn07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtsZW46IDMsIHRva2VuOiBcImJhcl9yaWdodF9yZXBlYXRcIn07XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtsZW46IDIsIHRva2VuOiBcImJhcl9yaWdodF9yZXBlYXRcIn07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIHtsZW46IDEsIHdhcm46IFwiVW5rbm93biBiYXIgc3ltYm9sXCJ9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWyc6XHQvLyBbXG5cdFx0XHRcdCsraTtcblx0XHRcdFx0aWYgKGxpbmUuY2hhckF0KGkpID09PSAnfCcpIHtcdC8vIFt8XG5cdFx0XHRcdFx0KytpO1xuXHRcdFx0XHRcdHN3aXRjaCAobGluZS5jaGFyQXQoaSkpIHtcblx0XHRcdFx0XHRcdGNhc2UgJzonOiByZXR1cm4ge2xlbjogMywgdG9rZW46IFwiYmFyX2xlZnRfcmVwZWF0XCJ9O1xuXHRcdFx0XHRcdFx0Y2FzZSAnXSc6IHJldHVybiB7bGVuOiAzLCB0b2tlbjogXCJiYXJfaW52aXNpYmxlXCJ9O1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIHtsZW46IDIsIHRva2VuOiBcImJhcl90aGlja190aGluXCJ9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoKGxpbmUuY2hhckF0KGkpID49ICcxJyAmJiBsaW5lLmNoYXJBdChpKSA8PSAnOScpIHx8IGxpbmUuY2hhckF0KGkpID09PSAnXCInKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHtsZW46IDEsIHRva2VuOiBcImJhcl9pbnZpc2libGVcIn07XG5cdFx0XHRcdFx0cmV0dXJuIHtsZW46IDB9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnfCc6XHQvLyB8XG5cdFx0XHRcdCsraTtcblx0XHRcdFx0c3dpdGNoIChsaW5lLmNoYXJBdChpKSkge1xuXHRcdFx0XHRcdGNhc2UgJ10nOiByZXR1cm4ge2xlbjogMiwgdG9rZW46IFwiYmFyX3RoaW5fdGhpY2tcIn07XG5cdFx0XHRcdFx0Y2FzZSAnfCc6IC8vIHx8XG5cdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRpZiAobGluZS5jaGFyQXQoaSkgPT09ICc6JykgcmV0dXJuIHtsZW46IDMsIHRva2VuOiBcImJhcl9sZWZ0X3JlcGVhdFwifTtcblx0XHRcdFx0XHRcdHJldHVybiB7bGVuOiAyLCB0b2tlbjogXCJiYXJfdGhpbl90aGluXCJ9O1xuXHRcdFx0XHRcdGNhc2UgJzonOlx0Ly8gfDpcblx0XHRcdFx0XHRcdHZhciBjb2xvbnMgPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGxpbmUuY2hhckF0KGkrY29sb25zKSA9PT0gJzonKSBjb2xvbnMrKztcblx0XHRcdFx0XHRcdHJldHVybiB7IGxlbjogMStjb2xvbnMsIHRva2VuOiBcImJhcl9sZWZ0X3JlcGVhdFwifTtcblx0XHRcdFx0XHRkZWZhdWx0OiByZXR1cm4ge2xlbjogMSwgdG9rZW46IFwiYmFyX3RoaW5cIn07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiB7bGVuOiAwfTtcblx0fTtcblxuXHQvLyB0aGlzIHJldHVybnMgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBtYXRjaCBvbmUgb2YgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGxlZ2FsQ2hhcnMgc3RyaW5nXG5cdHRoaXMuZ2V0VG9rZW5PZiA9IGZ1bmN0aW9uKHN0ciwgbGVnYWxDaGFycykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAobGVnYWxDaGFycy5pbmRleE9mKHN0ci5jaGFyQXQoaSkpIDwgMClcblx0XHRcdFx0cmV0dXJuIHtsZW46IGksIHRva2VuOiBzdHIuc3Vic3RyaW5nKDAsIGkpfTtcblx0XHR9XG5cdFx0cmV0dXJuIHtsZW46IGksIHRva2VuOiBzdHJ9O1xuXHR9O1xuXG5cdHRoaXMuZ2V0VG9rZW4gPSBmdW5jdGlvbihzdHIsIHN0YXJ0LCBlbmQpIHtcblx0XHQvLyBUaGlzIHJldHVybnMgdGhlIG5leHQgc2V0IG9mIGNoYXJzIHRoYXQgZG9lc24ndCBjb250YWluIHNwYWNlc1xuXHRcdHZhciBpID0gc3RhcnQ7XG5cdFx0d2hpbGUgKGkgPCBlbmQgJiYgIXRoaXMuaXNXaGl0ZVNwYWNlKHN0ci5jaGFyQXQoaSkpKVxuXHRcdFx0aSsrO1xuXHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcblx0fTtcblxuXHQvLyBUaGlzIGp1c3Qgc2VlcyBpZiB0aGUgbmV4dCB0b2tlbiBpcyB0aGUgd29yZCBwYXNzZWQgaW4sIHdpdGggcG9zc2libGUgbGVhZGluZyBzcGFjZXNcblx0dGhpcy5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBtYXRjaCkge1xuXHRcdHZhciBpID0gdGhpcy5za2lwV2hpdGVTcGFjZShzdHIpO1xuXHRcdGlmIChmaW5pc2hlZChzdHIsIGkpKVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0aWYgKHBhcnNlQ29tbW9uLnN0YXJ0c1dpdGgoc3RyLnN1YnN0cmluZyhpKSwgbWF0Y2gpKVxuXHRcdFx0cmV0dXJuIGkrbWF0Y2gubGVuZ3RoO1xuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdHRoaXMuZ2V0UGl0Y2hGcm9tVG9rZW5zID0gZnVuY3Rpb24odG9rZW5zKSB7XG5cdFx0dmFyIHJldCA9IHsgfTtcblx0XHR2YXIgcGl0Y2hlcyA9IHtBOiA1LCBCOiA2LCBDOiAwLCBEOiAxLCBFOiAyLCBGOiAzLCBHOiA0LCBhOiAxMiwgYjogMTMsIGM6IDcsIGQ6IDgsIGU6IDksIGY6IDEwLCBnOiAxMX07XG5cdFx0cmV0LnBvc2l0aW9uID0gcGl0Y2hlc1t0b2tlbnNbMF0udG9rZW5dO1xuXHRcdGlmIChyZXQucG9zaXRpb24gPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiB7IHdhcm46IFwiUGl0Y2ggZXhwZWN0ZWQuIEZvdW5kOiBcIiArIHRva2Vuc1swXS50b2tlbiB9O1xuXHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG5cdFx0XHRzd2l0Y2ggKHRva2Vuc1swXS50b2tlbikge1xuXHRcdFx0XHRjYXNlICcsJzogcmV0LnBvc2l0aW9uIC09IDc7IHRva2Vucy5zaGlmdCgpOyBicmVhaztcblx0XHRcdFx0Y2FzZSAnXFwnJzogcmV0LnBvc2l0aW9uICs9IDc7IHRva2Vucy5zaGlmdCgpOyBicmVhaztcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXHR0aGlzLmdldEtleUFjY2lkZW50YWxzMiA9IGZ1bmN0aW9uKHRva2Vucykge1xuXHRcdHZhciBhY2NzO1xuXHRcdC8vIGZpbmQgYW5kIHN0cmlwIG9mZiBhbGwgYWNjaWRlbnRhbHMgaW4gdGhlIHRva2VuIGxpc3Rcblx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBhY2M7XG5cdFx0XHRpZiAodG9rZW5zWzBdLnRva2VuID09PSAnXicpIHtcblx0XHRcdFx0YWNjID0gJ3NoYXJwJztcblx0XHRcdFx0dG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSByZXR1cm4ge2FjY3M6IGFjY3MsIHdhcm46ICdFeHBlY3RlZCBub3RlIG5hbWUgYWZ0ZXIgJyArIGFjY307XG5cdFx0XHRcdHN3aXRjaCAodG9rZW5zWzBdLnRva2VuKSB7XG5cdFx0XHRcdFx0Y2FzZSAnXic6IGFjYyA9ICdkYmxzaGFycCc7IHRva2Vucy5zaGlmdCgpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICcvJzogYWNjID0gJ3F1YXJ0ZXJzaGFycCc7IHRva2Vucy5zaGlmdCgpOyBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbMF0udG9rZW4gPT09ICc9Jykge1xuXHRcdFx0XHRhY2MgPSAnbmF0dXJhbCc7XG5cdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbMF0udG9rZW4gPT09ICdfJykge1xuXHRcdFx0XHRhY2MgPSAnZmxhdCc7XG5cdFx0XHRcdHRva2Vucy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHthY2NzOiBhY2NzLCB3YXJuOiAnRXhwZWN0ZWQgbm90ZSBuYW1lIGFmdGVyICcgKyBhY2N9O1xuXHRcdFx0XHRzd2l0Y2ggKHRva2Vuc1swXS50b2tlbikge1xuXHRcdFx0XHRcdGNhc2UgJ18nOiBhY2MgPSAnZGJsZmxhdCc7IHRva2Vucy5zaGlmdCgpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICcvJzogYWNjID0gJ3F1YXJ0ZXJmbGF0JzsgdG9rZW5zLnNoaWZ0KCk7IGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBOb3QgYW4gYWNjaWRlbnRhbCwgd2UnbGwgYXNzdW1lIHRoYXQgYSBsYXRlciBwYXJzZSB3aWxsIHJlY29nbml6ZSBpdC5cblx0XHRcdFx0cmV0dXJuIHsgYWNjczogYWNjcyB9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHJldHVybiB7YWNjczogYWNjcywgd2FybjogJ0V4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciAnICsgYWNjfTtcblx0XHRcdHN3aXRjaCAodG9rZW5zWzBdLnRva2VuLmNoYXJBdCgwKSlcblx0XHRcdHtcblx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGNhc2UgJ2InOlxuXHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdGNhc2UgJ2UnOlxuXHRcdFx0XHRjYXNlICdmJzpcblx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRjYXNlICdCJzpcblx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdGNhc2UgJ0QnOlxuXHRcdFx0XHRjYXNlICdFJzpcblx0XHRcdFx0Y2FzZSAnRic6XG5cdFx0XHRcdGNhc2UgJ0cnOlxuXHRcdFx0XHRcdGlmIChhY2NzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRhY2NzID0gW107XG5cdFx0XHRcdFx0YWNjcy5wdXNoKHsgYWNjOiBhY2MsIG5vdGU6IHRva2Vuc1swXS50b2tlbi5jaGFyQXQoMCkgfSk7XG5cdFx0XHRcdFx0aWYgKHRva2Vuc1swXS50b2tlbi5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR0b2tlbnNbMF0udG9rZW4gPSB0b2tlbnNbMF0udG9rZW4uc3Vic3RyaW5nKDEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiB7YWNjczogYWNjcywgd2FybjogJ0V4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciAnICsgYWNjICsgJyBGb3VuZDogJyArIHRva2Vuc1swXS50b2tlbiB9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4geyBhY2NzOiBhY2NzIH07XG5cdH07XG5cblx0Ly8gVGhpcyBnZXRzIGFuIGFjY2lkZW50YWwgbWFya2luZyBmb3IgdGhlIGtleSBzaWduYXR1cmUuIEl0IGhhcyB0aGUgYWNjaWRlbnRhbCB0aGVuIHRoZSBwaXRjaCBsZXR0ZXIuXG5cdHRoaXMuZ2V0S2V5QWNjaWRlbnRhbCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBhY2NUcmFuc2xhdGlvbiA9IHtcblx0XHRcdCdeJzogJ3NoYXJwJyxcblx0XHRcdCdeXic6ICdkYmxzaGFycCcsXG5cdFx0XHQnPSc6ICduYXR1cmFsJyxcblx0XHRcdCdfJzogJ2ZsYXQnLFxuXHRcdFx0J19fJzogJ2RibGZsYXQnLFxuXHRcdFx0J18vJzogJ3F1YXJ0ZXJmbGF0Jyxcblx0XHRcdCdeLyc6ICdxdWFydGVyc2hhcnAnXG5cdFx0fTtcblx0XHR2YXIgaSA9IHRoaXMuc2tpcFdoaXRlU3BhY2Uoc3RyKTtcblx0XHRpZiAoZmluaXNoZWQoc3RyLCBpKSlcblx0XHRcdHJldHVybiB7bGVuOiAwfTtcblx0XHR2YXIgYWNjID0gbnVsbDtcblx0XHRzd2l0Y2ggKHN0ci5jaGFyQXQoaSkpXG5cdFx0e1xuXHRcdFx0Y2FzZSAnXic6XG5cdFx0XHRjYXNlICdfJzpcblx0XHRcdGNhc2UgJz0nOlxuXHRcdFx0XHRhY2MgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6cmV0dXJuIHtsZW46IDB9O1xuXHRcdH1cblx0XHRpKys7XG5cdFx0aWYgKGZpbmlzaGVkKHN0ciwgaSkpXG5cdFx0XHRyZXR1cm4ge2xlbjogMSwgd2FybjogJ0V4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciBhY2NpZGVudGFsJ307XG5cdFx0c3dpdGNoIChzdHIuY2hhckF0KGkpKVxuXHRcdHtcblx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0Y2FzZSAnZSc6XG5cdFx0XHRjYXNlICdmJzpcblx0XHRcdGNhc2UgJ2cnOlxuXHRcdFx0Y2FzZSAnQSc6XG5cdFx0XHRjYXNlICdCJzpcblx0XHRcdGNhc2UgJ0MnOlxuXHRcdFx0Y2FzZSAnRCc6XG5cdFx0XHRjYXNlICdFJzpcblx0XHRcdGNhc2UgJ0YnOlxuXHRcdFx0Y2FzZSAnRyc6XG5cdFx0XHRcdHJldHVybiB7bGVuOiBpKzEsIHRva2VuOiB7YWNjOiBhY2NUcmFuc2xhdGlvblthY2NdLCBub3RlOiBzdHIuY2hhckF0KGkpfX07XG5cdFx0XHRjYXNlICdeJzpcblx0XHRcdGNhc2UgJ18nOlxuXHRcdFx0Y2FzZSAnLyc6XG5cdFx0XHRcdGFjYyArPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0XHRpKys7XG5cdFx0XHRcdGlmIChmaW5pc2hlZChzdHIsIGkpKVxuXHRcdFx0XHRcdHJldHVybiB7bGVuOiAyLCB3YXJuOiAnRXhwZWN0ZWQgbm90ZSBuYW1lIGFmdGVyIGFjY2lkZW50YWwnfTtcblx0XHRcdFx0c3dpdGNoIChzdHIuY2hhckF0KGkpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0Y2FzZSAnZSc6XG5cdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0Y2FzZSAnQSc6XG5cdFx0XHRcdFx0Y2FzZSAnQic6XG5cdFx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdFx0Y2FzZSAnRCc6XG5cdFx0XHRcdFx0Y2FzZSAnRSc6XG5cdFx0XHRcdFx0Y2FzZSAnRic6XG5cdFx0XHRcdFx0Y2FzZSAnRyc6XG5cdFx0XHRcdFx0XHRyZXR1cm4ge2xlbjogaSsxLCB0b2tlbjoge2FjYzogYWNjVHJhbnNsYXRpb25bYWNjXSwgbm90ZTogc3RyLmNoYXJBdChpKX19O1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4ge2xlbjogMiwgd2FybjogJ0V4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciBhY2NpZGVudGFsJ307XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4ge2xlbjogMSwgd2FybjogJ0V4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciBhY2NpZGVudGFsJ307XG5cdFx0fVxuXHR9O1xuXG5cdHRoaXMuaXNXaGl0ZVNwYWNlID0gZnVuY3Rpb24oY2gpIHtcblx0XHRyZXR1cm4gY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXHgxMic7XG5cdH07XG5cblx0dGhpcy5nZXRNZWF0ID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGVuZCkge1xuXHRcdC8vIFRoaXMgcmVtb3ZlcyBhbnkgY29tbWVudHMgc3RhcnRpbmcgd2l0aCAnJScgYW5kIHRyaW1zIHRoZSBlbmRzIG9mIHRoZSBzdHJpbmcgc28gdGhhdCB0aGVyZSBhcmUgbm8gbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMuXG5cdFx0Ly8gaXQgcmV0dXJucyBqdXN0IHRoZSBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgdGhhdCBjb250YWluIHRoZSBtZWF0LlxuXHRcdHZhciBjb21tZW50ID0gbGluZS5pbmRleE9mKCclJywgc3RhcnQpO1xuXHRcdGlmIChjb21tZW50ID49IDAgJiYgY29tbWVudCA8IGVuZClcblx0XHRcdGVuZCA9IGNvbW1lbnQ7XG5cdFx0d2hpbGUgKHN0YXJ0IDwgZW5kICYmIChsaW5lLmNoYXJBdChzdGFydCkgPT09ICcgJyB8fCBsaW5lLmNoYXJBdChzdGFydCkgPT09ICdcXHQnIHx8IGxpbmUuY2hhckF0KHN0YXJ0KSA9PT0gJ1xceDEyJykpXG5cdFx0XHRzdGFydCsrO1xuXHRcdHdoaWxlIChzdGFydCA8IGVuZCAmJiAobGluZS5jaGFyQXQoZW5kLTEpID09PSAnICcgfHwgbGluZS5jaGFyQXQoZW5kLTEpID09PSAnXFx0JyB8fCBsaW5lLmNoYXJBdChlbmQtMSkgPT09ICdcXHgxMicpKVxuXHRcdFx0ZW5kLS07XG5cdFx0cmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfTtcblx0fTtcblxuXHR2YXIgaXNMZXR0ZXIgPSBmdW5jdGlvbihjaCkge1xuXHRcdHJldHVybiAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHwgKGNoID49ICdhJyAmJiBjaCA8PSAneicpO1xuXHR9O1xuXG5cdHZhciBpc051bWJlciA9IGZ1bmN0aW9uKGNoKSB7XG5cdFx0cmV0dXJuIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKTtcblx0fTtcblxuXHR0aGlzLnRva2VuaXplID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGVuZCwgYWxwaGFVbnRpbFdoaXRlU3BhY2UpIHtcblx0XHQvLyB0aGlzIHJldHVybnMgYWxsIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBwYXNzZWQgc3RyaW5nLiBBIHRva2VuIGlzIGEgcHVuY3R1YXRpb24gbWFyaywgYSBzdHJpbmcgb2YgZGlnaXRzLCBhIHN0cmluZyBvZiBsZXR0ZXJzLlxuXHRcdC8vICBRdW90ZWQgc3RyaW5ncyBhcmUgb25lIHRva2VuLlxuXHRcdC8vICBJZiB0aGVyZSBpcyBhIG1pbnVzIHNpZ24gbmV4dCB0byBhIG51bWJlciwgdGhlbiBpdCBpcyBpbmNsdWRlZCBpbiB0aGUgbnVtYmVyLlxuXHRcdC8vIElmIHRoZXJlIGlzIGEgcGVyaW9kIGltbWVkaWF0ZWx5IGFmdGVyIGEgbnVtYmVyLCB3aXRoIGEgbnVtYmVyIGltbWVkaWF0ZWx5IGZvbGxvd2luZywgdGhlbiBhIGZsb2F0IGlzIHJldHVybmVkLlxuXHRcdC8vIFRoZSB0eXBlIG9mIHRva2VuIGlzIHJldHVybmVkOiBxdW90ZSwgYWxwaGEsIG51bWJlciwgcHVuY3Rcblx0XHQvLyBJZiBhbHBoYVVudGlsV2hpdGVTcGFjZSBpcyB0cnVlLCB0aGVuIHRoZSBiZWhhdmlvciBvZiB0aGUgYWxwaGEgdG9rZW4gY2hhbmdlcy5cblxuXHRcdHZhciByZXQgPSB0aGlzLmdldE1lYXQobGluZSwgc3RhcnQsIGVuZCk7XG5cdFx0c3RhcnQgPSByZXQuc3RhcnQ7XG5cdFx0ZW5kID0gcmV0LmVuZDtcblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0dmFyIGk7XG5cdFx0d2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG5cdFx0XHRpZiAobGluZS5jaGFyQXQoc3RhcnQpID09PSAnXCInKSB7XG5cdFx0XHRcdGkgPSBzdGFydCsxO1xuXHRcdFx0XHR3aGlsZSAoaSA8IGVuZCAmJiBsaW5lLmNoYXJBdChpKSAhPT0gJ1wiJykgaSsrO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7IHR5cGU6ICdxdW90ZScsIHRva2VuOiBsaW5lLnN1YnN0cmluZyhzdGFydCsxLCBpKSwgc3RhcnQ6IHN0YXJ0KzEsIGVuZDogaX0pO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9IGVsc2UgaWYgKGlzTGV0dGVyKGxpbmUuY2hhckF0KHN0YXJ0KSkpIHtcblx0XHRcdFx0aSA9IHN0YXJ0KzE7XG5cdFx0XHRcdGlmIChhbHBoYVVudGlsV2hpdGVTcGFjZSlcblx0XHRcdFx0XHR3aGlsZSAoaSA8IGVuZCAmJiAhdGhpcy5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoaSkpKSBpKys7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR3aGlsZSAoaSA8IGVuZCAmJiBpc0xldHRlcihsaW5lLmNoYXJBdChpKSkpIGkrKztcblx0XHRcdFx0dG9rZW5zLnB1c2goeyB0eXBlOiAnYWxwaGEnLCB0b2tlbjogbGluZS5zdWJzdHJpbmcoc3RhcnQsIGkpLCBjb250aW51ZUlkOiBpc051bWJlcihsaW5lLmNoYXJBdChpKSksIHN0YXJ0OiBzdGFydCwgZW5kOiBpfSk7XG5cdFx0XHRcdHN0YXJ0ID0gaSArIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGxpbmUuY2hhckF0KHN0YXJ0KSA9PT0gJy4nICYmIGlzTnVtYmVyKGxpbmUuY2hhckF0KGkrMSkpKSB7XG5cdFx0XHRcdGkgPSBzdGFydCsxO1xuXHRcdFx0XHR2YXIgaW50MiA9IG51bGw7XG5cdFx0XHRcdHZhciBmbG9hdDIgPSBudWxsO1xuXHRcdFx0XHR3aGlsZSAoaSA8IGVuZCAmJiBpc051bWJlcihsaW5lLmNoYXJBdChpKSkpIGkrKztcblxuXHRcdFx0XHRmbG9hdDIgPSBwYXJzZUZsb2F0KGxpbmUuc3Vic3RyaW5nKHN0YXJ0LCBpKSk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHsgdHlwZTogJ251bWJlcicsIHRva2VuOiBsaW5lLnN1YnN0cmluZyhzdGFydCwgaSksIGludHQ6IGludDIsIGZsb2F0dDogZmxvYXQyLCBjb250aW51ZUlkOiBpc0xldHRlcihsaW5lLmNoYXJBdChpKSksIHN0YXJ0OiBzdGFydCwgZW5kOiBpfSk7XG5cdFx0XHRcdHN0YXJ0ID0gaSArIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGxpbmUuY2hhckF0KHN0YXJ0KSkgfHwgKGxpbmUuY2hhckF0KHN0YXJ0KSA9PT0gJy0nICYmIGlzTnVtYmVyKGxpbmUuY2hhckF0KGkrMSkpKSkge1xuXHRcdFx0XHRpID0gc3RhcnQrMTtcblx0XHRcdFx0dmFyIGludHQgPSBudWxsO1xuXHRcdFx0XHR2YXIgZmxvYXR0ID0gbnVsbDtcblx0XHRcdFx0d2hpbGUgKGkgPCBlbmQgJiYgaXNOdW1iZXIobGluZS5jaGFyQXQoaSkpKSBpKys7XG5cdFx0XHRcdGlmIChsaW5lLmNoYXJBdChpKSA9PT0gJy4nICYmIGlzTnVtYmVyKGxpbmUuY2hhckF0KGkrMSkpKSB7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdHdoaWxlIChpIDwgZW5kICYmIGlzTnVtYmVyKGxpbmUuY2hhckF0KGkpKSkgaSsrO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRpbnR0ID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoc3RhcnQsIGkpKTtcblxuXHRcdFx0XHRmbG9hdHQgPSBwYXJzZUZsb2F0KGxpbmUuc3Vic3RyaW5nKHN0YXJ0LCBpKSk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHsgdHlwZTogJ251bWJlcicsIHRva2VuOiBsaW5lLnN1YnN0cmluZyhzdGFydCwgaSksIGludHQ6IGludHQsIGZsb2F0dDogZmxvYXR0LCBjb250aW51ZUlkOiBpc0xldHRlcihsaW5lLmNoYXJBdChpKSksIHN0YXJ0OiBzdGFydCwgZW5kOiBpfSk7XG5cdFx0XHRcdHN0YXJ0ID0gaSArIDE7XG5cdFx0XHR9IGVsc2UgaWYgKGxpbmUuY2hhckF0KHN0YXJ0KSA9PT0gJyAnIHx8IGxpbmUuY2hhckF0KHN0YXJ0KSA9PT0gJ1xcdCcpIHtcblx0XHRcdFx0aSA9IHN0YXJ0KzE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7IHR5cGU6ICdwdW5jdCcsIHRva2VuOiBsaW5lLmNoYXJBdChzdGFydCksIHN0YXJ0OiBzdGFydCwgZW5kOiBzdGFydCsxfSk7XG5cdFx0XHRcdGkgPSBzdGFydCsxO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBpO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9rZW5zO1xuXHR9O1xuXG5cdHRoaXMuZ2V0Vm9pY2VUb2tlbiA9IGZ1bmN0aW9uKGxpbmUsIHN0YXJ0LCBlbmQpIHtcblx0XHQvLyBUaGlzIGZpbmRzIHRoZSBuZXh0IHRva2VuLiBBIHRva2VuIGlzIGRlbGltaXRlZCBieSBhIHNwYWNlIG9yIGFuIGVxdWFsIHNpZ24uIElmIGl0IHN0YXJ0cyB3aXRoIGEgcXVvdGUsIHRoZW4gdGhlIHBvcnRpb24gYmV0d2VlbiB0aGUgcXVvdGVzIGlzIHJldHVybmVkLlxuXHRcdHZhciBpID0gc3RhcnQ7XG5cdFx0d2hpbGUgKGkgPCBlbmQgJiYgdGhpcy5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoaSkpIHx8IGxpbmUuY2hhckF0KGkpID09PSAnPScpXG5cdFx0XHRpKys7XG5cblx0XHRpZiAobGluZS5jaGFyQXQoaSkgPT09ICdcIicpIHtcblx0XHRcdHZhciBjbG9zZSA9IGxpbmUuaW5kZXhPZignXCInLCBpKzEpO1xuXHRcdFx0aWYgKGNsb3NlID09PSAtMSB8fCBjbG9zZSA+PSBlbmQpXG5cdFx0XHRcdHJldHVybiB7bGVuOiAxLCBlcnI6IFwiTWlzc2luZyBjbG9zZSBxdW90ZVwifTtcblx0XHRcdHJldHVybiB7bGVuOiBjbG9zZS1zdGFydCsxLCB0b2tlbjogdGhpcy50cmFuc2xhdGVTdHJpbmcobGluZS5zdWJzdHJpbmcoaSsxLCBjbG9zZSkpfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGlpID0gaTtcblx0XHRcdHdoaWxlIChpaSA8IGVuZCAmJiAhdGhpcy5pc1doaXRlU3BhY2UobGluZS5jaGFyQXQoaWkpKSAmJiBsaW5lLmNoYXJBdChpaSkgIT09ICc9Jylcblx0XHRcdFx0aWkrKztcblx0XHRcdHJldHVybiB7bGVuOiBpaS1zdGFydCsxLCB0b2tlbjogbGluZS5zdWJzdHJpbmcoaSwgaWkpfTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGNoYXJNYXAgPSB7XG5cdFx0XCJgYVwiOiAnw6AnLCBcIidhXCI6IFwiw6FcIiwgXCJeYVwiOiBcIsOiXCIsIFwifmFcIjogXCLDo1wiLCBcIlxcXCJhXCI6IFwiw6RcIiwgXCJvYVwiOiBcIsOlXCIsIFwiYWFcIjogXCLDpVwiLCBcIj1hXCI6IFwixIFcIiwgXCJ1YVwiOiBcIsSDXCIsIFwiO2FcIjogXCLEhVwiLFxuXHRcdFwiYGVcIjogJ8OoJywgXCInZVwiOiBcIsOpXCIsIFwiXmVcIjogXCLDqlwiLCBcIlxcXCJlXCI6IFwiw6tcIiwgXCI9ZVwiOiBcIsSTXCIsIFwidWVcIjogXCLElVwiLCBcIjtlXCI6IFwixJlcIiwgXCIuZVwiOiBcIsSXXCIsXG5cdFx0XCJgaVwiOiAnw6wnLCBcIidpXCI6IFwiw61cIiwgXCJeaVwiOiBcIsOuXCIsIFwiXFxcImlcIjogXCLDr1wiLCBcIj1pXCI6IFwixKtcIiwgXCJ1aVwiOiBcIsStXCIsIFwiO2lcIjogXCLEr1wiLFxuXHRcdFwiYG9cIjogJ8OyJywgXCInb1wiOiBcIsOzXCIsIFwiXm9cIjogXCLDtFwiLCBcIn5vXCI6IFwiw7VcIiwgXCJcXFwib1wiOiBcIsO2XCIsIFwiPW9cIjogXCLFjVwiLCBcInVvXCI6IFwixY9cIiwgXCIvb1wiOiBcIsO4XCIsXG5cdFx0XCJgdVwiOiAnw7knLCBcIid1XCI6IFwiw7pcIiwgXCJedVwiOiBcIsO7XCIsIFwifnVcIjogXCLFqVwiLCBcIlxcXCJ1XCI6IFwiw7xcIiwgXCJvdVwiOiBcIsWvXCIsIFwiPXVcIjogXCLFq1wiLCBcInV1XCI6IFwixa1cIiwgXCI7dVwiOiBcIsWzXCIsXG5cdFx0XCJgQVwiOiAnw4AnLCBcIidBXCI6IFwiw4FcIiwgXCJeQVwiOiBcIsOCXCIsIFwifkFcIjogXCLDg1wiLCBcIlxcXCJBXCI6IFwiw4RcIiwgXCJvQVwiOiBcIsOFXCIsIFwiQUFcIjogXCLDhVwiLCBcIj1BXCI6IFwixIBcIiwgXCJ1QVwiOiBcIsSCXCIsIFwiO0FcIjogXCLEhFwiLFxuXHRcdFwiYEVcIjogJ8OIJywgXCInRVwiOiBcIsOJXCIsIFwiXkVcIjogXCLDilwiLCBcIlxcXCJFXCI6IFwiw4tcIiwgXCI9RVwiOiBcIsSSXCIsIFwidUVcIjogXCLElFwiLCBcIjtFXCI6IFwixJhcIiwgXCIuRVwiOiBcIsSWXCIsXG5cdFx0XCJgSVwiOiAnw4wnLCBcIidJXCI6IFwiw41cIiwgXCJeSVwiOiBcIsOOXCIsIFwifklcIjogXCLEqFwiLCBcIlxcXCJJXCI6IFwiw49cIiwgXCI9SVwiOiBcIsSqXCIsIFwidUlcIjogXCLErFwiLCBcIjtJXCI6IFwixK5cIiwgXCIuSVwiOiBcIsSwXCIsXG5cdFx0XCJgT1wiOiAnw5InLCBcIidPXCI6IFwiw5NcIiwgXCJeT1wiOiBcIsOUXCIsIFwifk9cIjogXCLDlVwiLCBcIlxcXCJPXCI6IFwiw5ZcIiwgXCI9T1wiOiBcIsWMXCIsIFwidU9cIjogXCLFjlwiLCBcIi9PXCI6IFwiw5hcIixcblx0XHRcImBVXCI6ICfDmScsIFwiJ1VcIjogXCLDmlwiLCBcIl5VXCI6IFwiw5tcIiwgXCJ+VVwiOiBcIsWoXCIsIFwiXFxcIlVcIjogXCLDnFwiLCBcIm9VXCI6IFwixa5cIiwgXCI9VVwiOiBcIsWqXCIsIFwidVVcIjogXCLFrFwiLCBcIjtVXCI6IFwixbJcIixcblx0XHRcImFlXCI6IFwiw6ZcIiwgXCJBRVwiOiBcIsOGXCIsIFwib2VcIjogXCLFk1wiLCBcIk9FXCI6IFwixZJcIiwgXCJzc1wiOiBcIsOfXCIsXG5cdFx0XCInY1wiOiBcIsSHXCIsIFwiXmNcIjogXCLEiVwiLCBcInVjXCI6IFwixI1cIiwgXCJjY1wiOiBcIsOnXCIsIFwiLmNcIjogXCLEi1wiLCBcImNDXCI6IFwiw4dcIiwgXCInQ1wiOiBcIsSGXCIsIFwiXkNcIjogXCLEiFwiLCBcInVDXCI6IFwixIxcIiwgXCIuQ1wiOiBcIsSKXCIsXG5cdFx0XCJ+TlwiOiBcIsORXCIsIFwifm5cIjogXCLDsVwiLFxuXHRcdFwiPXNcIjogXCLFoVwiLCBcInZzXCI6IFwixaFcIixcblx0XHRcIkRIXCI6IFwiw5BcIiwgXCJkaFwiOiBcIsOwXCIsXG5cdFx0XCJIT1wiOiBcIsWQXCIsIFwiSG9cIjogXCLFkVwiLCBcIkhVXCI6IFwixbBcIiwgXCJIdVwiOiBcIsWxXCIsXG5cdFx0XCInWVwiOiBcIsOdXCIsIFwiJ3lcIjogXCLDvVwiLCBcIl5ZXCI6IFwixbZcIiwgXCJeeVwiOiBcIsW3XCIsIFwiXFxcIllcIjogXCLFuFwiLCBcIlxcXCJ5XCI6IFwiw79cIixcblx0XHRcInZTXCI6IFwixaBcIiwgXCJ2WlwiOiBcIsW9XCIsIFwidnpcIjogJ8W+J1xuXG4vLyBNb3JlIGNoYXJzOiDEsiDEsyDEjiDEjyDEkCDEkSDEnCDEnSDEniDEnyDEoCDEoSDEoiDEoyDEpCDEpSDEpiDEpyDEtCDEtSDEtiDEtyDEuCDEuSDEuiDEuyDEvCDEvSDEviDEvyDFgCDFgSDFgiDFgyDFhCDFhSDFhiDFhyDFiCDFiSDFiiDFiyDFlCDFlSDFliDFlyDFmCDFmSDFmiDFmyDFnCDFnSDFniDFnyDFoCDFoiDFoyDFpCDFpSDFpiDFpyDFtCDFtSDFuSDFuiDFuyDFvCDFvVxuXHR9O1xuXHR2YXIgY2hhck1hcDEgPSB7XG5cdFx0XCIjXCI6IFwi4pmvXCIsXG5cdFx0XCJiXCI6IFwi4pmtXCIsXG5cdFx0XCI9XCI6IFwi4pmuXCJcblx0fTtcblx0dmFyIGNoYXJNYXAyID0ge1xuXHRcdFwiMjAxXCI6IFwi4pmvXCIsXG5cdFx0XCIyMDJcIjogXCLima1cIixcblx0XHRcIjIwM1wiOiBcIuKZrlwiLFxuXHRcdFwiMjQxXCI6IFwiwqFcIixcblx0XHRcIjI0MlwiOiBcIsKiXCIsIFwiMjUyXCI6IFwiYVwiLCBcIjI2MlwiOiBcIjJcIiwgXCIyNzJcIjogXCJvXCIsIFwiMzAyXCI6IFwiw4JcIiwgXCIzMTJcIjogXCLDilwiLCBcIjMyMlwiOiBcIsOSXCIsIFwiMzMyXCI6IFwiw5pcIiwgXCIzNDJcIjogXCLDolwiLCBcIjM1MlwiOiBcIsOqXCIsIFwiMzYyXCI6IFwiw7JcIiwgXCIzNzJcIjogXCLDulwiLFxuXHRcdFwiMjQzXCI6IFwiwqNcIiwgXCIyNTNcIjogXCLCq1wiLCBcIjI2M1wiOiBcIjNcIiwgXCIyNzNcIjogXCLCu1wiLCBcIjMwM1wiOiBcIsODXCIsIFwiMzEzXCI6IFwiw4tcIiwgXCIzMjNcIjogXCLDk1wiLCBcIjMzM1wiOiBcIsObXCIsIFwiMzQzXCI6IFwiw6NcIiwgXCIzNTNcIjogXCLDq1wiLCBcIjM2M1wiOiBcIsOzXCIsIFwiMzczXCI6IFwiw7tcIixcblx0XHRcIjI0NFwiOiBcIsKkXCIsIFwiMjU0XCI6IFwiwqxcIiwgXCIyNjRcIjogXCIgIMyBXCIsIFwiMjc0XCI6IFwiMeKBhDRcIiwgXCIzMDRcIjogXCLDhFwiLCBcIjMxNFwiOiBcIsOMXCIsIFwiMzI0XCI6IFwiw5RcIiwgXCIzMzRcIjogXCLDnFwiLCBcIjM0NFwiOiBcIsOkXCIsIFwiMzU0XCI6IFwiw6xcIiwgXCIzNjRcIjogXCLDtFwiLCBcIjM3NFwiOiBcIsO8XCIsXG5cdFx0XCIyNDVcIjogXCLCpVwiLCBcIjI1NVwiOiBcIi1cIiwgXCIyNjVcIjogXCLOvFwiLCBcIjI3NVwiOiBcIjHigYQyXCIsIFwiMzA1XCI6IFwiw4VcIiwgXCIzMTVcIjogXCLDjVwiLCBcIjMyNVwiOiBcIsOVXCIsIFwiMzM1XCI6IFwiw51cIiwgIFwiMzQ1XCI6IFwiw6VcIiwgXCIzNTVcIjogXCLDrVwiLCBcIjM2NVwiOiBcIsO1XCIsIFwiMzc1XCI6IFwiw71cIixcblx0XHRcIjI0NlwiOiBcIsKmXCIsIFwiMjU2XCI6IFwiwq5cIiwgXCIyNjZcIjogXCLCtlwiLCBcIjI3NlwiOiBcIjPigYQ0XCIsIFwiMzA2XCI6IFwiw4ZcIiwgXCIzMTZcIjogXCLDjlwiLCBcIjMyNlwiOiBcIsOWXCIsIFwiMzM2XCI6IFwiw55cIiwgXCIzNDZcIjogXCLDplwiLCBcIjM1NlwiOiBcIsOuXCIsIFwiMzY2XCI6IFwiw7ZcIiwgXCIzNzZcIjogXCLDvlwiLFxuXHRcdFwiMjQ3XCI6IFwiwqdcIiwgXCIyNTdcIjogXCIgzIRcIiwgXCIyNjdcIjogXCLCt1wiLCBcIjI3N1wiOiBcIsK/XCIsIFwiMzA3XCI6IFwiw4dcIiwgXCIzMTdcIjogXCLDj1wiLCBcIjMyN1wiOiBcIsOXXCIsIFwiMzM3XCI6IFwiw59cIiwgXCIzNDdcIjogXCLDp1wiLCBcIjM1N1wiOiBcIsOvXCIsIFwiMzY3XCI6IFwiw7dcIiwgXCIzNzdcIjogXCLDv1wiLFxuXHRcdFwiMjUwXCI6IFwiIMyIXCIsIFwiMjYwXCI6IFwiwrBcIiwgXCIyNzBcIjogXCIgzKdcIiwgXCIzMDBcIjogXCLDgFwiLCBcIjMxMFwiOiBcIsOIXCIsIFwiMzIwXCI6IFwiw5BcIiwgXCIzMzBcIjogXCLDmFwiLCBcIjM0MFwiOiBcIsOgXCIsIFwiMzUwXCI6IFwiw6hcIiwgXCIzNjBcIjogXCLDsFwiLCBcIjM3MFwiOiBcIsO4XCIsXG5cdFx0XCIyNTFcIjogXCLCqVwiLCBcIjI2MVwiOiBcIsKxXCIsIFwiMjcxXCI6IFwiMVwiLCBcIjMwMVwiOiBcIsOBXCIsIFwiMzExXCI6IFwiw4lcIiwgXCIzMjFcIjogXCLDkVwiLCBcIjMzMVwiOiBcIsOZXCIsIFwiMzQxXCI6IFwiw6FcIiwgXCIzNTFcIjogXCLDqVwiLCBcIjM2MVwiOiBcIsOxXCIsIFwiMzcxXCI6IFwiw7lcIiB9O1xuXHR0aGlzLnRyYW5zbGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBhcnIgPSBzdHIuc3BsaXQoJ1xcXFwnKTtcblx0XHRpZiAoYXJyLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHN0cjtcblx0XHR2YXIgb3V0ID0gbnVsbDtcblx0XHRwYXJzZUNvbW1vbi5lYWNoKGFyciwgZnVuY3Rpb24ocykge1xuXHRcdFx0aWYgKG91dCA9PT0gbnVsbClcblx0XHRcdFx0b3V0ID0gcztcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgYyA9IGNoYXJNYXBbcy5zdWJzdHJpbmcoMCwgMildO1xuXHRcdFx0XHRpZiAoYyAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdG91dCArPSBjICsgcy5zdWJzdHJpbmcoMik7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGMgPSBjaGFyTWFwMltzLnN1YnN0cmluZygwLCAzKV07XG5cdFx0XHRcdFx0aWYgKGMgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdG91dCArPSBjICsgcy5zdWJzdHJpbmcoMyk7XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjID0gY2hhck1hcDFbcy5zdWJzdHJpbmcoMCwgMSldO1xuXHRcdFx0XHRcdFx0aWYgKGMgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdFx0b3V0ICs9IGMgKyBzLnN1YnN0cmluZygxKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0b3V0ICs9IFwiXFxcXFwiICsgcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9O1xuXHR0aGlzLmdldE51bWJlciA9IGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG5cdFx0dmFyIG51bSA9IDA7XG5cdFx0d2hpbGUgKGluZGV4IDwgbGluZS5sZW5ndGgpIHtcblx0XHRcdHN3aXRjaCAobGluZS5jaGFyQXQoaW5kZXgpKSB7XG5cdFx0XHRcdGNhc2UgJzAnOm51bSA9IG51bSoxMDtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICcxJzpudW0gPSBudW0qMTArMTtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICcyJzpudW0gPSBudW0qMTArMjtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICczJzpudW0gPSBudW0qMTArMztpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc0JzpudW0gPSBudW0qMTArNDtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc1JzpudW0gPSBudW0qMTArNTtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc2JzpudW0gPSBudW0qMTArNjtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc3JzpudW0gPSBudW0qMTArNztpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc4JzpudW0gPSBudW0qMTArODtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRjYXNlICc5JzpudW0gPSBudW0qMTArOTtpbmRleCsrO2JyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiB7bnVtOiBudW0sIGluZGV4OiBpbmRleH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7bnVtOiBudW0sIGluZGV4OiBpbmRleH07XG5cdH07XG5cblx0dGhpcy5nZXRGcmFjdGlvbiA9IGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG5cdFx0dmFyIG51bSA9IDE7XG5cdFx0dmFyIGRlbiA9IDE7XG5cdFx0aWYgKGxpbmUuY2hhckF0KGluZGV4KSAhPT0gJy8nKSB7XG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5nZXROdW1iZXIobGluZSwgaW5kZXgpO1xuXHRcdFx0bnVtID0gcmV0Lm51bTtcblx0XHRcdGluZGV4ID0gcmV0LmluZGV4O1xuXHRcdH1cblx0XHRpZiAobGluZS5jaGFyQXQoaW5kZXgpID09PSAnLycpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRpZiAobGluZS5jaGFyQXQoaW5kZXgpID09PSAnLycpIHtcblx0XHRcdFx0dmFyIGRpdiA9IDAuNTtcblx0XHRcdFx0d2hpbGUgKGxpbmUuY2hhckF0KGluZGV4KyspID09PSAnLycpXG5cdFx0XHRcdFx0ZGl2ID0gZGl2IC8yO1xuXHRcdFx0XHRyZXR1cm4ge3ZhbHVlOiBudW0gKiBkaXYsIGluZGV4OiBpbmRleC0xfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBpU2F2ZSA9IGluZGV4O1xuXHRcdFx0XHR2YXIgcmV0MiA9IHRoaXMuZ2V0TnVtYmVyKGxpbmUsIGluZGV4KTtcblx0XHRcdFx0aWYgKHJldDIubnVtID09PSAwICYmIGlTYXZlID09PSBpbmRleClcdC8vIElmIHdlIGRpZG4ndCB1c2UgYW55IGNoYXJhY3RlcnMsIGl0IGlzIGFuIGltcGxpZWQgMlxuXHRcdFx0XHRcdHJldDIubnVtID0gMjtcblx0XHRcdFx0aWYgKHJldDIubnVtICE9PSAwKVxuXHRcdFx0XHRcdGRlbiA9IHJldDIubnVtO1xuXHRcdFx0XHRpbmRleCA9IHJldDIuaW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHt2YWx1ZTogbnVtL2RlbiwgaW5kZXg6IGluZGV4fTtcblx0fTtcblxuXHR0aGlzLnRoZVJldmVyc2VyID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0aWYgKHBhcnNlQ29tbW9uLmVuZHNXaXRoKHN0ciwgXCIsIFRoZVwiKSlcblx0XHRcdHJldHVybiBcIlRoZSBcIiArIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aC01KTtcblx0XHRpZiAocGFyc2VDb21tb24uZW5kc1dpdGgoc3RyLCBcIiwgQVwiKSlcblx0XHRcdHJldHVybiBcIkEgXCIgKyBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGgtMyk7XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXHR0aGlzLnN0cmlwQ29tbWVudCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBpID0gc3RyLmluZGV4T2YoJyUnKTtcblx0XHRpZiAoaSA+PSAwKVxuXHRcdFx0cmV0dXJuIHBhcnNlQ29tbW9uLnN0cmlwKHN0ci5zdWJzdHJpbmcoMCwgaSkpO1xuXHRcdHJldHVybiBwYXJzZUNvbW1vbi5zdHJpcChzdHIpO1xuXHR9O1xuXG5cdHRoaXMuZ2V0SW50ID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0Ly8gVGhpcyBwYXJzZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIGZvciBhIG51bWJlciBhbmQgcmV0dXJucyB7IHZhbHVlOiBudW0sIGRpZ2l0czogbnVtIH1cblx0XHQvLyBJZiBkaWdpdHMgaXMgMCwgdGhlbiB0aGUgc3RyaW5nIGRpZG4ndCBwb2ludCB0byBhIG51bWJlci5cblx0XHR2YXIgeCA9IHBhcnNlSW50KHN0cik7XG5cdFx0aWYgKGlzTmFOKHgpKVxuXHRcdFx0cmV0dXJuIHtkaWdpdHM6IDB9O1xuXHRcdHZhciBzID0gXCJcIiArIHg7XG5cdFx0dmFyIGkgPSBzdHIuaW5kZXhPZihzKTtcdC8vIFRoaXMgaXMgdG8gYWNjb3VudCBmb3IgbGVhZGluZyBzcGFjZXNcblx0XHRyZXR1cm4ge3ZhbHVlOiB4LCBkaWdpdHM6IGkrcy5sZW5ndGh9O1xuXHR9O1xuXG5cdHRoaXMuZ2V0RmxvYXQgPSBmdW5jdGlvbihzdHIpIHtcblx0XHQvLyBUaGlzIHBhcnNlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgZm9yIGEgbnVtYmVyIGFuZCByZXR1cm5zIHsgdmFsdWU6IG51bSwgZGlnaXRzOiBudW0gfVxuXHRcdC8vIElmIGRpZ2l0cyBpcyAwLCB0aGVuIHRoZSBzdHJpbmcgZGlkbid0IHBvaW50IHRvIGEgbnVtYmVyLlxuXHRcdHZhciB4ID0gcGFyc2VGbG9hdChzdHIpO1xuXHRcdGlmIChpc05hTih4KSlcblx0XHRcdHJldHVybiB7ZGlnaXRzOiAwfTtcblx0XHR2YXIgcyA9IFwiXCIgKyB4O1xuXHRcdHZhciBpID0gc3RyLmluZGV4T2Yocyk7XHQvLyBUaGlzIGlzIHRvIGFjY291bnQgZm9yIGxlYWRpbmcgc3BhY2VzXG5cdFx0cmV0dXJuIHt2YWx1ZTogeCwgZGlnaXRzOiBpK3MubGVuZ3RofTtcblx0fTtcblxuXHR0aGlzLmdldE1lYXN1cmVtZW50ID0gZnVuY3Rpb24odG9rZW5zKSB7XG5cdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHJldHVybiB7IHVzZWQ6IDAgfTtcblx0XHR2YXIgdXNlZCA9IDE7XG5cdFx0dmFyIG51bSA9ICcnO1xuXHRcdGlmICh0b2tlbnNbMF0udG9rZW4gPT09ICctJykge1xuXHRcdFx0dG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRudW0gPSAnLSc7XG5cdFx0XHR1c2VkKys7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRva2Vuc1swXS50eXBlICE9PSAnbnVtYmVyJykgcmV0dXJuIHsgdXNlZDogMCB9O1xuXHRcdG51bSArPSB0b2tlbnMuc2hpZnQoKS50b2tlbjtcblx0XHRpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgdXNlZDogMSwgdmFsdWU6IHBhcnNlSW50KG51bSkgfTtcblx0XHR2YXIgeCA9IHRva2Vucy5zaGlmdCgpO1xuXHRcdGlmICh4LnRva2VuID09PSAnLicpIHtcblx0XHRcdHVzZWQrKztcblx0XHRcdGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSByZXR1cm4geyB1c2VkOiB1c2VkLCB2YWx1ZTogcGFyc2VJbnQobnVtKSB9O1xuXHRcdFx0aWYgKHRva2Vuc1swXS50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHR4ID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdG51bSA9IG51bSArICcuJyArIHgudG9rZW47XG5cdFx0XHRcdHVzZWQrKztcblx0XHRcdFx0aWYgKHRva2Vucy5sZW5ndGggPT09IDApIHJldHVybiB7IHVzZWQ6IHVzZWQsIHZhbHVlOiBwYXJzZUZsb2F0KG51bSkgfTtcblx0XHRcdH1cblx0XHRcdHggPSB0b2tlbnMuc2hpZnQoKTtcblx0XHR9XG5cdFx0c3dpdGNoICh4LnRva2VuKSB7XG5cdFx0XHRjYXNlICdwdCc6IHJldHVybiB7IHVzZWQ6IHVzZWQrMSwgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSB9O1xuXHRcdFx0Y2FzZSAnY20nOiByZXR1cm4geyB1c2VkOiB1c2VkKzEsIHZhbHVlOiBwYXJzZUZsb2F0KG51bSkvMi41NCo3MiB9O1xuXHRcdFx0Y2FzZSAnaW4nOiByZXR1cm4geyB1c2VkOiB1c2VkKzEsIHZhbHVlOiBwYXJzZUZsb2F0KG51bSkqNzIgfTtcblx0XHRcdGRlZmF1bHQ6IHRva2Vucy51bnNoaWZ0KHgpOyByZXR1cm4geyB1c2VkOiB1c2VkLCB2YWx1ZTogcGFyc2VGbG9hdChudW0pIH07XG5cdFx0fVxuXHRcdHJldHVybiB7IHVzZWQ6IDAgfTtcblx0fTtcblx0dmFyIHN1YnN0SW5DaG9yZCA9IGZ1bmN0aW9uKHN0cilcblx0e1xuXHRcdHdoaWxlICggc3RyLmluZGV4T2YoXCJcXFxcblwiKSAhPT0gLTEpXG5cdFx0e1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoXCJcXFxcblwiLCBcIlxcblwiKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblx0dGhpcy5nZXRCcmFja2V0dGVkU3Vic3RyaW5nID0gZnVuY3Rpb24obGluZSwgaSwgbWF4RXJyb3JDaGFycywgX21hdGNoQ2hhcilcblx0e1xuXHRcdC8vIFRoaXMgZXh0cmFjdHMgdGhlIHN1YiBzdHJpbmcgYnkgbG9va2luZyBhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBzZWFyY2hpbmcgZm9yIHRoYXRcblx0XHQvLyBjaGFyYWN0ZXIgbGF0ZXIgaW4gdGhlIGxpbmUgKG9yIHNlYXJjaCBmb3IgdGhlIG9wdGlvbmFsIF9tYXRjaENoYXIpLlxuXHRcdC8vIEZvciBpbnN0YW5jZSwgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIHF1b3RlIGl0IHdpbGwgbG9vayBmb3Jcblx0XHQvLyB0aGUgZW5kIHF1b3RlLiBJZiB0aGUgZW5kIG9mIHRoZSBsaW5lIGlzIHJlYWNoZWQsIHRoZW4gb25seSB1cCB0byB0aGUgZGVmYXVsdCBudW1iZXJcblx0XHQvLyBvZiBjaGFyYWN0ZXJzIGFyZSByZXR1cm5lZCwgc28gdGhhdCBhIG1pc3NpbmcgZW5kIHF1b3RlIHdvbid0IGVhdCB1cCB0aGUgZW50aXJlIGxpbmUuXG5cdFx0Ly8gSXQgcmV0dXJucyB0aGUgc3Vic3RyaW5nIGFuZCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29uc3VtZWQuXG5cdFx0Ly8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnN1bWVkIGlzIG5vcm1hbGx5IHR3byBtb3JlIHRoYW4gdGhlIHNpemUgb2YgdGhlIHN1YnN0cmluZyxcblx0XHQvLyBidXQgaW4gdGhlIGVycm9yIGNhc2UgaXQgbWlnaHQgbm90IGJlLlxuXHRcdHZhciBtYXRjaENoYXIgPSBfbWF0Y2hDaGFyIHx8IGxpbmUuY2hhckF0KGkpO1xuXHRcdHZhciBwb3MgPSBpKzE7XG5cdFx0d2hpbGUgKChwb3MgPCBsaW5lLmxlbmd0aCkgJiYgKGxpbmUuY2hhckF0KHBvcykgIT09IG1hdGNoQ2hhcikpXG5cdFx0XHQrK3Bvcztcblx0XHRpZiAobGluZS5jaGFyQXQocG9zKSA9PT0gbWF0Y2hDaGFyKVxuXHRcdFx0cmV0dXJuIFtwb3MtaSsxLHN1YnN0SW5DaG9yZChsaW5lLnN1YnN0cmluZyhpKzEsIHBvcykpLCB0cnVlXTtcblx0XHRlbHNlXHQvLyB3ZSBoaXQgdGhlIGVuZCBvZiBsaW5lLCBzbyB3ZSdsbCBqdXN0IHBpY2sgYW4gYXJiaXRyYXJ5IG51bSBvZiBjaGFycyBzbyB0aGUgbGluZSBkb2Vzbid0IGRpc2FwcGVhci5cblx0XHR7XG5cdFx0XHRwb3MgPSBpK21heEVycm9yQ2hhcnM7XG5cdFx0XHRpZiAocG9zID4gbGluZS5sZW5ndGgtMSlcblx0XHRcdFx0cG9zID0gbGluZS5sZW5ndGgtMTtcblx0XHRcdHJldHVybiBbcG9zLWkrMSwgc3Vic3RJbkNob3JkKGxpbmUuc3Vic3RyaW5nKGkrMSwgcG9zKSksIGZhbHNlXTtcblx0XHR9XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuaXplcjtcbiIsIi8vICAgIGFiY190cmFuc3Bvc2UuanM6IEhhbmRsZXMgdGhlIGF1dG9tYXRpYyB0cmFuc3Bvc2l0aW9uIG9mIGtleSBzaWduYXR1cmVzLCBjaG9yZCBzeW1ib2xzLCBhbmQgbm90ZXMuXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBQYXVsIFJvc2VuIChwYXVsIGF0IHBhdWxyb3NlbiBkb3QgbmV0KVxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdHJhbnNwb3NlID0ge307XG5cbnZhciBrZXlJbmRleCA9IHtcblx0J0MnOiAwLFxuXHQnQyMnOiAxLFxuXHQnRGInOiAxLFxuXHQnRCc6IDIsXG5cdCdEIyc6IDMsXG5cdCdFYic6IDMsXG5cdCdFJzogNCxcblx0J0YnOiA1LFxuXHQnRiMnOiA2LFxuXHQnR2InOiA2LFxuXHQnRyc6IDcsXG5cdCdHIyc6IDgsXG5cdCdBYic6IDgsXG5cdCdBJzogOSxcblx0J0EjJzogMTAsXG5cdCdCYic6IDEwLFxuXHQnQic6IDExXG59O1xudmFyIG5ld0tleSA9IFsnQycsICdEYicsICdEJywgJ0ViJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0FiJywgJ0EnLCAnQmInLCAnQiddO1xudmFyIG5ld0tleU1pbm9yID0gWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdCYicsICdCJ107XG5cbnRyYW5zcG9zZS5rZXlTaWduYXR1cmUgPSBmdW5jdGlvbihtdWx0aWxpbmVWYXJzLCBrZXlzLCBrZXlOYW1lLCByb290LCBhY2MsIGxvY2FsVHJhbnNwb3NlKSB7XG5cdGlmICghbG9jYWxUcmFuc3Bvc2UpIGxvY2FsVHJhbnNwb3NlID0gMDtcblx0bXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZVZlcnRpY2FsTW92ZW1lbnQgPSAwO1xuXHRtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlUHJlZmVyRmxhdHMgPSBmYWxzZTtcblx0dmFyIGsgPSBrZXlzW2tleU5hbWVdO1xuXHRpZiAoIWspIHJldHVybiBtdWx0aWxpbmVWYXJzLmtleTsgLy8gSWYgdGhlIGtleSBpc24ndCBpbiB0aGUgbGlzdCwgaXQgaXMgbm9uLXN0YW5kYXJkLiBXZSB3b24ndCBhdHRlbXB0IHRvIHRyYW5zcG9zZSBpdC5cblx0bXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZSA9IChtdWx0aWxpbmVWYXJzLmdsb2JhbFRyYW5zcG9zZSA/IG11bHRpbGluZVZhcnMuZ2xvYmFsVHJhbnNwb3NlIDogMCkgKyBsb2NhbFRyYW5zcG9zZTtcblxuXHRpZiAoIW11bHRpbGluZVZhcnMubG9jYWxUcmFuc3Bvc2UpXG5cdFx0cmV0dXJuIHsgYWNjaWRlbnRhbHM6IGssIHJvb3Q6IHJvb3QsIGFjYzogYWNjIH07XG5cdG11bHRpbGluZVZhcnMuZ2xvYmFsVHJhbnNwb3NlT3JpZ0tleVNpZyA9IGs7XG5cdGlmIChtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlICUgMTIgPT09IDApIHtcblx0XHRtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlVmVydGljYWxNb3ZlbWVudCA9IChtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlIC8gMTIpICogNztcblx0XHRyZXR1cm4geyBhY2NpZGVudGFsczogaywgcm9vdDogcm9vdCwgYWNjOiBhY2MgfTtcblx0fVxuXG5cdHZhciBiYXNlS2V5ID0ga2V5TmFtZVswXTtcblx0aWYgKGtleU5hbWVbMV0gPT09ICdiJyB8fCBrZXlOYW1lWzFdID09PSAnIycpIHtcblx0XHRiYXNlS2V5ICs9IGtleU5hbWVbMV07XG5cdFx0a2V5TmFtZSA9IGtleU5hbWUuc3Vic3RyKDIpO1xuXHR9IGVsc2Vcblx0XHRrZXlOYW1lID0ga2V5TmFtZS5zdWJzdHIoMSk7XG5cdHZhciBpbmRleCA9IGtleUluZGV4W2Jhc2VLZXldICsgbXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZTtcblx0d2hpbGUgKGluZGV4IDwgMCkgaW5kZXggKz0gMTI7XG5cdGlmIChpbmRleCA+IDExKSBpbmRleCA9IGluZGV4ICUgMTI7XG5cdHZhciBuZXdLZXlOYW1lID0gKGtleU5hbWVbMF0gPT09ICdtJyA/IG5ld0tleU1pbm9yW2luZGV4XSA6IG5ld0tleVtpbmRleF0pO1xuXHR2YXIgdHJhbnNwb3NlZEtleSA9IG5ld0tleU5hbWUgKyBrZXlOYW1lO1xuXHR2YXIgbmV3S2V5U2lnID0ga2V5c1t0cmFuc3Bvc2VkS2V5XTtcblx0aWYgKG5ld0tleVNpZy5sZW5ndGggPiAwICYmIG5ld0tleVNpZ1swXS5hY2MgPT09ICdmbGF0Jylcblx0XHRtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlUHJlZmVyRmxhdHMgPSB0cnVlO1xuXHR2YXIgZGlzdGFuY2UgPSB0cmFuc3Bvc2VkS2V5LmNoYXJDb2RlQXQoMCkgLSBiYXNlS2V5LmNoYXJDb2RlQXQoMCk7XG5cdGlmIChtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlID4gMCkge1xuXHRcdGlmIChkaXN0YW5jZSA8IDApXG5cdFx0XHRkaXN0YW5jZSArPSA3O1xuXHRcdGVsc2UgaWYgKGRpc3RhbmNlID09PSAwKSB7XG5cdFx0XHQvLyBUaGVyZSdzIGEgZnVubnkgdGhpbmcgdGhhdCBoYXBwZW5zIHdoZW4gdGhlIGtleSBjaGFuZ2VzIG9ubHkgYW4gYWNjaWRlbnRhbCdzIGRpc3RhbmNlLCBmb3IgaW5zdGFuY2UsIGZyb20gQWIgdG8gQS5cblx0XHRcdC8vIElmIHRoZSBkaXN0YW5jZSBpcyBwb3NpdGl2ZSAod2UgYXJlIHJhaXNpbmcgcGl0Y2gpLCBhbmQgdGhlIGNoYW5nZSBpcyBoaWdoZXIgKHRoYXQgaXMsIEFiIC0+IEEpLCB0aGVuIHJhaXNlIGFuIG9jdGF2ZS5cblx0XHRcdC8vIFRoaXMgdGVzdCBpcyBlYXNpZXIgYmVjYXVzZSB3ZSBrbm93IHRoZSBrZXlzIGFyZSBub3QgZXF1YWwgKG9yIHdlIHdvdWxkbid0IGdldCB0aGlzIGZhciksIHNvIGlmIHRoZSBiYXNlIGtleSBpcyBhIGZsYXQga2V5LCB0aGVuXG5cdFx0XHQvLyB0aGUgdHJhbnNwb3NlZCBrZXkgbXVzdCBiZSBoaWdoZXIuIExpa2V3aXNlLCBpZiB0aGUgdHJhbnNwb3NlZCBrZXkgaXMgc2hhcnAsIHRoZW4gdGhlIGJhc2Uga2V5IG11c3QgYmUgbG93ZXIuIEFuZCBvbmVcblx0XHRcdC8vIG9mIHRob3NlIHR3byB0aGluZ3MgbXVzdCBiZSB0cnVlIGJlY2F1c2UgdGhleSBhcmUgbm90IGJvdGggbmF0dXJhbC5cblx0XHRcdGlmIChiYXNlS2V5WzFdID09PSAnIycgfHwgIHRyYW5zcG9zZWRLZXlbMV0gPT09ICdiJylcblx0XHRcdFx0ZGlzdGFuY2UgKz0gNztcblx0XHR9XG5cdH0gZWxzZSBpZiAobXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZSA8IDApIHtcblx0XHRpZiAoZGlzdGFuY2UgPiAwKVxuXHRcdFx0ZGlzdGFuY2UgLT0gNztcblx0XHRlbHNlIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuXHRcdFx0Ly8gVGhlcmUncyBhIGZ1bm55IHRoaW5nIHRoYXQgaGFwcGVucyB3aGVuIHRoZSBrZXkgY2hhbmdlcyBvbmx5IGFuIGFjY2lkZW50YWwncyBkaXN0YW5jZSwgZm9yIGluc3RhbmNlLCBmcm9tIEFiIHRvIEEuXG5cdFx0XHQvLyBJZiB0aGUgZGlzdGFuY2UgaXMgbmVnYXRpdmUgKHdlIGFyZSBkcm9wcGluZyBwaXRjaCksIGFuZCB0aGUgY2hhbmdlIGlzIGxvd2VyICh0aGF0IGlzLCBBIC0+IEFiKSwgdGhlbiBkcm9wIGFuIG9jdGF2ZS5cblx0XHRcdGlmIChiYXNlS2V5WzFdID09PSAnYicgfHwgIHRyYW5zcG9zZWRLZXlbMV0gPT09ICcjJylcblx0XHRcdFx0ZGlzdGFuY2UgLT0gNztcblx0XHR9XG5cdH1cblxuXHRpZiAobXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZSA+IDApXG5cdFx0bXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZVZlcnRpY2FsTW92ZW1lbnQgPSBkaXN0YW5jZSArIE1hdGguZmxvb3IobXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZSAvIDEyKSAqIDc7XG5cdGVsc2Vcblx0XHRtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlVmVydGljYWxNb3ZlbWVudCA9IGRpc3RhbmNlICsgTWF0aC5jZWlsKG11bHRpbGluZVZhcnMubG9jYWxUcmFuc3Bvc2UgLyAxMikgKiA3O1xuXHRyZXR1cm4geyBhY2NpZGVudGFsczogbmV3S2V5U2lnLCByb290OiBuZXdLZXlOYW1lWzBdLCBhY2M6IG5ld0tleU5hbWUubGVuZ3RoID4gMSA/IG5ld0tleU5hbWVbMV0gOiBcIlwiIH07XG59O1xuXG52YXIgc2hhcnBDaG9yZHMgPSBbICdDJywgJ0Pima8nLCAnRCcsIFwiROKZr1wiLCAnRScsICdGJywgXCJG4pmvXCIsICdHJywgJ0fima8nLCAnQScsICdB4pmvJywgJ0InXTtcbnZhciBmbGF0Q2hvcmRzID0gWyAnQycsICdE4pmtJywgJ0QnLCAnReKZrScsICdFJywgJ0YnLCAnR+KZrScsICdHJywgJ0Hima0nLCAnQScsICdC4pmtJywgJ0InXTtcbnZhciBzaGFycENob3Jkc0ZyZWUgPSBbICdDJywgJ0MjJywgJ0QnLCBcIkQjXCIsICdFJywgJ0YnLCBcIkYjXCIsICdHJywgJ0cjJywgJ0EnLCAnQSMnLCAnQiddO1xudmFyIGZsYXRDaG9yZHNGcmVlID0gWyAnQycsICdEYicsICdEJywgJ0ViJywgJ0UnLCAnRicsICdHYicsICdHJywgJ0FiJywgJ0EnLCAnQmInLCAnQiddO1xuXG50cmFuc3Bvc2UuY2hvcmROYW1lID0gZnVuY3Rpb24obXVsdGlsaW5lVmFycywgY2hvcmQpIHtcblx0aWYgKG11bHRpbGluZVZhcnMubG9jYWxUcmFuc3Bvc2UgJiYgKG11bHRpbGluZVZhcnMubG9jYWxUcmFuc3Bvc2UgJSAxMiAhPT0gMCkpIHsgLy8gVGhlIGNob3JkcyBhcmUgdGhlIHNhbWUgaWYgaXQgaXMgYW4gZXhhY3Qgb2N0YXZlIGNoYW5nZS5cblx0XHR2YXIgdHJhbnNwb3NlRmFjdG9yID0gbXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZTtcblx0XHR3aGlsZSAodHJhbnNwb3NlRmFjdG9yIDwgMCkgdHJhbnNwb3NlRmFjdG9yICs9IDEyO1xuXHRcdGlmICh0cmFuc3Bvc2VGYWN0b3IgPiAxMSkgdHJhbnNwb3NlRmFjdG9yID0gdHJhbnNwb3NlRmFjdG9yICUgMTI7XG5cdFx0aWYgKG11bHRpbGluZVZhcnMuZnJlZWdjaG9yZCkge1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9DYi9nLCBcImB+MTFgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9EYi9nLCBcImB+MWBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0ViL2csIFwiYH4zYFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvRmIvZywgXCJgfjRgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9HYi9nLCBcImB+NmBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0FiL2csIFwiYH44YFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQmIvZywgXCJgfjEwYFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQyMvZywgXCJgfjFgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9EIy9nLCBcImB+M2BcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0UjL2csIFwiYH41YFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvRiMvZywgXCJgfjZgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9HIy9nLCBcImB+OGBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0EjL2csIFwiYH4xMGBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0IjL2csIFwiYH4wYFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9D4pmtL2csIFwiYH4xMWBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0Tima0vZywgXCJgfjFgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9F4pmtL2csIFwiYH4zYFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvRuKZrS9nLCBcImB+NGBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0fima0vZywgXCJgfjZgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9B4pmtL2csIFwiYH44YFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQuKZrS9nLCBcImB+MTBgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9D4pmvL2csIFwiYH4xYFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvROKZry9nLCBcImB+M2BcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0Xima8vZywgXCJgfjVgXCIpO1xuXHRcdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9G4pmvL2csIFwiYH42YFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvR+KZry9nLCBcImB+OGBcIik7XG5cdFx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0Hima8vZywgXCJgfjEwYFwiKTtcblx0XHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQuKZry9nLCBcImB+MGBcIik7XG5cdFx0fVxuXHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQy9nLCBcImB+MGBcIik7XG5cdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9EL2csIFwiYH4yYFwiKTtcblx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0UvZywgXCJgfjRgXCIpO1xuXHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvRi9nLCBcImB+NWBcIik7XG5cdFx0Y2hvcmQgPSBjaG9yZC5yZXBsYWNlKC9HL2csIFwiYH43YFwiKTtcblx0XHRjaG9yZCA9IGNob3JkLnJlcGxhY2UoL0EvZywgXCJgfjlgXCIpO1xuXHRcdGNob3JkID0gY2hvcmQucmVwbGFjZSgvQi9nLCBcImB+MTFgXCIpO1xuXHRcdHZhciBhcnIgPSBjaG9yZC5zcGxpdChcImBcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnJbaV1bMF0gPT09ICd+Jykge1xuXHRcdFx0XHR2YXIgY2hvcmROdW0gPSBwYXJzZUludChhcnJbaV0uc3Vic3RyKDEpLDEwKTtcblx0XHRcdFx0Y2hvcmROdW0gKz0gdHJhbnNwb3NlRmFjdG9yO1xuXHRcdFx0XHRpZiAoY2hvcmROdW0gPiAxMSkgY2hvcmROdW0gLT0gMTI7XG5cdFx0XHRcdGlmIChtdWx0aWxpbmVWYXJzLmZyZWVnY2hvcmQpXG5cdFx0XHRcdFx0YXJyW2ldID0gbXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZVByZWZlckZsYXRzID8gZmxhdENob3Jkc0ZyZWVbY2hvcmROdW1dIDogc2hhcnBDaG9yZHNGcmVlW2Nob3JkTnVtXTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGFycltpXSA9IG11bHRpbGluZVZhcnMubG9jYWxUcmFuc3Bvc2VQcmVmZXJGbGF0cyA/IGZsYXRDaG9yZHNbY2hvcmROdW1dIDogc2hhcnBDaG9yZHNbY2hvcmROdW1dO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaG9yZCA9IGFyci5qb2luKFwiXCIpO1xuXHR9XG5cdHJldHVybiBjaG9yZDtcbn07XG5cbnZhciBwaXRjaFRvTGV0dGVyID0gWyAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2EnLCAnYicgXTtcbmZ1bmN0aW9uIGFjY2lkZW50YWxDaGFuZ2Uob3JpZ1BpdGNoLCBuZXdQaXRjaCwgYWNjaWRlbnRhbCwgb3JpZ0tleVNpZywgbmV3S2V5U2lnKSB7XG5cdHZhciBvcmlnUGl0Y2hMZXR0ZXIgPSBwaXRjaFRvTGV0dGVyWyhvcmlnUGl0Y2ggKyA0OSkgJSA3XTsgLy8gTWFrZSBzdXJlIGl0IGlzIGEgcG9zaXRpdmUgcGl0Y2ggYmVmb3JlIG5vcm1hbGl6aW5nLlxuXHR2YXIgb3JpZ0FjY2lkZW50YWwgPSAwO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdLZXlTaWcubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAob3JpZ0tleVNpZ1tpXS5ub3RlLnRvTG93ZXJDYXNlKCkgPT09IG9yaWdQaXRjaExldHRlcilcblx0XHRcdG9yaWdBY2NpZGVudGFsID0gYWNjaWRlbnRhbHNbb3JpZ0tleVNpZ1tpXS5hY2NdO1xuXHR9XG5cblx0dmFyIGN1cnJlbnRBY2NpZGVudGFsID0gYWNjaWRlbnRhbHNbYWNjaWRlbnRhbF07XG5cdHZhciBkZWx0YSA9IGN1cnJlbnRBY2NpZGVudGFsIC0gb3JpZ0FjY2lkZW50YWw7XG5cblx0dmFyIG5ld1BpdGNoTGV0dGVyID0gcGl0Y2hUb0xldHRlclsobmV3UGl0Y2ggKyA0OSkgJSA3XTsgLy8gTWFrZSBzdXJlIGl0IGlzIGEgcG9zaXRpdmUgcGl0Y2ggYmVmb3JlIG5vcm1hbGl6aW5nLlxuXHR2YXIgbmV3QWNjaWRlbnRhbCA9IDA7XG5cdGZvciAodmFyIGogPSAwOyBqIDwgbmV3S2V5U2lnLmFjY2lkZW50YWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0aWYgKG5ld0tleVNpZy5hY2NpZGVudGFsc1tqXS5ub3RlLnRvTG93ZXJDYXNlKCkgPT09IG5ld1BpdGNoTGV0dGVyKVxuXHRcdFx0bmV3QWNjaWRlbnRhbCA9IGFjY2lkZW50YWxzW25ld0tleVNpZy5hY2NpZGVudGFsc1tqXS5hY2NdO1xuXHR9XG5cdHZhciBjYWxjQWNjaWRlbnRhbCA9IGRlbHRhICsgbmV3QWNjaWRlbnRhbDtcblx0aWYgKGNhbGNBY2NpZGVudGFsIDwgLTIpIHtcblx0XHRuZXdQaXRjaC0tO1xuXHRcdGNhbGNBY2NpZGVudGFsICs9IChuZXdQaXRjaExldHRlciA9PT0gJ2MnIHx8IG5ld1BpdGNoTGV0dGVyID09PSAnZicpID8gMSA6IDI7XG5cdH1cblx0aWYgKGNhbGNBY2NpZGVudGFsID4gMikge1xuXHRcdG5ld1BpdGNoKys7XG5cdFx0Y2FsY0FjY2lkZW50YWwgLT0gKG5ld1BpdGNoTGV0dGVyID09PSAnYicgfHwgbmV3UGl0Y2hMZXR0ZXIgPT09ICdlJykgPyAxIDogMjtcblx0fVxuXHRyZXR1cm4gW25ld1BpdGNoLCBjYWxjQWNjaWRlbnRhbF07XG59XG5cbnZhciBhY2NpZGVudGFscyA9IHtcblx0ZGJsZmxhdDogLTIsXG5cdGZsYXQ6IC0xLFxuXHRuYXR1cmFsOiAwLFxuXHRzaGFycDogMSxcblx0ZGJsc2hhcnA6IDJcbn07XG52YXIgYWNjaWRlbnRhbHMyID0ge1xuXHRcIi0yXCI6IFwiZGJsZmxhdFwiLFxuXHRcIi0xXCI6IFwiZmxhdFwiLFxuXHRcIjBcIjogXCJuYXR1cmFsXCIsXG5cdFwiMVwiOiBcInNoYXJwXCIsXG5cdFwiMlwiOiBcImRibHNoYXJwXCJcbn07XG50cmFuc3Bvc2Uubm90ZSA9IGZ1bmN0aW9uKG11bHRpbGluZVZhcnMsIGVsKSB7XG5cdC8vIHRoZSBcImVsXCIgdGhhdCBpcyBwYXNzZWQgaW4gaGFzIGVsLmFjY2lkZW50YWwsIGFuZCBlbC5waXRjaC4gXCJwaXRjaFwiIGlzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAoMD1taWRkbGUgQylcblx0Ly8gbG9jYWxUcmFuc3Bvc2UgaXMgdGhlIG51bWJlciBvZiBoYWxmIHN0ZXBzXG5cdC8vIGxvY2FsVHJhbnNwb3NlVmVydGljYWxNb3ZlbWVudCBpcyB0aGUgdmVydGljYWwgZGlzdGFuY2UgdG8gbW92ZS5cblx0aWYgKCFtdWx0aWxpbmVWYXJzLmxvY2FsVHJhbnNwb3NlKVxuXHRcdHJldHVybjtcblx0dmFyIG9yaWdQaXRjaCA9IGVsLnBpdGNoO1xuXHRlbC5waXRjaCA9IGVsLnBpdGNoICsgbXVsdGlsaW5lVmFycy5sb2NhbFRyYW5zcG9zZVZlcnRpY2FsTW92ZW1lbnQ7XG5cblx0aWYgKGVsLmFjY2lkZW50YWwpIHtcblx0XHR2YXIgcmV0ID0gYWNjaWRlbnRhbENoYW5nZShvcmlnUGl0Y2gsIGVsLnBpdGNoLCBlbC5hY2NpZGVudGFsLCBtdWx0aWxpbmVWYXJzLmdsb2JhbFRyYW5zcG9zZU9yaWdLZXlTaWcsIG11bHRpbGluZVZhcnMudGFyZ2V0S2V5KTtcblx0XHRlbC5waXRjaCA9IHJldFswXTtcblx0XHRlbC5hY2NpZGVudGFsID0gYWNjaWRlbnRhbHMyW3JldFsxXV07XG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3Bvc2U7XG4iLCIvLyAgICB3cmFwX2xpbmVzLmpzOiBkb2VzIGxpbmUgd3JhcCBvbiBhbiBhbHJlYWR5IHBhcnNlZCB0dW5lLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDE4IFBhdWwgUm9zZW4gKHBhdWwgYXQgcGF1bHJvc2VuIGRvdCBuZXQpXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIHdyYXBMaW5lcyh0dW5lLCBsaW5lQnJlYWtzKSB7XG5cdGlmICghbGluZUJyZWFrcyB8fCB0dW5lLmxpbmVzLmxlbmd0aCA9PT0gMClcblx0XHRyZXR1cm47XG5cblx0Ly8gdHVuZS5saW5lcyBjb250YWlucyBuZXN0ZWQgYXJyYXlzOiB0aGVyZSBpcyBhbiBhcnJheSBvZiBsaW5lcyAodGhhdCdzIHRoZSBwYXJ0IHRoaXMgZnVuY3Rpb24gcmV3cml0ZXMpLFxuXHQvLyB0aGVyZSBpcyBhbiBhcnJheSBvZiBzdGFmZnMgcGVyIGxpbmUgKGZvciBpbnN0YW5jZSwgcGlhbm8gd2lsbCBoYXZlIDIsIG9yY2hlc3RyYSB3aWxsIGhhdmUgbWFueSlcblx0Ly8gdGhlcmUgaXMgYW4gYXJyYXkgb2Ygdm9pY2VzIHBlciBzdGFmZiAoZm9yIGluc3RhbmNlLCA0LXBhcnQgaGFybW9ueSBtaWdodCBoYXZlIGJhc3MgYW5kIHRlbm9yIG9uIGEgc2luZ2xlIHN0YWZmKVxuXHQvLyBUaGUgbWVhc3VyZSBudW1iZXJzIHN0YXJ0IGF0IHplcm8gZm9yIGVhY2ggc3RhZmYsIGJ1dCBvbiB0aGUgc3VjY2VlZGluZyBsaW5lcywgdGhlIG1lYXN1cmUgbnVtYmVycyBhcmUgcmVzZXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZS5cblx0dmFyIG5ld0xpbmVzID0gW107XG5cdC8vIGtlZXAgdHJhY2sgb2Ygb3VyIGNvdW50ZXJzIGZvciBlYWNoIHN0YWZmIGFuZCB2b2ljZVxuXHR2YXIgc3RhcnROZXdMaW5lID0gW107XG5cdHZhciBjdXJyZW50TGluZSA9IFtdO1xuXHR2YXIgbWVhc3VyZU51bWJlciA9IFtdO1xuXHR2YXIgbWVhc3VyZU1hcmtlciA9IFtdO1xuXHR2YXIgbGFzdE1ldGVyID0gJyc7XG5cdHZhciB2b2ljZVN0YXJ0ID0ge307XG5cdHZhciBsaW5lc1dpdGhvdXRTdGFmZiA9IDA7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0dW5lLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGxpbmUgPSB0dW5lLmxpbmVzW2ldO1xuXHRcdGlmIChsaW5lLnN0YWZmKSB7XG5cdFx0XHR2YXIgc3RhZmZzID0gbGluZS5zdGFmZjtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc3RhZmZzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChzdGFydE5ld0xpbmVbal0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHN0YXJ0TmV3TGluZVtqXSA9IFtdO1xuXHRcdFx0XHRcdGN1cnJlbnRMaW5lW2pdID0gW107XG5cdFx0XHRcdFx0bWVhc3VyZU51bWJlcltqXSA9IFtdO1xuXHRcdFx0XHRcdG1lYXN1cmVNYXJrZXJbal0gPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhZmYgPSBzdGFmZnNbal07XG5cdFx0XHRcdHZhciB2b2ljZXMgPSBzdGFmZi52b2ljZXM7XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgdm9pY2VzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0TmV3TGluZVtqXVtrXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzdGFydE5ld0xpbmVbal1ba10gPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y3VycmVudExpbmVbal1ba10gPSAwO1xuXHRcdFx0XHRcdFx0bWVhc3VyZU51bWJlcltqXVtrXSA9IDA7XG5cdFx0XHRcdFx0XHRtZWFzdXJlTWFya2VyW2pdW2tdID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxpbmVzV2l0aG91dFN0YWZmID4gMCkgY3VycmVudExpbmVbal1ba10gKz0gbGluZXNXaXRob3V0U3RhZmY7XG5cdFx0XHRcdFx0dmFyIHZvaWNlID0gdm9pY2VzW2tdO1xuXHRcdFx0XHRcdGZvciAodmFyIGUgPSAwOyBlIDwgdm9pY2UubGVuZ3RoOyBlKyspIHtcblx0XHRcdFx0XHRcdGlmIChzdGFydE5ld0xpbmVbal1ba10pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0pXG5cdFx0XHRcdFx0XHRcdFx0bmV3TGluZXNbY3VycmVudExpbmVbal1ba11dID0geyBzdGFmZjogW10gfTtcblx0XHRcdFx0XHRcdFx0aWYgKCFuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0uc3RhZmZbal0pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0uc3RhZmZbal0gPSB7dm9pY2VzOiBbXX07XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHN0YWZmKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhZmYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoa2V5ID09PSAnbWV0ZXInKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5ld0xpbmVzLmxlbmd0aCA9PT0gMSB8fCBsYXN0TWV0ZXIgIT09IEpTT04uc3RyaW5naWZ5KHN0YWZmW2tleV0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYXN0TWV0ZXIgPSBKU09OLnN0cmluZ2lmeShzdGFmZltrZXldKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ld0xpbmVzW2N1cnJlbnRMaW5lW2pdW2tdXS5zdGFmZltqXVtrZXldID0gc3RhZmZba2V5XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoa2V5ICE9PSAndm9pY2VzJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ld0xpbmVzW2N1cnJlbnRMaW5lW2pdW2tdXS5zdGFmZltqXVtrZXldID0gc3RhZmZba2V5XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAobWVhc3VyZU1hcmtlcltqXVtrXSlcblx0XHRcdFx0XHRcdFx0XHRuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0uc3RhZmZbal0uYmFyTnVtYmVyID0gbWVhc3VyZU1hcmtlcltqXVtrXTtcblx0XHRcdFx0XHRcdFx0c3RhcnROZXdMaW5lW2pdW2tdID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHZvaWNlW2VdO1xuXHRcdFx0XHRcdFx0aWYgKCFuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0uc3RhZmZbal0udm9pY2VzW2tdKSB7XG5cdFx0XHRcdFx0XHRcdG5ld0xpbmVzW2N1cnJlbnRMaW5lW2pdW2tdXS5zdGFmZltqXS52b2ljZXNba10gPSBbXTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgc3RhcnRJdGVtIGluIHZvaWNlU3RhcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodm9pY2VTdGFydC5oYXNPd25Qcm9wZXJ0eShzdGFydEl0ZW0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdMaW5lc1tjdXJyZW50TGluZVtqXVtrXV0uc3RhZmZbal0udm9pY2VzW2tdLnB1c2godm9pY2VTdGFydFtzdGFydEl0ZW1dKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bmV3TGluZXNbY3VycmVudExpbmVbal1ba11dLnN0YWZmW2pdLnZvaWNlc1trXS5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuZWxfdHlwZSA9PT0gJ3N0ZW0nKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBuaWNlIHRyaWNrIHRvIGp1c3QgcGF5IGF0dGVudGlvbiB0byB0aGUgbGFzdCBzZXR0aW5nIG9mIGVhY2ggdHlwZS5cblx0XHRcdFx0XHRcdFx0dm9pY2VTdGFydFtlbGVtZW50LmVsX3R5cGVdID0gZWxlbWVudDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuZWxfdHlwZSA9PT0gJ2JhcicpIHtcblx0XHRcdFx0XHRcdFx0bWVhc3VyZU51bWJlcltqXVtrXSsrO1xuXHRcdFx0XHRcdFx0XHRpZiAobGluZUJyZWFrc1ttZWFzdXJlTnVtYmVyW2pdW2tdXSkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0TmV3TGluZVtqXVtrXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudExpbmVbal1ba10rKztcblx0XHRcdFx0XHRcdFx0XHRtZWFzdXJlTWFya2VyW2pdW2tdID0gZWxlbWVudC5iYXJOdW1iZXI7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIGVsZW1lbnQuYmFyTnVtYmVyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpbmVzV2l0aG91dFN0YWZmID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3TGluZXMucHVzaChsaW5lKTtcblx0XHRcdGxpbmVzV2l0aG91dFN0YWZmKys7XG5cdFx0fVxuXHR9XG5cdHR1bmUubGluZXMgPSBuZXdMaW5lcztcbn1cblxuZnVuY3Rpb24gZnJlZUZvcm1MaW5lQnJlYWtzKHdpZHRocywgbGluZUJyZWFrUG9pbnQpIHtcblx0dmFyIGxpbmVCcmVha3MgPSBbXTtcblx0dmFyIHRvdGFscyA9IFtdO1xuXHR2YXIgdG90YWxUaGlzTGluZSA9IDA7XG5cdC8vIHJ1biB0aHJvdWdoIGVhY2ggbWVhc3VyZSBhbmQgc2VlIGlmIHRoZSBhY2N1bXVsYXRpb24gaXMgbGVzcyB0aGFuIHRoZSBpZGVhbC5cblx0Ly8gaWYgaXQgcGFzc2VzIHRoZSBpZGVhbCwgdGhlbiBzZWUgd2hldGhlciB0aGUgbGFzdCBvciB0aGlzIG9uZSBpcyBjbG9zZXIgdG8gdGhlIGlkZWFsLlxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRocy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB3aWR0aCA9IHdpZHRoc1tpXTtcblx0XHR2YXIgYXR0ZW1wdGVkV2lkdGggPSB0b3RhbFRoaXNMaW5lICsgd2lkdGg7XG5cdFx0aWYgKGF0dGVtcHRlZFdpZHRoIDwgbGluZUJyZWFrUG9pbnQpXG5cdFx0XHR0b3RhbFRoaXNMaW5lID0gYXR0ZW1wdGVkV2lkdGg7XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBUaGlzIGp1c3QgcGFzc2VkIHRoZSBpZGVhbCwgc28gc2VlIHdoZXRoZXIgdGhlIHByZXZpb3VzIG9yIHRoZSBjdXJyZW50IG51bWJlciBvZiBtZWFzdXJlcyBpcyBjbG9zZXIuXG5cdFx0XHR2YXIgb2xkRGlzdGFuY2UgPSBsaW5lQnJlYWtQb2ludCAtIHRvdGFsVGhpc0xpbmU7XG5cdFx0XHR2YXIgbmV3RGlzdGFuY2UgPSBhdHRlbXB0ZWRXaWR0aCAtIGxpbmVCcmVha1BvaW50O1xuXHRcdFx0aWYgKG9sZERpc3RhbmNlIDwgbmV3RGlzdGFuY2UgJiYgdG90YWxUaGlzTGluZSA+IDApIHtcblx0XHRcdFx0bGluZUJyZWFrcy5wdXNoKGkgLSAxKTtcblx0XHRcdFx0dG90YWxzLnB1c2goTWF0aC5yb3VuZCh0b3RhbFRoaXNMaW5lIC0gd2lkdGgpKTtcblx0XHRcdFx0dG90YWxUaGlzTGluZSA9IHdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGkgPCB3aWR0aHMubGVuZ3RoLTEpIHtcblx0XHRcdFx0XHRsaW5lQnJlYWtzLnB1c2goaSk7XG5cdFx0XHRcdFx0dG90YWxzLnB1c2goTWF0aC5yb3VuZCh0b3RhbFRoaXNMaW5lKSk7XG5cdFx0XHRcdFx0dG90YWxUaGlzTGluZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dG90YWxzLnB1c2goTWF0aC5yb3VuZCh0b3RhbFRoaXNMaW5lKSk7XG5cdHJldHVybiB7IGxpbmVCcmVha3M6IGxpbmVCcmVha3MsIHRvdGFsczogdG90YWxzIH07XG59XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZUxpbmVUZXN0QXJyYXkobnVtTGluZXMsIG51bU1lYXN1cmVzLCBtYXhNZWFzdXJlc1BlckxpbmUsIG1pbk1lYXN1cmVzUGVyTGluZSkge1xuLy8gXHR2YXIgdHJpZXMgPSBbXTtcbi8vIFx0Ly8gVG8gZ2V0IGFsbCB0aGUgaXRlcmF0aW9ucywgaXQgaXMgZXZlcnkgZGlnaXQgaW4gYSBwYXJ0aWN1bGFyIGJhc2UtbnVtYmVyaW5nIHN5c3RlbS5cbi8vIFx0Ly8gVGhhdCBpcywgd2Ugd2FudCB0byBnZW5lcmF0ZSBldmVyeSBudW1iZXIgdGhhdCBpcyAobnVtTGluZXMtMSkgZGlnaXRzLCBpbiBiYXNlIChtYXgtbWluKzEpXG4vLyBcdC8vIEZvciBpbnN0YW5jZSwgZm9yIDUgbGluZXMgd2hlcmUgdGhlIG1pbiBpcyA2IGFuZCBtYXggaXMgOCwgd2Ugd2FudCBldmVyIGNvbWJpbmF0aW9uIG9mIDQgZGlnaXRzIGluIGJhc2UgMy5cbi8vIFx0dmFyIGJhc2UgPSBtYXhNZWFzdXJlc1BlckxpbmUgLSBtaW5NZWFzdXJlc1BlckxpbmUgKyAxO1xuLy8gXHR2YXIgZGlnaXRzID0gbnVtTGluZXMgLSAxOyAvLyBUaGUgbGFzdCBkaWdpdCBpcyBmaXhlZDogaXQgaXMgd2hhdCBldmVyIGlzIG5lZWRlZCB0byBzdW0gdXAgdG8gdGhlIHRvdGFsIG51bWJlciBvZiBtZWFzdXJlcy5cbi8vIFx0dmFyIGRvbmUgPSBmYWxzZTtcbi8vIFx0dmFyIGl0ZXIgPSAwO1xuLy8gXHR3aGlsZSAoIWRvbmUpIHtcbi8vIFx0XHR2YXIgYXR0ZW1wdCA9IFtdO1xuLy8gXHRcdHZhciBudW0gPSBpdGVyO1xuLy8gXHRcdHZhciB0b3RhbCA9IDA7XG4vLyBcdFx0Zm9yICh2YXIgZCA9IGRpZ2l0cyAtIDE7IGQgPj0gMDsgZC0tKSB7XG4vLyBcdFx0XHRhdHRlbXB0W2RdID0gKG51bSAlIGJhc2UpICsgbWluTWVhc3VyZXNQZXJMaW5lO1xuLy8gXHRcdFx0bnVtID0gTWF0aC5mbG9vcihudW0gLyBiYXNlKTtcbi8vIFx0XHRcdHRvdGFsICs9IGF0dGVtcHRbZF07XG4vLyBcdFx0fVxuLy8gXHRcdGlmIChudW0gPiAwKVxuLy8gXHRcdFx0ZG9uZSA9IHRydWU7IC8vIGNvbnRpbnVlIHVudGlsIHdlIGV4Y2VlZCB0aGUgZ3JlYXRlc3QgbnVtYmVyLiBXZSBrbm93IGJlY2F1c2UgdGhlcmUgaXMgYSByZW1haW5lci5cbi8vIFx0XHRlbHNlIHtcbi8vIFx0XHRcdHZhciBsYXN0TGluZSA9IG51bU1lYXN1cmVzIC0gdG90YWw7XG4vLyBcdFx0XHRpZiAobGFzdExpbmUgPj0gbWluTWVhc3VyZXNQZXJMaW5lICYmIGxhc3RMaW5lIDw9IG1heE1lYXN1cmVzUGVyTGluZSkge1xuLy8gXHRcdFx0XHRhdHRlbXB0W2RpZ2l0c10gPSBsYXN0TGluZTtcbi8vIFx0XHRcdFx0dHJpZXMucHVzaChhdHRlbXB0KTtcbi8vIFx0XHRcdH1cbi8vIFx0XHRcdGl0ZXIrKztcbi8vIFx0XHR9XG4vLyBcdH1cbi8vIFx0cmV0dXJuIHRyaWVzO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBnZXRWYXJpYW5jZShhdHRlbXB0LCBpZGVhbExpbmVCcmVhaywgd2lkdGhzLCBhbGxvd2FibGVPdmVyYWdlKSB7XG4vLyBcdHZhciBtZWFzdXJlTnVtYmVyID0gMDtcbi8vIFx0dmFyIHRoaXNXb3JzdFZhcmlhbmNlID0gMDtcbi8vIFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhdHRlbXB0Lmxlbmd0aDsgaisrKSB7XG4vLyBcdFx0dmFyIGxpbmVXaWR0aCA9IDA7XG4vLyBcdFx0dmFyIG1lYXN1cmVzVGhpc0xpbmUgPSBhdHRlbXB0W2pdO1xuLy8gXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbWVhc3VyZXNUaGlzTGluZTsgaysrKSB7XG4vLyBcdFx0XHRsaW5lV2lkdGggKz0gd2lkdGhzW21lYXN1cmVOdW1iZXIrK107XG4vLyBcdFx0fVxuLy8gXHRcdGlmIChsaW5lV2lkdGggPiBhbGxvd2FibGVPdmVyYWdlKVxuLy8gXHRcdFx0cmV0dXJuIG51bGw7XG4vLyBcdFx0dmFyIHZhcmlhbmNlID0gTWF0aC5hYnMobGluZVdpZHRoIC0gaWRlYWxMaW5lQnJlYWspO1xuLy8gXHRcdGlmICh2YXJpYW5jZSA+IHRoaXNXb3JzdFZhcmlhbmNlKVxuLy8gXHRcdFx0dGhpc1dvcnN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcbi8vIFx0fVxuLy8gXHRyZXR1cm4gdGhpc1dvcnN0VmFyaWFuY2U7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGdldE1heFZhcmlhbmNlKHdpZHRocywgbGluZUJyZWFrUG9pbnQsIGxpbmVCcmVha3MpIHtcbi8vIFx0dmFyIG1heFZhcmlhbmNlID0gMDtcbi8vIFx0dmFyIG51bUxpbmVzID0gbGluZUJyZWFrcy5sZW5ndGggKyAxOyAvLyB0aGUgbGFzdCBsaW5lIGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBicmVha1xuLy8gXHR2YXIgbWVhc3VyZU51bWJlciA9IDA7XG4vLyBcdHZhciB0b3RhbHMgPSBbXTtcbi8vIFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbGluZUJyZWFrcy5sZW5ndGg7IGkrKykge1xuLy8gXHRcdHZhciBicmVha01lYXN1cmUgPSAoaSA9PT0gbGluZUJyZWFrcy5sZW5ndGgpID8gd2lkdGhzLmxlbmd0aCA6IGxpbmVCcmVha3NbaV07XG4vLyBcdFx0dmFyIHRoaXNUb3RhbCA9IDA7XG4vLyBcdFx0Zm9yICh2YXIgaiA9IG1lYXN1cmVOdW1iZXI7IGogPCBicmVha01lYXN1cmU7IGorKykge1xuLy8gXHRcdFx0dGhpc1RvdGFsICs9IHdpZHRoc1tqXTtcbi8vIFx0XHR9XG4vLyBcdFx0bWVhc3VyZU51bWJlciA9IGJyZWFrTWVhc3VyZTtcbi8vIFx0XHR2YXIgdGhpc1ZhcmlhbmNlID0gdGhpc1RvdGFsIDw9IGxpbmVCcmVha1BvaW50ID8gbGluZUJyZWFrUG9pbnQgLSB0aGlzVG90YWwgOiAxMDAwMDAwO1xuLy8gXHRcdHRvdGFscy5wdXNoKHt0b3RhbDogdGhpc1RvdGFsLCB2YXJpYW5jZTogdGhpc1ZhcmlhbmNlfSlcbi8vIFx0XHRtYXhWYXJpYW5jZSA9IE1hdGgubWF4KG1heFZhcmlhbmNlLCB0aGlzVmFyaWFuY2UpO1xuLy8gXHR9XG4vL1xuLy8gXHRjb25zb2xlLmxvZyhsaW5lQnJlYWtQb2ludCwgdG90YWxzKVxuLy8gXHRyZXR1cm4gbWF4VmFyaWFuY2U7XG4vLyB9XG5cbmZ1bmN0aW9uIGdldFZhcmlhbmNlKHdpZHRocywgbGluZUJyZWFrcykge1xuXHR2YXIgbnVtTGluZXMgPSBsaW5lQnJlYWtzLmxlbmd0aCArIDE7IC8vIHRoZSBsYXN0IGxpbmUgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGJyZWFrXG5cdHZhciBhdmcgPSB3aWR0aHMudG90YWwgLyBudW1MaW5lcztcblx0dmFyIGxhcmdlc3RWYXJpYW5jZSA9IDA7XG5cdHZhciBtZWFzdXJlTnVtYmVyID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbGluZUJyZWFrcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBicmVha01lYXN1cmUgPSAoaSA9PT0gbGluZUJyZWFrcy5sZW5ndGgpID8gd2lkdGhzLm1lYXN1cmVXaWR0aHMubGVuZ3RoLTEgOiBsaW5lQnJlYWtzW2ldO1xuXHRcdHZhciB0aGlzVmFyaWFuY2UgPSBsaW5lVmFyaWFuY2Uod2lkdGhzLm1lYXN1cmVXaWR0aHMsIG1lYXN1cmVOdW1iZXIsIGJyZWFrTWVhc3VyZSwgYXZnKTtcblx0XHRtZWFzdXJlTnVtYmVyID0gYnJlYWtNZWFzdXJlKzE7XG5cdFx0bGFyZ2VzdFZhcmlhbmNlID0gTWF0aC5tYXgobGFyZ2VzdFZhcmlhbmNlLCB0aGlzVmFyaWFuY2UpO1xuXHR9XG5cblx0cmV0dXJuIGxhcmdlc3RWYXJpYW5jZTtcbn1cblxuLy8gZnVuY3Rpb24gZ2V0QXZnVmFyaWFuY2Uod2lkdGhzLCBsaW5lQnJlYWtQb2ludCwgbGluZUJyZWFrcykge1xuLy8gXHR2YXIgdG90YWxWYXJpYW5jZSA9IDA7XG4vLyBcdHZhciBudW1MaW5lcyA9IGxpbmVCcmVha3MubGVuZ3RoICsgMTsgLy8gdGhlIGxhc3QgbGluZSBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQgYnJlYWtcbi8vIFx0dmFyIG1lYXN1cmVOdW1iZXIgPSAwO1xuLy8gXHRmb3IgKHZhciBpID0gMDsgaSA8PSBsaW5lQnJlYWtzLmxlbmd0aDsgaSsrKSB7XG4vLyBcdFx0dmFyIGJyZWFrTWVhc3VyZSA9IChpID09PSBsaW5lQnJlYWtzLmxlbmd0aCkgPyB3aWR0aHMubGVuZ3RoIDogbGluZUJyZWFrc1tpXTtcbi8vIFx0XHR2YXIgdGhpc1RvdGFsID0gMDtcbi8vIFx0XHRmb3IgKHZhciBqID0gbWVhc3VyZU51bWJlcjsgaiA8IGJyZWFrTWVhc3VyZTsgaisrKSB7XG4vLyBcdFx0XHR0aGlzVG90YWwgKz0gd2lkdGhzW2pdO1xuLy8gXHRcdH1cbi8vIFx0XHRtZWFzdXJlTnVtYmVyID0gYnJlYWtNZWFzdXJlO1xuLy8gXHRcdHZhciB0aGlzVmFyaWFuY2UgPSBNYXRoLmFicyhsaW5lQnJlYWtQb2ludCAtIHRoaXNUb3RhbCk7XG4vLyBcdFx0dG90YWxWYXJpYW5jZSArPSB0aGlzVmFyaWFuY2U7XG4vLyBcdH1cbi8vXG4vLyBcdHJldHVybiB0b3RhbFZhcmlhbmNlIC8gbnVtTGluZXM7XG4vLyB9XG5cbmZ1bmN0aW9uIGxpbmVWYXJpYW5jZSh3aWR0aHMsIHN0YXJ0LCBlbmQsIGF2Zykge1xuXHR2YXIgdGhpc1RvdGFsID0gbGluZVdpZHRoKHdpZHRocywgc3RhcnQsIGVuZCk7XG5cdHZhciB0aGlzVmFyaWFuY2UgPSBNYXRoLmFicyhhdmcgLSB0aGlzVG90YWwpO1xuXHRyZXR1cm4gdGhpc1ZhcmlhbmNlO1xufVxuXG5mdW5jdGlvbiBsaW5lV2lkdGgod2lkdGhzLCBzdGFydCwgZW5kKSB7XG5cdHZhciB0aGlzVG90YWwgPSAwO1xuXHRmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspXG5cdFx0dGhpc1RvdGFsICs9IHdpZHRoc1tqXTtcblx0cmV0dXJuIHRoaXNUb3RhbDtcbn1cblxuLy8gVE9ETy1QRVI6IEZvciBsb25nIHBpZWNlcyBvZiBtdXNpYywgdGhpcyBjYW4gZ2V0IGxvbmcsIHNvIHN0b3AgZmluZGluZyB0aGUgY29tYmluYXRpb25zIGF0IGFuIGFyYml0cmFyeSBwbGFjZS5cbmZ1bmN0aW9uIGdldEF0dGVtcHRzKHdpZHRocywgc3RhcnQsIGxpbmVzTGVmdCwgbWluLCBtYXgsIGxhc3RMaW5lcykge1xuXHR2YXIgTUFYX0NPTUJJTkFUSU9OUyA9IDEyMDA7XG5cdHZhciBhY2MgPSAwO1xuXHR2YXIgYXR0ZW1wdHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgd2lkdGhzLmxlbmd0aCAmJiBhY2MgPCBtYXg7IGkrKykge1xuXHRcdGFjYyArPSB3aWR0aHNbaV07XG5cdFx0aWYgKGFjYyA+IG1heClcblx0XHRcdGJyZWFrO1xuXHRcdGlmIChhY2MgPiBtaW4pIHtcblx0XHRcdGlmIChsaW5lc0xlZnQgPiAwICYmIGF0dGVtcHRzLmxlbmd0aCA8IE1BWF9DT01CSU5BVElPTlMpIHtcblx0XHRcdFx0dmFyIG5leHRMaW5lcyA9IGdldEF0dGVtcHRzKHdpZHRocywgaSArIDEsIGxpbmVzTGVmdCAtIDEsIG1pbiwgbWF4LCBsYXN0TGluZXMpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5leHRMaW5lcy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRhdHRlbXB0cy5wdXNoKFtpXS5jb25jYXQobmV4dExpbmVzW2pdKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGluZXNMZWZ0ID09PSAxICYmIGxhc3RMaW5lcy5pbmRleE9mKGkpID49IDApXG5cdFx0XHRcdGF0dGVtcHRzLnB1c2goW2ldKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGF0dGVtcHRzO1xufVxuXG5mdW5jdGlvbiBsYXN0TGluZVBvc3NpYmlsaXRpZXMod2lkdGhzLCBzdGFydCwgbWluLCBtYXgpIHtcblx0dmFyIGFjYyA9IDA7XG5cdHZhciBwb3NzaWJpbGl0aWVzID0gW107XG5cdGZvciAodmFyIGkgPSB3aWR0aHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0YWNjICs9IHdpZHRoc1tpXTtcblx0XHRpZiAoYWNjID4gbWF4KVxuXHRcdFx0YnJlYWs7XG5cdFx0aWYgKGFjYyA+IG1pbiAmJiBpIDwgc3RhcnQpIHtcblx0XHRcdHBvc3NpYmlsaXRpZXMucHVzaChpLTEpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcG9zc2liaWxpdGllcztcbn1cblxuZnVuY3Rpb24gY2xvbmUoYXJyKSB7XG5cdHZhciBuZXdBcnIgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG5cdFx0bmV3QXJyLnB1c2goYXJyW2ldKTtcblx0cmV0dXJuIG5ld0Fycjtcbn1cblxuZnVuY3Rpb24gb25lVHJ5KG1lYXN1cmVXaWR0aHMsIGlkZWFsV2lkdGhzLCBhY2N1bXVsYXRvciwgbGluZUFjY3VtdWxhdG9yLCBsaW5lV2lkdGhzLCBsYXN0VmFyaWFuY2UsIGhpZ2hlc3RWYXJpYW5jZSwgY3VyckxpbmUsIGxpbmVCcmVha3MsIHN0YXJ0SW5kZXgsIG90aGVyVHJpZXMpIHtcblx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBtZWFzdXJlV2lkdGhzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIG1lYXN1cmVXaWR0aCA9IG1lYXN1cmVXaWR0aHNbaV07XG5cdFx0YWNjdW11bGF0b3IgKz0gbWVhc3VyZVdpZHRoO1xuXHRcdGxpbmVBY2N1bXVsYXRvciArPSBtZWFzdXJlV2lkdGg7XG5cdFx0dmFyIHRoaXNWYXJpYW5jZSA9IE1hdGguYWJzKGFjY3VtdWxhdG9yIC0gaWRlYWxXaWR0aHNbY3VyckxpbmVdKTtcblx0XHR2YXIgdmFyaWFuY2VJc0Nsb3NlID0gTWF0aC5hYnModGhpc1ZhcmlhbmNlIC0gbGFzdFZhcmlhbmNlKSA8IGlkZWFsV2lkdGhzWzBdIC8gMTA7IC8vIHNlZSBpZiB0aGUgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gMTAlLCBpZiBzbywgcnVuIHRoZSB0ZXN0IGJvdGggd2F5cy5cblx0XHRpZiAodmFyaWFuY2VJc0Nsb3NlKSB7XG5cdFx0XHRpZiAodGhpc1ZhcmlhbmNlIDwgbGFzdFZhcmlhbmNlKSB7XG5cdFx0XHRcdC8vIEFsc28gYXR0ZW1wdCBvbmUgbGVzcyBtZWFzdXJlIG9uIHRoZSBjdXJyZW50IGxpbmUgLSBzb21ldGltZXMgdGhhdCB3b3JrcyBvdXQgYmV0dGVyLlxuXHRcdFx0XHR2YXIgbmV3V2lkdGhzID0gY2xvbmUobGluZVdpZHRocyk7XG5cdFx0XHRcdHZhciBuZXdCcmVha3MgPSBjbG9uZShsaW5lQnJlYWtzKTtcblx0XHRcdFx0bmV3QnJlYWtzLnB1c2goaS0xKTtcblx0XHRcdFx0bmV3V2lkdGhzLnB1c2gobGluZUFjY3VtdWxhdG9yIC0gbWVhc3VyZVdpZHRoKTtcblx0XHRcdFx0b3RoZXJUcmllcy5wdXNoKHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcjogYWNjdW11bGF0b3IsXG5cdFx0XHRcdFx0bGluZUFjY3VtdWxhdG9yOiBtZWFzdXJlV2lkdGgsXG5cdFx0XHRcdFx0bGluZVdpZHRoczogbmV3V2lkdGhzLFxuXHRcdFx0XHRcdGxhc3RWYXJpYW5jZTogTWF0aC5hYnMoYWNjdW11bGF0b3IgLSBpZGVhbFdpZHRoc1tjdXJyTGluZSsxXSksXG5cdFx0XHRcdFx0aGlnaGVzdFZhcmlhbmNlOiBNYXRoLm1heChoaWdoZXN0VmFyaWFuY2UsIGxhc3RWYXJpYW5jZSksXG5cdFx0XHRcdFx0Y3VyckxpbmU6IGN1cnJMaW5lKzEsXG5cdFx0XHRcdFx0bGluZUJyZWFrczogbmV3QnJlYWtzLFxuXHRcdFx0XHRcdHN0YXJ0SW5kZXg6IGkrMX0pO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzVmFyaWFuY2UgPiBsYXN0VmFyaWFuY2UgJiYgaSA8IG1lYXN1cmVXaWR0aHMubGVuZ3RoLTEpIHtcblx0XHRcdFx0Ly8gQWxzbyBhdHRlbXB0IG9uZSBleHRyYSBtZWFzdXJlIG9uIHRoaXMgbGluZS5cblx0XHRcdFx0bmV3V2lkdGhzID0gY2xvbmUobGluZVdpZHRocyk7XG5cdFx0XHRcdG5ld0JyZWFrcyA9IGNsb25lKGxpbmVCcmVha3MpO1xuXHRcdFx0XHQvLyBuZXdCcmVha3NbbmV3QnJlYWtzLmxlbmd0aC0xXSA9IGk7XG5cdFx0XHRcdC8vIG5ld1dpZHRoc1tuZXdXaWR0aHMubGVuZ3RoLTFdID0gbGluZUFjY3VtdWxhdG9yO1xuXHRcdFx0XHRvdGhlclRyaWVzLnB1c2goe1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yOiBhY2N1bXVsYXRvcixcblx0XHRcdFx0XHRsaW5lQWNjdW11bGF0b3I6IGxpbmVBY2N1bXVsYXRvcixcblx0XHRcdFx0XHRsaW5lV2lkdGhzOiBuZXdXaWR0aHMsXG5cdFx0XHRcdFx0bGFzdFZhcmlhbmNlOiB0aGlzVmFyaWFuY2UsXG5cdFx0XHRcdFx0aGlnaGVzdFZhcmlhbmNlOiBNYXRoLm1heChoaWdoZXN0VmFyaWFuY2UsIHRoaXNWYXJpYW5jZSksXG5cdFx0XHRcdFx0Y3VyckxpbmU6IGN1cnJMaW5lLFxuXHRcdFx0XHRcdGxpbmVCcmVha3M6IG5ld0JyZWFrcyxcblx0XHRcdFx0XHRzdGFydEluZGV4OiBpKzF9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRoaXNWYXJpYW5jZSA+IGxhc3RWYXJpYW5jZSkge1xuXHRcdFx0bGluZUJyZWFrcy5wdXNoKGkgLSAxKTtcblx0XHRcdGN1cnJMaW5lKys7XG5cdFx0XHRoaWdoZXN0VmFyaWFuY2UgPSBNYXRoLm1heChoaWdoZXN0VmFyaWFuY2UsIGxhc3RWYXJpYW5jZSk7XG5cdFx0XHRsYXN0VmFyaWFuY2UgPSBNYXRoLmFicyhhY2N1bXVsYXRvciAtIGlkZWFsV2lkdGhzW2N1cnJMaW5lXSk7XG5cdFx0XHRsaW5lV2lkdGhzLnB1c2gobGluZUFjY3VtdWxhdG9yIC0gbWVhc3VyZVdpZHRoKTtcblx0XHRcdGxpbmVBY2N1bXVsYXRvciA9IG1lYXN1cmVXaWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGFzdFZhcmlhbmNlID0gdGhpc1ZhcmlhbmNlO1xuXHRcdH1cblx0fVxuXHRsaW5lV2lkdGhzLnB1c2gobGluZUFjY3VtdWxhdG9yKTtcbn1cblxuZnVuY3Rpb24gb3B0aW1pemVMaW5lV2lkdGhzKHdpZHRocywgbGluZUJyZWFrUG9pbnQsIGxpbmVCcmVha3MsIGV4cGxhbmF0aW9uKSB7XG5cdC8vXHRmaWd1cmUgb3V0IGhvdyBtYW55IGxpbmVzIC0gVGhhdCdzIG9uZSBtb3JlIHRoYW4gd2FzIHRyaWVkIGJlZm9yZS5cblx0dmFyIG51bUxpbmVzID0gTWF0aC5jZWlsKHdpZHRocy50b3RhbCAvIGxpbmVCcmVha1BvaW50KSArIDE7XG5cblx0Ly9cdGdldCB0aGUgaWRlYWwgd2lkdGggZm9yIGEgbGluZSAoY3VtdWxhdGl2ZSB3aWR0aCAvIG51bSBsaW5lcykgLSBhcHByb3ggdGhlIHNhbWUgYXMgbGluZUJyZWFrUG9pbnQgZXhjZXB0IGZvciByb3VuZGluZ1xuXHR2YXIgaWRlYWxXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGhzLnRvdGFsIC8gbnVtTGluZXMpO1xuXG5cdC8vXHRnZXQgZWFjaCBpZGVhbCBsaW5lIHdpZHRoICgxKmlkZWFsLCAyKmlkZWFsLCAzKmlkZWFsLCBldGMpXG5cdHZhciBpZGVhbFdpZHRocyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpbmVzOyBpKyspXG5cdFx0aWRlYWxXaWR0aHMucHVzaChpZGVhbFdpZHRoKihpKzEpKTtcblxuXHQvL1x0ZnJvbSBmaXJzdCBtZWFzdXJlLCBzdGVwIHRocm91Z2ggYWNjdW0uIFdpZHRocyB1bnRpbCB0aGUgYWJzIG9mIHRoZSBpZGVhbCBpcyBncmVhdGVyIHRoYW4gdGhlIGxhc3Qgb25lLlxuXHQvLyBUaGlzIGNhbiBzb21ldGltZXMgbG9vayBmdW5ueSBpbiBlZGdlIGNhc2VzLCBzbyB3aGVuIHRoZSBsZW5ndGggaXMgd2l0aGluIDEwJSwgdHJ5IG9uZSBtb3JlIG9yIG9uZSBsZXNzIHRvIHNlZSB3aGljaCBpcyBiZXR0ZXIuXG5cdC8vIFRoaXMgaXMgYmV0dGVyIHRoYW4gdHJ5aW5nIGFsbCB0aGUgcG9zc2liaWxpdGllcyBiZWNhdXNlIHRoYXQgd291bGQgZ2V0IHRvIGJlIGEgaHVnZSBudW1iZXIgZm9yIGV2ZW4gYSBtZWRpdW0gc2l6ZSBwaWVjZS5cblx0Ly8gVGhpcyBtZXRob2Qgc2VlbXMgdG8gbmV2ZXIgZ2VuZXJhdGUgbW9yZSB0aGFuIGFib3V0IDE2IHRyaWVzIGFuZCBpdCBpcyB1c3VhbGx5IDQgb3IgbGVzcy5cblx0dmFyIG90aGVyVHJpZXMgPSBbXTtcblx0b3RoZXJUcmllcy5wdXNoKHtcblx0XHRhY2N1bXVsYXRvcjogMCxcblx0XHRsaW5lQWNjdW11bGF0b3I6IDAsXG5cdFx0bGluZVdpZHRoczogW10sXG5cdFx0bGFzdFZhcmlhbmNlOiA5OTk5OTksXG5cdFx0aGlnaGVzdFZhcmlhbmNlOiAwLFxuXHRcdGN1cnJMaW5lOiAwLFxuXHRcdGxpbmVCcmVha3M6IFtdLCAvLyBUaGVzZSBhcmUgdGhlIHplcm8tYmFzZWQgbGFzdCBtZWFzdXJlIG9uIGVhY2ggbGluZVxuXHRcdHN0YXJ0SW5kZXg6IDB9KTtcblx0dmFyIGluZGV4ID0gMDtcblx0d2hpbGUgKGluZGV4IDwgb3RoZXJUcmllcy5sZW5ndGgpIHtcblx0XHRvbmVUcnkod2lkdGhzLm1lYXN1cmVXaWR0aHMsXG5cdFx0XHRpZGVhbFdpZHRocyxcblx0XHRcdG90aGVyVHJpZXNbaW5kZXhdLmFjY3VtdWxhdG9yLFxuXHRcdFx0b3RoZXJUcmllc1tpbmRleF0ubGluZUFjY3VtdWxhdG9yLFxuXHRcdFx0b3RoZXJUcmllc1tpbmRleF0ubGluZVdpZHRocyxcblx0XHRcdG90aGVyVHJpZXNbaW5kZXhdLmxhc3RWYXJpYW5jZSxcblx0XHRcdG90aGVyVHJpZXNbaW5kZXhdLmhpZ2hlc3RWYXJpYW5jZSxcblx0XHRcdG90aGVyVHJpZXNbaW5kZXhdLmN1cnJMaW5lLFxuXHRcdFx0b3RoZXJUcmllc1tpbmRleF0ubGluZUJyZWFrcyxcblx0XHRcdG90aGVyVHJpZXNbaW5kZXhdLnN0YXJ0SW5kZXgsXG5cdFx0XHRvdGhlclRyaWVzKTtcblx0XHRpbmRleCsrO1xuXHR9XG5cdGZvciAoaSA9IDA7IGkgPCBvdGhlclRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIG90aGVyVHJ5ID0gb3RoZXJUcmllc1tpXTtcblx0XHRvdGhlclRyeS52YXJpYW5jZXMgPSBbXTtcblx0XHRvdGhlclRyeS5hdmVWYXJpYW5jZSA9IDA7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvdGhlclRyeS5saW5lV2lkdGhzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGluZVdpZHRoID0gb3RoZXJUcnkubGluZVdpZHRoc1tqXTtcblx0XHRcdG90aGVyVHJ5LnZhcmlhbmNlcy5wdXNoKGxpbmVXaWR0aCAtIGlkZWFsV2lkdGhzWzBdKTtcblx0XHRcdG90aGVyVHJ5LmF2ZVZhcmlhbmNlICs9IE1hdGguYWJzKGxpbmVXaWR0aCAtIGlkZWFsV2lkdGhzWzBdKTtcblx0XHR9XG5cdFx0b3RoZXJUcnkuYXZlVmFyaWFuY2UgPSAgb3RoZXJUcnkuYXZlVmFyaWFuY2UgLyBvdGhlclRyeS5saW5lV2lkdGhzLmxlbmd0aDtcblx0XHRleHBsYW5hdGlvbi5hdHRlbXB0cy5wdXNoKHsgdHlwZTogXCJvcHRpbWl6ZUxpbmVXaWR0aHNcIiwgbGluZUJyZWFrczogb3RoZXJUcnkubGluZUJyZWFrcywgdmFyaWFuY2VzOiBvdGhlclRyeS52YXJpYW5jZXMsIGF2ZVZhcmlhbmNlOiBvdGhlclRyeS5hdmVWYXJpYW5jZSwgd2lkdGhzOiB3aWR0aHMubWVhc3VyZVdpZHRocyB9KTtcblx0fVxuXHR2YXIgc21hbGxlc3QgPSA5OTk5OTk5O1xuXHR2YXIgc21hbGxlc3RJbmRleCA9IC0xO1xuXHRmb3IgKGkgPSAwOyBpIDwgb3RoZXJUcmllcy5sZW5ndGg7IGkrKykge1xuXHRcdG90aGVyVHJ5ID0gb3RoZXJUcmllc1tpXTtcblx0XHRpZiAob3RoZXJUcnkuYXZlVmFyaWFuY2UgPCBzbWFsbGVzdCkge1xuXHRcdFx0c21hbGxlc3QgPSBvdGhlclRyeS5hdmVWYXJpYW5jZTtcblx0XHRcdHNtYWxsZXN0SW5kZXggPSBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4geyBmYWlsZWQ6IGZhbHNlLCBsaW5lQnJlYWtzOiBvdGhlclRyaWVzW3NtYWxsZXN0SW5kZXhdLmxpbmVCcmVha3MsIHZhcmlhbmNlOiBvdGhlclRyaWVzW3NtYWxsZXN0SW5kZXhdLmhpZ2hlc3RWYXJpYW5jZSB9O1xufVxuLy8gXHQvLyBJbnN0ZWFkIG9mIGhhdmluZyB0byB0cnkgYWxsIHRoZSBkaWZmZXJlbnQgY29tYmluYXRpb25zIHRvIGZpbmQgdGhlIGJlc3QsIHdlIHN0YXJ0IHdpdGggYW4gaW1wb3J0YW50IHBpZWNlIG9mIGtub3dsZWRnZSBhYm91dCB0aGUgbGluZUJyZWFrcyB3ZSBhcmUgZ2l2ZW46XG4vLyBcdC8vIElmIHRoZXJlIGlzIGEgbGluZSB0b28gc2hvcnQsIGl0IGlzIHRoZSBsYXN0IG9uZS5cbi8vIFx0Ly8gU28sIGxldCdzIGp1c3QgZG8gYSBjb3VwbGUgb2YgdHdlYWtzIHRvIHNlZSBob3cgaXQgd29ya3MgdG8gYWRkIG9uZSBvciB0d28gbWVhc3VyZXMgdG8gdGhlIGxhc3QgbGluZS5cbi8vIFx0dmFyIGF2ZyA9IHdpZHRocy50b3RhbCAvIChsaW5lQnJlYWtzLmxlbmd0aCArIDEpO1xuLy8gXHR2YXIgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZSh3aWR0aHMsIGxpbmVCcmVha3MpO1xuLy8gXHR2YXIgdmFyaWFuY2VQY3QgPSB2YXJpYW5jZS9saW5lQnJlYWtQb2ludCoxMDA7XG4vL1xuLy8gXHRpZiAobGluZUJyZWFrcy5sZW5ndGggPT09IDApXG4vLyBcdFx0cmV0dXJuIHsgZmFpbGVkOiB0cnVlLCByZWFzb246IFwiT25seSBvbmUgbGluZS5cIiB9O1xuLy9cbi8vIFx0dmFyIGxhc3RMaW5lU3RhcnQgPSBsaW5lQnJlYWtzW2xpbmVCcmVha3MubGVuZ3RoLTFdKzE7XG4vLyBcdHZhciBsYXN0TGluZVZhcmlhbmNlID0gbGluZVZhcmlhbmNlKHdpZHRocy5tZWFzdXJlV2lkdGhzLCBsYXN0TGluZVN0YXJ0LCB3aWR0aHMubWVhc3VyZVdpZHRocy5sZW5ndGgsIGF2Zyk7XG4vLyBcdGlmICh2YXJpYW5jZSA+IGxhc3RMaW5lVmFyaWFuY2UpXG4vLyBcdFx0cmV0dXJuIHsgZmFpbGVkOiB0cnVlLCByZWFzb246IFwiTGFzdCBsaW5lIGlzIG5vdCB0b28gc2hvcnQuXCIgfTtcbi8vXG4vLyBcdC8vIExldCdzIGdldCBhIGxpc3Qgb2YgYWxsIGNvbWJpbmF0aW9ucyB0aGF0IGhhdmUgYSBwb3NzaWJpbGl0eSBvZiB3b3JraW5nLiBUaGF0IGlzLCBhbGwgY29tYmluYXRpb25zIHdoZXJlIG5vIGxpbmUgaGFzIGEgdmFyaWFuY2UgbGFyZ2VyIHRoYW4gXCJ2YXJpYW5jZVwiLlxuLy8gXHR2YXIgbGFzdExpbmVzID0gbGFzdExpbmVQb3NzaWJpbGl0aWVzKHdpZHRocy5tZWFzdXJlV2lkdGhzLCBsYXN0TGluZVN0YXJ0LCBhdmcgLSB2YXJpYW5jZSwgYXZnICsgdmFyaWFuY2UpO1xuLy8gXHR2YXIgYXR0ZW1wdHMgPSBnZXRBdHRlbXB0cyh3aWR0aHMubWVhc3VyZVdpZHRocywgMCwgbGluZUJyZWFrcy5sZW5ndGgsIGF2ZyAtIHZhcmlhbmNlLCBhdmcgKyB2YXJpYW5jZSwgbGFzdExpbmVzKTtcbi8vIFx0Ly9jb25zb2xlLmxvZyhhdHRlbXB0cywgYXZnIC0gdmFyaWFuY2UsIGF2ZyArIHZhcmlhbmNlKTtcbi8vXG4vLyBcdHZhciBmYWlsZWQgPSB0cnVlO1xuLy8gXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0dGVtcHRzLmxlbmd0aDsgaSsrKSB7XG4vLyBcdFx0dmFyIG5ld1ZhcmlhbmNlID0gZ2V0VmFyaWFuY2Uod2lkdGhzLCBhdHRlbXB0c1tpXSk7XG4vLyBcdFx0aWYgKG5ld1ZhcmlhbmNlIDwgdmFyaWFuY2UpIHtcbi8vIFx0XHRcdGV4cGxhbmF0aW9uLmF0dGVtcHRzLnB1c2goe1xuLy8gXHRcdFx0XHR0eXBlOiBcIk9wdGltaXplIHRyeVwiLCBsaW5lQnJlYWtzOiBhdHRlbXB0c1tpXSxcbi8vIFx0XHRcdFx0dmFyaWFuY2U6IE1hdGgucm91bmQodmFyaWFuY2UpLCBuZXdWYXJpYW5jZTogTWF0aC5yb3VuZChuZXdWYXJpYW5jZSksXG4vLyBcdFx0XHRcdHRvdGFsQXR0ZW1wdHM6IGF0dGVtcHRzLmxlbmd0aFxuLy8gXHRcdFx0fSk7XG4vLyBcdFx0XHR2YXJpYW5jZSA9IG5ld1ZhcmlhbmNlO1xuLy8gXHRcdFx0bGluZUJyZWFrcyA9IGF0dGVtcHRzW2ldO1xuLy8gXHRcdFx0ZmFpbGVkID0gZmFsc2U7XG4vLyBcdFx0fVxuLy8gXHR9XG4vLyBcdGlmIChmYWlsZWQpIHtcbi8vIFx0XHRleHBsYW5hdGlvbi5hdHRlbXB0cy5wdXNoKHsgdHlwZTogXCJPcHRpbWl6ZSB0cnlcIiwgbGluZUJyZWFrczogbGluZUJyZWFrcywgdmFyaWFuY2U6IHZhcmlhbmNlLCByZWFzb246IFwiTm9uZSBvZiB0aGUgXCIgKyBhdHRlbXB0cy5sZW5ndGggKyBcIiBhdHRlbXB0cyB3ZXJlIGJldHRlci5cIiB9KTtcbi8vIFx0XHQvLyBUT0RPLVBFUjogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBidXQganVzdCB0cnkgdG8gbW92ZSBvbmUgbWVhc3VyZSBkb3duIGFuZCBzZWUgaWYgaXQgaGVscHMuXG4vLyBcdFx0aWYgKGxpbmVCcmVha3MubGVuZ3RoID4gMCkge1xuLy8gXHRcdFx0dmFyIGF0dGVtcHQgPSBbXS5jb25jYXQobGluZUJyZWFrcyk7XG4vLyBcdFx0XHRhdHRlbXB0W2F0dGVtcHQubGVuZ3RoIC0gMV0tLTtcbi8vIFx0XHRcdG5ld1ZhcmlhbmNlID0gZ2V0VmFyaWFuY2Uod2lkdGhzLCBhdHRlbXB0KTtcbi8vIFx0XHRcdGV4cGxhbmF0aW9uLmF0dGVtcHRzLnB1c2goe1xuLy8gXHRcdFx0XHR0eXBlOiBcIk9wdGltaXplIGxhc3QgdHJ5XCIsIGxpbmVCcmVha3M6IGF0dGVtcHRzW2ldLFxuLy8gXHRcdFx0XHR2YXJpYW5jZTogTWF0aC5yb3VuZCh2YXJpYW5jZSksIG5ld1ZhcmlhbmNlOiBNYXRoLnJvdW5kKG5ld1ZhcmlhbmNlKSxcbi8vIFx0XHRcdFx0dG90YWxBdHRlbXB0czogYXR0ZW1wdHMubGVuZ3RoXG4vLyBcdFx0XHR9KTtcbi8vIFx0XHRcdGlmIChuZXdWYXJpYW5jZSA8IHZhcmlhbmNlKSB7XG4vLyBcdFx0XHRcdHZhcmlhbmNlID0gbmV3VmFyaWFuY2U7XG4vLyBcdFx0XHRcdGxpbmVCcmVha3MgPSBhdHRlbXB0O1xuLy8gXHRcdFx0XHRmYWlsZWQgPSBmYWxzZTtcbi8vIFx0XHRcdH1cbi8vIFx0XHR9XG4vLyBcdH1cbi8vIFx0Ly8gTGV0J3Mgc3F1ZWV6ZSB0aGUgbGluZSBzdWNjZXNzaXZlbHkgdW50aWwgaXQgc3BpbGxzIG9udG8gYW4gZXh0cmEgbGluZSwgdGhlbiB0YWtlIHRoZSBvcHRpb24gd2l0aCB0aGUgbG93ZXN0IHZhcmlhbmNlXG4vLyBcdC8vIHZhciB0YXJnZXROdW1MaW5lcyA9IGxpbmVCcmVha3MubGVuZ3RoO1xuLy8gXHQvLyB2YXIgbmV3TnVtTGluZXMgPSB0YXJnZXROdW1MaW5lcztcbi8vIFx0Ly8gdmFyIFRSWV9JTkNSRU1FTlQgPSAxO1xuLy8gXHQvLyB2YXIgdHJ5QnJlYWtQb2ludCA9IGxpbmVCcmVha1BvaW50IC0gVFJZX0lOQ1JFTUVOVDtcbi8vIFx0Ly8gdmFyIGZhaWxlZCA9IHRydWU7XG4vLyBcdC8vIHdoaWxlICh0YXJnZXROdW1MaW5lcyA9PT0gbmV3TnVtTGluZXMgJiYgdHJ5QnJlYWtQb2ludCA+IDUwKSB7XG4vLyBcdC8vIFx0dmFyIGZmID0gZnJlZUZvcm1MaW5lQnJlYWtzKHdpZHRocy5tZWFzdXJlV2lkdGhzLCB0cnlCcmVha1BvaW50KTtcbi8vIFx0Ly8gXHRuZXdOdW1MaW5lcyA9IGZmLmxpbmVCcmVha3MubGVuZ3RoO1xuLy8gXHQvLyBcdGlmIChuZXdOdW1MaW5lcyA9PT0gdGFyZ2V0TnVtTGluZXMpIHtcbi8vIFx0Ly8gXHRcdHZhciBuZXdWYXJpYW5jZSA9IGdldFZhcmlhbmNlKHdpZHRocywgZmYubGluZUJyZWFrcyk7XG4vLyBcdC8vIFx0XHR2YXIgbmV3VmFyaWFuY2VQY3QgPSBuZXdWYXJpYW5jZS90cnlCcmVha1BvaW50KjEwMDtcbi8vIFx0Ly8gXHRcdGV4cGxhbmF0aW9uLmF0dGVtcHRzLnB1c2goe3R5cGU6IFwiT3B0aW1pemUgdHJ5XCIsIHRyeUJyZWFrUG9pbnQ6IE1hdGgucm91bmQodHJ5QnJlYWtQb2ludCksIGxpbmVCcmVha3M6IGZmLmxpbmVCcmVha3MsIHRvdGFsczogZmYudG90YWxzLFxuLy8gXHQvLyBcdFx0XHR2YXJpYW5jZTogTWF0aC5yb3VuZCh2YXJpYW5jZSksIG5ld1ZhcmlhbmNlOiBNYXRoLnJvdW5kKG5ld1ZhcmlhbmNlKSwgdmFyaWFuY2VQY3Q6IE1hdGgucm91bmQodmFyaWFuY2VQY3QpLCBuZXdWYXJpYW5jZVBjdDogTWF0aC5yb3VuZChuZXdWYXJpYW5jZVBjdClcbi8vIFx0Ly8gXHRcdH0pO1xuLy8gXHQvLyBcdFx0aWYgKG5ld1ZhcmlhbmNlUGN0IDwgdmFyaWFuY2VQY3QpIHtcbi8vIFx0Ly8gXHRcdFx0dmFyaWFuY2VQY3QgPSBuZXdWYXJpYW5jZVBjdDtcbi8vIFx0Ly8gXHRcdFx0bGluZUJyZWFrcyA9IGZmLmxpbmVCcmVha3M7XG4vLyBcdC8vIFx0XHRcdGZhaWxlZCA9IGZhbHNlO1xuLy8gXHQvLyBcdFx0fVxuLy8gXHQvLyBcdH0gZWxzZSB7XG4vLyBcdC8vIFx0XHRleHBsYW5hdGlvbi5hdHRlbXB0cy5wdXNoKHt0eXBlOiBcIk9wdGltaXplIHRyeVwiLCBleHBsYW5hdGlvbjogXCJFeGNlZWRlZCBudW1iZXIgb2YgbGluZXMuXCIgLCB0cnlCcmVha1BvaW50OiBNYXRoLnJvdW5kKHRyeUJyZWFrUG9pbnQpLCBsaW5lQnJlYWtzOiBmZi5saW5lQnJlYWtzLCB0b3RhbHM6IGZmLnRvdGFscywgdmFyaWFuY2U6IHZhcmlhbmNlLCBhdmc6IGF2ZywgdmFyaWFuY2VQY3Q6IHZhcmlhbmNlUGN0fSk7XG4vLyBcdC8vIFx0fVxuLy8gXHQvLyBcdHRyeUJyZWFrUG9pbnQgLT0gVFJZX0lOQ1JFTUVOVDtcbi8vIFx0Ly8gfVxuLy9cbi8vIFx0cmV0dXJuIHsgZmFpbGVkOiBmYWlsZWQsIGxpbmVCcmVha3M6IGxpbmVCcmVha3MsIHZhcmlhbmNlOiB2YXJpYW5jZSB9O1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBmaXhlZE51bUxpbmVzQnJlYWtzKHdpZHRocywgbnVtTGluZXMsIGFsbG93T3ZlciwgYWxsb3dhYmxlVmFyaWFuY2UpIHtcbi8vIFx0dmFyIGlkZWFsTGluZUJyZWFrID0gd2lkdGhzLnRvdGFsIC8gbnVtTGluZXM7XG4vLyBcdC8vIElmIGFsbCB0aGUgbWVhc3VyZXMgaGFkIHRoZSBzYW1lIGFtb3VudCBvZiBzdHVmZiwgdGhlbiB0aGUgYXZlIHdvdWxkIGJlIGNvcnJlY3QuXG4vLyBcdC8vIFdlIHdpbGwgdGVzdCBhbGwgdGhlIGNvbWJpbmF0aW9ucyBmcm9tIG9uZSBsZXNzIHRvIG9uZSBtb3JlIHRoYW4gdGhlIGF2ZXJhZ2UuXG4vLyBcdHZhciBhdmVyYWdlTWVhc3VyZXNQZXJMaW5lID0gTWF0aC5yb3VuZCh3aWR0aHMubWVhc3VyZVdpZHRocy5sZW5ndGggLyBudW1MaW5lcyk7XG4vLyBcdHZhciBtaW5NZWFzdXJlc1BlckxpbmUgPSBNYXRoLm1heChhdmVyYWdlTWVhc3VyZXNQZXJMaW5lIC0gMSwgMSk7XG4vLyBcdHZhciBtYXhNZWFzdXJlc1BlckxpbmUgPSBhdmVyYWdlTWVhc3VyZXNQZXJMaW5lICsgMTtcbi8vIFx0dmFyIHRyaWVzID0gY3JlYXRlTGluZVRlc3RBcnJheShudW1MaW5lcywgd2lkdGhzLm1lYXN1cmVXaWR0aHMubGVuZ3RoLCBtYXhNZWFzdXJlc1BlckxpbmUsIG1pbk1lYXN1cmVzUGVyTGluZSk7XG4vLyBcdGNvbnNvbGUubG9nKFwiZml4ZWROdW1MaW5lc0JyZWFrcyB0ZXN0cyAoXCIrbWluTWVhc3VyZXNQZXJMaW5lKyctJyttYXhNZWFzdXJlc1BlckxpbmUrXCIpXCIsIG51bUxpbmVzLCB0cmllcy5sZW5ndGgpXG4vL1xuLy8gXHQvLyBGb3IgZWFjaCBwb3NzaWJsZSBudW1iZXIgb2YgbWVhc3VyZXMgcGVyIGxpbmUsIHNlZSB3aGljaCBoYXMgdGhlIGNsb3Nlc3Qgc3BhY2luZyB0byB0aGUgaWRlYWwuXG4vLyBcdHZhciBiZXN0Q2FzZSA9IC0xO1xuLy8gXHR2YXIgYmVzdENhc2VWYXJpYW5jZSA9IDEwMDAwMDA7XG4vLyBcdGZvciAodmFyIGkgPSAwIDsgaSA8IHRyaWVzLmxlbmd0aDsgaSsrKSB7XG4vLyBcdFx0dmFyIGF0dGVtcHQgPSB0cmllc1tpXTtcbi8vIFx0XHR2YXIgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZShhdHRlbXB0LCBpZGVhbExpbmVCcmVhaywgd2lkdGhzLm1lYXN1cmVXaWR0aHMsIGFsbG93T3ZlciA/IGFsbG93YWJsZVZhcmlhbmNlIDogMCk7XG4vLyBcdFx0aWYgKHZhcmlhbmNlICE9PSBudWxsKSB7XG4vLyBcdFx0XHRpZiAodmFyaWFuY2UgPCBiZXN0Q2FzZVZhcmlhbmNlKSB7XG4vLyBcdFx0XHRcdGJlc3RDYXNlVmFyaWFuY2UgPSB2YXJpYW5jZTtcbi8vIFx0XHRcdFx0YmVzdENhc2UgPSBpO1xuLy8gXHRcdFx0fVxuLy8gXHRcdH1cbi8vIFx0fVxuLy8gXHR2YXIgZmFpbGVkID0gdHJ1ZTtcbi8vIFx0Ly8gRm9yIGRlYnVnZ2luZywgcmVjcmVhdGUgdGhlIGxpbmUgd2lkdGhzXG4vLyBcdHZhciB0b3RhbHMgPSBbXTtcbi8vIFx0aWYgKGJlc3RDYXNlID49IDApIHtcbi8vIFx0XHRmYWlsZWQgPSBmYWxzZTtcbi8vIFx0XHR2YXIgaW5kZXggPSAwO1xuLy8gXHRcdGZvciAoaSA9IDA7IGkgPCB0cmllc1tiZXN0Q2FzZV0ubGVuZ3RoOyBpKyspIHtcbi8vIFx0XHRcdHZhciB0b3RhbCA9IDA7XG4vLyBcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHRyaWVzW2Jlc3RDYXNlXVtpXTsgaisrKSB7XG4vLyBcdFx0XHRcdHRvdGFsICs9IHdpZHRocy5tZWFzdXJlV2lkdGhzW2luZGV4KytdO1xuLy8gXHRcdFx0fVxuLy8gXHRcdFx0dG90YWxzLnB1c2goTWF0aC5yb3VuZCh0b3RhbCkpO1xuLy8gXHRcdH1cbi8vIFx0XHQvLyBXZSBub3cgaGF2ZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBudW1iZXIgb2YgbWVhc3VyZXMgcGVyIGxpbmUsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiB0aGUgYWJzb2x1dGUgbWVhc3VyZSBudW1iZXIgdG8gYnJlYWsgb24uXG4vLyBcdFx0aWYgKHRyaWVzW2Jlc3RDYXNlXS5sZW5ndGggPiAwKSB7XG4vLyBcdFx0XHR0cmllc1tiZXN0Q2FzZV1bMF0tLTsgLy8gVGhlIHJlc3VsdHMgc2hvdWxkIGNvbnRhaW4gdGhlIGxhc3QgbWVhc3VyZSBudW1iZXIgb24gdGhlIGxpbmUsIHplcm8tYmFzZWQuXG4vLyBcdFx0XHRmb3IgKGkgPSAxOyBpIDwgdHJpZXNbYmVzdENhc2VdLmxlbmd0aDsgaSsrKVxuLy8gXHRcdFx0XHR0cmllc1tiZXN0Q2FzZV1baV0gKz0gdHJpZXNbYmVzdENhc2VdW2kgLSAxXTsgLy8gVGhpcyBzZXRzIHRoZSB6ZXJvLWJhc2VkIG1lYXN1cmUgbnVtYmVyXG4vLyBcdFx0XHQvLyBUaGUgbGFzdCBsaW5lIGlzIGltcGxpZWQgYW5kIHdlIGRvbid0IG5lZWQgdG8gcmV0dXJuIGl0XG4vLyBcdFx0XHR0cmllc1tiZXN0Q2FzZV0ucG9wKCk7XG4vLyBcdFx0fVxuLy8gXHR9XG4vLyBcdHJldHVybiB7IGZhaWxlZDogZmFpbGVkLCBsaW5lQnJlYWtzOiB0cmllc1tiZXN0Q2FzZV0sIGJlc3RDYXNlVmFyaWFuY2U6IE1hdGgucm91bmQoYmVzdENhc2VWYXJpYW5jZSksIHRvdGFsczogdG90YWxzIH07XG4vLyB9XG5cbmZ1bmN0aW9uIGZpeGVkTWVhc3VyZUxpbmVCcmVha3Mod2lkdGhzLCBsaW5lQnJlYWtQb2ludCwgcHJlZmVycmVkTWVhc3VyZXNQZXJMaW5lKSB7XG5cdHZhciBsaW5lQnJlYWtzID0gW107XG5cdHZhciB0b3RhbHMgPSBbXTtcblx0dmFyIHRoaXNXaWR0aCA9IDA7XG5cdHZhciBmYWlsZWQgPSBmYWxzZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aHMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzV2lkdGggKz0gd2lkdGhzW2ldO1xuXHRcdGlmICh0aGlzV2lkdGggPiBsaW5lQnJlYWtQb2ludCkge1xuXHRcdFx0ZmFpbGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKGkgJSBwcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUgPT09IChwcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUtMSkpIHtcblx0XHRcdGlmIChpICE9PSB3aWR0aHMubGVuZ3RoLTEpIC8vIERvbid0IGJvdGhlciBwdXR0aW5nIGEgbGluZSBicmVhayBmb3IgdGhlIGxhc3QgbGluZSAtIGl0J3MgYWxyZWFkeSBhIGJyZWFrLlxuXHRcdFx0XHRsaW5lQnJlYWtzLnB1c2goaSk7XG5cdFx0XHR0b3RhbHMucHVzaChNYXRoLnJvdW5kKHRoaXNXaWR0aCkpO1xuXHRcdFx0dGhpc1dpZHRoID0gMDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHsgZmFpbGVkOiBmYWlsZWQsIHRvdGFsczogdG90YWxzLCBsaW5lQnJlYWtzOiBsaW5lQnJlYWtzIH07XG59XG5cbmZ1bmN0aW9uIGdldFJldmlzZWRUdW5lKGxpbmVCcmVha3MsIHN0YWZmV2lkdGgsIGFiY1N0cmluZywgcGFyYW1zLCBQYXJzZSkge1xuXHR2YXIgYWJjUGFyc2VyID0gbmV3IFBhcnNlKCk7XG5cdHZhciByZXZpc2VkUGFyYW1zID0ge1xuXHRcdGxpbmVCcmVha3M6IGxpbmVCcmVha3MsXG5cdFx0c3RhZmZ3aWR0aDogc3RhZmZXaWR0aFxuXHR9O1xuXHRmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG5cdFx0aWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ3dyYXAnICYmIGtleSAhPT0gJ3N0YWZmd2lkdGgnKSB7XG5cdFx0XHRyZXZpc2VkUGFyYW1zW2tleV0gPSBwYXJhbXNba2V5XTtcblx0XHR9XG5cdH1cblxuXHRhYmNQYXJzZXIucGFyc2UoYWJjU3RyaW5nLCByZXZpc2VkUGFyYW1zKTtcblx0cmV0dXJuIHsgdHVuZTogYWJjUGFyc2VyLmdldFR1bmUoKSwgcmV2aXNlZFBhcmFtczogcmV2aXNlZFBhcmFtcyB9O1xufVxuXG5mdW5jdGlvbiBjYWxjTGluZVdyYXBzKHR1bmUsIHdpZHRocywgYWJjU3RyaW5nLCBwYXJhbXMsIFBhcnNlLCBlbmdyYXZlcl9jb250cm9sbGVyKSB7XG5cdC8vIEZvciBjYWxjdWxhdGluZyBob3cgbXVjaCBjYW4gZ28gb24gdGhlIGxpbmUsIGl0IGRlcGVuZHMgb24gdGhlIHdpZHRoIG9mIHRoZSBsaW5lLiBJdCBpcyBhIGNvbnZlbmllbmNlIHRvIGp1c3QgZGl2aWRlIGl0IGhlcmVcblx0Ly8gYnkgdGhlIG1pbmltdW0gc3BhY2luZyBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIHRoZSBtaW4gc3BhY2luZyBsYXRlci5cblx0Ly8gVGhlIHNjYWxpbmcgd29ya3MgZGlmZmVyZW50bHk6IHRoaXMgaXMgZG9uZSBieSBjaGFuZ2luZyB0aGUgc2NhbGluZyBvZiB0aGUgb3V0ZXIgU1ZHLCBzbyB0aGUgc2NhbGluZyBuZWVkcyB0byBiZSBjb21wZW5zYXRlZFxuXHQvLyBmb3IgaGVyZSwgYmVjYXVzZSB0aGUgYWN0dWFsIHdpZHRoIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIGNhbGN1bGF0ZWQgbnVtYmVycy5cblxuXHQvLyBJZiB0aGUgZGVzaXJlZCB3aWR0aCBpcyBsZXNzIHRoYW4gdGhlIG1hcmdpbiwganVzdCBwdW50IGFuZCByZXR1cm4gdGhlIG9yaWdpbmFsIHR1bmVcblx0aWYgKHBhcmFtcy5zdGFmZndpZHRoIDwgd2lkdGhzLmxlZnQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXhwbGFuYXRpb246IFwiU3RhZmZ3aWR0aCBpcyBuYXJyb3dlciB0aGFuIHRoZSBtYXJnaW5cIixcblx0XHRcdHR1bmU6IHR1bmUsXG5cdFx0XHRyZXZpc2VkUGFyYW1zOiBwYXJhbXNcblx0XHR9O1xuXHR9XG5cdHZhciBzY2FsZSA9IHBhcmFtcy5zY2FsZSA/IE1hdGgubWF4KHBhcmFtcy5zY2FsZSwgMC4xKSA6IDE7XG5cdHZhciBtaW5TcGFjaW5nID0gcGFyYW1zLndyYXAubWluU3BhY2luZyA/IE1hdGgubWF4KHBhcnNlRmxvYXQocGFyYW1zLndyYXAubWluU3BhY2luZyksIDEpIDogMTtcblx0dmFyIG1pblNwYWNpbmdMaW1pdCA9IHBhcmFtcy53cmFwLm1pblNwYWNpbmdMaW1pdCA/IE1hdGgubWF4KHBhcnNlRmxvYXQocGFyYW1zLndyYXAubWluU3BhY2luZ0xpbWl0KSwgMSkgOiBtaW5TcGFjaW5nIC0gMC4xO1xuXHR2YXIgbWF4U3BhY2luZyA9IHBhcmFtcy53cmFwLm1heFNwYWNpbmcgPyBNYXRoLm1heChwYXJzZUZsb2F0KHBhcmFtcy53cmFwLm1heFNwYWNpbmcpLCAxKSA6IHVuZGVmaW5lZDtcblx0aWYgKHBhcmFtcy53cmFwLmxhc3RMaW5lTGltaXQgJiYgIW1heFNwYWNpbmcpXG5cdFx0bWF4U3BhY2luZyA9IE1hdGgubWF4KHBhcnNlRmxvYXQocGFyYW1zLndyYXAubGFzdExpbmVMaW1pdCksIDEpO1xuXHR2YXIgdGFyZ2V0SGVpZ2h0ID0gcGFyYW1zLndyYXAudGFyZ2V0SGVpZ2h0ID8gTWF0aC5tYXgocGFyc2VJbnQocGFyYW1zLndyYXAudGFyZ2V0SGVpZ2h0LCAxMCksIDEwMCkgOiB1bmRlZmluZWQ7XG5cdHZhciBwcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUgPSBwYXJhbXMud3JhcC5wcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUgPyBNYXRoLm1heChwYXJzZUludChwYXJhbXMud3JhcC5wcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUsIDEwKSwgMSkgOiB1bmRlZmluZWQ7XG5cblx0dmFyIGxpbmVCcmVha1BvaW50ID0gKHBhcmFtcy5zdGFmZndpZHRoIC0gd2lkdGhzLmxlZnQpIC8gbWluU3BhY2luZyAvIHNjYWxlO1xuXHR2YXIgbWluTGluZVNpemUgPSAocGFyYW1zLnN0YWZmd2lkdGggLSB3aWR0aHMubGVmdCkgLyBtYXhTcGFjaW5nIC8gc2NhbGU7XG5cdHZhciBhbGxvd2FibGVWYXJpYW5jZSA9IChwYXJhbXMuc3RhZmZ3aWR0aCAtIHdpZHRocy5sZWZ0KSAvIG1pblNwYWNpbmdMaW1pdCAvIHNjYWxlO1xuXHR2YXIgZXhwbGFuYXRpb24gPSB7IHdpZHRoczogd2lkdGhzLCBsaW5lQnJlYWtQb2ludDogbGluZUJyZWFrUG9pbnQsIG1pbkxpbmVTaXplOiBtaW5MaW5lU2l6ZSwgYXR0ZW1wdHM6IFtdLCBzdGFmZldpZHRoOiBwYXJhbXMuc3RhZmZ3aWR0aCwgbWluV2lkdGg6IE1hdGgucm91bmQoYWxsb3dhYmxlVmFyaWFuY2UpIH07XG5cblx0Ly8gSWYgdGhlcmUgaXMgYSBwcmVmZXJyZWQgbnVtYmVyIG9mIG1lYXN1cmVzIHBlciBsaW5lLCB0ZXN0IHRoYXQgZmlyc3QuIElmIG5vbmUgb2YgdGhlIGxpbmVzIGlzIHRvbyBsb25nLCB0aGVuIHdlJ3JlIGZpbmlzaGVkLlxuXHR2YXIgbGluZUJyZWFrcyA9IG51bGw7XG5cdGlmIChwcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUpIHtcblx0XHR2YXIgZiA9IGZpeGVkTWVhc3VyZUxpbmVCcmVha3Mod2lkdGhzLm1lYXN1cmVXaWR0aHMsIGxpbmVCcmVha1BvaW50LCBwcmVmZXJyZWRNZWFzdXJlc1BlckxpbmUpO1xuXHRcdGV4cGxhbmF0aW9uLmF0dGVtcHRzLnB1c2goeyB0eXBlOiBcIkZpeGVkIE1lYXN1cmVzIFBlciBMaW5lXCIsIHByZWZlcnJlZE1lYXN1cmVzUGVyTGluZTogcHJlZmVycmVkTWVhc3VyZXNQZXJMaW5lLCBsaW5lQnJlYWtzOiBmLmxpbmVCcmVha3MsIGZhaWxlZDogZi5mYWlsZWQsIHRvdGFsczogZi50b3RhbHMgfSk7XG5cdFx0aWYgKCFmLmZhaWxlZClcblx0XHRcdGxpbmVCcmVha3MgPSBmLmxpbmVCcmVha3M7XG5cdH1cblxuXHQvLyBJZiB3ZSBkb24ndCBoYXZlIGxpbmVCcmVha3MgeWV0LCB1c2UgdGhlIGZyZWUgZm9ybSBtZXRob2Qgb2YgbGluZSBicmVha3MuXG5cdC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgZWl0aGVyIGlmIFByZWZlcnJlZCBNZWFzdXJlcyBpcyBub3QgdXNlZCwgb3IgaWYgdGhlIG11c2ljIGlzIGp1c3Qgd2VpcmQgLSBsaWtlIGEgc2luZ2xlIG1lYXN1cmUgaXMgd2F5IHRvbyBjcm93ZGVkLlxuXHRpZiAoIWxpbmVCcmVha3MpIHtcblx0XHR2YXIgZmYgPSBmcmVlRm9ybUxpbmVCcmVha3Mod2lkdGhzLm1lYXN1cmVXaWR0aHMsIGxpbmVCcmVha1BvaW50KTtcblx0XHRleHBsYW5hdGlvbi5hdHRlbXB0cy5wdXNoKHsgdHlwZTogXCJGcmVlIEZvcm1cIiwgbGluZUJyZWFrczogZmYubGluZUJyZWFrcywgdG90YWxzOiBmZi50b3RhbHMgfSk7XG5cdFx0bGluZUJyZWFrcyA9IGZmLmxpbmVCcmVha3M7XG5cblx0XHQvLyBXZSBub3cgaGF2ZSBhbiBhY2NlcHRhYmxlIG51bWJlciBvZiBsaW5lcywgYnV0IHRoZSBtZWFzdXJlcyBtYXkgbm90IGJlIG9wdGltYWxseSBkaXN0cmlidXRlZC4gU2VlIGlmIHRoZXJlIGlzIGEgYmV0dGVyIGRpc3RyaWJ1dGlvbi5cblx0XHRmZiA9IG9wdGltaXplTGluZVdpZHRocyh3aWR0aHMsIGxpbmVCcmVha1BvaW50LCBsaW5lQnJlYWtzLCBleHBsYW5hdGlvbik7XG5cdFx0ZXhwbGFuYXRpb24uYXR0ZW1wdHMucHVzaCh7IHR5cGU6IFwiT3B0aW1pemVcIiwgZmFpbGVkOiBmZi5mYWlsZWQsIHJlYXNvbjogZmYucmVhc29uLCBsaW5lQnJlYWtzOiBmZi5saW5lQnJlYWtzLCB0b3RhbHM6IGZmLnRvdGFscyB9KTtcblx0XHRpZiAoIWZmLmZhaWxlZClcblx0XHRcdGxpbmVCcmVha3MgPSBmZi5saW5lQnJlYWtzO1xuXHR9XG5cblx0Ly8gSWYgdGhlIHZlcnRpY2FsIHNwYWNlIGV4Y2VlZHMgdGFyZ2V0SGVpZ2h0LCByZW1vdmUgYSBsaW5lIGFuZCB0cnkgYWdhaW4uIElmIHRoYXQgaXMgdG9vIGNyb3dkZWQsIHRoZW4gZG9uJ3QgdXNlIGl0LlxuXHR2YXIgc3RhZmZXaWR0aCA9IHBhcmFtcy5zdGFmZndpZHRoO1xuXHR2YXIgcmV0ID0gZ2V0UmV2aXNlZFR1bmUobGluZUJyZWFrcywgc3RhZmZXaWR0aCwgYWJjU3RyaW5nLCBwYXJhbXMsIFBhcnNlKTtcblx0dmFyIG5ld1dpZHRocyA9IGVuZ3JhdmVyX2NvbnRyb2xsZXIuZ2V0TWVhc3VyZVdpZHRocyhyZXQudHVuZSk7XG5cdHZhciBnb3RUdW5lID0gdHJ1ZTsgLy8gSWYgd2UgYWRqdXN0IHRoZSBudW0gbGluZXMsIHNldCB0aGlzIHRvIGZhbHNlXG5cdGV4cGxhbmF0aW9uLmF0dGVtcHRzLnB1c2goe3R5cGU6IFwiaGVpZ2h0Q2hlY2tcIiwgaGVpZ2h0OiBuZXdXaWR0aHMuaGVpZ2h0IH0pO1xuXG5cdC8vIFx0aWYgYWxsIG9mIHRoZSBsaW5lcyBhcmUgdG9vIHNwYXJzZSwgbWFrZSB0aGUgd2lkdGggbmFycm93ZXIuXG5cdC8vIFRPRE8tUEVSOiBpbXBsZW1lbnQgdGhpcyBjYXNlLlxuXG5cdC8vIElmIG9uZSBsaW5lIGFuZCB0aGUgc3BhY2luZyBpcyA+IG1heFNwYWNpbmcsIG1ha2UgdGhlIHdpZHRoIG5hcnJvd2VyLlxuXHRpZiAobGluZUJyZWFrcy5sZW5ndGggPT09IDAgJiYgbWluTGluZVNpemUgPiB3aWR0aHMudG90YWwpIHtcblx0XHRzdGFmZldpZHRoID0gKHdpZHRocy50b3RhbCAqIG1heFNwYWNpbmcgKiBzY2FsZSkgKyB3aWR0aHMubGVmdDtcblx0XHRleHBsYW5hdGlvbi5hdHRlbXB0cy5wdXNoKHt0eXBlOiBcInRvbyBzcGFyc2VcIiwgbmV3V2lkdGg6IE1hdGgucm91bmQoc3RhZmZXaWR0aCl9KVxuXHRcdGdvdFR1bmUgPSBmYWxzZTtcblx0fVxuXG5cdC8vIGlmIChyZXQubGluZUJyZWFrcy5sZW5ndGggPT09IDApIHtcblx0Ly8gXHQvLyBFdmVyeXRoaW5nIGZpdHMgb24gb25lIGxpbmUsIHNvIHNlZSBpZiB0aGVyZSBpcyBUT08gbXVjaCBzcGFjZSBhbmQgdGhlIHN0YWZmIHdpZHRoIG5lZWRzIHRvIGJlIHNob3J0ZW5lZC5cblx0Ly8gXHRpZiAobWluTGluZVNpemUgPiAwICYmIHJldC50b3RhbFRoaXNMaW5lID4gMCAmJiByZXQudG90YWxUaGlzTGluZSA8IG1pbkxpbmVTaXplKVxuXHQvLyBcdFx0c3RhZmZXaWR0aCA9IHN0YWZmV2lkdGggLyAobWluTGluZVNpemUgLyByZXQudG90YWxUaGlzTGluZSk7XG5cdC8vIH0gZWxzZSBpZiAocmV0LnRvdGFsVGhpc0xpbmUgPCBtaW5MaW5lU2l6ZSkge1xuXHQvLyBcdC8vIHRoZSBsYXN0IGxpbmUgaXMgdG9vIHNob3J0LCBzbyBhdHRlbXB0IHRvIHJlZGlzdHJpYnV0ZSBieSBjaGFuZ2luZyB0aGUgbWluLlxuXHQvLyBcdC8vIFdlIHdpbGwgdHJ5IG1vcmUgYW5kIGxlc3Mgc3BhY2UgYWx0ZXJuYXRpdmVseS4gVGhlIHNwYWNlIGNhbid0IGJlIGxlc3MgdGhhbiAxLjAsIGFuZCB3ZSdsbCB0cnkgaW4gMC4xIGluY3JlbWVudHMuXG5cdC8vIFx0dmFyIG1pblRyeXMgPSBbXTtcblx0Ly8gXHRpZiAobWluU3BhY2luZyA+IDEuMSlcblx0Ly8gXHRcdG1pblRyeXMucHVzaChtaW5TcGFjaW5nIC0gMC4xKTtcblx0Ly8gXHRtaW5UcnlzLnB1c2gobWluU3BhY2luZyArIDAuMSk7XG5cdC8vIFx0aWYgKG1pblNwYWNpbmcgPiAxLjIpXG5cdC8vIFx0XHRtaW5UcnlzLnB1c2gobWluU3BhY2luZyAtIDAuMik7XG5cdC8vIFx0bWluVHJ5cy5wdXNoKG1pblNwYWNpbmcgKyAwLjIpO1xuXHQvLyBcdGlmIChtaW5TcGFjaW5nID4gMS4zKVxuXHQvLyBcdFx0bWluVHJ5cy5wdXNoKG1pblNwYWNpbmcgLSAwLjMpO1xuXHQvLyBcdG1pblRyeXMucHVzaChtaW5TcGFjaW5nICsgMC4zKTtcblx0Ly8gXHRmb3IgKHZhciBpID0gMDsgaSA8IG1pblRyeXMubGVuZ3RoICYmIHJldC50b3RhbFRoaXNMaW5lIDwgbWluTGluZVNpemU7IGkrKykge1xuXHQvLyBcdFx0bGluZUJyZWFrUG9pbnQgPSAocGFyYW1zLnN0YWZmd2lkdGggLSB3aWR0aHMubGVmdCkgLyBtaW5UcnlzW2ldIC8gc2NhbGU7XG5cdC8vIFx0XHRyZXQgPSBjYWxjTGluZUJyZWFrcyh3aWR0aHMubWVhc3VyZVdpZHRocywgbGluZUJyZWFrUG9pbnQpO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG5cdGlmICghZ290VHVuZSlcblx0XHRyZXQgPSBnZXRSZXZpc2VkVHVuZShsaW5lQnJlYWtzLCBzdGFmZldpZHRoLCBhYmNTdHJpbmcsIHBhcmFtcywgUGFyc2UpO1xuXHRyZXQuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcblx0cmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHdyYXBMaW5lczogd3JhcExpbmVzLCBjYWxjTGluZVdyYXBzOiBjYWxjTGluZVdyYXBzIH07XG4iLCJmdW5jdGlvbiBhY3RpdmVBdWRpb0NvbnRleHQoKSB7XG5cdHJldHVybiB3aW5kb3cuYWJjanNBdWRpb0NvbnRleHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWN0aXZlQXVkaW9Db250ZXh0O1xuIiwiLy8gQ29udmVydCB0aGUgaW5wdXQgc3RydWN0dXJlIHRvIGEgbW9yZSB1c2VmdWwgc3RydWN0dXJlIHdoZXJlIGVhY2ggaXRlbSBoYXMgYSBsZW5ndGggb2YgaXRzIG93bi5cblxudmFyIGluc3RydW1lbnRJbmRleFRvTmFtZSA9IHJlcXVpcmUoJy4vaW5zdHJ1bWVudC1pbmRleC10by1uYW1lJyk7XG5cbnZhciBjcmVhdGVOb3RlTWFwID0gZnVuY3Rpb24oc2VxdWVuY2UpIHtcblx0dmFyIG1hcCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlLnRyYWNrcy5sZW5ndGg7IGkrKylcblx0XHRtYXAucHVzaChbXSk7XG5cblx0Ly8gVE9ETy1QRVI6IGhhbmRsZSBtb3JlIHRoYW4gb25lIG5vdGUgaW4gYSB0cmFja1xuXHR2YXIgbmV4dE5vdGUgPSB7fTtcblx0dmFyIGN1cnJlbnRJbnN0cnVtZW50ID0gaW5zdHJ1bWVudEluZGV4VG9OYW1lWzBdO1xuXHRzZXF1ZW5jZS50cmFja3MuZm9yRWFjaChmdW5jdGlvbih0cmFjaywgaSkge1xuXHRcdHZhciBjdXJyZW50VGltZSA9IDA7XG5cdFx0dHJhY2suZm9yRWFjaChmdW5jdGlvbihldikge1xuXHRcdFx0c3dpdGNoIChldi5jbWQpIHtcblx0XHRcdFx0Y2FzZSBcInN0YXJ0XCI6XG5cdFx0XHRcdFx0bmV4dE5vdGVbZXYucGl0Y2hdID0geyB0aW1lOiBjdXJyZW50VGltZSwgaW5zdHJ1bWVudDogY3VycmVudEluc3RydW1lbnQsIHZvbHVtZTogZXYudm9sdW1lIH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJtb3ZlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFRpbWUgKz0gZXYuZHVyYXRpb247XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJzdG9wXCI6XG5cdFx0XHRcdFx0bWFwW2ldLnB1c2goe3BpdGNoOiBldi5waXRjaCwgaW5zdHJ1bWVudDogbmV4dE5vdGVbZXYucGl0Y2hdLmluc3RydW1lbnQsIHN0YXJ0OiBuZXh0Tm90ZVtldi5waXRjaF0udGltZSwgZW5kOiBjdXJyZW50VGltZSwgdm9sdW1lOiBuZXh0Tm90ZVtldi5waXRjaF0udm9sdW1lfSk7XG5cdFx0XHRcdFx0ZGVsZXRlIG5leHROb3RlW2V2LnBpdGNoXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInByb2dyYW1cIjpcblx0XHRcdFx0XHRjdXJyZW50SW5zdHJ1bWVudCA9IGluc3RydW1lbnRJbmRleFRvTmFtZVtldi5pbnN0cnVtZW50XTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBUT0RPLVBFUjogaGFuZGxlIG90aGVyIGV2ZW50IHR5cGVzXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJVbmhhbmRlZCBtaWRpIGV2ZW50XCIsIGV2KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBtYXA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vdGVNYXA7XG4iLCJ2YXIgc3VwcG9ydHNBdWRpbyA9IHJlcXVpcmUoJy4vc3VwcG9ydHMtYXVkaW8nKTtcbnZhciByZWdpc3RlckF1ZGlvQ29udGV4dCA9IHJlcXVpcmUoJy4vcmVnaXN0ZXItYXVkaW8tY29udGV4dCcpO1xudmFyIGFjdGl2ZUF1ZGlvQ29udGV4dCA9IHJlcXVpcmUoJy4vYWN0aXZlLWF1ZGlvLWNvbnRleHQnKTtcbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2FiY19jb21tb24nKTtcbi8vIFRPRE8tUEVSOiBUaGUgcmVxdWlyZSBzdGF0ZW1lbnRzIGZvciBzdmcgZG9uJ3QgcGxheSB3ZWxsIGZvciBub2RlIGFwcHMgd2l0aG91dCBleHRyYSBwbHVnaW5zLiBUaGUgZm9sbG93aW5nIGxpbmVzIHdvdWxkIGJlIGNsZWFyZXIgdGhhbiBpbmxpbmluZyB0aGUgU1ZHXG4vLyB2YXIgbG9vcEltYWdlID0gcmVxdWlyZSgnLi9pbWFnZXMvbG9vcC5zdmcnKTtcbi8vIHZhciBwbGF5SW1hZ2UgPSByZXF1aXJlKCcuL2ltYWdlcy9wbGF5LnN2ZycpO1xuLy8gdmFyIHBhdXNlSW1hZ2UgPSByZXF1aXJlKCcuL2ltYWdlcy9wYXVzZS5zdmcnKTtcbi8vIHZhciBsb2FkaW5nSW1hZ2UgPSByZXF1aXJlKCcuL2ltYWdlcy9sb2FkaW5nLnN2ZycpO1xuLy8gdmFyIHJlc2V0SW1hZ2UgPSByZXF1aXJlKCcuL2ltYWdlcy9yZXNldC5zdmcnKTtcbnZhciBsb29wSW1hZ2UgPSAnPHN2ZyB2ZXJzaW9uPVwiMS4wXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgNzAwIDcwMFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1pZCBtZWV0XCI+XFxuJyArXG5cdCc8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMCw3MDApIHNjYWxlKDAuMSwtMC4xKVwiID5cXG4nICtcblx0JzxwYXRoIGQ9XCJNMzExMSA2OTgxIGMtMjAgLTM3IC05MCAtNTUgLTM2NCAtOTYgLTEyMCAtMTggLTE5MCAtMzMgLTI0NCAtNTUgJyArXG5cdCctNDIgLTE3IC0xMjQgLTQyIC0xODIgLTU2IC03OCAtMTggLTExOSAtMzQgLTE1NyAtNjAgLTI4IC0xOSAtODYgLTQ2IC0xMjggJyArXG5cdCctNjAgLTQzIC0xMyAtMTA3IC00MiAtMTQ0IC02NCAtMzcgLTIzIC04NCAtNDYgLTEwNiAtNTIgLTIxIC03IC01NiAtMjkgLTc5ICcgK1xuXHQnLTUwIC0yMiAtMjIgLTYxIC01MCAtODYgLTYzIC0yNiAtMTMgLTY3IC00MCAtOTEgLTYwIC0yNCAtMjAgLTY1IC00NyAtOTAgLTYwICcgK1xuXHQnLTI1IC0xMyAtNTMgLTMxIC02MSAtNDEgLTggLTkgLTMyIC0zMCAtNTQgLTQ2IC03NSAtNTQgLTQ4NiAtNDYwIC01MTIgLTUwNyAnICtcblx0Jy0xNSAtMjUgLTQ4IC02OSAtNzUgLTk4IC0yNiAtMjggLTQ4IC01NyAtNDggLTYzIDAgLTYgLTE4IC0yOSAtMzkgLTUzIC0yMSAnICtcblx0Jy0yMyAtNTYgLTcxIC03NyAtMTA3IC0yMCAtMzYgLTUwIC04MCAtNjUgLTk3IC0xNiAtMTggLTMzIC01MiAtNDAgLTc1IC0xMiAnICtcblx0Jy00NyAtNDcgLTExNSAtODQgLTE2NiAtMTMgLTE4IC0zMCAtNTYgLTM4IC04MyAtOCAtMjcgLTM0IC04MCAtNTYgLTExOCAtMzMgJyArXG5cdCctNTMgLTQ2IC05MSAtNjIgLTE2NyAtMTIgLTYzIC0zNCAtMTI3IC01OSAtMTc5IC00MiAtODQgLTYwIC0xNjYgLTYwIC0yNzAgMCAnICtcblx0Jy05MCAyNiAtMTIyIDEyNSAtMTU0IDU0IC0xNyA5NiAtMTkgNDMwIC0yMCAzMDUgLTEgMzgxIDIgNDMwIDE0IDgyIDIyIDE0MCA1MSAnICtcblx0JzE1MyA3OCA2IDEyIDIyIDQ3IDM3IDc3IDE0IDMwIDM4IDc3IDU0IDEwMyAxNSAyNyAzNCA3MyA0MCAxMDMgNyAzMCAyOCA3OCA0OCAnICtcblx0JzEwNyAxOSAyOCA0NCA3NCA1NSAxMDEgMTAgMjggMzQgNjcgNTMgODcgMTggMjAgNDkgNjEgNjggOTAgMTkgMzAgNDQgNjMgNTcgJyArXG5cdCc3NCAxMyAxMSAzNiA0MCA1MiA2NSA1OSA5NCAyMzIgMjcwIDMwNiAzMTMgMjAgMTEgNTcgMzcgODIgNTggMjUgMjAgNzAgNTIgJyArXG5cdCcxMDAgNzIgMzAgMTkgNjYgNDcgNzkgNjEgMTMgMTQgNDkgMzUgODAgNDYgMzAgMTIgODAgMzcgMTExIDU2IDMxIDE5IDk1IDQ1ICcgK1xuXHQnMTQzIDU4IDQ4IDEyIDExMCAzNyAxMzkgNTUgNjMgNDAgMTI3IDU1IDMyMyA3NiA4MyA5IDIwOCAyOCAyNzkgNDEgMTU2IDI5ICcgK1xuXHQnMTY1IDI5IDMzMCA0IDQ1MyAtNzEgNTE0IC04NCA2MDYgLTEzMCAzMSAtMTYgODMgLTM2IDExNiAtNDUgMzIgLTkgODQgLTM0ICcgK1xuXHQnMTE1IC01NiAzMSAtMjEgODIgLTQ4IDExMyAtNjAgMzIgLTExIDcyIC0zMyA4OSAtNDggMTggLTE2IDU5IC00NSA5MiAtNjUgMzMgJyArXG5cdCctMjEgNzQgLTUxIDkwIC02NiAxNyAtMTUgNDkgLTQwIDczIC01NCA1MiAtMzIgNjUgLTYxIDUwIC0xMTMgLTggLTMxIC02MSAtOTAgJyArXG5cdCctMjc3IC0zMDggLTMwMCAtMzAzIC0zNjEgLTM4MiAtMzY5IC00ODEgLTIgLTI5IDAgLTY2IDYgLTgxIDEzIC00MCA4OCAtMTM4ICcgK1xuXHQnMTE1IC0xNTEgMTIgLTYgNTQgLTI2IDkyIC00NCBsNzAgLTMzIDk0NSAtMiBjNTIwIC0xIDk3NSAyIDEwMTIgNyA2NCA4IDE5MSAnICtcblx0JzUwIDIzMSA3NiAxMSA3IDMzIDM0IDUwIDYwIDIyIDM0IDQyIDUxIDY1IDU4IGwzMiA5IDAgMTEwMSAwIDExMDIgLTMyIDkgYy0yMSAnICtcblx0JzcgLTQ0IDI2IC02NCA1NSAtNjAgODQgLTc3IDk3IC0xNDAgMTEwIC00NCA5IC03NiAxMCAtMTI3IDIgLTU5IC05IC03NyAtMTcgJyArXG5cdCctMTM0IC02MiAtMzcgLTI4IC0xNzIgLTE1NSAtMzAxIC0yODEgLTEyOSAtMTI3IC0yNDkgLTIzNyAtMjY3IC0yNDUgLTI1IC0xMCAnICtcblx0Jy00MSAtMTEgLTcxIC0yIC01OCAxNSAtMTEyIDQ1IC0xMjQgNjkgLTYgMTEgLTM1IDM1IC02NCA1NCAtMjggMTggLTU4IDQxIC02NiAnICtcblx0JzUwIC04IDkgLTQxIDM1IC03NSA1OCAtMzMgMjIgLTc3IDU2IC05OSA3NSAtMjEgMTggLTY0IDQ2IC05NSA2MSAtMzEgMTQgLTczICcgK1xuXHQnMzkgLTkzIDU1IC0yMCAxNSAtNzAgNDAgLTExMCA1NSAtNDAgMTUgLTk3IDQ0IC0xMjcgNjQgLTI5IDIxIC03OCA0NCAtMTA3IDUzICcgK1xuXHQnLTMwIDggLTc3IDMxIC0xMDUgNTEgLTQyIDI4IC03MyAzOSAtMTczIDYwIC02OCAxNCAtMTU0IDM5IC0xOTYgNTggLTk1IDQzICcgK1xuXHQnLTEzMSA1MSAtMzQzIDc2IC0yMDkgMjQgLTI0MiAzMiAtMjc5IDcwIGwtMzAgMjkgLTMyOCAwIGMtMzEyIDAgLTMzMCAtMSAtMzM5ICcgK1xuXHQnLTE5elwiPjwvcGF0aD5cXG4nICtcblx0JzxwYXRoIGQ9XCJNMjU0IDI4NzUgYy04OSAtMTYgLTEwNyAtMjYgLTE0NSAtNzggLTMyIC00NCAtNjIgLTY2IC05MSAtNjcgLTE3IDAgJyArXG5cdCctMTggLTYxIC0xOCAtMTE0MCBsMCAtMTE0MCAyNCAwIGMxNiAwIDQxIC0xNyA3MiAtNTAgNDAgLTQyIDYxIC01NSAxMTcgLTcyICcgK1xuXHQnbDY5IC0yMSA4MiAyMyBjNDQgMTIgOTYgMzAgMTE0IDM5IDE4IDkgMTQ4IDEzMiAyOTAgMjcyIDE0MSAxNDEgMjY3IDI2MSAyNzkgJyArXG5cdCcyNjggNTEgMjYgODYgMTQgMTc2IC02MSAzMiAtMjYgNjIgLTQ4IDY2IC00OCA1IDAgMzYgLTI1IDcwIC01NSAzNCAtMzAgNzQgJyArXG5cdCctNjEgODkgLTY5IDE1IC04IDM3IC0yOCA1MCAtNDUgMTIgLTE3IDUwIC00NSA4NCAtNjIgMzQgLTE3IDc4IC00NCA5OCAtNjAgMTkgJyArXG5cdCctMTYgNjEgLTM3IDkzIC00OCAzMiAtMTEgODEgLTM3IDEwNyAtNTYgMjcgLTIwIDc2IC00NSAxMDkgLTU2IDMzIC0xMiA3NSAtMzEgJyArXG5cdCc5MyAtNDQgNjIgLTQ1IDkzIC01OCAxOTEgLTgyIDU0IC0xMiAxMzAgLTM3IDE2OCAtNTQgNjggLTI5IDE4MCAtNTggMjI2IC01OSAnICtcblx0JzYyIDAgMTgzIC02NCAxODMgLTk2IDAgLTEyIDg4IC0xNCA2MzkgLTE0IGw2MzkgMCAxMiAzMCBjMTggNDQgNzYgNjYgMjMzIDg5ICcgK1xuXHQnODkgMTQgMTYwIDMwIDIwMCA0NyAzNCAxNSAxMDYgNDIgMTU5IDYwIDU0IDE4IDExMiA0NCAxMzAgNTcgNDcgMzUgODUgNTIgMTQ2ICcgK1xuXHQnNjcgMjkgNyA3NiAyOCAxMDUgNDggMjkgMjAgNzcgNDggMTA3IDYzIDMwIDE1IDY2IDM5IDgwIDU0IDE0IDE1IDUwIDQwIDgxIDU2ICcgK1xuXHQnMzEgMTUgNzggNDYgMTA0IDY5IDI2IDIyIDYxIDQ2IDc5IDU0IDE3IDcgNDMgMjYgNTYgNDIgMTQgMTYgNDEgNDEgNjAgNTYgNjQgJyArXG5cdCc0OCAzODAgMzYyIDQwOCA0MDUgMTUgMjMgNDAgNTEgNTUgNjMgMTUgMTIgMzYgMzggNDYgNTggMTEgMjEgMzcgNTcgNTggODIgMjIgJyArXG5cdCcyNSA0OSA2MiA2MiA4MyAxMyAyMCAzOCA1NiA1NyA3OCAxOSAyMyA1MCA3NCA2OSAxMTMgMTkgMzkgNDYgODYgNTkgMTA0IDE0ICcgK1xuXHQnMTggMzQgNjIgNDYgOTggMTIgMzYgMzIgNzcgNDUgOTIgMzEgMzggNjAgOTcgODAgMTY3IDkgMzMgMjYgNzYgMzcgOTUgMjkgNTAgJyArXG5cdCc0NyAxMDMgNjggMjA2IDEwIDUyIDMyIDExNyA1MSAxNTUgMjkgNTYgMzMgNzQgMzQgMTQwIDAgOTQgLTEwIDEwOCAtMTAxIDEzOCAnICtcblx0Jy02MSAyMCAtODMgMjEgLTQ2MyAyMSAtMjI2IDAgLTQyMSAtNCAtNDUxIC0xMCAtNjMgLTEyIC04NiAtMzAgLTExMCAtODUgLTEwICcgK1xuXHQnLTIyIC0zMyAtNjMgLTUyIC05MiAtMjEgLTMxIC00MiAtODAgLTUzIC0xMjMgLTExIC00NCAtMzIgLTkzIC01NiAtMTI4IC0yMCAnICtcblx0Jy0zMiAtNDcgLTgzIC01OSAtMTE1IC0xMiAtMzIgLTM3IC03NyAtNTYgLTEwMCAtMTkgLTIzIC01MCAtNjUgLTY5IC05NCAtMTkgJyArXG5cdCctMjkgLTQ0IC01NyAtNTQgLTYzIC0xMSAtNSAtMjkgLTI3IC00MiAtNDcgLTUyIC04NSAtMjM0IC0yNzcgLTMwMCAtMzE1IC0yNSAnICtcblx0Jy0xNSAtNTMgLTM4IC02MiAtNTEgLTkgLTE0IC00MiAtMzkgLTc0IC01NyAtMzIgLTE4IC03NSAtNDggLTk1IC02NiAtMjEgLTE4ICcgK1xuXHQnLTU5IC00NCAtODUgLTU4IC0yNiAtMTMgLTcyIC00MCAtMTAwIC01OSAtMzUgLTI0IC03OCAtNDEgLTEyOCAtNTIgLTQ3IC0xMSAnICtcblx0Jy05OSAtMzEgLTEzOSAtNTYgLTY5IC00MiAtOTQgLTQ5IC0zOTEgLTExMCAtMjQ1IC01MSAtNDI1IC02NiAtNTk1IC01MCAtMTY4ICcgK1xuXHQnMTYgLTIzMCAyNyAtMzMwIDYxIC00NyAxNiAtMTIzIDM1IC0xNzAgNDQgLTk4IDE3IC0xMjMgMjUgLTE3MiA1OCAtMjAgMTQgLTcxICcgK1xuXHQnMzcgLTExNCA1MyAtNDQgMTUgLTk1IDQwIC0xMTUgNTYgLTIwIDE2IC03MCA0MiAtMTEwIDU5IC00MCAxNiAtODggNDUgLTEwOCAnICtcblx0JzYzIC0yMCAxOSAtNTUgNDYgLTc4IDYxIC0yNCAxNCAtNDkgMzUgLTU1IDQ3IC03IDExIC0zNCAzMyAtNjAgNDkgLTUwIDMxIC02NSAnICtcblx0JzYxIC01MyAxMDIgNCAxMyAxMzAgMTQ3IDI4MSAyOTggMjM2IDIzOCAyNzcgMjgzIDI5OSAzMzUgMTUgMzIgMzUgNzEgNDYgODYgJyArXG5cdCcxMiAxOCAxOSA0NCAxOSA3NiAwIDQyIC04IDYzIC01MyAxMzggLTkyIDE1MSAxMSAxMzkgLTEyMDcgMTQxIC03OTggMiAtMTAzMCAnICtcblx0JzAgLTEwODYgLTExelwiPjwvcGF0aD5cXG4nICtcblx0JzwvZz5cXG4nICtcblx0Jzwvc3ZnPlxcbic7XG52YXIgcGxheUltYWdlID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIiBjbGFzcz1cImFiY2pzLXBsYXktc3ZnXCI+XFxuJyArXG5cdCcgICAgPGc+XFxuJyArXG5cdCcgICAgPHBvbHlnb24gcG9pbnRzPVwiNCAwIDIzIDEyLjUgNCAyNVwiLz5cXG4nICtcblx0JyAgICA8L2c+XFxuJyArXG5cdCc8L3N2Zz4nO1xudmFyIHBhdXNlSW1hZ2UgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNSAyNVwiIGNsYXNzPVwiYWJjanMtcGF1c2Utc3ZnXCI+XFxuJyArXG5cdCcgIDxnPlxcbicgK1xuXHQnICAgIDxyZWN0IHdpZHRoPVwiOC4yM1wiIGhlaWdodD1cIjI1XCIvPlxcbicgK1xuXHQnICAgIDxyZWN0IHdpZHRoPVwiOC4yM1wiIGhlaWdodD1cIjI1XCIgeD1cIjE3XCIvPlxcbicgK1xuXHQnICA8L2c+XFxuJyArXG5cdCc8L3N2Zz4nO1xudmFyIGxvYWRpbmdJbWFnZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiBjbGFzcz1cImFiY2pzLWxvYWRpbmctc3ZnXCI+XFxuJyArXG5cdCcgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMjBcIiByPVwiMzVcIiBzdHJva2UtZGFzaGFycmF5PVwiMTYwIDU1XCI+PC9jaXJjbGU+XFxuJyArXG5cdCc8L3N2Zz4nO1xudmFyIHJlc2V0SW1hZ2UgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNSAyNVwiPlxcbicgK1xuXHQnICA8Zz5cXG4nICtcblx0JyAgICA8cG9seWdvbiBwb2ludHM9XCI1IDEyLjUgMjQgMCAyNCAyNVwiLz5cXG4nICtcblx0JyAgICA8cmVjdCB3aWR0aD1cIjNcIiBoZWlnaHQ9XCIyNVwiIHg9XCIwXCIgeT1cIjBcIi8+XFxuJyArXG5cdCcgIDwvZz5cXG4nICtcblx0Jzwvc3ZnPic7XG5cbmZ1bmN0aW9uIENyZWF0ZVN5bnRoQ29udHJvbChwYXJlbnQsIG9wdGlvbnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHQvLyBwYXJlbnQgaXMgZWl0aGVyIGFuIGVsZW1lbnQgb3IgYSBzZWxlY3Rvci5cblx0aWYgKHR5cGVvZiBwYXJlbnQgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgc2VsZWN0b3IgPSBwYXJlbnQ7XG5cdFx0cGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0aWYgKCFwYXJlbnQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBlbGVtZW50IFxcXCJcIiArIHNlbGVjdG9yICsgXCJcXFwiIGluIHRoZSBET00uXCIpO1xuXHR9IGVsc2UgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIHZhbGlkIGVsZW1lbnQgb3Igc2VsZWN0b3IgaW4gdGhlIERPTS5cIik7XG5cblx0c2VsZi5wYXJlbnQgPSBwYXJlbnQ7XG5cdHNlbGYub3B0aW9ucyA9IHt9O1xuXHRpZiAob3B0aW9ucylcblx0XHRzZWxmLm9wdGlvbnMgPSBwYXJzZUNvbW1vbi5jbG9uZShvcHRpb25zKTtcblxuXHQvLyBUaGlzIGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gQUMgYWxyZWFkeSByZWdpc3RlcmVkIGFuZCBub3Qgc3VzcGVuZGVkXG5cdC8vIEFDIGFscmVhZHkgcmVnaXN0ZXJlZCBhbmQgc3VzcGVuZGVkXG5cdC8vIEFDIG5vdCByZWdpc3RlcmVkIGFuZCBub3QgcGFzc2VkIGluXG5cdC8vIEFDIG5vdCByZWdpc3RlcmVkIGJ1dCBwYXNzZWQgaW4gKGJ1dCBzdXNwZW5kZWQpXG5cdC8vIEFDIG5vdCByZWdpc3RlcmVkIGJ1dCBwYXNzZWQgaW4gKG5vdCBzdXNwZW5kZWQpXG5cdC8vIElmIHRoZSBBQyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZW4ganVzdCB1c2UgaXQgLSBpZ25vcmUgd2hhdCBpcyBwYXNzZWQgaW5cblx0Ly8gQ3JlYXRlIHRoZSBBQyBpZiBuZWNlc3NhcnkgaWYgdGhlcmUgaXNuJ3Qgb25lIGFscmVhZHkuXG5cdC8vIFdlIGRvbid0IGNhcmUgcmlnaHQgbm93IGlmIHRoZSBBQyBpcyBzdXNwZW5kZWQgLSB3aGVuZXZlciBhIGJ1dHRvbiBpcyBjbGlja2VkIHRoZW4gd2UgY2hlY2sgaXQuXG5cdGlmIChzZWxmLm9wdGlvbnMuYWMpXG5cdFx0cmVnaXN0ZXJBdWRpb0NvbnRleHQoc2VsZi5vcHRpb25zLmFjKTtcblx0YnVpbGREb20oc2VsZi5wYXJlbnQsIHNlbGYub3B0aW9ucyk7XG5cdGF0dGFjaExpc3RlbmVycyhzZWxmKTtcblxuXHRzZWxmLnNldFRlbXBvID0gZnVuY3Rpb24odGVtcG8pIHtcblx0XHR2YXIgZWwgPSBzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktY3VycmVudC10ZW1wb1wiKTtcblx0XHRpZiAoZWwpXG5cdFx0XHRlbC5pbm5lckhUTUwgPSB0ZW1wbztcblx0fTtcblx0c2VsZi5yZXNldEFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwdXNoZWRCdXR0b25zID0gc2VsZi5wYXJlbnQucXVlcnlTZWxlY3RvckFsbChcIi5hYmNqcy1wdXNoZWRcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwdXNoZWRCdXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYnV0dG9uID0gcHVzaGVkQnV0dG9uc1tpXTtcblx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiYWJjanMtcHVzaGVkXCIpO1xuXHRcdH1cblx0fTtcblx0c2VsZi5wdXNoUGxheSA9IGZ1bmN0aW9uKHB1c2gpIHtcblx0XHR2YXIgc3RhcnRCdXR0b24gPSBzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktc3RhcnRcIik7XG5cdFx0aWYgKCFzdGFydEJ1dHRvbilcblx0XHRcdHJldHVybjtcblx0XHRpZiAocHVzaClcblx0XHRcdHN0YXJ0QnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJhYmNqcy1wdXNoZWRcIik7XG5cdFx0ZWxzZVxuXHRcdFx0c3RhcnRCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImFiY2pzLXB1c2hlZFwiKTtcblx0fTtcblx0c2VsZi5wdXNoTG9vcCA9IGZ1bmN0aW9uKHB1c2gpIHtcblx0XHR2YXIgbG9vcEJ1dHRvbiA9IHNlbGYucGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYWJjanMtbWlkaS1sb29wXCIpO1xuXHRcdGlmICghbG9vcEJ1dHRvbilcblx0XHRcdHJldHVybjtcblx0XHRpZiAocHVzaClcblx0XHRcdGxvb3BCdXR0b24uY2xhc3NMaXN0LmFkZChcImFiY2pzLXB1c2hlZFwiKTtcblx0XHRlbHNlXG5cdFx0XHRsb29wQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJhYmNqcy1wdXNoZWRcIik7XG5cdH07XG5cblx0c2VsZi5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIChwZXJjZW50LCB0b3RhbFRpbWUpIHtcblx0XHR2YXIgcHJvZ3Jlc3NCYWNrZ3JvdW5kID0gc2VsZi5wYXJlbnQucXVlcnlTZWxlY3RvcihcIi5hYmNqcy1taWRpLXByb2dyZXNzLWJhY2tncm91bmRcIik7XG5cdFx0dmFyIHByb2dyZXNzVGh1bWIgPSBzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktcHJvZ3Jlc3MtaW5kaWNhdG9yXCIpO1xuXHRcdGlmICghcHJvZ3Jlc3NCYWNrZ3JvdW5kIHx8ICFwcm9ncmVzc1RodW1iKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciB3aWR0aCA9IHByb2dyZXNzQmFja2dyb3VuZC5jbGllbnRXaWR0aDtcblx0XHR2YXIgbGVmdCA9IHdpZHRoICogcGVyY2VudDtcblx0XHRwcm9ncmVzc1RodW1iLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuXG5cdFx0dmFyIGNsb2NrID0gc2VsZi5wYXJlbnQucXVlcnlTZWxlY3RvcihcIi5hYmNqcy1taWRpLWNsb2NrXCIpO1xuXHRcdGlmIChjbG9jaykge1xuXHRcdFx0dmFyIHRvdGFsU2Vjb25kcyA9ICh0b3RhbFRpbWUgKiBwZXJjZW50KSAvIDEwMDA7XG5cdFx0XHR2YXIgbWludXRlcyA9IE1hdGguZmxvb3IodG90YWxTZWNvbmRzIC8gNjApO1xuXHRcdFx0dmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKHRvdGFsU2Vjb25kcyAlIDYwKTtcblx0XHRcdHZhciBzZWNvbmRzRm9ybWF0dGVkID0gc2Vjb25kcyA8IDEwID8gXCIwXCIgKyBzZWNvbmRzIDogc2Vjb25kcztcblx0XHRcdGNsb2NrLmlubmVySFRNTCA9IG1pbnV0ZXMgKyBcIjpcIiArIHNlY29uZHNGb3JtYXR0ZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmIChzZWxmLm9wdGlvbnMuYWZ0ZXJSZXN1bWUpIHtcblx0XHR2YXIgaXNSZXN1bWVkID0gZmFsc2U7XG5cdFx0aWYgKHNlbGYub3B0aW9ucy5hYykge1xuXHRcdFx0aXNSZXN1bWVkID0gc2VsZi5vcHRpb25zLmFjLnN0YXRlICE9PSBcInN1c3BlbmRlZFwiO1xuXHRcdH0gZWxzZSBpZiAoYWN0aXZlQXVkaW9Db250ZXh0KCkpIHtcblx0XHRcdGlzUmVzdW1lZCA9IGFjdGl2ZUF1ZGlvQ29udGV4dCgpLnN0YXRlICE9PSBcInN1c3BlbmRlZFwiO1xuXHRcdH1cblx0XHRpZiAoaXNSZXN1bWVkKVxuXHRcdFx0c2VsZi5vcHRpb25zLmFmdGVyUmVzdW1lKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYnVpbGREb20ocGFyZW50LCBvcHRpb25zKSB7XG5cdHZhciBoYXNMb29wID0gISFvcHRpb25zLmxvb3BIYW5kbGVyO1xuXHR2YXIgaGFzUmVzdGFydCA9ICEhb3B0aW9ucy5yZXN0YXJ0SGFuZGxlcjtcblx0dmFyIGhhc1BsYXkgPSAhIW9wdGlvbnMucGxheUhhbmRsZXIgfHwgISFvcHRpb25zLnBsYXlQcm9taXNlSGFuZGxlcjtcblx0dmFyIGhhc1Byb2dyZXNzID0gISFvcHRpb25zLnByb2dyZXNzSGFuZGxlcjtcblx0dmFyIGhhc1dhcnAgPSAhIW9wdGlvbnMud2FycEhhbmRsZXI7XG5cdHZhciBoYXNDbG9jayA9IG9wdGlvbnMuaGFzQ2xvY2sgIT09IGZhbHNlO1xuXG5cdHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCJhYmNqcy1pbmxpbmUtYXVkaW9cIj5cXG4nO1xuXHRpZiAoaGFzTG9vcCkge1xuXHRcdHZhciByZXBlYXRUaXRsZSA9IG9wdGlvbnMucmVwZWF0VGl0bGUgPyBvcHRpb25zLnJlcGVhdFRpdGxlIDogXCJDbGljayB0byB0b2dnbGUgcGxheSBvbmNlL3JlcGVhdC5cIjtcblx0XHR2YXIgcmVwZWF0QXJpYSA9IG9wdGlvbnMucmVwZWF0QXJpYSA/IG9wdGlvbnMucmVwZWF0QXJpYSA6IHJlcGVhdFRpdGxlO1xuXHRcdGh0bWwgKz0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWJjanMtbWlkaS1sb29wIGFiY2pzLWJ0blwiIHRpdGxlPVwiJyArIHJlcGVhdFRpdGxlICsgJ1wiIGFyaWEtbGFiZWw9XCInICsgcmVwZWF0QXJpYSArICdcIj4nICsgbG9vcEltYWdlICsgJzwvYnV0dG9uPlxcbic7XG5cdH1cblx0aWYgKGhhc1Jlc3RhcnQpIHtcblx0XHR2YXIgcmVzdGFydFRpdGxlID0gb3B0aW9ucy5yZXN0YXJ0VGl0bGUgPyBvcHRpb25zLnJlc3RhcnRUaXRsZSA6IFwiQ2xpY2sgdG8gZ28gdG8gYmVnaW5uaW5nLlwiO1xuXHRcdHZhciByZXN0YXJ0QXJpYSA9IG9wdGlvbnMucmVzdGFydEFyaWEgPyBvcHRpb25zLnJlc3RhcnRBcmlhIDogcmVzdGFydFRpdGxlO1xuXHRcdGh0bWwgKz0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWJjanMtbWlkaS1yZXNldCBhYmNqcy1idG5cIiB0aXRsZT1cIicgKyByZXN0YXJ0VGl0bGUgKyAnXCIgYXJpYS1sYWJlbD1cIicgKyByZXN0YXJ0QXJpYSArICdcIj4nICsgcmVzZXRJbWFnZSArICc8L2J1dHRvbj5cXG4nO1xuXHR9XG5cdGlmIChoYXNQbGF5KSB7XG5cdFx0dmFyIHBsYXlUaXRsZSA9IG9wdGlvbnMucGxheVRpdGxlID8gb3B0aW9ucy5wbGF5VGl0bGUgOiBcIkNsaWNrIHRvIHBsYXkvcGF1c2UuXCI7XG5cdFx0dmFyIHBsYXlBcmlhID0gb3B0aW9ucy5wbGF5QXJpYSA/IG9wdGlvbnMucGxheUFyaWEgOiBwbGF5VGl0bGU7XG5cdFx0aHRtbCArPSAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJhYmNqcy1taWRpLXN0YXJ0IGFiY2pzLWJ0blwiIHRpdGxlPVwiJyArIHBsYXlUaXRsZSArICdcIiBhcmlhLWxhYmVsPVwiJyArIHBsYXlBcmlhICsgJ1wiPicgKyBwbGF5SW1hZ2UgKyBwYXVzZUltYWdlICsgbG9hZGluZ0ltYWdlICsgJzwvYnV0dG9uPlxcbic7XG5cdH1cblx0aWYgKGhhc1Byb2dyZXNzKSB7XG5cdFx0dmFyIHJhbmRvbVRpdGxlID0gb3B0aW9ucy5yYW5kb21UaXRsZSA/IG9wdGlvbnMucmFuZG9tVGl0bGUgOiBcIkNsaWNrIHRvIGNoYW5nZSB0aGUgcGxheWJhY2sgcG9zaXRpb24uXCI7XG5cdFx0dmFyIHJhbmRvbUFyaWEgPSBvcHRpb25zLnJhbmRvbUFyaWEgPyBvcHRpb25zLnJhbmRvbUFyaWEgOiByYW5kb21UaXRsZTtcblx0XHRodG1sICs9ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImFiY2pzLW1pZGktcHJvZ3Jlc3MtYmFja2dyb3VuZFwiIHRpdGxlPVwiJyArIHJhbmRvbVRpdGxlICsgJ1wiIGFyaWEtbGFiZWw9XCInICsgcmFuZG9tQXJpYSArICdcIj48c3BhbiBjbGFzcz1cImFiY2pzLW1pZGktcHJvZ3Jlc3MtaW5kaWNhdG9yXCI+PC9zcGFuPjwvYnV0dG9uPlxcbic7XG5cdH1cblx0aWYgKGhhc0Nsb2NrKSB7XG5cdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJhYmNqcy1taWRpLWNsb2NrXCI+PC9zcGFuPlxcbic7XG5cdH1cblx0aWYgKGhhc1dhcnApIHtcblx0XHR2YXIgd2FycFRpdGxlID0gb3B0aW9ucy53YXJwVGl0bGUgPyBvcHRpb25zLndhcnBUaXRsZSA6IFwiQ2hhbmdlIHRoZSBwbGF5YmFjayBzcGVlZC5cIjtcblx0XHR2YXIgd2FycEFyaWEgPSBvcHRpb25zLndhcnBBcmlhID8gb3B0aW9ucy53YXJwQXJpYSA6IHdhcnBUaXRsZTtcblx0XHR2YXIgYnBtID0gb3B0aW9ucy5icG0gPyBvcHRpb25zLmJwbSA6IFwiQlBNXCI7XG5cdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJhYmNqcy10ZW1wby13cmFwcGVyXCI+PGxhYmVsPjxpbnB1dCBjbGFzcz1cImFiY2pzLW1pZGktdGVtcG9cIiB0eXBlPVwibnVtYmVyXCIgbWluPVwiMVwiIG1heD1cIjMwMFwiIHZhbHVlPVwiMTAwXCIgdGl0bGU9XCInICsgd2FycFRpdGxlICsgJ1wiIGFyaWEtbGFiZWw9XCInICsgd2FycEFyaWEgKyAnXCI+JTwvbGFiZWw+PHNwYW4+Jm5ic3A7KDxzcGFuIGNsYXNzPVwiYWJjanMtbWlkaS1jdXJyZW50LXRlbXBvXCI+PC9zcGFuPiAnICsgYnBtICsgJyk8L3NwYW4+PC9zcGFuPlxcbic7XG5cdH1cblx0aHRtbCArPSAnPC9kaXY+XFxuJztcblx0cGFyZW50LmlubmVySFRNTCA9IGh0bWw7XG59XG5cbmZ1bmN0aW9uIGFjUmVzdW1lck1pZGRsZVdhcmUobmV4dCwgZXYsIHBsYXlCdG4sIGFmdGVyUmVzdW1lLCBpc1Byb21pc2UpIHtcblx0dmFyIG5lZWRzSW5pdCA9IHRydWU7XG5cdGlmICghYWN0aXZlQXVkaW9Db250ZXh0KCkpIHtcblx0XHRyZWdpc3RlckF1ZGlvQ29udGV4dCgpO1xuXHR9IGVsc2Uge1xuXHRcdG5lZWRzSW5pdCA9IGFjdGl2ZUF1ZGlvQ29udGV4dCgpLnN0YXRlID09PSBcInN1c3BlbmRlZFwiO1xuXHR9XG5cdGlmICghc3VwcG9ydHNBdWRpbygpKSB7XG5cdFx0dGhyb3cgeyBzdGF0dXM6IFwiTm90U3VwcG9ydGVkXCIsIG1lc3NhZ2U6IFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYXVkaW8uXCJ9O1xuXHR9XG5cblx0aWYgKChuZWVkc0luaXQgfHwgaXNQcm9taXNlKSAmJiBwbGF5QnRuKVxuXHRcdHBsYXlCdG4uY2xhc3NMaXN0LmFkZChcImFiY2pzLWxvYWRpbmdcIik7XG5cblx0aWYgKG5lZWRzSW5pdCkge1xuXHRcdGFjdGl2ZUF1ZGlvQ29udGV4dCgpLnJlc3VtZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGFmdGVyUmVzdW1lKSB7XG5cdFx0XHRcdGFmdGVyUmVzdW1lKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRkb05leHQobmV4dCwgZXYsIHBsYXlCdG4sIGlzUHJvbWlzZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9OZXh0KG5leHQsIGV2LCBwbGF5QnRuLCBpc1Byb21pc2UpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGRvTmV4dChuZXh0LCBldiwgcGxheUJ0biwgaXNQcm9taXNlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb05leHQobmV4dCwgZXYsIHBsYXlCdG4sIGlzUHJvbWlzZSkge1xuXHRpZiAoaXNQcm9taXNlKSB7XG5cdFx0bmV4dChldikudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGlmIChwbGF5QnRuKVxuXHRcdFx0XHRwbGF5QnRuLmNsYXNzTGlzdC5yZW1vdmUoXCJhYmNqcy1sb2FkaW5nXCIpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG5leHQoZXYpO1xuXHRcdGlmIChwbGF5QnRuKVxuXHRcdFx0cGxheUJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwiYWJjanMtbG9hZGluZ1wiKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhdHRhY2hMaXN0ZW5lcnMoc2VsZikge1xuXHR2YXIgaGFzTG9vcCA9ICEhc2VsZi5vcHRpb25zLmxvb3BIYW5kbGVyO1xuXHR2YXIgaGFzUmVzdGFydCA9ICEhc2VsZi5vcHRpb25zLnJlc3RhcnRIYW5kbGVyO1xuXHR2YXIgaGFzUGxheSA9ICEhc2VsZi5vcHRpb25zLnBsYXlIYW5kbGVyIHx8ICEhc2VsZi5vcHRpb25zLnBsYXlQcm9taXNlSGFuZGxlcjtcblx0dmFyIGhhc1Byb2dyZXNzID0gISFzZWxmLm9wdGlvbnMucHJvZ3Jlc3NIYW5kbGVyO1xuXHR2YXIgaGFzV2FycCA9ICEhc2VsZi5vcHRpb25zLndhcnBIYW5kbGVyO1xuXHR2YXIgcGxheUJ0biA9IHNlbGYucGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYWJjanMtbWlkaS1zdGFydFwiKTtcblxuXHRpZiAoaGFzTG9vcClcblx0XHRzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktbG9vcFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe2FjUmVzdW1lck1pZGRsZVdhcmUoc2VsZi5vcHRpb25zLmxvb3BIYW5kbGVyLCBldiwgcGxheUJ0biwgc2VsZi5vcHRpb25zLmFmdGVyUmVzdW1lKX0pO1xuXHRpZiAoaGFzUmVzdGFydClcblx0XHRzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktcmVzZXRcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2KXthY1Jlc3VtZXJNaWRkbGVXYXJlKHNlbGYub3B0aW9ucy5yZXN0YXJ0SGFuZGxlciwgZXYsIHBsYXlCdG4sIHNlbGYub3B0aW9ucy5hZnRlclJlc3VtZSl9KTtcblx0aWYgKGhhc1BsYXkpXG5cdFx0cGxheUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXYpe1xuXHRcdFx0YWNSZXN1bWVyTWlkZGxlV2FyZShcblx0XHRcdFx0c2VsZi5vcHRpb25zLnBsYXlQcm9taXNlSGFuZGxlciB8fCBzZWxmLm9wdGlvbnMucGxheUhhbmRsZXIsXG5cdFx0XHRcdGV2LFxuXHRcdFx0XHRwbGF5QnRuLFxuXHRcdFx0XHRzZWxmLm9wdGlvbnMuYWZ0ZXJSZXN1bWUsXG5cdFx0XHRcdCEhc2VsZi5vcHRpb25zLnBsYXlQcm9taXNlSGFuZGxlcilcblx0XHR9KTtcblx0aWYgKGhhc1Byb2dyZXNzKVxuXHRcdHNlbGYucGFyZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYWJjanMtbWlkaS1wcm9ncmVzcy1iYWNrZ3JvdW5kXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldil7YWNSZXN1bWVyTWlkZGxlV2FyZShzZWxmLm9wdGlvbnMucHJvZ3Jlc3NIYW5kbGVyLCBldiwgcGxheUJ0biwgc2VsZi5vcHRpb25zLmFmdGVyUmVzdW1lKX0pO1xuXHRpZiAoaGFzV2FycClcblx0XHRzZWxmLnBhcmVudC5xdWVyeVNlbGVjdG9yKFwiLmFiY2pzLW1pZGktdGVtcG9cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihldil7YWNSZXN1bWVyTWlkZGxlV2FyZShzZWxmLm9wdGlvbnMud2FycEhhbmRsZXIsIGV2LCBwbGF5QnRuLCBzZWxmLm9wdGlvbnMuYWZ0ZXJSZXN1bWUpfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVN5bnRoQ29udHJvbDtcbiIsInZhciBnZXROb3RlID0gcmVxdWlyZSgnLi9sb2FkLW5vdGUnKTtcbnZhciBzb3VuZHNDYWNoZSA9IHJlcXVpcmUoJy4vc291bmRzLWNhY2hlJyk7XG52YXIgY3JlYXRlTm90ZU1hcCA9IHJlcXVpcmUoJy4vY3JlYXRlLW5vdGUtbWFwJyk7XG52YXIgcmVnaXN0ZXJBdWRpb0NvbnRleHQgPSByZXF1aXJlKCcuL3JlZ2lzdGVyLWF1ZGlvLWNvbnRleHQnKTtcbnZhciBhY3RpdmVBdWRpb0NvbnRleHQgPSByZXF1aXJlKCcuL2FjdGl2ZS1hdWRpby1jb250ZXh0Jyk7XG52YXIgc3VwcG9ydHNBdWRpbyA9IHJlcXVpcmUoJy4vc3VwcG9ydHMtYXVkaW8nKTtcbnZhciBwaXRjaFRvTm90ZU5hbWUgPSByZXF1aXJlKCcuL3BpdGNoLXRvLW5vdGUtbmFtZScpO1xudmFyIGluc3RydW1lbnRJbmRleFRvTmFtZSA9IHJlcXVpcmUoJy4vaW5zdHJ1bWVudC1pbmRleC10by1uYW1lJyk7XG52YXIgZG93bmxvYWRCdWZmZXIgPSByZXF1aXJlKCcuL2Rvd25sb2FkLWJ1ZmZlcicpO1xudmFyIHNlcXVlbmNlID0gcmVxdWlyZSgnLi4vbWlkaS9hYmNfbWlkaV9zZXF1ZW5jZXInKTtcbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi4vbWlkaS9hYmNfbWlkaV9mbGF0dGVuZXInKTtcblxuLy8gVE9ETy1QRVI6IHJlbW92ZSB0aGUgbWlkaSB0ZXN0cyBmcm9tIGhlcmU6IEkgZG9uJ3QgdGhpbmsgdGhlIG9iamVjdCBjYW4gYmUgY29uc3RydWN0ZWQgdW5sZXNzIGl0IHBhc3Nlcy5cbnZhciBub3RTdXBwb3J0ZWRNZXNzYWdlID0gXCJNSURJIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLlwiO1xuXG52YXIgZGVmYXVsdFNvdW5kRm9udFVybCA9IFwiaHR0cHM6Ly9wYXVscm9zZW4uZ2l0aHViLmlvL21pZGktanMtc291bmRmb250cy9GbHVpZFIzX0dNL1wiO1xuXG5cbmZ1bmN0aW9uIENyZWF0ZVN5bnRoKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHNlbGYuYXVkaW9CdWZmZXJQb3NzaWJsZSA9IHVuZGVmaW5lZDtcblx0c2VsZi5kaXJlY3RTb3VyY2UgPSBbXTsgLy8gdHlwZTogQXVkaW9CdWZmZXJTb3VyY2VOb2RlXG5cdHNlbGYuc3RhcnRUaW1lU2VjID0gdW5kZWZpbmVkOyAvLyB0aGUgdGltZSB0aGF0IHRoZSBtaWRpIHN0YXJ0ZWQ6IHVzZWQgZm9yIHBhdXNlL3Jlc3VtZS5cblx0c2VsZi5wYXVzZWRUaW1lU2VjID0gdW5kZWZpbmVkOyAvLyB0aGUgdGltZSB0aGF0IHRoZSBtaWRpIHdhcyBwYXVzZWQ6IHVzZWQgZm9yIHJlc3VtZS5cblx0c2VsZi5hdWRpb0J1ZmZlcnMgPSBbXTsgLy8gY2FjaGUgb2YgdGhlIGJ1ZmZlcnMgc28gc3RhcnRpbmcgcGxheSBjYW4gYmUgZmFzdC5cblx0c2VsZi5kdXJhdGlvbiA9IHVuZGVmaW5lZDsgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSB0dW5lIGluIHNlY29uZHMuXG5cdHNlbGYuaXNSdW5uaW5nID0gZmFsc2U7IC8vIHdoZXRoZXIgdGhlcmUgaXMgY3VycmVudGx5IGEgc291bmQgYnVmZmVyIHJ1bm5pbmcuXG5cblx0Ly8gTG9hZCBhbmQgY2FjaGUgYWxsIG5lZWRlZCBzb3VuZHNcblx0c2VsZi5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRyZWdpc3RlckF1ZGlvQ29udGV4dChvcHRpb25zLmF1ZGlvQ29udGV4dCk7IC8vIFRoaXMgd29ya3Mgbm8gbWF0dGVyIHdoYXQgLSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFjIGl0IGlzIGEgbm9wOyBpZiB0aGUgY29udGV4dCBpcyBub3QgcGFzc2VkIGluLCB0aGVuIGl0IGNyZWF0ZXMgb25lLlxuXHRcdHZhciBzdGFydFRpbWUgPSBhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZTtcblx0XHRzZWxmLmRlYnVnQ2FsbGJhY2sgPSBvcHRpb25zLmRlYnVnQ2FsbGJhY2s7XG5cdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdHNlbGYuZGVidWdDYWxsYmFjayhcImluaXQgY2FsbGVkXCIpO1xuXHRcdHNlbGYuYXVkaW9CdWZmZXJQb3NzaWJsZSA9IHNlbGYuX2RldmljZUNhcGFibGUoKTtcblx0XHRpZiAoIXNlbGYuYXVkaW9CdWZmZXJQb3NzaWJsZSlcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7IHN0YXR1czogXCJOb3RTdXBwb3J0ZWRcIiwgbWVzc2FnZTogbm90U3VwcG9ydGVkTWVzc2FnZX0pO1xuXHRcdHNlbGYuc291bmRGb250VXJsID0gb3B0aW9ucy5zb3VuZEZvbnRVcmwgPyBvcHRpb25zLnNvdW5kRm9udFVybCA6IGRlZmF1bHRTb3VuZEZvbnRVcmw7XG5cdFx0c2VsZi5taWxsaXNlY29uZHNQZXJNZWFzdXJlID0gb3B0aW9ucy5taWxsaXNlY29uZHNQZXJNZWFzdXJlID8gb3B0aW9ucy5taWxsaXNlY29uZHNQZXJNZWFzdXJlIDogKG9wdGlvbnMudmlzdWFsT2JqID8gb3B0aW9ucy52aXN1YWxPYmoubWlsbGlzZWNvbmRzUGVyTWVhc3VyZSgpIDogMTAwMCk7XG5cdFx0dmFyIHBhcmFtcyA9IG9wdGlvbnMub3B0aW9ucyA/IG9wdGlvbnMub3B0aW9ucyA6IHt9O1xuXHRcdHNlbGYubWV0ZXJTaXplID0gMTtcblx0XHRpZiAob3B0aW9ucy52aXN1YWxPYmopIHtcblx0XHRcdHZhciBzZXEgPSBzZXF1ZW5jZShvcHRpb25zLnZpc3VhbE9iaiwgcGFyYW1zKTtcblx0XHRcdHNlbGYuZmxhdHRlbmVkID0gZmxhdHRlbihzZXEsIHBhcmFtcyk7XG5cdFx0XHRzZWxmLm1ldGVyU2l6ZSA9IG9wdGlvbnMudmlzdWFsT2JqLmdldE1ldGVyRnJhY3Rpb24oKS5udW0gLyBvcHRpb25zLnZpc3VhbE9iai5nZXRNZXRlckZyYWN0aW9uKCkuZGVuO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5zZXF1ZW5jZSlcblx0XHRcdHNlbGYuZmxhdHRlbmVkID0gb3B0aW9ucy5zZXF1ZW5jZTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTXVzdCBwYXNzIGluIGVpdGhlciBhIHZpc3VhbE9iaiBvciBhIHNlcXVlbmNlXCIpKTtcblx0XHRzZWxmLnNlcXVlbmNlQ2FsbGJhY2sgPSBwYXJhbXMuc2VxdWVuY2VDYWxsYmFjaztcblx0XHRzZWxmLmNhbGxiYWNrQ29udGV4dCA9IHBhcmFtcy5jYWxsYmFja0NvbnRleHQ7XG5cdFx0c2VsZi5vbkVuZGVkID0gb3B0aW9ucy5vbkVuZGVkO1xuXG5cdFx0dmFyIGFsbE5vdGVzID0ge307XG5cdFx0dmFyIGN1cnJlbnRJbnN0cnVtZW50ID0gaW5zdHJ1bWVudEluZGV4VG9OYW1lWzBdO1xuXHRcdHNlbGYuZmxhdHRlbmVkLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG5cdFx0XHR0cmFjay5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmIChldmVudC5jbWQgPT09IFwicHJvZ3JhbVwiICYmIGluc3RydW1lbnRJbmRleFRvTmFtZVtldmVudC5pbnN0cnVtZW50XSlcblx0XHRcdFx0XHRjdXJyZW50SW5zdHJ1bWVudCA9IGluc3RydW1lbnRJbmRleFRvTmFtZVtldmVudC5pbnN0cnVtZW50XTtcblx0XHRcdFx0aWYgKGV2ZW50LnBpdGNoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YXIgcGl0Y2hOdW1iZXIgPSBldmVudC5waXRjaCArIDYwO1xuXHRcdFx0XHRcdHZhciBub3RlTmFtZSA9IHBpdGNoVG9Ob3RlTmFtZVtwaXRjaE51bWJlcl07XG5cdFx0XHRcdFx0aWYgKG5vdGVOYW1lKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWFsbE5vdGVzW2N1cnJlbnRJbnN0cnVtZW50XSlcblx0XHRcdFx0XHRcdFx0YWxsTm90ZXNbY3VycmVudEluc3RydW1lbnRdID0ge307XG5cdFx0XHRcdFx0XHRhbGxOb3Rlc1tjdXJyZW50SW5zdHJ1bWVudF1bcGl0Y2hUb05vdGVOYW1lW3BpdGNoTnVtYmVyXV0gPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJDYW4ndCBmaW5kIG5vdGU6IFwiLCBwaXRjaE51bWJlcik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGlmIChzZWxmLmRlYnVnQ2FsbGJhY2spXG5cdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soXCJub3RlIGdhdGhlcmluZyB0aW1lID0gXCIgKyBNYXRoLmZsb29yKChhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSAtIHN0YXJ0VGltZSkqMTAwMCkrXCJtc1wiKTtcblx0XHRzdGFydFRpbWUgPSBhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZTtcblxuXHRcdHZhciBub3RlcyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKGFsbE5vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGluc3RydW1lbnQpIHtcblx0XHRcdE9iamVjdC5rZXlzKGFsbE5vdGVzW2luc3RydW1lbnRdKS5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpIHtcblx0XHRcdFx0bm90ZXMucHVzaCh7IGluc3RydW1lbnQ6IGluc3RydW1lbnQsIG5vdGU6IG5vdGUgfSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHQvLyBJZiB0aGVyZSBhcmUgbG90cyBvZiBub3RlcywgbG9hZCB0aGVtIGluIGJhdGNoZXNcblx0XHR2YXIgYmF0Y2hlcyA9IFtdO1xuXHRcdHZhciBDSFVOSyA9IDI1Njtcblx0XHRmb3IgKHZhciBpPTA7IGkgPCBub3Rlcy5sZW5ndGg7IGkgKz0gQ0hVTkspIHtcblx0XHRcdGJhdGNoZXMucHVzaChub3Rlcy5zbGljZShpLCBpICsgQ0hVTkspKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdFx0dmFyIG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKGluZGV4IDwgYmF0Y2hlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRzZWxmLl9sb2FkQmF0Y2goYmF0Y2hlc1tpbmRleF0sIHNlbGYuc291bmRGb250VXJsLCBzdGFydFRpbWUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdFx0c3RhcnRUaW1lID0gYWN0aXZlQXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWU7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goZGF0YSk7XG5cdFx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHRcdH0sIHJlamVjdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdG5leHQoKTtcblx0XHR9KTtcblx0fTtcblxuXHRzZWxmLl9sb2FkQmF0Y2ggPSAoZnVuY3Rpb24oYmF0Y2gsIHNvdW5kRm9udFVybCwgc3RhcnRUaW1lKSB7XG5cdFx0dmFyIHByb21pc2VzID0gW107XG5cdFx0YmF0Y2guZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRwcm9taXNlcy5wdXNoKGdldE5vdGUoc291bmRGb250VXJsLCBpdGVtLmluc3RydW1lbnQsIGl0ZW0ubm90ZSwgYWN0aXZlQXVkaW9Db250ZXh0KCkpKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdGlmIChzZWxmLmRlYnVnQ2FsbGJhY2spXG5cdFx0XHRcdHNlbGYuZGVidWdDYWxsYmFjayhcIm1wMyBsb2FkIHRpbWUgPSBcIiArIE1hdGguZmxvb3IoKGFjdGl2ZUF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lKSoxMDAwKStcIm1zXCIpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHNlbGYucHJpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRzZWxmLmlzUnVubmluZyA9IGZhbHNlO1xuXHRcdGlmICghc2VsZi5hdWRpb0J1ZmZlclBvc3NpYmxlKVxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihub3RTdXBwb3J0ZWRNZXNzYWdlKSk7XG5cdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdHNlbGYuZGVidWdDYWxsYmFjayhcInByaW1lIGNhbGxlZFwiKTtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHRcdFx0dmFyIHN0YXJ0VGltZSA9IGFjdGl2ZUF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lO1xuXHRcdFx0dmFyIHRlbXBvTXVsdGlwbGllciA9IHNlbGYubWlsbGlzZWNvbmRzUGVyTWVhc3VyZSAvIDEwMDAgLyBzZWxmLm1ldGVyU2l6ZTtcblx0XHRcdHNlbGYuZHVyYXRpb24gPSBzZWxmLmZsYXR0ZW5lZC50b3RhbER1cmF0aW9uICogdGVtcG9NdWx0aXBsaWVyO1xuXHRcdFx0dmFyIHRvdGFsU2FtcGxlcyA9IE1hdGguZmxvb3IoYWN0aXZlQXVkaW9Db250ZXh0KCkuc2FtcGxlUmF0ZSAqIHNlbGYuZHVyYXRpb24pO1xuXG5cdFx0XHQvLyBUaGVyZSBtaWdodCBiZSBhIHByZXZpb3VzIHJ1biB0aGF0IG5lZWRzIHRvIGJlIHR1cm5lZCBvZmYuXG5cdFx0XHRzZWxmLnN0b3AoKTtcblxuXHRcdFx0dmFyIG5vdGVNYXBUcmFja3MgPSBjcmVhdGVOb3RlTWFwKHNlbGYuZmxhdHRlbmVkKTtcblx0XHRcdGlmIChzZWxmLnNlcXVlbmNlQ2FsbGJhY2spXG5cdFx0XHRcdHNlbGYuc2VxdWVuY2VDYWxsYmFjayhub3RlTWFwVHJhY2tzLCBzZWxmLmNhbGxiYWNrQ29udGV4dCk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKG5vdGVNYXBUcmFja3MpO1xuXG5cdFx0XHRzZWxmLmF1ZGlvQnVmZmVycyA9IFtdO1xuXHRcdFx0bm90ZU1hcFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGVNYXApIHtcblx0XHRcdFx0dmFyIGF1ZGlvQnVmZmVyID0gYWN0aXZlQXVkaW9Db250ZXh0KCkuY3JlYXRlQnVmZmVyKDEsIHRvdGFsU2FtcGxlcywgYWN0aXZlQXVkaW9Db250ZXh0KCkuc2FtcGxlUmF0ZSk7XG5cdFx0XHRcdHZhciBjaGFuRGF0YSA9IGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXG5cdFx0XHRcdG5vdGVNYXAuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG5cdFx0XHRcdFx0c2VsZi5fcGxhY2VOb3RlKGNoYW5EYXRhLCBub3RlLCB0ZW1wb011bHRpcGxpZXIsIHNvdW5kc0NhY2hlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c2VsZi5hdWRpb0J1ZmZlcnMucHVzaChhdWRpb0J1ZmZlcik7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaykge1xuXHRcdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soXCJzYW1wbGVSYXRlID0gXCIgKyBhY3RpdmVBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlKTtcblx0XHRcdFx0c2VsZi5kZWJ1Z0NhbGxiYWNrKFwidG90YWxTYW1wbGVzID0gXCIgKyB0b3RhbFNhbXBsZXMpO1xuXHRcdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soXCJjcmVhdGlvblRpbWUgPSBcIiArIE1hdGguZmxvb3IoKGFjdGl2ZUF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lKSoxMDAwKSArIFwibXNcIik7XG5cdFx0XHR9XG5cdFx0XHRyZXNvbHZlKHtcblx0XHRcdFx0c3RhdHVzOiBcIm9rXCIsXG5cdFx0XHRcdHNlY29uZHM6IDBcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8vIFRoaXMgaXMgY2FsbGVkIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgc2V0IHVwLCBzbyBpdCBjYW4gcXVpY2tseSBtYWtlIHNvdW5kXG5cdHNlbGYuc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoc2VsZi5wYXVzZWRUaW1lU2VjKSB7XG5cdFx0XHRzZWxmLnJlc3VtZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghc2VsZi5hdWRpb0J1ZmZlclBvc3NpYmxlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG5vdFN1cHBvcnRlZE1lc3NhZ2UpO1xuXHRcdGlmIChzZWxmLmRlYnVnQ2FsbGJhY2spXG5cdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soXCJzdGFydCBjYWxsZWRcIik7XG5cblx0XHRzZWxmLl9raWNrT2ZmU291bmQoMCk7XG5cdFx0c2VsZi5zdGFydFRpbWVTZWMgPSBhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZTtcblx0XHRzZWxmLnBhdXNlZFRpbWVTZWMgPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoc2VsZi5kZWJ1Z0NhbGxiYWNrKVxuXHRcdFx0c2VsZi5kZWJ1Z0NhbGxiYWNrKFwiTUlESSBTVEFSVEVEXCIsIHNlbGYuc3RhcnRUaW1lU2VjKTtcblx0fTtcblxuXHRzZWxmLnBhdXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFzZWxmLmF1ZGlvQnVmZmVyUG9zc2libGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Iobm90U3VwcG9ydGVkTWVzc2FnZSk7XG5cdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdHNlbGYuZGVidWdDYWxsYmFjayhcInBhdXNlIGNhbGxlZFwiKTtcblxuXHRcdGlmICghc2VsZi5wYXVzZWRUaW1lU2VjKSB7IC8vIGlnbm9yZSBpZiBzZWxmIGlzIGFscmVhZHkgcGF1c2VkLlxuXHRcdFx0c2VsZi5zdG9wKCk7XG5cdFx0XHRzZWxmLnBhdXNlZFRpbWVTZWMgPSBhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZTtcblx0XHR9XG5cdH07XG5cblx0c2VsZi5yZXN1bWUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXNlbGYuYXVkaW9CdWZmZXJQb3NzaWJsZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihub3RTdXBwb3J0ZWRNZXNzYWdlKTtcblx0XHRpZiAoc2VsZi5kZWJ1Z0NhbGxiYWNrKVxuXHRcdFx0c2VsZi5kZWJ1Z0NhbGxiYWNrKFwicmVzdW1lIGNhbGxlZFwiKTtcblxuXHRcdHZhciBvZmZzZXQgPSBzZWxmLnBhdXNlZFRpbWVTZWMgLSBzZWxmLnN0YXJ0VGltZVNlYztcblx0XHRzZWxmLnN0YXJ0VGltZVNlYyA9IGFjdGl2ZUF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lIC0gb2Zmc2V0OyAvLyBXZSBtb3ZlIHRoZSBzdGFydCB0aW1lIGluIGNhc2UgdGhlcmUgaXMgYW5vdGhlciBwYXVzZS9yZXN1bWUuXG5cdFx0c2VsZi5wYXVzZWRUaW1lU2VjID0gdW5kZWZpbmVkO1xuXHRcdHNlbGYuX2tpY2tPZmZTb3VuZChvZmZzZXQpO1xuXHR9O1xuXG5cdHNlbGYuc2VlayA9IGZ1bmN0aW9uKHBlcmNlbnQpIHtcblx0XHR2YXIgb2Zmc2V0ID0gc2VsZi5kdXJhdGlvbiAqIHBlcmNlbnQ7XG5cblx0XHQvLyBUT0RPLVBFUjogY2FuIHNlZWsgd2hlbiBwYXVzZWQgb3Igd2hlbiBwbGF5aW5nXG5cdFx0aWYgKCFzZWxmLmF1ZGlvQnVmZmVyUG9zc2libGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Iobm90U3VwcG9ydGVkTWVzc2FnZSk7XG5cdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdHNlbGYuZGVidWdDYWxsYmFjayhcInNlZWsgY2FsbGVkIHNlYz1cIiArIG9mZnNldCk7XG5cblx0XHRpZiAoc2VsZi5pc1J1bm5pbmcpIHtcblx0XHRcdHNlbGYuc3RvcCgpO1xuXHRcdFx0c2VsZi5fa2lja09mZlNvdW5kKG9mZnNldCk7XG5cdFx0fVxuXHRcdHZhciBwYXVzZURpc3RhbmNlID0gc2VsZi5wYXVzZWRUaW1lU2VjID8gc2VsZi5wYXVzZWRUaW1lU2VjIC0gc2VsZi5zdGFydFRpbWVTZWMgOiB1bmRlZmluZWQ7XG5cdFx0c2VsZi5zdGFydFRpbWVTZWMgPSBhY3RpdmVBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSAtIG9mZnNldDtcblx0XHRpZiAoc2VsZi5wYXVzZWRUaW1lU2VjKVxuXHRcdFx0c2VsZi5wYXVzZWRUaW1lU2VjID0gc2VsZi5zdGFydFRpbWVTZWMgKyBwYXVzZURpc3RhbmNlO1xuXHR9O1xuXG5cdHNlbGYuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuaXNSdW5uaW5nID0gZmFsc2U7XG5cdFx0c2VsZi5wYXVzZWRUaW1lU2VjID0gdW5kZWZpbmVkO1xuXHRcdHNlbGYuZGlyZWN0U291cmNlLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzb3VyY2Uuc3RvcCgpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gV2UgZG9uJ3QgY2FyZSBpZiBzZWxmIHN1Y2NlZWRzOiBpdCBtaWdodCBmYWlsIGlmIHNvbWV0aGluZyBlbHNlIHR1cm5lZCBvZmYgdGhlIHNvdW5kIG9yIGl0IGVuZGVkIGZvciBzb21lIHJlYXNvbi5cblx0XHRcdFx0Y29uc29sZS5sb2coXCJkaXJlY3Qgc291cmNlIGRpZG4ndCBzdG9wOlwiLCBlcnJvcilcblx0XHRcdH1cblx0XHR9KTtcblx0XHRzZWxmLmRpcmVjdFNvdXJjZSA9IFtdO1xuXHR9O1xuXG5cdHNlbGYuZG93bmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG93bmxvYWRCdWZmZXIoc2VsZik7XG5cdH07XG5cblx0Ly8vLy8vLy8vLy8vLy8vIFByaXZhdGUgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vXG5cblx0c2VsZi5fZGV2aWNlQ2FwYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3VwcG9ydHNBdWRpbygpKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obm90U3VwcG9ydGVkTWVzc2FnZSk7XG5cdFx0XHRpZiAoc2VsZi5kZWJ1Z0NhbGxiYWNrKVxuXHRcdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2sobm90U3VwcG9ydGVkTWVzc2FnZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdHNlbGYuX2tpY2tPZmZTb3VuZCA9IGZ1bmN0aW9uKHNlY29uZHMpIHtcblx0XHRzZWxmLmlzUnVubmluZyA9IHRydWU7XG5cdFx0c2VsZi5kaXJlY3RTb3VyY2UgPSBbXTtcblx0XHRzZWxmLmF1ZGlvQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGF1ZGlvQnVmZmVyLCB0cmFja051bSkge1xuXHRcdFx0c2VsZi5kaXJlY3RTb3VyY2VbdHJhY2tOdW1dID0gYWN0aXZlQXVkaW9Db250ZXh0KCkuY3JlYXRlQnVmZmVyU291cmNlKCk7IC8vIGNyZWF0ZXMgYSBzb3VuZCBzb3VyY2Vcblx0XHRcdHNlbGYuZGlyZWN0U291cmNlW3RyYWNrTnVtXS5idWZmZXIgPSBhdWRpb0J1ZmZlcjsgLy8gdGVsbCB0aGUgc291cmNlIHdoaWNoIHNvdW5kIHRvIHBsYXlcblx0XHRcdHNlbGYuZGlyZWN0U291cmNlW3RyYWNrTnVtXS5jb25uZWN0KGFjdGl2ZUF1ZGlvQ29udGV4dCgpLmRlc3RpbmF0aW9uKTsgLy8gY29ubmVjdCB0aGUgc291cmNlIHRvIHRoZSBjb250ZXh0J3MgZGVzdGluYXRpb24gKHRoZSBzcGVha2Vycylcblx0XHR9KTtcblx0XHRzZWxmLmRpcmVjdFNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0c291cmNlLnN0YXJ0KDAsIHNlY29uZHMpO1xuXHRcdH0pO1xuXHRcdGlmIChzZWxmLm9uRW5kZWQpIHtcblx0XHRcdHNlbGYuZGlyZWN0U291cmNlWzBdLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYub25FbmRlZChzZWxmLmNhbGxiYWNrQ29udGV4dCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHRzZWxmLl9wbGFjZU5vdGUgPSBmdW5jdGlvbihjaGFuRGF0YSwgbm90ZSwgdGVtcG9NdWx0aXBsaWVyLCBzb3VuZHNDYWNoZSkge1xuXHRcdHZhciBzdGFydCA9IE1hdGguZmxvb3Iobm90ZS5zdGFydCphY3RpdmVBdWRpb0NvbnRleHQoKS5zYW1wbGVSYXRlICogdGVtcG9NdWx0aXBsaWVyKTtcblx0XHR2YXIgbnVtQmVhdHMgPSBub3RlLmVuZCAtIG5vdGUuc3RhcnQ7XG5cdFx0dmFyIG5vdGVUaW1lU2VjID0gbnVtQmVhdHMgKiB0ZW1wb011bHRpcGxpZXI7XG5cdFx0dmFyIG5vdGVOYW1lID0gcGl0Y2hUb05vdGVOYW1lW25vdGUucGl0Y2grNjBdO1xuXHRcdGlmIChub3RlTmFtZSkgeyAvLyBKdXN0IGlnbm9yZSBwaXRjaGVzIHRoYXQgZG9uJ3QgZXhpc3QuXG5cdFx0XHR2YXIgcGl0Y2ggPSBzb3VuZHNDYWNoZVtub3RlLmluc3RydW1lbnRdW25vdGVOYW1lXS5nZXRDaGFubmVsRGF0YSgwKTtcblx0XHRcdHZhciBkdXJhdGlvbiA9IE1hdGgubWluKHBpdGNoLmxlbmd0aCwgTWF0aC5mbG9vcihub3RlVGltZVNlYyAqIGFjdGl2ZUF1ZGlvQ29udGV4dCgpLnNhbXBsZVJhdGUpKTtcblx0XHRcdC8vY29uc29sZS5sb2cocGl0Y2hUb05vdGVbbm90ZS5waXRjaCsnJ10sIHN0YXJ0LCBudW1CZWF0cywgbm90ZVRpbWVTZWMsIGR1cmF0aW9uKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZHVyYXRpb247IGkrKykge1xuXHRcdFx0XHR2YXIgdGhpc1NhbXBsZSA9IHBpdGNoW2ldICogbm90ZS52b2x1bWUgLyAxMjg7XG5cdFx0XHRcdGlmIChjaGFuRGF0YVtzdGFydCArIGldKVxuXHRcdFx0XHRcdGNoYW5EYXRhW3N0YXJ0ICsgaV0gPSAoY2hhbkRhdGFbc3RhcnQgKyBpXSArIHRoaXNTYW1wbGUpICowLjc1O1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y2hhbkRhdGFbc3RhcnQgKyBpXSA9IHRoaXNTYW1wbGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZVN5bnRoO1xuIiwidmFyIGRvd25sb2FkQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cdHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChidWZmZXJUb1dhdmUoYnVmZmVyLmF1ZGlvQnVmZmVycykpO1xufTtcblxuLy8gQ29udmVydCBhbiBBdWRpb0J1ZmZlciB0byBhIEJsb2IgdXNpbmcgV0FWRSByZXByZXNlbnRhdGlvblxuZnVuY3Rpb24gYnVmZmVyVG9XYXZlKGF1ZGlvQnVmZmVycykge1xuXHR2YXIgbnVtT2ZDaGFuID0gYXVkaW9CdWZmZXJzLmxlbmd0aDtcblx0dmFyIGxlbmd0aCA9IGF1ZGlvQnVmZmVyc1swXS5sZW5ndGggKiBudW1PZkNoYW4gKiAyICsgNDQ7XG5cdHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcblx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblx0dmFyIGNoYW5uZWxzID0gW107XG5cdHZhciBpO1xuXHR2YXIgc2FtcGxlO1xuXHR2YXIgb2Zmc2V0ID0gMDtcblx0dmFyIHBvcyA9IDA7XG5cblx0Ly8gd3JpdGUgV0FWRSBoZWFkZXJcblx0c2V0VWludDMyKDB4NDY0NjQ5NTIpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIlJJRkZcIlxuXHRzZXRVaW50MzIobGVuZ3RoIC0gOCk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgbGVuZ3RoIC0gOFxuXHRzZXRVaW50MzIoMHg0NTU2NDE1Nyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiV0FWRVwiXG5cblx0c2V0VWludDMyKDB4MjA3NDZkNjYpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcImZtdCBcIiBjaHVua1xuXHRzZXRVaW50MzIoMTYpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlbmd0aCA9IDE2XG5cdHNldFVpbnQxNigxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUENNICh1bmNvbXByZXNzZWQpXG5cdHNldFVpbnQxNihudW1PZkNoYW4pO1xuXHRzZXRVaW50MzIoYXVkaW9CdWZmZXJzWzBdLnNhbXBsZVJhdGUpO1xuXHRzZXRVaW50MzIoYXVkaW9CdWZmZXJzWzBdLnNhbXBsZVJhdGUgKiAyICogbnVtT2ZDaGFuKTsgLy8gYXZnLiBieXRlcy9zZWNcblx0c2V0VWludDE2KG51bU9mQ2hhbiAqIDIpOyAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jay1hbGlnblxuXHRzZXRVaW50MTYoMTYpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDE2LWJpdCAoaGFyZGNvZGVkIGluIHRoaXMgZGVtbylcblxuXHRzZXRVaW50MzIoMHg2MTc0NjE2NCk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZGF0YVwiIC0gY2h1bmtcblx0c2V0VWludDMyKGxlbmd0aCAtIHBvcyAtIDQpOyAgICAgICAgICAgICAgICAgICAvLyBjaHVuayBsZW5ndGhcblxuXHQvLyB3cml0ZSBpbnRlcmxlYXZlZCBkYXRhXG5cdGZvcihpID0gMDsgaSA8IGF1ZGlvQnVmZmVycy5sZW5ndGg7IGkrKylcblx0XHRjaGFubmVscy5wdXNoKGF1ZGlvQnVmZmVyc1tpXS5nZXRDaGFubmVsRGF0YSgwKSk7XG5cblx0d2hpbGUocG9zIDwgbGVuZ3RoKSB7XG5cdFx0Zm9yKGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHsgICAgICAgICAgICAgLy8gaW50ZXJsZWF2ZSBjaGFubmVsc1xuXHRcdFx0c2FtcGxlID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGNoYW5uZWxzW2ldW29mZnNldF0pKTsgLy8gY2xhbXBcblx0XHRcdHNhbXBsZSA9ICgwLjUgKyBzYW1wbGUgPCAwID8gc2FtcGxlICogMzI3NjggOiBzYW1wbGUgKiAzMjc2Nyl8MDsgLy8gc2NhbGUgdG8gMTYtYml0IHNpZ25lZCBpbnRcblx0XHRcdHZpZXcuc2V0SW50MTYocG9zLCBzYW1wbGUsIHRydWUpOyAgICAgICAgICAvLyB3cml0ZSAxNi1iaXQgc2FtcGxlXG5cdFx0XHRwb3MgKz0gMjtcblx0XHR9XG5cdFx0b2Zmc2V0Kys7IC8vIG5leHQgc291cmNlIHNhbXBsZVxuXHR9XG5cblx0Ly8gY3JlYXRlIEJsb2Jcblx0cmV0dXJuIG5ldyBCbG9iKFtidWZmZXJdLCB7dHlwZTogXCJhdWRpby93YXZcIn0pO1xuXG5cdGZ1bmN0aW9uIHNldFVpbnQxNihkYXRhKSB7XG5cdFx0dmlldy5zZXRVaW50MTYocG9zLCBkYXRhLCB0cnVlKTtcblx0XHRwb3MgKz0gMjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFVpbnQzMihkYXRhKSB7XG5cdFx0dmlldy5zZXRVaW50MzIocG9zLCBkYXRhLCB0cnVlKTtcblx0XHRwb3MgKz0gNDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvd25sb2FkQnVmZmVyO1xuIiwidmFyIGluc3RydW1lbnRJbmRleFRvTmFtZSA9IFtcblx0XCJhY291c3RpY19ncmFuZF9waWFub1wiLFxuXHRcImJyaWdodF9hY291c3RpY19waWFub1wiLFxuXHRcImVsZWN0cmljX2dyYW5kX3BpYW5vXCIsXG5cdFwiaG9ua3l0b25rX3BpYW5vXCIsXG5cdFwiZWxlY3RyaWNfcGlhbm9fMVwiLFxuXHRcImVsZWN0cmljX3BpYW5vXzJcIixcblx0XCJoYXJwc2ljaG9yZFwiLFxuXHRcImNsYXZpbmV0XCIsXG5cblx0XCJjZWxlc3RhXCIsXG5cdFwiZ2xvY2tlbnNwaWVsXCIsXG5cdFwibXVzaWNfYm94XCIsXG5cdFwidmlicmFwaG9uZVwiLFxuXHRcIm1hcmltYmFcIixcblx0XCJ4eWxvcGhvbmVcIixcblx0XCJ0dWJ1bGFyX2JlbGxzXCIsXG5cdFwiZHVsY2ltZXJcIixcblxuXHRcImRyYXdiYXJfb3JnYW5cIixcblx0XCJwZXJjdXNzaXZlX29yZ2FuXCIsXG5cdFwicm9ja19vcmdhblwiLFxuXHRcImNodXJjaF9vcmdhblwiLFxuXHRcInJlZWRfb3JnYW5cIixcblx0XCJhY2NvcmRpb25cIixcblx0XCJoYXJtb25pY2FcIixcblx0XCJ0YW5nb19hY2NvcmRpb25cIixcblxuXHRcImFjb3VzdGljX2d1aXRhcl9ueWxvblwiLFxuXHRcImFjb3VzdGljX2d1aXRhcl9zdGVlbFwiLFxuXHRcImVsZWN0cmljX2d1aXRhcl9qYXp6XCIsXG5cdFwiZWxlY3RyaWNfZ3VpdGFyX2NsZWFuXCIsXG5cdFwiZWxlY3RyaWNfZ3VpdGFyX211dGVkXCIsXG5cdFwib3ZlcmRyaXZlbl9ndWl0YXJcIixcblx0XCJkaXN0b3J0aW9uX2d1aXRhclwiLFxuXHRcImd1aXRhcl9oYXJtb25pY3NcIixcblxuXHRcImFjb3VzdGljX2Jhc3NcIixcblx0XCJlbGVjdHJpY19iYXNzX2ZpbmdlclwiLFxuXHRcImVsZWN0cmljX2Jhc3NfcGlja1wiLFxuXHRcImZyZXRsZXNzX2Jhc3NcIixcblx0XCJzbGFwX2Jhc3NfMVwiLFxuXHRcInNsYXBfYmFzc18yXCIsXG5cdFwic3ludGhfYmFzc18xXCIsXG5cdFwic3ludGhfYmFzc18yXCIsXG5cblx0XCJ2aW9saW5cIixcblx0XCJ2aW9sYVwiLFxuXHRcImNlbGxvXCIsXG5cdFwiY29udHJhYmFzc1wiLFxuXHRcInRyZW1vbG9fc3RyaW5nc1wiLFxuXHRcInBpenppY2F0b19zdHJpbmdzXCIsXG5cdFwib3JjaGVzdHJhbF9oYXJwXCIsXG5cdFwidGltcGFuaVwiLFxuXG5cdFwic3RyaW5nX2Vuc2VtYmxlXzFcIixcblx0XCJzdHJpbmdfZW5zZW1ibGVfMlwiLFxuXHRcInN5bnRoX3N0cmluZ3NfMVwiLFxuXHRcInN5bnRoX3N0cmluZ3NfMlwiLFxuXHRcImNob2lyX2FhaHNcIixcblx0XCJ2b2ljZV9vb2hzXCIsXG5cdFwic3ludGhfY2hvaXJcIixcblx0XCJvcmNoZXN0cmFfaGl0XCIsXG5cblx0XCJ0cnVtcGV0XCIsXG5cdFwidHJvbWJvbmVcIixcblx0XCJ0dWJhXCIsXG5cdFwibXV0ZWRfdHJ1bXBldFwiLFxuXHRcImZyZW5jaF9ob3JuXCIsXG5cdFwiYnJhc3Nfc2VjdGlvblwiLFxuXHRcInN5bnRoX2JyYXNzXzFcIixcblx0XCJzeW50aF9icmFzc18yXCIsXG5cblx0XCJzb3ByYW5vX3NheFwiLFxuXHRcImFsdG9fc2F4XCIsXG5cdFwidGVub3Jfc2F4XCIsXG5cdFwiYmFyaXRvbmVfc2F4XCIsXG5cdFwib2JvZVwiLFxuXHRcImVuZ2xpc2hfaG9yblwiLFxuXHRcImJhc3Nvb25cIixcblx0XCJjbGFyaW5ldFwiLFxuXG5cdFwicGljY29sb1wiLFxuXHRcImZsdXRlXCIsXG5cdFwicmVjb3JkZXJcIixcblx0XCJwYW5fZmx1dGVcIixcblx0XCJibG93bl9ib3R0bGVcIixcblx0XCJzaGFrdWhhY2hpXCIsXG5cdFwid2hpc3RsZVwiLFxuXHRcIm9jYXJpbmFcIixcblxuXHRcImxlYWRfMV9zcXVhcmVcIixcblx0XCJsZWFkXzJfc2F3dG9vdGhcIixcblx0XCJsZWFkXzNfY2FsbGlvcGVcIixcblx0XCJsZWFkXzRfY2hpZmZcIixcblx0XCJsZWFkXzVfY2hhcmFuZ1wiLFxuXHRcImxlYWRfNl92b2ljZVwiLFxuXHRcImxlYWRfN19maWZ0aHNcIixcblx0XCJsZWFkXzhfYmFzc19fbGVhZFwiLFxuXG5cdFwicGFkXzFfbmV3X2FnZVwiLFxuXHRcInBhZF8yX3dhcm1cIixcblx0XCJwYWRfM19wb2x5c3ludGhcIixcblx0XCJwYWRfNF9jaG9pclwiLFxuXHRcInBhZF81X2Jvd2VkXCIsXG5cdFwicGFkXzZfbWV0YWxsaWNcIixcblx0XCJwYWRfN19oYWxvXCIsXG5cdFwicGFkXzhfc3dlZXBcIixcblxuXHRcImZ4XzFfcmFpblwiLFxuXHRcImZ4XzJfc291bmR0cmFja1wiLFxuXHRcImZ4XzNfY3J5c3RhbFwiLFxuXHRcImZ4XzRfYXRtb3NwaGVyZVwiLFxuXHRcImZ4XzVfYnJpZ2h0bmVzc1wiLFxuXHRcImZ4XzZfZ29ibGluc1wiLFxuXHRcImZ4XzdfZWNob2VzXCIsXG5cdFwiZnhfOF9zY2lmaVwiLFxuXG5cdFwic2l0YXJcIixcblx0XCJiYW5qb1wiLFxuXHRcInNoYW1pc2VuXCIsXG5cdFwia290b1wiLFxuXHRcImthbGltYmFcIixcblx0XCJiYWdwaXBlXCIsXG5cdFwiZmlkZGxlXCIsXG5cdFwic2hhbmFpXCIsXG5cblx0XCJ0aW5rbGVfYmVsbFwiLFxuXHRcImFnb2dvXCIsXG5cdFwic3RlZWxfZHJ1bXNcIixcblx0XCJ3b29kYmxvY2tcIixcblx0XCJ0YWlrb19kcnVtXCIsXG5cdFwibWVsb2RpY190b21cIixcblx0XCJzeW50aF9kcnVtXCIsXG5cdFwicmV2ZXJzZV9jeW1iYWxcIixcblxuXHRcImd1aXRhcl9mcmV0X25vaXNlXCIsXG5cdFwiYnJlYXRoX25vaXNlXCIsXG5cdFwic2Vhc2hvcmVcIixcblx0XCJiaXJkX3R3ZWV0XCIsXG5cdFwidGVsZXBob25lX3JpbmdcIixcblx0XCJoZWxpY29wdGVyXCIsXG5cdFwiYXBwbGF1c2VcIixcblx0XCJndW5zaG90XCIsXG5cblx0XCJwZXJjdXNzaW9uXCJcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdHJ1bWVudEluZGV4VG9OYW1lO1xuIiwiLy8gTG9hZCBvbmUgbXAzIGZpbGUgZm9yIG9uZSBub3RlLlxuLy8gdXJsID0gdGhlIGJhc2UgdXJsIGZvciB0aGUgc291bmRmb250XG4vLyBpbnN0cnVtZW50ID0gdGhlIGluc3RydW1lbnQgbmFtZSAoZS5nLiBcImFjb3VzdGljX2dyYW5kX3BpYW5vXCIpXG4vLyBuYW1lID0gdGhlIHBpdGNoIG5hbWUgKGUuZy4gXCJBM1wiKVxudmFyIHNvdW5kc0NhY2hlID0gcmVxdWlyZSgnLi9zb3VuZHMtY2FjaGUnKTtcblxudmFyIGdldE5vdGUgPSBmdW5jdGlvbih1cmwsIGluc3RydW1lbnQsIG5hbWUsIGF1ZGlvQ29udGV4dCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGlmICghc291bmRzQ2FjaGVbaW5zdHJ1bWVudF0pXG5cdFx0XHRzb3VuZHNDYWNoZVtpbnN0cnVtZW50XSA9IHt9O1xuXHRcdHZhciBpbnN0cnVtZW50Q2FjaGUgPSBzb3VuZHNDYWNoZVtpbnN0cnVtZW50XTtcblxuXHRcdGlmIChpbnN0cnVtZW50Q2FjaGVbbmFtZV0gPT09ICdlcnJvcicpIHtcblx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgc291bmQgZm9udFwiICsgJyAnICsgdXJsICsgJyAnICsgaW5zdHJ1bWVudCArICcgJyArIG5hbWUpKTtcblx0XHR9XG5cdFx0aWYgKGluc3RydW1lbnRDYWNoZVtuYW1lXSkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUoe2luc3RydW1lbnQ6IGluc3RydW1lbnQsIG5hbWU6IG5hbWV9KTtcblx0XHR9XG5cblx0XHQvLyBpZiAodGhpcy5kZWJ1Z0NhbGxiYWNrKVxuXHRcdC8vIFx0dGhpcy5kZWJ1Z0NhbGxiYWNrKGBMb2FkaW5nIHNvdW5kOiAke2luc3RydW1lbnR9ICR7bmFtZX1gKTtcblx0XHRpbnN0cnVtZW50Q2FjaGVbbmFtZV0gPSBcInBlbmRpbmdcIjsgLy8gVGhpcyBjYW4gYmUgY2FsbGVkIGluIHBhcmFsbGVsLCBzbyBkb24ndCBjYWxsIGl0IGEgc2Vjb25kIHRpbWUgYmVmb3JlIHRoZSBmaXJzdCBvbmUgaGFzIGxvYWRlZC5cblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oJ0dFVCcsIHVybCtpbnN0cnVtZW50KyctbXAzLycrbmFtZSsnLm1wMycsIHRydWUpO1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGZ1bmN0aW9uIG9uU3VjY2VzcyhhdWRpb0J1ZmZlcikge1xuXHRcdFx0aW5zdHJ1bWVudENhY2hlW25hbWVdID0gYXVkaW9CdWZmZXI7XG5cdFx0XHQvLyBpZiAoc2VsZi5kZWJ1Z0NhbGxiYWNrKVxuXHRcdFx0Ly8gXHRzZWxmLmRlYnVnQ2FsbGJhY2soYFNvdW5kIGxvYWRlZDogJHtpbnN0cnVtZW50fSAke25hbWV9ICR7dXJsfWApO1xuXHRcdFx0cmVzb2x2ZSh7aW5zdHJ1bWVudDogaW5zdHJ1bWVudCwgbmFtZTogbmFtZX0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uRmFpbHVyZShlcnJvcikge1xuXHRcdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdFx0c2VsZi5kZWJ1Z0NhbGxiYWNrKGVycm9yKTtcblx0XHRcdGNvbnNvbGUubG9nKGVycm9yKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0fVxuXG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHRoaXMucmVzcG9uc2UsIG9uU3VjY2Vzcywgb25GYWlsdXJlKTsvLy50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBcdHJldHVybiByZXNvbHZlKHtpbnN0cnVtZW50OiBpbnN0cnVtZW50LCBuYW1lOiBuYW1lfSk7XG5cdFx0XHRcdC8vIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdC8vIFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoY2FudExvYWRNcDMgKyBlcnJvcikpO1xuXHRcdFx0XHQvLyB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc3RydW1lbnRDYWNoZVtuYW1lXSA9IFwiZXJyb3JcIjsgLy8gVG8ga2VlcCB0aGlzIGZyb20gdHJ5aW5nIHRvIGxvYWQgcmVwZWF0ZWRseS5cblx0XHRcdFx0dmFyIGNhbnRMb2FkTXAzID0gXCJPbmxvYWQgZXJyb3IgbG9hZGluZyBzb3VuZDogXCIgKyAgbmFtZSArIFwiIFwiICsgdXJsICsgXCIgXCIgKyBlLmN1cnJlbnRUYXJnZXQuc3RhdHVzICsgXCIgXCIgKyBlLmN1cnJlbnRUYXJnZXQuc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKHNlbGYuZGVidWdDYWxsYmFjaylcblx0XHRcdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soY2FudExvYWRNcDMpO1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihjYW50TG9hZE1wMykpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0eGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpbnN0cnVtZW50Q2FjaGVbbmFtZV0gPSBcImVycm9yXCI7IC8vIFRvIGtlZXAgdGhpcyBmcm9tIHRyeWluZyB0byBsb2FkIHJlcGVhdGVkbHkuXG5cdFx0XHR2YXIgY2FudExvYWRNcDMgPSBcIkVycm9yIGluIGxvYWRpbmcgc291bmQ6IFwiICsgXCIgXCIgKyB1cmw7XG5cdFx0XHRpZiAoc2VsZi5kZWJ1Z0NhbGxiYWNrKVxuXHRcdFx0XHRzZWxmLmRlYnVnQ2FsbGJhY2soY2FudExvYWRNcDMpO1xuXHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoY2FudExvYWRNcDMpKTtcblx0XHR9LCBmYWxzZSk7XG5cdFx0eGhyLnNlbmQoKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vdGU7XG4iLCJ2YXIgcGl0Y2hUb05vdGVOYW1lID0ge1xuXHQyMTogJ0EwJyxcblx0MjI6ICdCYjAnLFxuXHQyMzogJ0IwJyxcblx0MjQ6ICdDMScsXG5cdDI1OiAnRGIxJyxcblx0MjY6ICdEMScsXG5cdDI3OiAnRWIxJyxcblx0Mjg6ICdFMScsXG5cdDI5OiAnRjEnLFxuXHQzMDogJ0diMScsXG5cdDMxOiAnRzEnLFxuXHQzMjogJ0FiMScsXG5cdDMzOiAnQTEnLFxuXHQzNDogJ0JiMScsXG5cdDM1OiAnQjEnLFxuXHQzNjogJ0MyJyxcblx0Mzc6ICdEYjInLFxuXHQzODogJ0QyJyxcblx0Mzk6ICdFYjInLFxuXHQ0MDogJ0UyJyxcblx0NDE6ICdGMicsXG5cdDQyOiAnR2IyJyxcblx0NDM6ICdHMicsXG5cdDQ0OiAnQWIyJyxcblx0NDU6ICdBMicsXG5cdDQ2OiAnQmIyJyxcblx0NDc6ICdCMicsXG5cdDQ4OiAnQzMnLFxuXHQ0OTogJ0RiMycsXG5cdDUwOiAnRDMnLFxuXHQ1MTogJ0ViMycsXG5cdDUyOiAnRTMnLFxuXHQ1MzogJ0YzJyxcblx0NTQ6ICdHYjMnLFxuXHQ1NTogJ0czJyxcblx0NTY6ICdBYjMnLFxuXHQ1NzogJ0EzJyxcblx0NTg6ICdCYjMnLFxuXHQ1OTogJ0IzJyxcblx0NjA6ICdDNCcsXG5cdDYxOiAnRGI0Jyxcblx0NjI6ICdENCcsXG5cdDYzOiAnRWI0Jyxcblx0NjQ6ICdFNCcsXG5cdDY1OiAnRjQnLFxuXHQ2NjogJ0diNCcsXG5cdDY3OiAnRzQnLFxuXHQ2ODogJ0FiNCcsXG5cdDY5OiAnQTQnLFxuXHQ3MDogJ0JiNCcsXG5cdDcxOiAnQjQnLFxuXHQ3MjogJ0M1Jyxcblx0NzM6ICdEYjUnLFxuXHQ3NDogJ0Q1Jyxcblx0NzU6ICdFYjUnLFxuXHQ3NjogJ0U1Jyxcblx0Nzc6ICdGNScsXG5cdDc4OiAnR2I1Jyxcblx0Nzk6ICdHNScsXG5cdDgwOiAnQWI1Jyxcblx0ODE6ICdBNScsXG5cdDgyOiAnQmI1Jyxcblx0ODM6ICdCNScsXG5cdDg0OiAnQzYnLFxuXHQ4NTogJ0RiNicsXG5cdDg2OiAnRDYnLFxuXHQ4NzogJ0ViNicsXG5cdDg4OiAnRTYnLFxuXHQ4OTogJ0Y2Jyxcblx0OTA6ICdHYjYnLFxuXHQ5MTogJ0c2Jyxcblx0OTI6ICdBYjYnLFxuXHQ5MzogJ0E2Jyxcblx0OTQ6ICdCYjYnLFxuXHQ5NTogJ0I2Jyxcblx0OTY6ICdDNycsXG5cdDk3OiAnRGI3Jyxcblx0OTg6ICdENycsXG5cdDk5OiAnRWI3Jyxcblx0MTAwOiAnRTcnLFxuXHQxMDE6ICdGNycsXG5cdDEwMjogJ0diNycsXG5cdDEwMzogJ0c3Jyxcblx0MTA0OiAnQWI3Jyxcblx0MTA1OiAnQTcnLFxuXHQxMDY6ICdCYjcnLFxuXHQxMDc6ICdCNycsXG5cdDEwODogJ0M4Jyxcblx0MTA5OiAnRGI4Jyxcblx0MTEwOiAnRDgnLFxuXHQxMTE6ICdFYjgnLFxuXHQxMTI6ICdFOCcsXG5cdDExMzogJ0Y4Jyxcblx0MTE0OiAnR2I4Jyxcblx0MTE1OiAnRzgnLFxuXHQxMTY6ICdBYjgnLFxuXHQxMTc6ICdBOCcsXG5cdDExODogJ0JiOCcsXG5cdDExOTogJ0I4Jyxcblx0MTIwOiAnQzknLFxuXHQxMjE6ICdEYjknXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpdGNoVG9Ob3RlTmFtZTtcbiIsInZhciBTeW50aFNlcXVlbmNlID0gcmVxdWlyZSgnLi9zeW50aC1zZXF1ZW5jZScpO1xudmFyIENyZWF0ZVN5bnRoID0gcmVxdWlyZSgnLi9jcmVhdGUtc3ludGgnKTtcblxuZnVuY3Rpb24gcGxheUV2ZW50KG1pZGlQaXRjaGVzLCBtaWRpR3JhY2VQaXRjaGVzLCBtaWxsaXNlY29uZHNQZXJNZWFzdXJlKSB7XG5cdHZhciBzZXF1ZW5jZSA9IG5ldyBTeW50aFNlcXVlbmNlKCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtaWRpUGl0Y2hlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBub3RlID0gbWlkaVBpdGNoZXNbaV07XG5cdFx0dmFyIHRyYWNrTnVtID0gc2VxdWVuY2UuYWRkVHJhY2soKTtcblx0XHRzZXF1ZW5jZS5zZXRJbnN0cnVtZW50KHRyYWNrTnVtLCBub3RlLmluc3RydW1lbnQpO1xuXHRcdGlmIChpID09PSAwICYmIG1pZGlHcmFjZVBpdGNoZXMpIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbWlkaUdyYWNlUGl0Y2hlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgZ3JhY2UgPSBtaWRpR3JhY2VQaXRjaGVzW2pdO1xuXHRcdFx0XHRzZXF1ZW5jZS5hcHBlbmROb3RlKHRyYWNrTnVtLCBncmFjZS5waXRjaCwgMSAvIDY0LCBncmFjZS52b2x1bWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzZXF1ZW5jZS5hcHBlbmROb3RlKHRyYWNrTnVtLCBub3RlLnBpdGNoLCBub3RlLmR1cmF0aW9uSW5NZWFzdXJlcywgbm90ZS52b2x1bWUpO1xuXHR9XG5cblx0dmFyIGJ1ZmZlciA9IG5ldyBDcmVhdGVTeW50aCgpO1xuXHRyZXR1cm4gYnVmZmVyLmluaXQoe1xuXHRcdHNlcXVlbmNlOiBzZXF1ZW5jZSxcblx0XHRtaWxsaXNlY29uZHNQZXJNZWFzdXJlOiBtaWxsaXNlY29uZHNQZXJNZWFzdXJlXG5cdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBidWZmZXIucHJpbWUoKTtcblx0fSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGJ1ZmZlci5zdGFydCgpO1xuXHR9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcGxheUV2ZW50O1xuIiwiLy8gQ2FsbCB0aGlzIHdoZW4gaXQgaXMgc2FmZSBmb3IgdGhlIGFiY2pzIHRvIHByb2R1Y2Ugc291bmQuIFRoaXMgaXMgYWZ0ZXIgdGhlIGZpcnN0IHVzZXIgZ2VzdHVyZSBvbiB0aGUgcGFnZS5cbi8vIElmIHlvdSBjYWxsIGl0IHdpdGggbm8gcGFyYW1ldGVycywgdGhlbiBhbiBBdWRpb0NvbnRleHQgaXMgY3JlYXRlZCBhbmQgc3RvcmVkLlxuLy8gSWYgeW91IGNhbGwgaXQgd2l0aCBhIHBhcmFtZXRlciwgdGhhdCBpcyB1c2VkIGFzIGFuIGFscmVhZHkgY3JlYXRlZCBBdWRpb0NvbnRleHQuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQXVkaW9Db250ZXh0KGFjKSB7XG5cdGlmICghd2luZG93LmFiY2pzQXVkaW9Db250ZXh0KSB7XG5cdFx0aWYgKCFhYykge1xuXHRcdFx0YWMgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8XG5cdFx0XHRcdHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcblx0XHRcdFx0bmF2aWdhdG9yLm1vekF1ZGlvQ29udGV4dCB8fFxuXHRcdFx0XHRuYXZpZ2F0b3IubXNBdWRpb0NvbnRleHQ7XG5cdFx0XHRhYyA9IG5ldyBhYygpO1xuXHRcdH1cblx0XHR3aW5kb3cuYWJjanNBdWRpb0NvbnRleHQgPSBhYztcblx0fVxuXHRyZXR1cm4gd2luZG93LmFiY2pzQXVkaW9Db250ZXh0LnN0YXRlICE9PSBcInN1c3BlbmRlZFwiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyQXVkaW9Db250ZXh0O1xuIiwidmFyIHNvdW5kc0NhY2hlID0ge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3VuZHNDYWNoZTtcbiIsInZhciBhY3RpdmVBdWRpb0NvbnRleHQgPSByZXF1aXJlKCcuL2FjdGl2ZS1hdWRpby1jb250ZXh0Jyk7XG5cbi8vXG4vLyBTdXBwb3J0IGZvciBhdWRpbyBkZXBlbmRzIG9uIHRocmVlIHRoaW5nczogc3VwcG9ydCBmb3IgUHJvbWlzZSwgc3VwcG9ydCBmb3IgQXVkaW9Db250ZXh0LCBhbmQgc3VwcG9ydCBmb3IgQXVkaW9Db250ZXh0LnJlc3VtZS5cbi8vIFVuZm9ydHVuYXRlbHksIEF1ZGlvQ29udGV4dC5yZXN1bWUgY2Fubm90IGJlIGRldGVjdGVkIHVubGVzcyBhbiBBdWRpb0NvbnRleHQgaXMgY3JlYXRlZCwgYW5kIGNyZWF0aW5nIGFuIEF1ZGlvQ29udGV4dCBjYW4ndFxuLy8gYmUgZG9uZSB1bnRpbCBhIHVzZXIgY2xpY2ssIHNvIHRoZXJlIGlzIG5vIHdheSB0byBrbm93IGZvciBzdXJlIGlmIGF1ZGlvIGlzIHN1cHBvcnRlZCB1bnRpbCB0aGUgdXNlciB0cmllcy5cbi8vIFdlIGNhbiBnZXQgY2xvc2UsIHRob3VnaCAtIHdlIGNhbiB0ZXN0IGZvciBQcm9taXNlcyBhbmQgQXVkaW9Db250ZXh0IC0gdGhlcmUgYXJlIGp1c3QgYSBmZXcgZXZlcmdyZWVuIGJyb3dzZXJzIHRoYXQgc3VwcG9ydGVkXG4vLyB0aGF0IGJlZm9yZSBzdXBwb3J0aW5nIHJlc3VtZSwgc28gd2UnbGwgdGVzdCB3aGF0IHdlIGNhbi5cblxuLy8gVGhlIGJlc3QgdXNlIG9mIHRoaXMgcm91dGluZSBpcyB0byBjYWxsIGl0IGJlZm9yZSBkb2luZyBhbnkgYXVkaW8gcmVsYXRlZCBzdHVmZiB0byBkZWNpZGUgd2hldGhlciB0byBib3RoZXIuXG4vLyBCdXQgdGhlbiwgY2FsbCBpdCBhZ2FpbiBhZnRlciBhIHVzZXIgaW50ZXJhY3Rpb24gdG8gdGVzdCBmb3IgcmVzdW1lLlxuXG5mdW5jdGlvbiBzdXBwb3J0c0F1ZGlvKCkge1xuXHR2YXIgYWFjID0gYWN0aXZlQXVkaW9Db250ZXh0KCk7XG5cdGlmIChhYWMpXG5cdFx0cmV0dXJuIGFhYy5yZXN1bWUgIT09IHVuZGVmaW5lZDtcblxuXHRpZiAoIXdpbmRvdy5Qcm9taXNlKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gd2luZG93LkF1ZGlvQ29udGV4dCB8fFxuXHRcdHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcblx0XHRuYXZpZ2F0b3IubW96QXVkaW9Db250ZXh0IHx8XG5cdFx0bmF2aWdhdG9yLm1zQXVkaW9Db250ZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXVkaW87XG4iLCJ2YXIgQ3JlYXRlU3ludGhDb250cm9sID0gcmVxdWlyZSgnLi9jcmVhdGUtc3ludGgtY29udHJvbCcpO1xudmFyIENyZWF0ZVN5bnRoID0gcmVxdWlyZSgnLi9jcmVhdGUtc3ludGgnKTtcbnZhciBUaW1pbmdDYWxsYmFja3MgPSByZXF1aXJlKCcuLi9hcGkvYWJjX3RpbWluZ19jYWxsYmFja3MnKTtcblxuZnVuY3Rpb24gU3ludGhDb250cm9sbGVyKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHNlbGYud2FycCA9IDEwMDtcblx0c2VsZi5jdXJzb3JDb250cm9sID0gbnVsbDtcblx0c2VsZi52aXN1YWxPYmogPSBudWxsO1xuXHRzZWxmLnRpbWVyID0gbnVsbDtcblx0c2VsZi5taWRpQnVmZmVyID0gbnVsbDtcblx0c2VsZi5vcHRpb25zID0gbnVsbDtcblx0c2VsZi5jdXJyZW50VGVtcG8gPSBudWxsO1xuXHRzZWxmLmNvbnRyb2wgPSBudWxsO1xuXHRzZWxmLmlzTG9vcGluZyA9IGZhbHNlO1xuXHRzZWxmLmlzU3RhcnRlZCA9IGZhbHNlO1xuXHRzZWxmLmlzTG9hZGVkID0gZmFsc2U7XG5cblx0c2VsZi5sb2FkID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjdXJzb3JDb250cm9sLCB2aXN1YWxPcHRpb25zKSB7XG5cdFx0aWYgKCF2aXN1YWxPcHRpb25zKVxuXHRcdFx0dmlzdWFsT3B0aW9ucyA9IHt9O1xuXHRcdHNlbGYuY29udHJvbCA9IG5ldyBDcmVhdGVTeW50aENvbnRyb2woc2VsZWN0b3IsIHtcblx0XHRcdGxvb3BIYW5kbGVyOiB2aXN1YWxPcHRpb25zLmRpc3BsYXlMb29wID8gc2VsZi50b2dnbGVMb29wIDogdW5kZWZpbmVkLFxuXHRcdFx0cmVzdGFydEhhbmRsZXI6IHZpc3VhbE9wdGlvbnMuZGlzcGxheVJlc3RhcnQgPyBzZWxmLnJlc3RhcnQgOiB1bmRlZmluZWQsXG5cdFx0XHRwbGF5UHJvbWlzZUhhbmRsZXI6IHZpc3VhbE9wdGlvbnMuZGlzcGxheVBsYXkgPyBzZWxmLnBsYXkgOiB1bmRlZmluZWQsXG5cdFx0XHRwcm9ncmVzc0hhbmRsZXI6IHZpc3VhbE9wdGlvbnMuZGlzcGxheVByb2dyZXNzID8gc2VsZi5yYW5kb21BY2Nlc3MgOiB1bmRlZmluZWQsXG5cdFx0XHR3YXJwSGFuZGxlcjogdmlzdWFsT3B0aW9ucy5kaXNwbGF5V2FycCA/IHNlbGYub25XYXJwIDogdW5kZWZpbmVkLFxuXHRcdFx0YWZ0ZXJSZXN1bWU6IHNlbGYuaW5pdFxuXHRcdH0pO1xuXHRcdHNlbGYuY3Vyc29yQ29udHJvbCA9IGN1cnNvckNvbnRyb2w7XG5cdH07XG5cblx0c2VsZi5zZXRUdW5lID0gZnVuY3Rpb24odmlzdWFsT2JqLCB1c2VyQWN0aW9uLCBhdWRpb1BhcmFtcykge1xuXHRcdHNlbGYuaXNMb2FkZWQgPSBmYWxzZTtcblx0XHRzZWxmLnZpc3VhbE9iaiA9IHZpc3VhbE9iajtcblx0XHRzZWxmLm9wdGlvbnMgPSBhdWRpb1BhcmFtcztcblxuXHRcdGlmIChzZWxmLmNvbnRyb2wpIHtcblx0XHRcdHNlbGYucGF1c2UoKTtcblx0XHRcdHNlbGYuc2V0UHJvZ3Jlc3MoMCwgMSk7XG5cdFx0XHRzZWxmLmNvbnRyb2wucmVzZXRBbGwoKTtcblx0XHRcdHNlbGYucmVzdGFydCgpO1xuXHRcdFx0c2VsZi5pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0c2VsZi5pc0xvb3BpbmcgPSBmYWxzZTtcblxuXHRcdGlmICh1c2VyQWN0aW9uKVxuXHRcdFx0cmV0dXJuIHNlbGYuZ28oKTtcblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoe3N0YXR1czogXCJuby1hdWRpby1jb250ZXh0XCJ9KTtcblx0XHR9XG5cdH07XG5cblx0c2VsZi5nbyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWlsbGlzZWNvbmRzUGVyTWVhc3VyZSA9IHNlbGYudmlzdWFsT2JqLm1pbGxpc2Vjb25kc1Blck1lYXN1cmUoKSAqIDEwMCAvIHNlbGYud2FycDtcblx0XHRzZWxmLmN1cnJlbnRUZW1wbyA9IE1hdGgucm91bmQoc2VsZi52aXN1YWxPYmouZ2V0QmVhdHNQZXJNZWFzdXJlKCkgLyBtaWxsaXNlY29uZHNQZXJNZWFzdXJlICogNjAwMDApO1xuXHRcdGlmIChzZWxmLmNvbnRyb2wpXG5cdFx0XHRzZWxmLmNvbnRyb2wuc2V0VGVtcG8oc2VsZi5jdXJyZW50VGVtcG8pO1xuXHRcdHNlbGYucGVyY2VudCA9IDA7XG5cblx0XHRpZiAoIXNlbGYubWlkaUJ1ZmZlcilcblx0XHRcdHNlbGYubWlkaUJ1ZmZlciA9IG5ldyBDcmVhdGVTeW50aCgpO1xuXHRcdHJldHVybiBzZWxmLm1pZGlCdWZmZXIuaW5pdCh7XG5cdFx0XHR2aXN1YWxPYmo6IHNlbGYudmlzdWFsT2JqLFxuXHRcdFx0b3B0aW9uczogc2VsZi5vcHRpb25zLFxuXHRcdFx0bWlsbGlzZWNvbmRzUGVyTWVhc3VyZTogbWlsbGlzZWNvbmRzUGVyTWVhc3VyZVxuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNlbGYubWlkaUJ1ZmZlci5wcmltZSgpO1xuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN1YmRpdmlzaW9ucyA9IDE2O1xuXHRcdFx0aWYgKHNlbGYuY3Vyc29yQ29udHJvbCAmJlxuXHRcdFx0XHRzZWxmLmN1cnNvckNvbnRyb2wuYmVhdFN1YmRpdmlzaW9ucyAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdHBhcnNlSW50KHNlbGYuY3Vyc29yQ29udHJvbC5iZWF0U3ViZGl2aXNpb25zLCAxMCkgPj0gMSAmJlxuXHRcdFx0XHRwYXJzZUludChzZWxmLmN1cnNvckNvbnRyb2wuYmVhdFN1YmRpdmlzaW9ucywgMTApIDw9IDY0KVxuXHRcdFx0XHRzdWJkaXZpc2lvbnMgPSBwYXJzZUludChzZWxmLmN1cnNvckNvbnRyb2wuYmVhdFN1YmRpdmlzaW9ucywgMTApO1xuXG5cdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgVGltaW5nQ2FsbGJhY2tzIGFmdGVyIHByaW1pbmcgdGhlIG1pZGkgc28gdGhhdCB0aGUgbWlkaSBkYXRhIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGNhbGxiYWNrcy5cblx0XHRcdHNlbGYudGltZXIgPSBuZXcgVGltaW5nQ2FsbGJhY2tzKHNlbGYudmlzdWFsT2JqLCB7XG5cdFx0XHRcdGJlYXRDYWxsYmFjazogc2VsZi5iZWF0Q2FsbGJhY2ssXG5cdFx0XHRcdGV2ZW50Q2FsbGJhY2s6IHNlbGYuZXZlbnRDYWxsYmFjayxcblx0XHRcdFx0bGluZUVuZENhbGxiYWNrOiBzZWxmLmxpbmVFbmRDYWxsYmFjayxcblx0XHRcdFx0cXBtOiBzZWxmLmN1cnJlbnRUZW1wbyxcblxuXHRcdFx0XHRleHRyYU1lYXN1cmVzQXRCZWdpbm5pbmc6IHNlbGYuY3Vyc29yQ29udHJvbCA/IHNlbGYuY3Vyc29yQ29udHJvbC5leHRyYU1lYXN1cmVzQXRCZWdpbm5pbmcgOiB1bmRlZmluZWQsXG5cdFx0XHRcdGxpbmVFbmRBbnRpY2lwYXRpb246IHNlbGYuY3Vyc29yQ29udHJvbCA/IHNlbGYuY3Vyc29yQ29udHJvbC5saW5lRW5kQW50aWNpcGF0aW9uIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRiZWF0U3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMsXG5cdFx0XHR9KTtcblx0XHRcdGlmIChzZWxmLmN1cnNvckNvbnRyb2wgJiYgc2VsZi5jdXJzb3JDb250cm9sLm9uUmVhZHkgJiYgdHlwZW9mIHNlbGYuY3Vyc29yQ29udHJvbC5vblJlYWR5ICA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0c2VsZi5jdXJzb3JDb250cm9sLm9uUmVhZHkoc2VsZik7XG5cdFx0XHRzZWxmLmlzTG9hZGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBzdGF0dXM6IFwiY3JlYXRlZFwiIH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHNlbGYuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoc2VsZi50aW1lcikge1xuXHRcdFx0c2VsZi50aW1lci5yZXNldCgpO1xuXHRcdFx0c2VsZi50aW1lci5zdG9wKCk7XG5cdFx0XHRzZWxmLnRpbWVyID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHNlbGYubWlkaUJ1ZmZlcikge1xuXHRcdFx0c2VsZi5taWRpQnVmZmVyLnN0b3AoKTtcblx0XHRcdHNlbGYubWlkaUJ1ZmZlciA9IG51bGw7XG5cdFx0fVxuXHRcdHNlbGYuc2V0UHJvZ3Jlc3MoMCwgMSk7XG5cdFx0aWYgKHNlbGYuY29udHJvbClcblx0XHRcdHNlbGYuY29udHJvbC5yZXNldEFsbCgpO1xuXHR9O1xuXG5cdHNlbGYucGxheSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXNlbGYuaXNMb2FkZWQpIHtcblx0XHRcdHJldHVybiBzZWxmLmdvKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYuX3BsYXkoKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZVxuXHRcdFx0cmV0dXJuIHNlbGYuX3BsYXkoKTtcblx0fTtcblxuXHRzZWxmLl9wbGF5ID0gZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuaXNTdGFydGVkID0gIXNlbGYuaXNTdGFydGVkO1xuXHRcdGlmIChzZWxmLmlzU3RhcnRlZCkge1xuXHRcdFx0aWYgKHNlbGYuY3Vyc29yQ29udHJvbCAmJiBzZWxmLmN1cnNvckNvbnRyb2wub25TdGFydCAmJiB0eXBlb2Ygc2VsZi5jdXJzb3JDb250cm9sLm9uU3RhcnQgID09PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHRzZWxmLmN1cnNvckNvbnRyb2wub25TdGFydCgpO1xuXHRcdFx0c2VsZi5taWRpQnVmZmVyLnN0YXJ0KCk7XG5cdFx0XHRzZWxmLnRpbWVyLnN0YXJ0KCk7XG5cdFx0XHRpZiAoc2VsZi5jb250cm9sKVxuXHRcdFx0XHRzZWxmLmNvbnRyb2wucHVzaFBsYXkodHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYucGF1c2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHN0YXR1czogXCJva1wiIH0pO1xuXHR9O1xuXG5cdHNlbGYucGF1c2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoc2VsZi50aW1lcikge1xuXHRcdFx0c2VsZi50aW1lci5wYXVzZSgpO1xuXHRcdFx0c2VsZi5taWRpQnVmZmVyLnBhdXNlKCk7XG5cdFx0XHRpZiAoc2VsZi5jb250cm9sKVxuXHRcdFx0XHRzZWxmLmNvbnRyb2wucHVzaFBsYXkoZmFsc2UpO1xuXHRcdH1cblx0fTtcblxuXHRzZWxmLnRvZ2dsZUxvb3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5pc0xvb3BpbmcgPSAhc2VsZi5pc0xvb3Bpbmc7XG5cdFx0aWYgKHNlbGYuY29udHJvbClcblx0XHRcdHNlbGYuY29udHJvbC5wdXNoTG9vcChzZWxmLmlzTG9vcGluZyk7XG5cdH07XG5cblx0c2VsZi5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChzZWxmLnRpbWVyKSB7XG5cdFx0XHRzZWxmLnRpbWVyLnNldFByb2dyZXNzKDApO1xuXHRcdFx0c2VsZi5taWRpQnVmZmVyLnNlZWsoMCk7XG5cdFx0fVxuXHR9O1xuXG5cdHNlbGYucmFuZG9tQWNjZXNzID0gZnVuY3Rpb24gKGV2KSB7XG5cdFx0aWYgKCFzZWxmLmlzTG9hZGVkKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5nbygpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLl9yYW5kb21BY2Nlc3MoZXYpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlXG5cdFx0XHRyZXR1cm4gc2VsZi5fcmFuZG9tQWNjZXNzKGV2KTtcblx0fTtcblxuXHRzZWxmLl9yYW5kb21BY2Nlc3MgPSBmdW5jdGlvbiAoZXYpIHtcblx0XHR2YXIgYmFja2dyb3VuZCA9IChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhYmNqcy1taWRpLXByb2dyZXNzLWluZGljYXRvcicpKSA/IGV2LnRhcmdldC5wYXJlbnROb2RlIDogZXYudGFyZ2V0O1xuXHRcdHZhciBwZXJjZW50ID0gKGV2LnggLSBiYWNrZ3JvdW5kLm9mZnNldExlZnQpIC8gYmFja2dyb3VuZC5vZmZzZXRXaWR0aDtcblx0XHRpZiAocGVyY2VudCA8IDApXG5cdFx0XHRwZXJjZW50ID0gMDtcblx0XHRpZiAocGVyY2VudCA+IDEwMClcblx0XHRcdHBlcmNlbnQgPSAxMDA7XG5cdFx0c2VsZi50aW1lci5zZXRQcm9ncmVzcyhwZXJjZW50KTtcblx0XHRzZWxmLm1pZGlCdWZmZXIuc2VlayhwZXJjZW50KTtcblx0fTtcblxuXHRzZWxmLm9uV2FycCA9IGZ1bmN0aW9uIChldikge1xuXHRcdHZhciBuZXdXYXJwID0gZXYudGFyZ2V0LnZhbHVlO1xuXHRcdGlmIChwYXJzZUludChuZXdXYXJwLCAxMCkgPiAwKSB7XG5cdFx0XHRzZWxmLndhcnAgPSBwYXJzZUludChuZXdXYXJwLCAxMCk7XG5cdFx0XHR2YXIgd2FzUGxheWluZyA9IHNlbGYuaXNTdGFydGVkO1xuXHRcdFx0dmFyIHN0YXJ0UGVyY2VudCA9IHNlbGYucGVyY2VudDtcblx0XHRcdHNlbGYuZGVzdHJveSgpO1xuXHRcdFx0c2VsZi5pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0XHRcdHNlbGYuZ28oKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5zZXRQcm9ncmVzcyhzdGFydFBlcmNlbnQsIHNlbGYubWlkaUJ1ZmZlci5kdXJhdGlvbiAqIDEwMDApO1xuXHRcdFx0XHRpZiAod2FzUGxheWluZykge1xuXHRcdFx0XHRcdHNlbGYucGxheSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYudGltZXIuc2V0UHJvZ3Jlc3Moc3RhcnRQZXJjZW50KTtcblx0XHRcdFx0c2VsZi5taWRpQnVmZmVyLnNlZWsoc3RhcnRQZXJjZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRzZWxmLnNldFByb2dyZXNzID0gZnVuY3Rpb24gKHBlcmNlbnQsIHRvdGFsVGltZSkge1xuXHRcdHNlbGYucGVyY2VudCA9IHBlcmNlbnQ7XG5cdFx0aWYgKHNlbGYuY29udHJvbClcblx0XHRcdHNlbGYuY29udHJvbC5zZXRQcm9ncmVzcyhwZXJjZW50LCB0b3RhbFRpbWUpO1xuXHR9O1xuXG5cdHNlbGYuZmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi50aW1lci5yZXNldCgpO1xuXHRcdGlmIChzZWxmLmlzTG9vcGluZykge1xuXHRcdFx0c2VsZi50aW1lci5zdGFydCgpO1xuXHRcdFx0c2VsZi5taWRpQnVmZmVyLnN0YXJ0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYudGltZXIuc3RvcCgpO1xuXHRcdFx0aWYgKHNlbGYuaXNTdGFydGVkKSB7XG5cdFx0XHRcdGlmIChzZWxmLmNvbnRyb2wpXG5cdFx0XHRcdFx0c2VsZi5jb250cm9sLnB1c2hQbGF5KGZhbHNlKTtcblx0XHRcdFx0c2VsZi5pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHNlbGYuY3Vyc29yQ29udHJvbCAmJiBzZWxmLmN1cnNvckNvbnRyb2wub25GaW5pc2hlZCAmJiB0eXBlb2Ygc2VsZi5jdXJzb3JDb250cm9sLm9uRmluaXNoZWQgID09PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHRcdHNlbGYuY3Vyc29yQ29udHJvbC5vbkZpbmlzaGVkKCk7XG5cdFx0XHRcdHNlbGYuc2V0UHJvZ3Jlc3MoMCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHNlbGYuYmVhdENhbGxiYWNrID0gZnVuY3Rpb24gKGJlYXROdW1iZXIsIHRvdGFsQmVhdHMsIHRvdGFsVGltZSkge1xuXHRcdHZhciBwZXJjZW50ID0gYmVhdE51bWJlciAvIHRvdGFsQmVhdHM7XG5cdFx0c2VsZi5zZXRQcm9ncmVzcyhwZXJjZW50LCB0b3RhbFRpbWUpO1xuXHRcdGlmIChzZWxmLmN1cnNvckNvbnRyb2wgJiYgc2VsZi5jdXJzb3JDb250cm9sLm9uQmVhdCAmJiB0eXBlb2Ygc2VsZi5jdXJzb3JDb250cm9sLm9uQmVhdCAgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRzZWxmLmN1cnNvckNvbnRyb2wub25CZWF0KGJlYXROdW1iZXIsIHRvdGFsQmVhdHMsIHRvdGFsVGltZSk7XG5cdH07XG5cblx0c2VsZi5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHRpZiAoc2VsZi5jdXJzb3JDb250cm9sICYmIHNlbGYuY3Vyc29yQ29udHJvbC5vbkV2ZW50ICYmIHR5cGVvZiBzZWxmLmN1cnNvckNvbnRyb2wub25FdmVudCAgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdHNlbGYuY3Vyc29yQ29udHJvbC5vbkV2ZW50KGV2ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VsZi5maW5pc2hlZCgpO1xuXHRcdH1cblx0fTtcblxuXHRzZWxmLmxpbmVFbmRDYWxsYmFjayA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0aWYgKHNlbGYuY3Vyc29yQ29udHJvbCAmJiBzZWxmLmN1cnNvckNvbnRyb2wub25MaW5lRW5kICYmIHR5cGVvZiBzZWxmLmN1cnNvckNvbnRyb2wub25MaW5lRW5kICA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdHNlbGYuY3Vyc29yQ29udHJvbC5vbkxpbmVFbmQoZGF0YSk7XG5cdH07XG5cblx0c2VsZi5nZXRVcmwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHNlbGYubWlkaUJ1ZmZlci5kb3dubG9hZCgpO1xuXHR9O1xuXG5cdHNlbGYuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuXHRcdHZhciB1cmwgPSBzZWxmLmdldFVybCgpO1xuXHRcdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwiZGlzcGxheTogbm9uZTtcIik7XG5cdFx0bGluay5ocmVmID0gdXJsO1xuXHRcdGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZSA/IGZpbGVOYW1lIDogJ291dHB1dC53YXYnO1xuXHRcdGxpbmsuY2xpY2soKTtcblx0XHR3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhDb250cm9sbGVyO1xuIiwidmFyIFN5bnRoU2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRzZWxmLnRyYWNrcyA9IFtdO1xuXHRzZWxmLnRvdGFsRHVyYXRpb24gPSAwO1xuXG5cdHNlbGYuYWRkVHJhY2sgPSBmdW5jdGlvbigpIHtcblx0XHRzZWxmLnRyYWNrcy5wdXNoKFtdKTtcblx0XHRyZXR1cm4gc2VsZi50cmFja3MubGVuZ3RoIC0gMTtcblx0fTtcblxuXHRzZWxmLnNldEluc3RydW1lbnQgPSBmdW5jdGlvbih0cmFja051bWJlciwgaW5zdHJ1bWVudE51bWJlcikge1xuXHRcdHNlbGYudHJhY2tzW3RyYWNrTnVtYmVyXS5wdXNoKHtcblx0XHRcdGNoYW5uZWw6IDAsXG5cdFx0XHRjbWQ6IFwicHJvZ3JhbVwiLFxuXHRcdFx0aW5zdHJ1bWVudDogaW5zdHJ1bWVudE51bWJlclxuXHRcdH0pO1xuXHR9O1xuXG5cdHNlbGYuYXBwZW5kTm90ZSA9IGZ1bmN0aW9uKHRyYWNrTnVtYmVyLCBwaXRjaCwgZHVyYXRpb25Jbk1lYXN1cmVzLCB2b2x1bWUpIHtcblx0XHRzZWxmLnRyYWNrc1t0cmFja051bWJlcl0ucHVzaCh7XG5cdFx0XHRjbWQ6IFwic3RhcnRcIixcblx0XHRcdHBpdGNoOiBwaXRjaCAtIDYwLFxuXHRcdFx0dm9sdW1lOiB2b2x1bWVcblx0XHR9KTtcblx0XHRzZWxmLnRyYWNrc1t0cmFja051bWJlcl0ucHVzaCh7XG5cdFx0XHRjbWQ6IFwibW92ZVwiLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uSW5NZWFzdXJlc1xuXHRcdH0pO1xuXHRcdHNlbGYudHJhY2tzW3RyYWNrTnVtYmVyXS5wdXNoKHtcblx0XHRcdGNtZDogXCJzdG9wXCIsXG5cdFx0XHRwaXRjaDogcGl0Y2ggLSA2MFxuXHRcdH0pO1xuXHRcdHZhciBkdXJhdGlvbiA9IDA7XG5cdFx0c2VsZi50cmFja3NbdHJhY2tOdW1iZXJdLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChldmVudC5kdXJhdGlvbilcblx0XHRcdFx0ZHVyYXRpb24gKz0gZXZlbnQuZHVyYXRpb247XG5cdFx0fSk7XG5cdFx0c2VsZi50b3RhbER1cmF0aW9uID0gTWF0aC5tYXgoc2VsZi50b3RhbER1cmF0aW9uLCBkdXJhdGlvbik7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoU2VxdWVuY2U7XG4iLCIvLyAgICBhYmMyYWJjX3dyaXRlLmpzOiBQcmludHMgYW4gYWJjIGZpbGUgaW4gdGV4dCBmb3JtYXQgcGFyc2VkIGJ5IGFiY19wYXJzZS5qc1xuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKVxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgVGV4dFByaW50ZXIgPSBmdW5jdGlvbihlbGVtLCByZXBvc2l0aW9uKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgIHRoaXMubCA9IDEvODtcbiAgICB0aGlzLnJlcG9zaXRpb24gPSByZXBvc2l0aW9uIHx8IGZhbHNlO1xufVxuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUucHJpbnRTdHJpbmcgPSBmdW5jdGlvbihzdHIsIGVsZW0pIHtcbiAgICBpZiAodGhpcy5yZXBvc2l0aW9uICYmIGVsZW0pIGVsZW0uc3RhcnRDaGFyID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB0aGlzLnRleHQgKz0gc3RyO1xuICAgIGlmICh0aGlzLnJlcG9zaXRpb24gJiYgZWxlbSkgZWxlbS5lbmRDaGFyID0gdGhpcy50ZXh0Lmxlbmd0aDtcbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5wcmludE5ld0xpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50ZXh0ICs9IFwiXFxuXCI7XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUucHJpbnRTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZXh0W3RoaXMudGV4dC5sZW5ndGgtMV0ubWF0Y2goL1xccy8pKSByZXR1cm47IC8vVE9ETyBtYXRjaCB3aGl0ZXNwYWNlXG4gICAgdGhpcy50ZXh0ICs9IFwiIFwiO1xufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLnByaW50QUJDID0gZnVuY3Rpb24oYWJjdHVuZSkge1xuICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgdGhpcy5hYmN0dW5lID0gYWJjdHVuZTtcbiAgICAvL1RPRE8gZm9ybWF0dGluZ1xuICAgIHRoaXMucHJpbnRIZWFkZXIoKTtcbiAgICB0aGlzLnByaW50Qm9keSgpO1xuICAgIHRoaXMuZWxlbS52YWx1ZT10aGlzLnRleHQ7XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUucHJpbnRIZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBtdWNoIG9mIHRoaXMgaW5mbyBpcyBkdXBsaWNhdGVkIGluIG1ldGFUZXh0SEVhZGVycyBpbiBhYmNfcGFyc2VfaGVhZGVyLmpzXG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJ4XCIsXCJYXCIsXCIxXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwidGl0bGVcIixcIlRcIik7XG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJjb21wb3NlclwiLFwiQ1wiKTtcbiAgICB0aGlzLnByaW50SGVhZGVyTGluZShcImhpc3RvcnlcIixcIkhcIik7XG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJhdXRob3JcIixcIkFcIik7XG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJib29rXCIsXCJCXCIpOyAgXG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJkaXNjb2dyYXBoeVwiLFwiRFwiKTsgIFxuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwidXJsXCIsXCJGXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwiZ3JvdXBcIixcIkdcIik7XG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJpbnN0cnVjdGlvblwiLFwiSVwiKTtcbiAgICB0aGlzLnByaW50SGVhZGVyTGluZShcIm5vdGVzXCIsXCJOXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwib3JpZ2luXCIsXCJPXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwicmh5dGhtXCIsXCJSXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwic291cmNlXCIsXCJTXCIpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwidW5hbGlnbmVkd29yZHNcIixcIldcIik7XG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJ0cmFuc2NyaXB0aW9uXCIsXCJaXCIpO1xuICAgIC8vVE9ETyBwYXJ0IG9yZGVyXG4gICAgLy9UT0RPIFEgdGVtcG9cbiAgICAvL1RPRE8gdGV4dEJsb2NrXG4gICAgdGhpcy5wcmludEhlYWRlckxpbmUoXCJOVUxMXCIsXCJMXCIsXCIxLzhcIik7IC8vVE9ETyBMXG5cbiAgICB0aGlzLnByaW50SGVhZGVyTGluZShcIk5VTExcIixcIk1cIix0aGlzLmdldE1ldGVyU3RyaW5nKHRoaXMuYWJjdHVuZS5saW5lc1swXS5zdGFmZlswXS5tZXRlcikpO1xuICAgIHRoaXMucHJpbnRIZWFkZXJMaW5lKFwiTlVMTFwiLFwiS1wiLHRoaXMuZ2V0S2V5U3RyaW5nKHRoaXMuYWJjdHVuZS5saW5lc1swXS5zdGFmZlswXS5rZXkpKTsvL1RPRE8gS1xufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLmdldEtleVN0cmluZyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBrZXkucm9vdCtrZXkuYWNjK2tleS5tb2RlO1xufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLmdldE1ldGVyU3RyaW5nID0gZnVuY3Rpb24obWV0ZXIpIHtcbiAgICBzd2l0Y2ggKG1ldGVyLnR5cGUpIHtcbiAgICBjYXNlIFwiY3V0X3RpbWVcIjogcmV0dXJuIFwiQ3xcIjtcbiAgICBjYXNlIFwiY29tbW9uX3RpbWVcIjogcmV0dXJuIFwiQ1wiO1xuICAgIGNhc2UgXCJzcGVjaWZpZWRcIjpcbiAgICAgIGlmIChtZXRlci52YWx1ZVswXS5kZW4pXG5cdFx0cmV0dXJuIG1ldGVyLnZhbHVlWzBdLm51bStcIi9cIittZXRlci52YWx1ZVswXS5kZW47XG4gICAgICBlbHNlXG5cdCAgICByZXR1cm4gbWV0ZXIudmFsdWVbMF0ubnVtO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5wcmludEhlYWRlckxpbmUgPSBmdW5jdGlvbihmaWVsZG5hbWUsIGFiY2ZpZWxkLCBkZWZhdXQpIHtcbiAgICB2YXIgdmFsID0gdGhpcy5hYmN0dW5lLm1ldGFUZXh0W2ZpZWxkbmFtZV0gfHwgZGVmYXV0O1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHR2YXIgdmFsYXJyYXkgPSB2YWwuc3BsaXQoXCJcXG5cIik7XG5cdGZvciAodmFyIGk9MDsgaTx2YWxhcnJheS5sZW5ndGg7IGkrKykge1xuXHQgICAgdGhpcy5wcmludFN0cmluZyhhYmNmaWVsZCtcIjogXCIrdmFsYXJyYXlbaV0pO1xuXHQgICAgdGhpcy5wcmludE5ld0xpbmUoKTtcblx0fSBcbiAgICB9XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUuZ2V0RWxlbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFiY2xpbmUubGVuZ3RoIDw9IHRoaXMucG9zKVxuXHRyZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5hYmNsaW5lW3RoaXMucG9zXTtcbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5nZXROZXh0RWxlbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFiY2xpbmUubGVuZ3RoIDw9IHRoaXMucG9zKzEpXG5cdHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmFiY2xpbmVbdGhpcy5wb3MrMV07XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUucHJpbnRCb2R5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciBsaW5lPTA7IGxpbmU8dGhpcy5hYmN0dW5lLmxpbmVzLmxlbmd0aDsgbGluZSsrKSB7XG5cdHZhciBhYmNsaW5lID0gdGhpcy5hYmN0dW5lLmxpbmVzW2xpbmVdO1xuXHRpZiAoYWJjbGluZS5zdGFmZikge1xuXHQgICAgdGhpcy5wcmludEFCQ0xpbmUoYWJjbGluZS5zdGFmZik7XG5cdH0gZWxzZSBpZiAoYWJjbGluZS5zdWJ0aXRsZSAmJiBsaW5lIT09MCkge1xuXHQgICAgLy9UT0RPXG5cdH0gZWxzZSBpZiAoYWJjbGluZS50ZXh0KSB7XG5cdCAgICAvL1RPRE9cblx0fVxuICAgIH1cbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5wcmludEFCQ0xpbmUgPSBmdW5jdGlvbihzdGFmZnMpIHtcbiAgICBmb3IgKHRoaXMucyA9IDA7IHRoaXMucyA8IHN0YWZmcy5sZW5ndGg7IHRoaXMucysrKSB7XG5cdHRoaXMucHJpbnRBQkNTdGFmZihzdGFmZnNbdGhpcy5zXSk7XG4gICAgfVxufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLnByaW50QUJDU3RhZmYgPSBmdW5jdGlvbihhYmNzdGFmZikge1xuICAgIFxuICAgIC8vIFRPRE8gaWYgKGFiY3N0YWZmLmJyYWNrZXQpIGhlYWRlciArPSBcImJyYWNrZXQgXCIrYWJjc3RhZmYuYnJhY2tldCtcIiBcIjtcbiAgICAvLyBUT0RPIGlmIChhYmNzdGFmZi5icmFjZSkgaGVhZGVyICs9IFwiYnJhY2UgXCIrYWJjc3RhZmYuYnJhY2UrXCIgXCI7XG4gICAgXG4gICAgXG4gICAgZm9yICh0aGlzLnYgPSAwOyB0aGlzLnYgPCBhYmNzdGFmZi52b2ljZXMubGVuZ3RoOyB0aGlzLnYrKykge1xuXHQvLyBUT0RPIHN0dWZmIGFib3V0IHZvaWNlc1xuXHRcblx0Ly8gVE9ETyB0aGlzIGlzIHdoZXJlIGtleSBzaWcgaXMgdGhpcy52b2ljZS5hZGRDaGlsZCh0aGlzLnByaW50Q2xlZihhYmNzdGFmZi5jbGVmKSk7XG5cdC8vIHRoaXMudm9pY2UuYWRkQ2hpbGQodGhpcy5wcmludEtleVNpZ25hdHVyZShhYmNzdGFmZi5rZXkpKTtcblx0Ly8gaWYgKGFiY3N0YWZmLm1ldGVyKSB0aGlzLnZvaWNlLmFkZENoaWxkKHRoaXMucHJpbnRUaW1lU2lnbmF0dXJlKGFiY3N0YWZmLm1ldGVyKSk7XG5cdHRoaXMucHJpbnRBQkNWb2ljZShhYmNzdGFmZi52b2ljZXNbdGhpcy52XSk7XG4gICAgfVxuICAgIFxufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLnByaW50QUJDVm9pY2UgPSBmdW5jdGlvbihhYmNsaW5lKSB7XG4gICAgdGhpcy5hYmNsaW5lID0gYWJjbGluZTtcbiAgICBmb3IgKHRoaXMucG9zPTA7IHRoaXMucG9zPHRoaXMuYWJjbGluZS5sZW5ndGg7IHRoaXMucG9zKyspIHtcblx0dGhpcy5wcmludEFCQ0VsZW1lbnQoKTtcbiAgICB9XG4gICAgdGhpcy5wcmludE5ld0xpbmUoKTtcbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5wcmludEFCQ0VsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlbSA9IHRoaXMuZ2V0RWxlbSgpO1xuICAgIHN3aXRjaCAoZWxlbS5lbF90eXBlKSB7XG4gICAgY2FzZSBcIm5vdGVcIjpcblx0dGhpcy5wcmludEJlYW0oKTtcblx0YnJlYWs7XG4gICAgY2FzZSBcImJhclwiOlxuXHR0aGlzLnByaW50QmFyTGluZShlbGVtKTtcblx0YnJlYWs7XG4gICAgY2FzZSBcIm1ldGVyXCI6XG5cdC8vVE9ETyB0aGlzLnByaW50VGltZVNpZ25hdHVyZShlbGVtKTtcblx0YnJlYWs7XG4gICAgY2FzZSBcImNsZWZcIjpcblx0Ly9UT0RPIHRoaXMucHJpbnRDbGVmKGVsZW0pO1xuXHRicmVhaztcbiAgICBjYXNlIFwia2V5XCI6XG5cdC8vVE9ETyB0aGlzLnByaW50S2V5U2lnbmF0dXJlKGVsZW0pO1xuICAgIGNhc2UgXCJzdGVtXCI6XG5cdC8vVE9ETyBkbyBub3RoaW5nP1xuXHRicmVhaztcbiAgICBjYXNlIFwicGFydFwiOlxuXHQvL1RPRE8gcHJpbnQgcGFydFxuXHRicmVhaztcbiAgICBkZWZhdWx0OlxuXHQvL1RPRE8gc2hvdyB3ZSdyZSBtaXNzaW5nIHNvbWV0aGluZ1xuICAgIH1cbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5wcmludEJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnByaW50U3BhY2UoKTtcbiAgICBpZiAodGhpcy5nZXRFbGVtKCkuc3RhcnRCZWFtICYmICF0aGlzLmdldEVsZW0oKS5lbmRCZWFtKSB7XG5cdHdoaWxlICh0aGlzLmdldEVsZW0oKSkge1xuXHQgICAgdGhpcy5wcmludE5vdGUodGhpcy5nZXRFbGVtKCkpO1xuXHQgICAgaWYgKHRoaXMuZ2V0RWxlbSgpLmVuZEJlYW0pIHtcblx0XHRicmVhaztcblx0ICAgIH1cblx0ICAgIHRoaXMucG9zKys7XG5cdH1cbiAgICB9IGVsc2Uge1xuXHR0aGlzLnByaW50Tm90ZSh0aGlzLmdldEVsZW0oKSk7XG4gICAgfVxuICAgIHRoaXMucHJpbnRTcGFjZSgpO1xufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLnByaW50Tm90ZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcblx0dmFyIGk7XG4gICAgaWYgKGVsZW0uY2hvcmQgIT09IHVuZGVmaW5lZCkge1xuXHRmb3IgKGk9MDsgaTxlbGVtLmNob3JkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzdHIrPSAnXCInK2VsZW0uY2hvcmRbaV0ubmFtZSsnXCInO1xuXHR9XG4gICAgfVxuICAgIFxuICAgIC8vVE9ETyB1bmlmeSBtYXAgYmV0d2VlbiBuYW1lcyBhbmQgc3ltYm9scyAodG8gYmUgdXNlZCB3aXRoIGFiY3BhcnNlPylcbiAgICB2YXIgZGVjb3JhdGlvbnMgPSB7XG5cdFwic3RhY2NhdG9cIiA6IFwiLlwiLFxuXHRcInVwYm93XCIgOiBcInVcIixcblx0XCJkb3duYm93XCIgOiBcInZcIixcblx0XCJyb2xsXCIgOiBcIn5cIixcblx0XCJmZXJtYXRhXCIgOiBcIkhcIixcblx0XCJzbGlkZVwiIDogXCJKXCIsXG5cdFwiYWNjZW50XCIgOiBcIkxcIixcblx0XCJtb3JkZW50XCIgOiBcIk1cIixcblx0XCJwcmFsbHRyaWxsZXJcIiA6IFwiUFwiLFxuXHRcInRyaWxsXCIgOiBcIlRcIixcblx0XCJsb3dlclwiIDogXCIuXCJcbiAgICB9O1xuXG4gICAgaWYgKGVsZW0uZGVjb3JhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdGZvciAoaT0wOyBpPGVsZW0uZGVjb3JhdGlvbi5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGRlYyA9IGVsZW0uZGVjb3JhdGlvbltpXTtcblx0ICAgIGlmIChkZWNvcmF0aW9uc1tkZWNdKSB7XG5cdFx0c3RyKz1kZWNvcmF0aW9uc1tkZWNdO1xuXHQgICAgfSBlbHNlIHtcblx0XHRzdHIrPVwiIVwiOyAvL1RPRE8gaGFyZGNvZGVkXG5cdFx0c3RyKz1kZWM7XG5cdFx0c3RyKz1cIiFcIjsgLy9UT0RPIGhhcmRjb2RlZFxuXHQgICAgfVxuXHR9XG4gICAgfVxuXG4gICAgaWYgKGVsZW0uZ3JhY2Vub3RlcyAhPT0gdW5kZWZpbmVkKSB7XG5cdHN0cis9XCJ7XCI7XG5cdGZvciAoaT0wOyBpPGVsZW0uZ3JhY2Vub3Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgc3RyKz10aGlzLmdldE5vdGVTdHJpbmcoZWxlbS5ncmFjZW5vdGVzW2ldKTtcblx0fVxuXHRzdHIrPVwifVwiO1xuICAgIH1cblxuICAgIHZhciBpZ25vcmVzbHVyID0gZmFsc2U7XG4gICAgaWYgKGVsZW0ucGl0Y2hlcy5sZW5ndGggPT09IDEgJiYgZWxlbS5waXRjaGVzWzBdLnN0YXJ0U2x1cikge1xuXHRpZ25vcmVzbHVyID0gdHJ1ZTtcblx0c3RyKz10aGlzLm11bHRpcGx5U3RyaW5nKFwiKFwiLGVsZW0ucGl0Y2hlc1swXS5zdGFydFNsdXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbS5zdGFydFNsdXIpIHtcblx0c3RyKz10aGlzLm11bHRpcGx5U3RyaW5nKFwiKFwiLGVsZW0uc3RhcnRTbHVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKChlbGVtLnBpdGNoZXMubGVuZ3RoID09PSAxICYmIGVsZW0ucGl0Y2hlc1swXS5lbmRTbHVyKSB8fCBlbGVtLmVuZFNsdXIpIHtcblx0aWdub3Jlc2x1ciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW0uc3RhcnRUcmlwbGV0KSB7XG5cdHN0cis9XCIoM1wiO1xuICAgIH1cblxuICAgIGlmIChlbGVtLnBpdGNoZXMpIHtcblx0aWYgKGVsZW0ucGl0Y2hlcy5sZW5ndGggPiAxKSBzdHIrPVwiW1wiO1xuXHRmb3IgKGk9MDsgaTxlbGVtLnBpdGNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVsZW0ucGl0Y2hlc1tpXS5kdXJhdGlvbiA9IGVsZW0uZHVyYXRpb247XG5cdCAgICBzdHIrPXRoaXMuZ2V0Tm90ZVN0cmluZyhlbGVtLnBpdGNoZXNbaV0sIGlnbm9yZXNsdXIpO1xuXHR9XG5cdGlmIChlbGVtLnBpdGNoZXMubGVuZ3RoID4gMSkgc3RyKz1cIl1cIjtcbiAgICB9IFxuXG4gICAgaWYgKGVsZW0ucGl0Y2hlcy5sZW5ndGggPT09IDEgJiYgZWxlbS5waXRjaGVzWzBdLmVuZFNsdXIpIHtcblx0c3RyKz10aGlzLm11bHRpcGx5U3RyaW5nKFwiKVwiLGVsZW0ucGl0Y2hlc1swXS5lbmRTbHVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW0uZW5kU2x1cikge1xuXHRzdHIrPXRoaXMubXVsdGlwbHlTdHJpbmcoXCIpXCIsZWxlbS5lbmRTbHVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmludFN0cmluZyhzdHIsZWxlbSk7XG5cbn07XG5cbi8vIGFjY2lkZW50YWxzLCB0aWVzIGFuZCBzb21ldGltZXMgc2x1cnMsIHNvbWV0aW1lcyBkdXJhdGlvblxuVGV4dFByaW50ZXIucHJvdG90eXBlLmdldE5vdGVTdHJpbmcgPSBmdW5jdGlvbihwaXRjaGVsZW0sIGlnbm9yZXNsdXIpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICBpZiAoIWlnbm9yZXNsdXIgJiYgcGl0Y2hlbGVtLnN0YXJ0U2x1cikge1xuXHRzdHIrPVwiKFwiO1xuICAgIH1cblxuICAgIHZhciBzeW1iID0gXCJcIjtcbiAgICBzd2l0Y2ggKHBpdGNoZWxlbS5hY2NpZGVudGFsKSB7XG4gICAgY2FzZSBcInF1YXJ0ZXJzaGFycFwiOlxuXHRzeW1iID0gXCJeL1wiO1xuXHRicmVhaztcbiAgICBjYXNlIFwiZGJsc2hhcnBcIjpcblx0c3ltYiA9IFwiXl5cIjtcblx0YnJlYWs7XG4gICAgY2FzZSBcInNoYXJwXCI6XG5cdHN5bWIgPSBcIl5cIjtcblx0YnJlYWs7XG4gICAgY2FzZSBcInF1YXJ0ZXJmbGF0XCI6XG5cdHN5bWIgPSBcIl8vXCI7XG5cdGJyZWFrO1xuICAgIGNhc2UgXCJmbGF0XCI6XG5cdHN5bWIgPSBcIl9cIjtcblx0YnJlYWs7XG4gICAgY2FzZSBcImRibGZsYXRcIjpcblx0c3ltYiA9IFwiX19cIjtcblx0YnJlYWs7XG4gICAgY2FzZSBcIm5hdHVyYWxcIjpcblx0c3ltYiA9IFwiPVwiO1xuICAgIH1cbiAgICBzdHIrPXN5bWI7XG5cbiAgICB2YXIgcGl0Y2hlcyA9IFtcIkNcIixcIkRcIixcIkVcIixcIkZcIixcIkdcIixcIkFcIixcIkJcIl07XG4gICAgdmFyIHBpdGNoc3RyID0gcGl0Y2hlc1t0aGlzLmV4dHJhY3ROb3RlKHBpdGNoZWxlbS5waXRjaCldO1xuICAgIHZhciBvY3RhdmUgPSB0aGlzLmV4dHJhY3RPY3RhdmUocGl0Y2hlbGVtLnBpdGNoKTtcbiAgICBpZiAob2N0YXZlPjApIHtcblx0cGl0Y2hzdHIgPSBwaXRjaHN0ci50b0xvd2VyQ2FzZSgpO1xuXHRvY3RhdmUtLTtcblx0d2hpbGUgKG9jdGF2ZT4wKSB7XG5cdCAgICBwaXRjaHN0cis9XCInXCI7XG5cdCAgICBvY3RhdmUtLTtcblx0fVxuICAgIH0gZWxzZSB7XG5cdHdoaWxlIChvY3RhdmU8MCkge1xuXHQgICAgcGl0Y2hzdHIrPVwiLFwiO1xuXHQgICAgb2N0YXZlKys7XG5cdH1cbiAgICB9XG4gICAgXG4gICAgc3RyKz1waXRjaHN0cjtcbiAgICBcbiAgICBpZiAocGl0Y2hlbGVtLmR1cmF0aW9uKSB7XG5cdHN0cis9dGhpcy5nZXREdXJhdGlvblN0cmluZyhwaXRjaGVsZW0uZHVyYXRpb24pO1xuICAgIH1cblxuICAgIGlmICghaWdub3Jlc2x1ciAmJiBwaXRjaGVsZW0uZW5kU2x1cikge1xuXHRzdHIrPVwiKVwiO1xuICAgIH1cblxuICAgIGlmIChwaXRjaGVsZW0uc3RhcnRUaWUpIHtcblx0c3RyKz1cIi1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuVGV4dFByaW50ZXIucHJvdG90eXBlLmdldER1cmF0aW9uU3RyaW5nID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICAvL1RPRE8gZGV0ZWN0IGNyb29rZWQgcmh5dGhtXG4gICAgaWYgKGR1cmF0aW9uL3RoaXMubCA+IDEpIHtcblx0cmV0dXJuIGR1cmF0aW9uL3RoaXMubDtcbiAgICB9IFxuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIGlmICh0aGlzLmwvZHVyYXRpb24+MSkge1xuXHRyZXQrPVwiL1wiO1xuXHRpZiAodGhpcy5sL2R1cmF0aW9uPjIpIHtcblx0ICAgIHJldCs9dGhpcy5sL2R1cmF0aW9uO1xuXHR9ICAgXG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUuZXh0cmFjdE5vdGUgPSBmdW5jdGlvbihwaXRjaCkge1xuICAgIHZhciBwaXRjaDIgPSBwaXRjaCU3O1xuICAgIGlmIChwaXRjaDI8MCkgcGl0Y2gyKz03O1xuICAgIHJldHVybiBwaXRjaDI7XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUuZXh0cmFjdE9jdGF2ZSA9IGZ1bmN0aW9uKHBpdGNoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocGl0Y2gvNyk7XG59O1xuXG5UZXh0UHJpbnRlci5wcm90b3R5cGUucHJpbnRCYXJMaW5lID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHZhciBiYXJzdHIgPSBcIlwiO1xuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgY2FzZSBcImJhcl90aGluXCI6IGJhcnN0cis9XCJ8XCI7IGJyZWFrO1xuICAgIGNhc2UgXCJiYXJfdGhpbl90aGlja1wiOiBiYXJzdHIrPVwifF1cIjsgYnJlYWs7XG4gICAgY2FzZSBcImJhcl90aGluX3RoaW5cIjogYmFyc3RyKz1cInx8XCI7IGJyZWFrO1xuICAgIGNhc2UgXCJiYXJfdGhpY2tfdGhpblwiOiBiYXJzdHIrPVwiW3xcIjsgYnJlYWs7XG4gICAgY2FzZSBcImJhcl9kYmxfcmVwZWF0XCI6IGJhcnN0cis9XCI6fHw6XCI7IGJyZWFrO1xuICAgIGNhc2UgXCJiYXJfbGVmdF9yZXBlYXRcIjogYmFyc3RyKz1cInw6XCI7IGJyZWFrO1xuICAgIGNhc2UgXCJiYXJfcmlnaHRfcmVwZWF0XCI6IGJhcnN0cis9XCI6fFwiOyBicmVhaztcbiAgICBjYXNlIFwiYmFyX2ludmlzaWJsZVwiOiBiYXJzdHIrPVwiXCI7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnByaW50U3RyaW5nKGJhcnN0cixlbGVtKTtcbn07XG5cblRleHRQcmludGVyLnByb3RvdHlwZS5tdWx0aXBseVN0cmluZyA9IGZ1bmN0aW9uIChzLCBuKSB7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgZm9yICg7bj4wO24tLSkgcmV0Kz1zO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRQcmludGVyO1xuIiwiLy8gICAgYWJjX2Fic29sdXRlX2VsZW1lbnQuanM6IERlZmluaXRpb24gb2YgdGhlIEFic29sdXRlRWxlbWVudCBjbGFzcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHNwYWNpbmcgPSByZXF1aXJlKCcuL2FiY19zcGFjaW5nJyk7XG5cbi8vIGR1cmF0aW9uIC0gYWN0dWFsIG11c2ljYWwgZHVyYXRpb24gLSBkaWZmZXJlbnQgZnJvbSBub3RlaGVhZCBkdXJhdGlvbiBpbiB0cmlwbGV0cy4gcmVmZXIgdG8gYWJjZWxlbSB0byBnZXQgdGhlIG5vdGVoZWFkIGR1cmF0aW9uXG4vLyBtaW5zcGFjaW5nIC0gc3BhY2luZyB3aGljaCBtdXN0IGJlIHRha2VuIG9uIHRvcCBvZiB0aGUgd2lkdGggZGVmaW5lZCBieSB0aGUgZHVyYXRpb25cbi8vIHR5cGUgaXMgYSBtZXRhLXR5cGUgZm9yIHRoZSBlbGVtZW50LiBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciBkcmF3aW5nLCBidXQgaXQgaXMgdXNlZnVsIHRvIG1ha2Ugc2VtYW50aWMgc2Vuc2Ugb2YgdGhlIGVsZW1lbnQuIEZvciBpbnN0YW5jZSwgaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGVsZW1lbnQncyBjbGFzcyBuYW1lLlxudmFyIEFic29sdXRlRWxlbWVudCA9IGZ1bmN0aW9uIEFic29sdXRlRWxlbWVudChhYmNlbGVtLCBkdXJhdGlvbiwgbWluc3BhY2luZywgdHlwZSwgdHVuZU51bWJlciwgb3B0aW9ucykge1xuXHQvL2NvbnNvbGUubG9nKFwiQWJzb2x1dGU6XCIsYWJjZWxlbSwgdHlwZSk7XG5cdGlmICghb3B0aW9ucylcblx0XHRvcHRpb25zID0ge307XG5cdHRoaXMudHVuZU51bWJlciA9IHR1bmVOdW1iZXI7XG5cdHRoaXMuYWJjZWxlbSA9IGFiY2VsZW07XG5cdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0dGhpcy5kdXJhdGlvbkNsYXNzID0gb3B0aW9ucy5kdXJhdGlvbkNsYXNzT3ZlcmlkZSA/IG9wdGlvbnMuZHVyYXRpb25DbGFzc092ZXJpZGUgOiB0aGlzLmR1cmF0aW9uO1xuXHR0aGlzLm1pbnNwYWNpbmcgPSBtaW5zcGFjaW5nIHx8IDA7XG5cdHRoaXMueCA9IDA7XG5cdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0dGhpcy5oZWFkcyA9IFtdO1xuXHR0aGlzLmV4dHJhID0gW107XG5cdHRoaXMuZXh0cmF3ID0gMDtcblx0Ly90aGlzLmRlY3MgPSBbXTtcblx0dGhpcy53ID0gMDtcblx0dGhpcy5yaWdodCA9IFtdO1xuXHR0aGlzLmludmlzaWJsZSA9IGZhbHNlO1xuXHR0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcblx0dGhpcy50b3AgPSB1bmRlZmluZWQ7XG5cdHRoaXMudHlwZSA9IHR5cGU7XG5cdC8vIHRoZXNlIGFyZSB0aGUgaGVpZ2h0cyBvZiBhbGwgb2YgdGhlIHZlcnRpY2FsIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgcGxhY2VkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG5cdC8vIHRoZSB2ZXJ0aWNhbCBvcmRlciBvZiBlbGVtZW50cyB0aGF0IGFyZSBhYm92ZSBpczogdGVtcG8sIHBhcnQsIHZvbHVtZS9keW5hbWljLCBlbmRpbmcvY2hvcmQsIGx5cmljXG5cdC8vIHRoZSB2ZXJ0aWNhbCBvcmRlciBvZiBlbGVtZW50cyB0aGF0IGFyZSBiZWxvdyBpczogbHlyaWMsIGNob3JkLCB2b2x1bWUvZHluYW1pY1xuXHR0aGlzLnNwZWNpYWxZID0ge1xuXHRcdHRlbXBvSGVpZ2h0QWJvdmU6IDAsXG5cdFx0cGFydEhlaWdodEFib3ZlOiAwLFxuXHRcdHZvbHVtZUhlaWdodEFib3ZlOiAwLFxuXHRcdGR5bmFtaWNIZWlnaHRBYm92ZTogMCxcblx0XHRlbmRpbmdIZWlnaHRBYm92ZTogMCxcblx0XHRjaG9yZEhlaWdodEFib3ZlOiAwLFxuXHRcdGx5cmljSGVpZ2h0QWJvdmU6IDAsXG5cblx0XHRseXJpY0hlaWdodEJlbG93OiAwLFxuXHRcdGNob3JkSGVpZ2h0QmVsb3c6IDAsXG5cdFx0dm9sdW1lSGVpZ2h0QmVsb3c6IDAsXG5cdFx0ZHluYW1pY0hlaWdodEJlbG93OiAwXG5cdH07XG59O1xuXG4vLyBGb3IgZWFjaCBvZiB0aGUgcmVsYXRpdmUgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBwbGFjZWQgaW4gYWR2YW5jZSAoYmVjYXVzZSB0aGVpciB2ZXJ0aWNhbCBwbGFjZW1lbnQgZGVwZW5kcyBvbiBldmVyeXRoaW5nXG4vLyBlbHNlIG9uIHRoZSBsaW5lKSwgdGhpcyBpdGVyYXRlcyB0aHJvdWdoIHRoZW0gYW5kIHNldHMgdGhlaXIgcGl0Y2guIEJ5IHRoZSB0aW1lIHRoaXMgaXMgY2FsbGVkLCBzcGVjaWFsWVJlc29sdmVkIGNvbnRhaW5zIGFcbi8vIGhhc2ggd2l0aCB0aGUgdmVydGljYWwgcGxhY2VtZW50IChpbiBwaXRjaCB1bml0cykgZm9yIGVhY2ggdHlwZS5cbi8vIFRPRE8tUEVSOiBJIHRoaW5rIHRoaXMgbmVlZHMgdG8gYmUgc2VwYXJhdGVkIGJ5IFwiYWJvdmVcIiBhbmQgXCJiZWxvd1wiLiBIb3cgZG8gd2Uga25vdyB0aGF0IGZvciBkeW5hbWljcyBhdCB0aGUgcG9pbnQgd2hlcmUgdGhleSBhcmUgYmVpbmcgZGVmaW5lZCwgdGhvdWdoPyBXZSBuZWVkIGEgcGFzcyB0aHJvdWdoIGFsbCB0aGUgcmVsYXRpdmUgZWxlbWVudHMgdG8gc2V0IFwiYWJvdmVcIiBhbmQgXCJiZWxvd1wiLlxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5zZXRVcHBlckFuZExvd2VyRWxlbWVudHMgPSBmdW5jdGlvbihzcGVjaWFsWVJlc29sdmVkKSB7XG5cdC8vIHNwZWNpYWxZUmVzb2x2ZWQgY29udGFpbnMgdGhlIGFjdHVhbCBwaXRjaCBmb3IgZWFjaCBvZiB0aGUgY2xhc3NlcyBvZiBlbGVtZW50cy5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5zcGVjaWFsWSkgeyAvLyBmb3IgZWFjaCBjbGFzcyBvZiBlbGVtZW50IHRoYXQgbmVlZHMgdG8gYmUgcGxhY2VkIHZlcnRpY2FsbHlcblx0XHRcdGlmICh0aGlzLnNwZWNpYWxZLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aWYgKGNoaWxkW2tleV0pIHsgLy8gSWYgdGhpcyByZWxhdGl2ZSBlbGVtZW50IGhhcyBkZWZpbmVkIGEgaGVpZ2h0IGZvciB0aGlzIGNsYXNzIG9mIGVsZW1lbnRcblx0XHRcdFx0XHRjaGlsZC5waXRjaCA9IHNwZWNpYWxZUmVzb2x2ZWRba2V5XTtcblx0XHRcdFx0XHRpZiAoY2hpbGQudG9wID09PSB1bmRlZmluZWQpIHsgLy8gVE9ETy1QRVI6IEhBQ0shIE5vdCBzdXJlIHRoaXMgaXMgdGhlIHJpZ2h0IHBsYWNlIHRvIGRvIHRoaXMuXG5cdFx0XHRcdFx0XHRjaGlsZC5zZXRVcHBlckFuZExvd2VyRWxlbWVudHMoc3BlY2lhbFlSZXNvbHZlZCk7XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hUb3AoY2hpbGQudG9wKTtcblx0XHRcdFx0XHRcdHRoaXMucHVzaEJvdHRvbShjaGlsZC5ib3R0b20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5nZXRNaW5XaWR0aCA9IGZ1bmN0aW9uICgpIHsgLy8gYWJzb2x1dGUgc3BhY2UgdGFrZW4gdG8gdGhlIHJpZ2h0IG9mIHRoZSBub3RlXG5cdHJldHVybiB0aGlzLnc7XG59O1xuXG5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLmdldEV4dHJhV2lkdGggPSBmdW5jdGlvbiAoKSB7IC8vIHNwYWNlIG5lZWRlZCB0byB0aGUgbGVmdCBvZiB0aGUgbm90ZVxuXHRyZXR1cm4gLXRoaXMuZXh0cmF3O1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5hZGRFeHRyYSA9IGZ1bmN0aW9uIChleHRyYSkge1xuXHRpZiAoZXh0cmEuZHg8dGhpcy5leHRyYXcpIHRoaXMuZXh0cmF3ID0gZXh0cmEuZHg7XG5cdHRoaXMuZXh0cmFbdGhpcy5leHRyYS5sZW5ndGhdID0gZXh0cmE7XG5cdHRoaXMuYWRkQ2hpbGQoZXh0cmEpO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5hZGRIZWFkID0gZnVuY3Rpb24gKGhlYWQpIHtcblx0aWYgKGhlYWQuZHg8dGhpcy5leHRyYXcpIHRoaXMuZXh0cmF3ID0gaGVhZC5keDtcblx0dGhpcy5oZWFkc1t0aGlzLmhlYWRzLmxlbmd0aF0gPSBoZWFkO1xuXHR0aGlzLmFkZFJpZ2h0KGhlYWQpO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5hZGRSaWdodCA9IGZ1bmN0aW9uIChyaWdodCkge1xuXHRpZiAocmlnaHQuZHgrcmlnaHQudz50aGlzLncpIHRoaXMudyA9IHJpZ2h0LmR4K3JpZ2h0Lnc7XG5cdHRoaXMucmlnaHRbdGhpcy5yaWdodC5sZW5ndGhdID0gcmlnaHQ7XG5cdHRoaXMuYWRkQ2hpbGQocmlnaHQpO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5hZGRDZW50ZXJlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG5cdHZhciBoYWxmID0gZWxlbS53LzI7XG5cdGlmICgtaGFsZjx0aGlzLmV4dHJhdykgdGhpcy5leHRyYXcgPSAtaGFsZjtcblx0dGhpcy5leHRyYVt0aGlzLmV4dHJhLmxlbmd0aF0gPSBlbGVtO1xuXHRpZiAoZWxlbS5keCtoYWxmPnRoaXMudykgdGhpcy53ID0gZWxlbS5keCtoYWxmO1xuXHR0aGlzLnJpZ2h0W3RoaXMucmlnaHQubGVuZ3RoXSA9IGVsZW07XG5cdHRoaXMuYWRkQ2hpbGQoZWxlbSk7XG59O1xuXG5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLnNldExpbWl0ID0gZnVuY3Rpb24obWVtYmVyLCBjaGlsZCkge1xuXHRpZiAoIWNoaWxkW21lbWJlcl0pIHJldHVybjtcblx0aWYgKCF0aGlzLnNwZWNpYWxZW21lbWJlcl0pXG5cdFx0dGhpcy5zcGVjaWFsWVttZW1iZXJdID0gY2hpbGRbbWVtYmVyXTtcblx0ZWxzZVxuXHRcdHRoaXMuc3BlY2lhbFlbbWVtYmVyXSA9IE1hdGgubWF4KHRoaXMuc3BlY2lhbFlbbWVtYmVyXSwgY2hpbGRbbWVtYmVyXSk7XG59O1xuXG5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG5cdC8vY29uc29sZS5sb2coXCJSZWxhdGl2ZTpcIixjaGlsZCk7XG5cdGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cdHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGhdID0gY2hpbGQ7XG5cdHRoaXMucHVzaFRvcChjaGlsZC50b3ApO1xuXHR0aGlzLnB1c2hCb3R0b20oY2hpbGQuYm90dG9tKTtcblx0dGhpcy5zZXRMaW1pdCgndGVtcG9IZWlnaHRBYm92ZScsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgncGFydEhlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCd2b2x1bWVIZWlnaHRBYm92ZScsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnZHluYW1pY0hlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdlbmRpbmdIZWlnaHRBYm92ZScsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnY2hvcmRIZWlnaHRBYm92ZScsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnbHlyaWNIZWlnaHRBYm92ZScsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnbHlyaWNIZWlnaHRCZWxvdycsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnY2hvcmRIZWlnaHRCZWxvdycsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgndm9sdW1lSGVpZ2h0QmVsb3cnLCBjaGlsZCk7XG5cdHRoaXMuc2V0TGltaXQoJ2R5bmFtaWNIZWlnaHRCZWxvdycsIGNoaWxkKTtcbn07XG5cbkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUucHVzaFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcblx0aWYgKHRvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRoaXMudG9wID09PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLnRvcCA9IE1hdGgubWF4KHRvcCwgdGhpcy50b3ApO1xuXHR9XG59O1xuXG5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLnB1c2hCb3R0b20gPSBmdW5jdGlvbiAoYm90dG9tKSB7XG5cdGlmIChib3R0b20gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aGlzLmJvdHRvbSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5ib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHRoaXMuYm90dG9tKTtcblx0fVxufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcblx0dGhpcy54ID0geDtcblx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG5cdFx0dGhpcy5jaGlsZHJlbltpXS5zZXRYKHgpO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5zZXRIaW50ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmhpbnQgPSB0cnVlO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBiYXJ0b3ApIHtcblx0aWYgKHRoaXMuaW52aXNpYmxlKSByZXR1cm47XG5cdHRoaXMuZWxlbXNldCA9IFtdO1xuXHRyZW5kZXJlci5iZWdpbkdyb3VwKCk7XG5cdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKC8qQUJDSlMud3JpdGUuZGVidWdQbGFjZW1lbnQqL2ZhbHNlKSB7XG5cdFx0XHRpZiAodGhpcy5jaGlsZHJlbltpXS5rbGFzcyA9PT0gJ29ybmFtZW50Jylcblx0XHRcdFx0cmVuZGVyZXIucHJpbnRTaGFkZWRCb3godGhpcy54LCByZW5kZXJlci5jYWxjWSh0aGlzLmNoaWxkcmVuW2ldLnRvcCksIHRoaXMudywgcmVuZGVyZXIuY2FsY1kodGhpcy5jaGlsZHJlbltpXS5ib3R0b20pLXJlbmRlcmVyLmNhbGNZKHRoaXMuY2hpbGRyZW5baV0udG9wKSwgXCJyZ2IoMCwwLDIwMClcIiwgMC4zKTtcblx0XHR9XG5cdFx0dmFyIGVsID0gdGhpcy5jaGlsZHJlbltpXS5kcmF3KHJlbmRlcmVyLGJhcnRvcCk7XG5cdFx0aWYgKGVsKVxuXHRcdFx0dGhpcy5lbGVtc2V0LnB1c2goZWwpO1xuXHR9XG5cdHZhciBrbGFzcyA9IHRoaXMudHlwZTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ25vdGUnIHx8IHRoaXMudHlwZSA9PT0gJ3Jlc3QnKSB7XG5cdFx0a2xhc3MgKz0gJyBkJyArIHRoaXMuZHVyYXRpb25DbGFzcztcblx0XHRrbGFzcyA9IGtsYXNzLnJlcGxhY2UoL1xcLi9nLCAnLScpO1xuXHRcdGlmICh0aGlzLmFiY2VsZW0ucGl0Y2hlcykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmFiY2VsZW0ucGl0Y2hlcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRrbGFzcyArPSAnIHAnICsgdGhpcy5hYmNlbGVtLnBpdGNoZXNbal0ucGl0Y2g7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHZhciBnID0gcmVuZGVyZXIuZW5kR3JvdXAoa2xhc3MpO1xuXHRpZiAoZylcblx0XHR0aGlzLmVsZW1zZXQucHVzaChnKTtcblx0aWYgKHRoaXMua2xhc3MpXG5cdFx0dGhpcy5zZXRDbGFzcyhcIm1hcmtcIiwgXCJcIiwgXCIjMDBmZjAwXCIpO1xuXHRpZiAodGhpcy5oaW50KVxuXHRcdHRoaXMuc2V0Q2xhc3MoXCJhYmNqcy1oaW50XCIsIFwiXCIsIG51bGwpO1xuXHR2YXIgb3BhY2l0eSA9IC8qQUJDSlMud3JpdGUuZGVidWdQbGFjZW1lbnQqL2ZhbHNlID8gMC4zIDogMDsgLy8gQ3JlYXRlIHRyYW5zcGFyZW50IGJveCB0aGF0IGVuY29tcGFzc2VzIHRoZSBlbGVtZW50LCBhbmQgbm90IHNvIHRyYW5zcGFyZW50IHRvIGRlYnVnIGl0LlxuXHR2YXIgdGFyZ2V0ID0gcmVuZGVyZXIucHJpbnRTaGFkZWRCb3godGhpcy54LCByZW5kZXJlci5jYWxjWSh0aGlzLnRvcCksIHRoaXMudywgcmVuZGVyZXIuY2FsY1kodGhpcy5ib3R0b20pLXJlbmRlcmVyLmNhbGNZKHRoaXMudG9wKSwgXCIjMDAwMDAwXCIsIG9wYWNpdHkpO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBjb250cm9sbGVyID0gcmVuZGVyZXIuY29udHJvbGxlcjtcblx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblx0XHRpZiAoc2VsZi5lbGVtc2V0KSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYuZWxlbXNldC5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgZXMgPSBzZWxmLmVsZW1zZXRbal07XG5cdFx0XHRcdGlmIChlcylcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goZXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250cm9sbGVyLm5vdGlmeVNlbGVjdChzZWxmLCBzZWxmLnR1bmVOdW1iZXIsIGNsYXNzZXMpO1xuXHR9KTtcblx0dGhpcy5hYmNlbGVtLmFic2VsZW0gPSB0aGlzO1xuXG5cdHZhciBzdGVwID0gc3BhY2luZy5TVEVQO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5pc0lFPS8qQGNjX29uIUAqL2ZhbHNlOy8vSUUgZGV0ZWN0b3JcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5zZXRDbGFzcyA9IGZ1bmN0aW9uIChhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsIGNvbG9yKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtc2V0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbGVtc2V0W2ldO1xuXHRcdGVsLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgY29sb3IpO1xuXHRcdHZhciBrbHMgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcblx0XHRpZiAoIWtscykga2xzID0gXCJcIjtcblx0XHRrbHMgPSBrbHMucmVwbGFjZShyZW1vdmVDbGFzcywgXCJcIik7XG5cdFx0a2xzID0ga2xzLnJlcGxhY2UoYWRkQ2xhc3MsIFwiXCIpO1xuXHRcdGlmIChhZGRDbGFzcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAoa2xzLmxlbmd0aCA+IDAgJiYga2xzLmNoYXJBdChrbHMubGVuZ3RoIC0gMSkgIT09ICcgJykga2xzICs9IFwiIFwiO1xuXHRcdFx0a2xzICs9IGFkZENsYXNzO1xuXHRcdH1cblx0XHRlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBrbHMpO1xuXHR9XG59O1xuXG5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChrbGFzcywgY29sb3IpIHtcblx0aWYgKGtsYXNzID09PSB1bmRlZmluZWQpXG5cdFx0a2xhc3MgPSBcImFiY2pzLW5vdGVfc2VsZWN0ZWRcIjtcblx0aWYgKGNvbG9yID09PSB1bmRlZmluZWQpXG5cdFx0Y29sb3IgPSBcIiNmZjAwMDBcIjtcblx0dGhpcy5zZXRDbGFzcyhrbGFzcywgXCJcIiwgY29sb3IpO1xufTtcblxuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChrbGFzcywgY29sb3IpIHtcblx0aWYgKGtsYXNzID09PSB1bmRlZmluZWQpXG5cdFx0a2xhc3MgPSBcImFiY2pzLW5vdGVfc2VsZWN0ZWRcIjtcblx0aWYgKGNvbG9yID09PSB1bmRlZmluZWQpXG5cdFx0Y29sb3IgPSBcIiMwMDAwMDBcIjtcblx0dGhpcy5zZXRDbGFzcyhcIlwiLCBrbGFzcywgY29sb3IpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnNvbHV0ZUVsZW1lbnQ7XG4iLCIvLyBhYmNfYWJzdHJhY3RfZW5ncmF2ZXIuanM6IENyZWF0ZXMgYSBkYXRhIHN0cnVjdHVyZSBzdWl0YWJsZSBmb3IgcHJpbnRpbmcgYSBsaW5lIG9mIGFiY1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKVxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQWJzb2x1dGVFbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfYWJzb2x1dGVfZWxlbWVudCcpO1xudmFyIEJlYW1FbGVtID0gcmVxdWlyZSgnLi9hYmNfYmVhbV9lbGVtZW50Jyk7XG52YXIgQnJhY2VFbGVtID0gcmVxdWlyZSgnLi9hYmNfYnJhY2VfZWxlbWVudCcpO1xudmFyIGNyZWF0ZUNsZWYgPSByZXF1aXJlKCcuL2FiY19jcmVhdGVfY2xlZicpO1xudmFyIGNyZWF0ZUtleVNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vYWJjX2NyZWF0ZV9rZXlfc2lnbmF0dXJlJyk7XG52YXIgY3JlYXRlVGltZVNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vYWJjX2NyZWF0ZV90aW1lX3NpZ25hdHVyZScpO1xudmFyIERlY29yYXRpb24gPSByZXF1aXJlKCcuL2FiY19kZWNvcmF0aW9uJyk7XG52YXIgRW5kaW5nRWxlbSA9IHJlcXVpcmUoJy4vYWJjX2VuZGluZ19lbGVtZW50Jyk7XG52YXIgZ2x5cGhzID0gcmVxdWlyZSgnLi9hYmNfZ2x5cGhzJyk7XG52YXIgUmVsYXRpdmVFbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfcmVsYXRpdmVfZWxlbWVudCcpO1xudmFyIHNwYWNpbmcgPSByZXF1aXJlKCcuL2FiY19zcGFjaW5nJyk7XG52YXIgU3RhZmZHcm91cEVsZW1lbnQgPSByZXF1aXJlKCcuL2FiY19zdGFmZl9ncm91cF9lbGVtZW50Jyk7XG52YXIgVGVtcG9FbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfdGVtcG9fZWxlbWVudCcpO1xudmFyIFRpZUVsZW0gPSByZXF1aXJlKCcuL2FiY190aWVfZWxlbWVudCcpO1xudmFyIFRyaXBsZXRFbGVtID0gcmVxdWlyZSgnLi9hYmNfdHJpcGxldF9lbGVtZW50Jyk7XG52YXIgVm9pY2VFbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfdm9pY2VfZWxlbWVudCcpO1xuXG52YXIgcGFyc2VDb21tb24gPSByZXF1aXJlKCcuLi9wYXJzZS9hYmNfY29tbW9uJyk7XG5cbnZhciBBYnN0cmFjdEVuZ3JhdmVyO1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0RHVyYXRpb24gPSBmdW5jdGlvbihlbGVtKSB7XG4gIHZhciBkID0gMDtcbiAgaWYgKGVsZW0uZHVyYXRpb24pIHtcbiAgICBkID0gZWxlbS5kdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gZDtcbn07XG5cbnZhciBoaW50ID0gZmFsc2U7XG5cblx0dmFyIGNoYXJ0YWJsZSA9IHtcblx0XHRyZXN0OnswOlwicmVzdHMud2hvbGVcIiwgMTpcInJlc3RzLmhhbGZcIiwgMjpcInJlc3RzLnF1YXJ0ZXJcIiwgMzpcInJlc3RzLjh0aFwiLCA0OiBcInJlc3RzLjE2dGhcIiw1OiBcInJlc3RzLjMybmRcIiwgNjogXCJyZXN0cy42NHRoXCIsIDc6IFwicmVzdHMuMTI4dGhcIiwgXCJtdWx0aVwiOiBcInJlc3RzLm11bHRpbWVhc3VyZVwifSxcblx0XHRub3RlOntcIi0xXCI6IFwibm90ZWhlYWRzLmRibFwiLCAwOlwibm90ZWhlYWRzLndob2xlXCIsIDE6XCJub3RlaGVhZHMuaGFsZlwiLCAyOlwibm90ZWhlYWRzLnF1YXJ0ZXJcIiwgMzpcIm5vdGVoZWFkcy5xdWFydGVyXCIsIDQ6XCJub3RlaGVhZHMucXVhcnRlclwiLCA1Olwibm90ZWhlYWRzLnF1YXJ0ZXJcIiwgNjpcIm5vdGVoZWFkcy5xdWFydGVyXCIsIDc6XCJub3RlaGVhZHMucXVhcnRlclwiLCAnbm9zdGVtJzpcIm5vdGVoZWFkcy5xdWFydGVyXCJ9LFxuXHRcdHJoeXRobTp7XCItMVwiOiBcIm5vdGVoZWFkcy5zbGFzaC53aG9sZVwiLCAwOlwibm90ZWhlYWRzLnNsYXNoLndob2xlXCIsIDE6XCJub3RlaGVhZHMuc2xhc2gud2hvbGVcIiwgMjpcIm5vdGVoZWFkcy5zbGFzaC5xdWFydGVyXCIsIDM6XCJub3RlaGVhZHMuc2xhc2gucXVhcnRlclwiLCA0Olwibm90ZWhlYWRzLnNsYXNoLnF1YXJ0ZXJcIiwgNTpcIm5vdGVoZWFkcy5zbGFzaC5xdWFydGVyXCIsIDY6XCJub3RlaGVhZHMuc2xhc2gucXVhcnRlclwiLCA3Olwibm90ZWhlYWRzLnNsYXNoLnF1YXJ0ZXJcIiwgbm9zdGVtOiBcIm5vdGVoZWFkcy5zbGFzaC5ub3N0ZW1cIn0sXG5cdFx0eDp7XCItMVwiOiBcIm5vdGVoZWFkcy5pbmRldGVybWluYXRlXCIsIDA6XCJub3RlaGVhZHMuaW5kZXRlcm1pbmF0ZVwiLCAxOlwibm90ZWhlYWRzLmluZGV0ZXJtaW5hdGVcIiwgMjpcIm5vdGVoZWFkcy5pbmRldGVybWluYXRlXCIsIDM6XCJub3RlaGVhZHMuaW5kZXRlcm1pbmF0ZVwiLCA0Olwibm90ZWhlYWRzLmluZGV0ZXJtaW5hdGVcIiwgNTpcIm5vdGVoZWFkcy5pbmRldGVybWluYXRlXCIsIDY6XCJub3RlaGVhZHMuaW5kZXRlcm1pbmF0ZVwiLCA3Olwibm90ZWhlYWRzLmluZGV0ZXJtaW5hdGVcIiwgbm9zdGVtOiBcIm5vdGVoZWFkcy5pbmRldGVybWluYXRlXCJ9LFxuXHRcdGhhcm1vbmljOntcIi0xXCI6IFwibm90ZWhlYWRzLmhhcm1vbmljLnF1YXJ0ZXJcIiwgMDpcIm5vdGVoZWFkcy5oYXJtb25pYy5xdWFydGVyXCIsIDE6XCJub3RlaGVhZHMuaGFybW9uaWMucXVhcnRlclwiLCAyOlwibm90ZWhlYWRzLmhhcm1vbmljLnF1YXJ0ZXJcIiwgMzpcIm5vdGVoZWFkcy5oYXJtb25pYy5xdWFydGVyXCIsIDQ6XCJub3RlaGVhZHMuaGFybW9uaWMucXVhcnRlclwiLCA1Olwibm90ZWhlYWRzLmhhcm1vbmljLnF1YXJ0ZXJcIiwgNjpcIm5vdGVoZWFkcy5oYXJtb25pYy5xdWFydGVyXCIsIDc6XCJub3RlaGVhZHMuaGFybW9uaWMucXVhcnRlclwiLCBub3N0ZW06IFwibm90ZWhlYWRzLmhhcm1vbmljLnF1YXJ0ZXJcIn0sXG5cdFx0dWZsYWdzOnszOlwiZmxhZ3MudTh0aFwiLCA0OlwiZmxhZ3MudTE2dGhcIiwgNTpcImZsYWdzLnUzMm5kXCIsIDY6XCJmbGFncy51NjR0aFwifSxcblx0XHRkZmxhZ3M6ezM6XCJmbGFncy5kOHRoXCIsIDQ6XCJmbGFncy5kMTZ0aFwiLCA1OlwiZmxhZ3MuZDMybmRcIiwgNjpcImZsYWdzLmQ2NHRoXCJ9XG5cdH07XG5cbkFic3RyYWN0RW5ncmF2ZXIgPSBmdW5jdGlvbihyZW5kZXJlciwgdHVuZU51bWJlciwgb3B0aW9ucykge1xuXHR0aGlzLmRlY29yYXRpb24gPSBuZXcgRGVjb3JhdGlvbigpO1xuXHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cdHRoaXMudHVuZU51bWJlciA9IHR1bmVOdW1iZXI7XG5cdHRoaXMuaXNCYWdwaXBlcyA9IG9wdGlvbnMuYmFncGlwZXM7XG5cdHRoaXMuZmxhdEJlYW1zID0gb3B0aW9ucy5mbGF0YmVhbXM7XG5cdHRoaXMucmVzZXQoKTtcbn07XG5cbkFic3RyYWN0RW5ncmF2ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2x1cnMgPSB7fTtcblx0dGhpcy50aWVzID0gW107XG5cdHRoaXMudm9pY2VTY2FsZSA9IDE7XG5cdHRoaXMuc2x1cnNieXZvaWNlID0ge307XG5cdHRoaXMudGllc2J5dm9pY2UgPSB7fTtcblx0dGhpcy5lbmRpbmdzYnl2b2ljZSA9IHt9O1xuXHR0aGlzLnNjYWxlQnlWb2ljZSA9IHt9O1xuXHR0aGlzLnRyaXBsZXRtdWx0aXBsaWVyID0gMTtcblxuXHR0aGlzLmFiY2xpbmUgPSB1bmRlZmluZWQ7XG5cdHRoaXMuYWNjaWRlbnRhbFNsb3QgPSB1bmRlZmluZWQ7XG5cdHRoaXMuYWNjaWRlbnRhbHNoaWZ0eCA9IHVuZGVmaW5lZDtcblx0dGhpcy5kb3RzaGlmdHggPSB1bmRlZmluZWQ7XG5cdHRoaXMuaGFzVm9jYWxzID0gZmFsc2U7XG5cdHRoaXMubWluWSA9IHVuZGVmaW5lZDtcblx0dGhpcy5wYXJ0c3RhcnRlbGVtID0gdW5kZWZpbmVkO1xuXHR0aGlzLnN0YXJ0bGltaXRlbGVtID0gdW5kZWZpbmVkO1xuXHR0aGlzLnN0ZW1kaXIgPSB1bmRlZmluZWQ7XG59O1xuXG5BYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5zZXRTdGVtSGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0SW5QaXhlbHMpIHtcblx0dGhpcy5zdGVtSGVpZ2h0ID0gaGVpZ2h0SW5QaXhlbHMgLyBzcGFjaW5nLlNURVA7XG59O1xuXG5BYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5nZXRDdXJyZW50Vm9pY2VJZCA9IGZ1bmN0aW9uKHMsdikge1xuICByZXR1cm4gXCJzXCIrcytcInZcIit2O1xufTtcblxuQWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUucHVzaENyb3NzTGluZUVsZW1zID0gZnVuY3Rpb24ocyx2KSB7XG4gIHRoaXMuc2x1cnNieXZvaWNlW3RoaXMuZ2V0Q3VycmVudFZvaWNlSWQocyx2KV0gPSB0aGlzLnNsdXJzO1xuICB0aGlzLnRpZXNieXZvaWNlW3RoaXMuZ2V0Q3VycmVudFZvaWNlSWQocyx2KV0gPSB0aGlzLnRpZXM7XG4gIHRoaXMuZW5kaW5nc2J5dm9pY2VbdGhpcy5nZXRDdXJyZW50Vm9pY2VJZChzLHYpXSA9IHRoaXMucGFydHN0YXJ0ZWxlbTtcbiAgdGhpcy5zY2FsZUJ5Vm9pY2VbdGhpcy5nZXRDdXJyZW50Vm9pY2VJZChzLHYpXSA9IHRoaXMudm9pY2VTY2FsZTtcbn07XG5cbkFic3RyYWN0RW5ncmF2ZXIucHJvdG90eXBlLnBvcENyb3NzTGluZUVsZW1zID0gZnVuY3Rpb24ocyx2KSB7XG4gIHRoaXMuc2x1cnMgPSB0aGlzLnNsdXJzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKHMsdildIHx8IHt9O1xuICB0aGlzLnRpZXMgPSB0aGlzLnRpZXNieXZvaWNlW3RoaXMuZ2V0Q3VycmVudFZvaWNlSWQocyx2KV0gfHwgW107XG4gIHRoaXMucGFydHN0YXJ0ZWxlbSA9IHRoaXMuZW5kaW5nc2J5dm9pY2VbdGhpcy5nZXRDdXJyZW50Vm9pY2VJZChzLHYpXTtcbiAgdGhpcy52b2ljZVNjYWxlID0gdGhpcy5zY2FsZUJ5Vm9pY2VbdGhpcy5nZXRDdXJyZW50Vm9pY2VJZChzLHYpXTtcbiAgaWYgKHRoaXMudm9pY2VTY2FsZSA9PT0gdW5kZWZpbmVkKSB0aGlzLnZvaWNlU2NhbGUgPSAxO1xufTtcblxuXHRBYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5jb250YWluc0x5cmljcyA9IGZ1bmN0aW9uKHN0YXZlcykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHN0YXZlc1tpXS52b2ljZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBzdGF2ZXNbaV0udm9pY2VzW2pdLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0dmFyIGVsID0gc3RhdmVzW2ldLnZvaWNlc1tqXVtrXTtcblx0XHRcdFx0XHRpZiAoZWwubHlyaWMpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGp1c3Qgd2FudCB0byBzZWUgaWYgdGhlcmUgYXJlIHZvY2FscyBiZWxvdyB0aGUgbXVzaWMgdG8ga25vdyB3aGVyZSB0byBwdXQgdGhlIGR5bmFtaWNzLlxuXHRcdFx0XHRcdFx0aWYgKCFlbC5wb3NpdGlvbmluZyB8fCBlbC5wb3NpdGlvbmluZy52b2NhbFBvc2l0aW9uID09PSAnYmVsb3cnKVxuXHRcdFx0XHRcdFx0XHR0aGlzLmhhc1ZvY2FscyA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5BYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5jcmVhdGVBQkNMaW5lID0gZnVuY3Rpb24oc3RhZmZzLCB0ZW1wbykge1xuICAgIHRoaXMubWluWSA9IDI7IC8vIFBFUjogVGhpcyB3aWxsIGJlIHRoZSBsb3dlc3QgdGhhdCBhbnkgbm90ZSByZWFjaGVzLiBJdCB3aWxsIGJlIHVzZWQgdG8gc2V0IHRoZSBkeW5hbWljcyByb3cuXG5cdC8vIFNlZSBpZiB0aGVyZSBhcmUgYW55IGx5cmljcyBvbiB0aGlzIGxpbmUuXG5cdHRoaXMuY29udGFpbnNMeXJpY3Moc3RhZmZzKTtcbiAgdmFyIHN0YWZmZ3JvdXAgPSBuZXcgU3RhZmZHcm91cEVsZW1lbnQoKTtcblx0dGhpcy50ZW1wb1NldCA9IGZhbHNlO1xuICBmb3IgKHZhciBzID0gMDsgcyA8IHN0YWZmcy5sZW5ndGg7IHMrKykge1xuXHQgIGlmIChoaW50KVxuXHRcdCAgdGhpcy5yZXN0b3JlU3RhdGUoKTtcblx0ICBoaW50ID0gZmFsc2U7XG4gICAgdGhpcy5jcmVhdGVBQkNTdGFmZihzdGFmZmdyb3VwLCBzdGFmZnNbc10sIHRlbXBvLCBzKTtcbiAgfVxuICByZXR1cm4gc3RhZmZncm91cDtcbn07XG5cbkFic3RyYWN0RW5ncmF2ZXIucHJvdG90eXBlLmNyZWF0ZUFCQ1N0YWZmID0gZnVuY3Rpb24oc3RhZmZncm91cCwgYWJjc3RhZmYsIHRlbXBvLCBzKSB7XG4vLyBJZiB0aGUgdGVtcG8gaXMgcGFzc2VkIGluLCB0aGVuIHRoZSBmaXJzdCBlbGVtZW50IHNob3VsZCBnZXQgdGhlIHRlbXBvIGF0dGFjaGVkIHRvIGl0LlxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGFiY3N0YWZmLnZvaWNlcy5sZW5ndGg7IHYrKykge1xuICAgIHZhciB2b2ljZSA9IG5ldyBWb2ljZUVsZW1lbnQodixhYmNzdGFmZi52b2ljZXMubGVuZ3RoKTtcbiAgICBpZiAodj09PTApIHtcblx0ICAgIHZvaWNlLmJhcmZyb20gPSAoYWJjc3RhZmYuY29ubmVjdEJhckxpbmVzPT09XCJzdGFydFwiIHx8IGFiY3N0YWZmLmNvbm5lY3RCYXJMaW5lcz09PVwiY29udGludWVcIik7XG5cdCAgICB2b2ljZS5iYXJ0byA9IChhYmNzdGFmZi5jb25uZWN0QmFyTGluZXM9PT1cImNvbnRpbnVlXCIgfHwgYWJjc3RhZmYuY29ubmVjdEJhckxpbmVzPT09XCJlbmRcIik7XG4gICAgfSBlbHNlIHtcblx0ICAgIHZvaWNlLmR1cGxpY2F0ZSA9IHRydWU7IC8vIGJhciBsaW5lcyBhbmQgb3RoZXIgZHVwbGljYXRlIGluZm8gbmVlZCBub3QgYmUgY3JlYXRlZFxuICAgIH1cbiAgICBpZiAoYWJjc3RhZmYudGl0bGUgJiYgYWJjc3RhZmYudGl0bGVbdl0pIHZvaWNlLmhlYWRlcj1hYmNzdGFmZi50aXRsZVt2XTtcblx0ICB2YXIgY2xlZiA9IGNyZWF0ZUNsZWYoYWJjc3RhZmYuY2xlZiwgdGhpcy50dW5lTnVtYmVyKTtcblx0ICBpZiAoY2xlZikge1xuXHRcdCAgaWYgKHYgPT09MCAmJiBhYmNzdGFmZi5iYXJOdW1iZXIpIHtcblx0XHRcdCAgdGhpcy5hZGRNZWFzdXJlTnVtYmVyKGFiY3N0YWZmLmJhck51bWJlciwgY2xlZik7XG5cdFx0ICB9XG5cdFx0ICB2b2ljZS5hZGRDaGlsZChjbGVmKTtcblx0ICB9XG5cdCAgdmFyIGtleVNpZyA9IGNyZWF0ZUtleVNpZ25hdHVyZShhYmNzdGFmZi5rZXksIHRoaXMudHVuZU51bWJlcik7XG5cdCAgaWYgKGtleVNpZykge1xuXHRcdCAgdm9pY2UuYWRkQ2hpbGQoa2V5U2lnKTtcblx0XHQgIHRoaXMuc3RhcnRsaW1pdGVsZW0gPSBrZXlTaWc7IC8vIGxpbWl0IHRpZXMgaGVyZVxuXHQgIH1cbiAgICBpZiAoYWJjc3RhZmYubWV0ZXIpIHtcbiAgICBcdGlmIChhYmNzdGFmZi5tZXRlci50eXBlID09PSAnc3BlY2lmaWVkJykge1xuICAgIFx0XHR0aGlzLm1lYXN1cmVMZW5ndGggPSBhYmNzdGFmZi5tZXRlci52YWx1ZVswXS5udW0gLyBhYmNzdGFmZi5tZXRlci52YWx1ZVswXS5kZW47XG5cdCAgICB9IGVsc2Vcblx0ICAgIFx0dGhpcy5tZWFzdXJlTGVuZ3RoID0gMTtcblx0XHR2YXIgdHMgPSBjcmVhdGVUaW1lU2lnbmF0dXJlKGFiY3N0YWZmLm1ldGVyLCB0aGlzLnR1bmVOdW1iZXIpO1xuXHQgICAgdm9pY2UuYWRkQ2hpbGQodHMpO1xuXHRcdHRoaXMuc3RhcnRsaW1pdGVsZW0gPSB0czsgLy8gbGltaXQgdGllcyBoZXJlXG5cdH1cblx0ICBpZiAodm9pY2UuZHVwbGljYXRlKVxuXHRcdCAgdm9pY2UuY2hpbGRyZW4gPSBbXTsgLy8gd2Ugc2hvdWxkbid0IHJlcHJpbnQgdGhlIGFib3ZlIGlmIHdlJ3JlIHJldXNpbmcgdGhlIHNhbWUgc3RhZmYuIFdlIGp1c3QgY3JlYXRlZCB0aGVtIHRvIGdldCB0aGUgcmlnaHQgc3BhY2luZy5cbiAgICB2YXIgc3RhZmZMaW5lcyA9IGFiY3N0YWZmLmNsZWYuc3RhZmZsaW5lcyB8fCBhYmNzdGFmZi5jbGVmLnN0YWZmbGluZXMgPT09IDAgPyBhYmNzdGFmZi5jbGVmLnN0YWZmbGluZXMgOiA1O1xuICAgIHN0YWZmZ3JvdXAuYWRkVm9pY2Uodm9pY2UscyxzdGFmZkxpbmVzKTtcblx0ICB2YXIgaXNTaW5nbGVMaW5lU3RhZmYgPSBzdGFmZkxpbmVzID09PSAxO1xuXHQgIHRoaXMuY3JlYXRlQUJDVm9pY2UoYWJjc3RhZmYudm9pY2VzW3ZdLHRlbXBvLCBzLCB2LCBpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UpO1xuXHQgIHN0YWZmZ3JvdXAuc2V0U3RhZmZMaW1pdHModm9pY2UpO1xuICAgICAgICAgICAgLy9Ub255OiBIZXJlIEkgYW0gZm9sbG93aW5nIHdoYXQgc3RhdmVzIG5lZWQgdG8gYmUgc3Vycm91bmRlZCBieSB0aGUgYnJhY2UsIGJ5IGluY3JlbWVudGluZyB0aGUgbGVuZ3RoIG9mIHRoZSBicmFjZSBjbGFzcy5cbiAgICAgICAgICAgIC8vU28gYmFzaWNhbGx5IHRoaXMga2VlcHMgaW5jcmVtZW50aW5nIHRoZSBudW1iZXIgb2Ygc3RhZmYgc3Vycm91bmRlZCBieSB0aGUgYnJhY2UgdW50aWwgaXQgc2VlcyBcImVuZFwiLlxuICAgICAgICAgICAgLy9UaGlzIHRoZW4gZ2V0cyBwcm9jZXNzZWQgaW4gYWJjX3N0YWZmX2dyb3VwX2VsZW1lbnQuanMsIHNvIHRoYXQgaXQgd2lsbCBoYXZlIHRoZSBjb3JyZWN0IHRvcCBhbmQgYm90dG9tIGNvb3JkaW5hdGVzIGZvciB0aGUgYnJhY2UuXG5cdFx0XHRpZihhYmNzdGFmZi5icmFjZSA9PT0gXCJzdGFydFwiKXtcblx0XHRcdFx0c3RhZmZncm91cC5icmFjZSA9IG5ldyBCcmFjZUVsZW0oMSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGFiY3N0YWZmLmJyYWNlID09PSBcImVuZFwiICYmIHN0YWZmZ3JvdXAuYnJhY2UpIHtcblx0XHRcdFx0c3RhZmZncm91cC5icmFjZS5pbmNyZWFzZVN0YXZlc0luY2x1ZGVkKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGFiY3N0YWZmLmJyYWNlID09PSBcImNvbnRpbnVlXCIgJiYgc3RhZmZncm91cC5icmFjZSl7XG5cdFx0XHRcdHN0YWZmZ3JvdXAuYnJhY2UuaW5jcmVhc2VTdGF2ZXNJbmNsdWRlZCgpO1xuXHRcdFx0fVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCZWFtR3JvdXAoYWJjbGluZSwgcG9zKSB7XG5cdC8vIElmIHRoZXJlIGFyZSBub3RlcyBiZWFtZWQgdG9nZXRoZXIsIHRoZXkgYXJlIGhhbmRsZWQgYXMgYSBncm91cCwgc28gZmluZCBhbGwgb2YgdGhlbSBoZXJlLlxuXHR2YXIgZWxlbSA9IGFiY2xpbmVbcG9zXTtcblx0aWYgKGVsZW0uZWxfdHlwZSAhPT0gJ25vdGUnIHx8ICFlbGVtLnN0YXJ0QmVhbSB8fCBlbGVtLmVuZEJlYW0pXG5cdFx0cmV0dXJuIHsgY291bnQ6IDEsIGVsZW06IGVsZW0gfTtcblxuXHR2YXIgZ3JvdXAgPSBbXTtcblx0d2hpbGUgKHBvcyA8IGFiY2xpbmUubGVuZ3RoICYmIGFiY2xpbmVbcG9zXS5lbF90eXBlID09PSAnbm90ZScpIHtcblx0XHRncm91cC5wdXNoKGFiY2xpbmVbcG9zXSk7XG5cdFx0aWYgKGFiY2xpbmVbcG9zXS5lbmRCZWFtKVxuXHRcdFx0YnJlYWs7XG5cdFx0cG9zKys7XG5cdH1cblx0cmV0dXJuIHsgY291bnQ6IGdyb3VwLmxlbmd0aCwgZWxlbTogZ3JvdXAgfTtcbn1cblxuQWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuY3JlYXRlQUJDVm9pY2UgPSBmdW5jdGlvbihhYmNsaW5lLCB0ZW1wbywgcywgdiwgaXNTaW5nbGVMaW5lU3RhZmYsIHZvaWNlKSB7XG4gIHRoaXMucG9wQ3Jvc3NMaW5lRWxlbXMocyx2KTtcbiAgdGhpcy5zdGVtZGlyID0gKHRoaXMuaXNCYWdwaXBlcyk/XCJkb3duXCI6bnVsbDtcbiAgdGhpcy5hYmNsaW5lID0gYWJjbGluZTtcbiAgaWYgKHRoaXMucGFydHN0YXJ0ZWxlbSkge1xuICAgIHRoaXMucGFydHN0YXJ0ZWxlbSA9IG5ldyBFbmRpbmdFbGVtKFwiXCIsIG51bGwsIG51bGwpO1xuXHQgIHZvaWNlLmFkZE90aGVyKHRoaXMucGFydHN0YXJ0ZWxlbSk7XG4gIH1cblx0dmFyIHZvaWNlTnVtYmVyID0gdm9pY2Uudm9pY2V0b3RhbCA8IDIgPyAtMSA6IHZvaWNlLnZvaWNlbnVtYmVyO1xuICBmb3IgKHZhciBzbHVyIGluIHRoaXMuc2x1cnMpIHtcbiAgICBpZiAodGhpcy5zbHVycy5oYXNPd25Qcm9wZXJ0eShzbHVyKSkge1xuXHQgICAgLy8gdGhpcyBpcyBhbHJlYWR5IGEgc2x1ciBlbGVtZW50LCBidXQgaXQgd2FzIGNyZWF0ZWQgZm9yIHRoZSBsYXN0IGxpbmUsIHNvIHJlY3JlYXRlIGl0LlxuICAgICAgdGhpcy5zbHVyc1tzbHVyXT0gbmV3IFRpZUVsZW0oe2ZvcmNlOiB0aGlzLnNsdXJzW3NsdXJdLmZvcmNlLCB2b2ljZU51bWJlcjogdm9pY2VOdW1iZXIsIHN0ZW1EaXI6IHRoaXMuc2x1cnNbc2x1cl0uc3RlbURpcn0pO1xuXHRcdGlmIChoaW50KSB0aGlzLnNsdXJzW3NsdXJdLnNldEhpbnQoKTtcblx0ICAgIHZvaWNlLmFkZE90aGVyKHRoaXMuc2x1cnNbc2x1cl0pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpPTA7IGk8dGhpcy50aWVzLmxlbmd0aDsgaSsrKSB7XG4gIFx0Ly8gdGhpcyBpcyBhbHJlYWR5IGEgdGllIGVsZW1lbnQsIGJ1dCBpdCB3YXMgY3JlYXRlZCBmb3IgdGhlIGxhc3QgbGluZSwgc28gcmVjcmVhdGUgaXQuXG4gICAgdGhpcy50aWVzW2ldPW5ldyBUaWVFbGVtKHsgZm9yY2U6IHRoaXMudGllc1tpXS5mb3JjZSwgc3RlbURpcjogdGhpcy50aWVzW2ldLnN0ZW1EaXIsIHZvaWNlTnVtYmVyOiB2b2ljZU51bWJlciB9KTtcblx0ICBpZiAoaGludCkgdGhpcy50aWVzW2ldLnNldEhpbnQoKTtcblx0ICB2b2ljZS5hZGRPdGhlcih0aGlzLnRpZXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmFiY2xpbmUubGVuZ3RoOyBqKyspIHtcblx0ICBzZXRBdmVyYWdlUGl0Y2godGhpcy5hYmNsaW5lW2pdKTtcblx0ICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLmFiY2xpbmVbal0ubWlucGl0Y2gsIHRoaXMubWluWSk7XG4gIH1cblxuXHR2YXIgaXNGaXJzdFN0YWZmID0gKHMgPT09IDApO1xuXHR2YXIgcG9zID0gMDtcblx0d2hpbGUgKHBvcyA8IHRoaXMuYWJjbGluZS5sZW5ndGgpIHtcblx0XHR2YXIgcmV0ID0gZ2V0QmVhbUdyb3VwKHRoaXMuYWJjbGluZSwgcG9zKTtcblx0XHR2YXIgYWJzZWxlbXMgPSB0aGlzLmNyZWF0ZUFCQ0VsZW1lbnQoaXNGaXJzdFN0YWZmLCBpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UsIHJldC5lbGVtKTtcblx0XHRpZiAoYWJzZWxlbXMpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhYnNlbGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMudGVtcG9TZXQgJiYgdGVtcG8gJiYgIXRlbXBvLnN1cHByZXNzKSB7XG5cdFx0XHRcdFx0dGhpcy50ZW1wb1NldCA9IHRydWU7XG5cdFx0XHRcdFx0dmFyIHRlbXBvRWxlbWVudCA9IG5ldyBBYnNvbHV0ZUVsZW1lbnQocmV0LmVsZW0sIDAsIDAsIFwidGVtcG9cIiwgdGhpcy50dW5lTnVtYmVyLCB7fSk7XG5cdFx0XHRcdFx0dGVtcG9FbGVtZW50LmFkZENoaWxkKG5ldyBUZW1wb0VsZW1lbnQodGVtcG8sIHRoaXMudHVuZU51bWJlciwgY3JlYXRlTm90ZUhlYWQpKTtcblx0XHRcdFx0XHR2b2ljZS5hZGRDaGlsZCh0ZW1wb0VsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZvaWNlLmFkZENoaWxkKGFic2VsZW1zW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cG9zICs9IHJldC5jb3VudDtcblx0fVxuXHR0aGlzLnB1c2hDcm9zc0xpbmVFbGVtcyhzLCB2KTtcbn07XG5cblx0QWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aWVzU2F2ZSA9IHBhcnNlQ29tbW9uLmNsb25lQXJyYXkodGhpcy50aWVzKTtcblx0XHR0aGlzLnNsdXJzU2F2ZSA9IHBhcnNlQ29tbW9uLmNsb25lSGFzaE9mSGFzaCh0aGlzLnNsdXJzKTtcblx0XHR0aGlzLnNsdXJzYnl2b2ljZVNhdmUgPSBwYXJzZUNvbW1vbi5jbG9uZUhhc2hPZkhhc2godGhpcy5zbHVyc2J5dm9pY2UpO1xuXHRcdHRoaXMudGllc2J5dm9pY2VTYXZlID0gcGFyc2VDb21tb24uY2xvbmVIYXNoT2ZBcnJheU9mSGFzaCh0aGlzLnRpZXNieXZvaWNlKTtcblx0fTtcblxuXHRBYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpZXMgPSBwYXJzZUNvbW1vbi5jbG9uZUFycmF5KHRoaXMudGllc1NhdmUpO1xuXHRcdHRoaXMuc2x1cnMgPSBwYXJzZUNvbW1vbi5jbG9uZUhhc2hPZkhhc2godGhpcy5zbHVyc1NhdmUpO1xuXHRcdHRoaXMuc2x1cnNieXZvaWNlID0gcGFyc2VDb21tb24uY2xvbmVIYXNoT2ZIYXNoKHRoaXMuc2x1cnNieXZvaWNlU2F2ZSk7XG5cdFx0dGhpcy50aWVzYnl2b2ljZSA9IHBhcnNlQ29tbW9uLmNsb25lSGFzaE9mQXJyYXlPZkhhc2godGhpcy50aWVzYnl2b2ljZVNhdmUpO1xuXHR9O1xuXG5cdC8vIGZ1bmN0aW9uIHdyaXRlTWVhc3VyZVdpZHRoKHZvaWNlKSB7XG5cdC8vIFx0dmFyIHdpZHRoID0gMDtcblx0Ly8gXHRmb3IgKHZhciBpID0gdm9pY2UuY2hpbGRyZW4ubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG5cdC8vIFx0XHR2YXIgZWxlbSA9IHZvaWNlLmNoaWxkcmVuW2ldO1xuXHQvLyBcdFx0aWYgKGVsZW0uYWJjZWxlbS5lbF90eXBlID09PSAnYmFyJylcblx0Ly8gXHRcdFx0YnJlYWs7XG5cdC8vIFx0XHR3aWR0aCArPSBlbGVtLnc7XG5cdC8vIFx0fVxuXHQvLyBcdHJldHVybiBuZXcgUmVsYXRpdmVFbGVtZW50KHdpZHRoLnRvRml4ZWQoMiksIC03MCwgMCwgdW5kZWZpbmVkLCB7dHlwZTpcImRlYnVnXCJ9KTtcblx0Ly8gfVxuXG5cdC8vIHJldHVybiBhbiBhcnJheSBvZiBBYnNvbHV0ZUVsZW1lbnRcbkFic3RyYWN0RW5ncmF2ZXIucHJvdG90eXBlLmNyZWF0ZUFCQ0VsZW1lbnQgPSBmdW5jdGlvbihpc0ZpcnN0U3RhZmYsIGlzU2luZ2xlTGluZVN0YWZmLCB2b2ljZSwgZWxlbSkge1xuICB2YXIgZWxlbXNldCA9IFtdO1xuICBzd2l0Y2ggKGVsZW0uZWxfdHlwZSkge1xuXHQgIGNhc2UgdW5kZWZpbmVkOlxuXHQgIFx0Ly8gaXQgaXMgdW5kZWZpbmVkIGlmIHdlIHdlcmUgcGFzc2VkIGFuIGFycmF5IGluIC0gYW4gYXJyYXkgbWVhbnMgYSBzZXQgb2Ygbm90ZXMgdGhhdCBzaG91bGQgYmUgYmVhbWVkIHRvZ2V0aGVyLlxuXHRcdCAgZWxlbXNldCA9IHRoaXMuY3JlYXRlQmVhbShpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UsIGVsZW0pO1xuXHQgIFx0YnJlYWs7XG4gIGNhc2UgXCJub3RlXCI6XG5cdCAgZWxlbXNldFswXSA9IHRoaXMuY3JlYXRlTm90ZShlbGVtLCBmYWxzZSwgaXNTaW5nbGVMaW5lU3RhZmYsIHZvaWNlKTtcblx0ICBpZiAodGhpcy50cmlwbGV0ICYmIHRoaXMudHJpcGxldC5pc0Nsb3NlZCgpKSB7XG5cdFx0ICB2b2ljZS5hZGRPdGhlcih0aGlzLnRyaXBsZXQpO1xuXHRcdCAgdGhpcy50cmlwbGV0ID0gbnVsbDtcblx0XHQgIHRoaXMudHJpcGxldG11bHRpcGxpZXIgPSAxO1xuXHQgIH1cbiAgICBicmVhaztcbiAgY2FzZSBcImJhclwiOlxuICAgIGVsZW1zZXRbMF0gPSB0aGlzLmNyZWF0ZUJhckxpbmUodm9pY2UsIGVsZW0sIGlzRmlyc3RTdGFmZik7XG4gICAgaWYgKHZvaWNlLmR1cGxpY2F0ZSAmJiBlbGVtc2V0Lmxlbmd0aCA+IDApIGVsZW1zZXRbMF0uaW52aXNpYmxlID0gdHJ1ZTtcbi8vXHQgIGVsZW1zZXRbMF0uYWRkQ2hpbGQod3JpdGVNZWFzdXJlV2lkdGgodm9pY2UpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIm1ldGVyXCI6XG4gICAgZWxlbXNldFswXSA9IGNyZWF0ZVRpbWVTaWduYXR1cmUoZWxlbSwgdGhpcy50dW5lTnVtYmVyKTtcblx0ICB0aGlzLnN0YXJ0bGltaXRlbGVtID0gZWxlbXNldFswXTsgLy8gbGltaXQgdGllcyBoZXJlXG4gICAgaWYgKHZvaWNlLmR1cGxpY2F0ZSAmJiBlbGVtc2V0Lmxlbmd0aCA+IDApIGVsZW1zZXRbMF0uaW52aXNpYmxlID0gdHJ1ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcImNsZWZcIjpcbiAgICBlbGVtc2V0WzBdID0gY3JlYXRlQ2xlZihlbGVtLCB0aGlzLnR1bmVOdW1iZXIpO1xuXHQgIGlmICghZWxlbXNldFswXSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZvaWNlLmR1cGxpY2F0ZSAmJiBlbGVtc2V0Lmxlbmd0aCA+IDApIGVsZW1zZXRbMF0uaW52aXNpYmxlID0gdHJ1ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcImtleVwiOlxuXHQgIHZhciBhYnNLZXkgPSBjcmVhdGVLZXlTaWduYXR1cmUoZWxlbSwgdGhpcy50dW5lTnVtYmVyKTtcblx0ICBpZiAoYWJzS2V5KSB7XG5cdFx0ICBlbGVtc2V0WzBdID0gYWJzS2V5O1xuXHRcdCAgdGhpcy5zdGFydGxpbWl0ZWxlbSA9IGVsZW1zZXRbMF07IC8vIGxpbWl0IHRpZXMgaGVyZVxuXHQgIH1cbiAgICBpZiAodm9pY2UuZHVwbGljYXRlICYmIGVsZW1zZXQubGVuZ3RoID4gMCkgZWxlbXNldFswXS5pbnZpc2libGUgPSB0cnVlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwic3RlbVwiOlxuICAgIHRoaXMuc3RlbWRpcj1lbGVtLmRpcmVjdGlvbjtcbiAgICBicmVhaztcbiAgY2FzZSBcInBhcnRcIjpcbiAgICB2YXIgYWJzZWxlbSA9IG5ldyBBYnNvbHV0ZUVsZW1lbnQoZWxlbSwwLDAsICdwYXJ0JywgdGhpcy50dW5lTnVtYmVyKTtcblx0ICB2YXIgZGltID0gdGhpcy5yZW5kZXJlci5nZXRUZXh0U2l6ZShlbGVtLnRpdGxlLCAncGFydHNmb250JywgXCJwYXJ0XCIpO1xuICAgIGFic2VsZW0uYWRkQ2hpbGQobmV3IFJlbGF0aXZlRWxlbWVudChlbGVtLnRpdGxlLCAwLCAwLCB1bmRlZmluZWQsIHt0eXBlOlwicGFydFwiLCBoZWlnaHQ6IGRpbS5oZWlnaHQvc3BhY2luZy5TVEVQfSkpO1xuICAgIGVsZW1zZXRbMF0gPSBhYnNlbGVtO1xuICAgIGJyZWFrO1xuICBjYXNlIFwidGVtcG9cIjpcbiAgICB2YXIgYWJzZWxlbTMgPSBuZXcgQWJzb2x1dGVFbGVtZW50KGVsZW0sMCwwLCAndGVtcG8nLCB0aGlzLnR1bmVOdW1iZXIpO1xuICAgIGFic2VsZW0zLmFkZENoaWxkKG5ldyBUZW1wb0VsZW1lbnQoZWxlbSwgdGhpcy50dW5lTnVtYmVyLCBjcmVhdGVOb3RlSGVhZCkpO1xuICAgIGVsZW1zZXRbMF0gPSBhYnNlbGVtMztcbiAgICBicmVhaztcblx0ICBjYXNlIFwic3R5bGVcIjpcblx0XHQgIGlmIChlbGVtLmhlYWQgPT09IFwibm9ybWFsXCIpXG5cdFx0XHQgIGRlbGV0ZSB0aGlzLnN0eWxlO1xuXHRcdCAgZWxzZVxuXHRcdFx0ICB0aGlzLnN0eWxlID0gZWxlbS5oZWFkO1xuXHRcdCAgYnJlYWs7XG5cdCAgY2FzZSBcImhpbnRcIjpcblx0XHQgIGhpbnQgPSB0cnVlO1xuXHRcdCAgdGhpcy5zYXZlU3RhdGUoKTtcblx0XHQgIGJyZWFrO1xuXHQgIGNhc2UgXCJtaWRpXCI6XG5cdFx0Ly8gVGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSB2aXNpYmxlIG11c2ljLCBzbyBqdXN0IHNraXAgaXQuXG5cdFx0YnJlYWs7XG5cdCAgY2FzZSBcInNjYWxlXCI6XG5cdCAgXHR0aGlzLnZvaWNlU2NhbGUgPSBlbGVtLnNpemU7XG5cdCAgXHRicmVhaztcblxuICBkZWZhdWx0OlxuICAgIHZhciBhYnNlbGVtMiA9IG5ldyBBYnNvbHV0ZUVsZW1lbnQoZWxlbSwwLDAsICd1bnN1cHBvcnRlZCcsIHRoaXMudHVuZU51bWJlcik7XG4gICAgYWJzZWxlbTIuYWRkQ2hpbGQobmV3IFJlbGF0aXZlRWxlbWVudChcImVsZW1lbnQgdHlwZSBcIitlbGVtLmVsX3R5cGUsIDAsIDAsIHVuZGVmaW5lZCwge3R5cGU6XCJkZWJ1Z1wifSkpO1xuICAgIGVsZW1zZXRbMF0gPSBhYnNlbGVtMjtcbiAgfVxuXG4gIHJldHVybiBlbGVtc2V0O1xufTtcblxuXHRmdW5jdGlvbiBzZXRBdmVyYWdlUGl0Y2goZWxlbSkge1xuXHRcdGlmIChlbGVtLnBpdGNoZXMpIHtcblx0XHRcdHNvcnRQaXRjaChlbGVtKTtcblx0XHRcdHZhciBzdW0gPSAwO1xuXHRcdFx0Zm9yICh2YXIgcCA9IDA7IHAgPCBlbGVtLnBpdGNoZXMubGVuZ3RoOyBwKyspIHtcblx0XHRcdFx0c3VtICs9IGVsZW0ucGl0Y2hlc1twXS52ZXJ0aWNhbFBvcztcblx0XHRcdH1cblx0XHRcdGVsZW0uYXZlcmFnZXBpdGNoID0gc3VtIC8gZWxlbS5waXRjaGVzLmxlbmd0aDtcblx0XHRcdGVsZW0ubWlucGl0Y2ggPSBlbGVtLnBpdGNoZXNbMF0udmVydGljYWxQb3M7XG5cdFx0XHRlbGVtLm1heHBpdGNoID0gZWxlbS5waXRjaGVzW2VsZW0ucGl0Y2hlcy5sZW5ndGggLSAxXS52ZXJ0aWNhbFBvcztcblx0XHR9XG5cdH1cblxuXHRBYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5jYWxjQmVhbURpciA9IGZ1bmN0aW9uIChpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UsIGVsZW1zKSB7XG5cdFx0aWYgKHRoaXMuc3RlbWRpcikgLy8gSWYgdGhlIHVzZXIgb3Igdm9pY2UgaXMgZm9yY2luZyB0aGUgc3RlbSBkaXJlY3Rpb24sIHdlIGFscmVhZHkga25vdyB0aGUgYW5zd2VyLlxuXHRcdFx0cmV0dXJuIHRoaXMuc3RlbWRpcjtcblx0XHR2YXIgYmVhbWVsZW0gPSBuZXcgQmVhbUVsZW0odGhpcy5zdGVtSGVpZ2h0ICogdGhpcy52b2ljZVNjYWxlLCB0aGlzLnN0ZW1kaXIsIHRoaXMuZmxhdEJlYW1zKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRiZWFtZWxlbS5hZGQoe2FiY2VsZW06IGVsZW1zW2ldfSk7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIGNhbGwgYmVhbSBlbGVtIHdpdGgganVzdCBhIG1pbmltdW0gb2YgcHJvY2Vzc2luZzogZm9yIG91ciBwdXJwb3Nlcywgd2UgZG9uJ3QgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIHdob2xlIG5vdGUuXG5cdFx0fVxuXG5cdFx0dmFyIGRpciA9IGJlYW1lbGVtLmNhbGNEaXIoKTtcblx0XHRyZXR1cm4gZGlyID8gXCJ1cFwiIDogXCJkb3duXCI7XG5cdH07XG5cblx0QWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuY3JlYXRlQmVhbSA9IGZ1bmN0aW9uIChpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UsIGVsZW1zKSB7XG5cdFx0dmFyIGFic2VsZW1zZXQgPSBbXTtcblxuXHRcdHZhciBkaXIgPSB0aGlzLmNhbGNCZWFtRGlyKGlzU2luZ2xlTGluZVN0YWZmLCB2b2ljZSwgZWxlbXMpO1xuXHRcdHZhciBiZWFtZWxlbSA9IG5ldyBCZWFtRWxlbSh0aGlzLnN0ZW1IZWlnaHQgKiB0aGlzLnZvaWNlU2NhbGUsIGRpciwgdGhpcy5mbGF0QmVhbXMpO1xuXHRcdGlmIChoaW50KSBiZWFtZWxlbS5zZXRIaW50KCk7XG5cdFx0dmFyIG9sZERpciA9IHRoaXMuc3RlbWRpcjtcblx0XHR0aGlzLnN0ZW1kaXIgPSBkaXI7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGVsZW0gPSBlbGVtc1tpXTtcblx0XHRcdHZhciBhYnNlbGVtID0gdGhpcy5jcmVhdGVOb3RlKGVsZW0sIHRydWUsIGlzU2luZ2xlTGluZVN0YWZmLCB2b2ljZSk7XG5cdFx0XHRhYnNlbGVtc2V0LnB1c2goYWJzZWxlbSk7XG5cdFx0XHRiZWFtZWxlbS5hZGQoYWJzZWxlbSk7XG5cdFx0XHRpZiAodGhpcy50cmlwbGV0ICYmIHRoaXMudHJpcGxldC5pc0Nsb3NlZCgpKSB7XG5cdFx0XHRcdHZvaWNlLmFkZE90aGVyKHRoaXMudHJpcGxldCk7XG5cdFx0XHRcdHRoaXMudHJpcGxldCA9IG51bGw7XG5cdFx0XHRcdHRoaXMudHJpcGxldG11bHRpcGxpZXIgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnN0ZW1kaXIgPSBvbGREaXI7XG5cdFx0dm9pY2UuYWRkQmVhbShiZWFtZWxlbSk7XG5cdFx0cmV0dXJuIGFic2VsZW1zZXQ7XG5cdH07XG5cbnZhciBzb3J0UGl0Y2ggPSBmdW5jdGlvbihlbGVtKSB7XG4gIHZhciBzb3J0ZWQ7XG4gIGRvIHtcbiAgICBzb3J0ZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIHAgPSAwOyBwPGVsZW0ucGl0Y2hlcy5sZW5ndGgtMTsgcCsrKSB7XG4gICAgICBpZiAoZWxlbS5waXRjaGVzW3BdLnBpdGNoPmVsZW0ucGl0Y2hlc1twKzFdLnBpdGNoKSB7XG4gICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdG1wID0gZWxlbS5waXRjaGVzW3BdO1xuICAgICAgICBlbGVtLnBpdGNoZXNbcF0gPSBlbGVtLnBpdGNoZXNbcCsxXTtcbiAgICAgICAgZWxlbS5waXRjaGVzW3ArMV0gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICghc29ydGVkKTtcbn07XG5cbnZhciBsZWRnZXJMaW5lcyA9IGZ1bmN0aW9uKGFic2VsZW0sIG1pblBpdGNoLCBtYXhQaXRjaCwgaXNSZXN0LCBzeW1ib2xXaWR0aCwgYWRkaXRpb25hbExlZGdlcnMsIGRpciwgZHgsIHNjYWxlKSB7XG5cdGZvciAodmFyIGk9bWF4UGl0Y2g7IGk+MTE7IGktLSkge1xuXHRcdGlmIChpJTI9PT0wICYmICFpc1Jlc3QpIHtcblx0XHRcdGFic2VsZW0uYWRkQ2hpbGQobmV3IFJlbGF0aXZlRWxlbWVudChudWxsLCBkeCwgKHN5bWJvbFdpZHRoKzQpKnNjYWxlLCBpLCB7dHlwZTpcImxlZGdlclwifSkpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaT1taW5QaXRjaDsgaTwxOyBpKyspIHtcblx0XHRpZiAoaSUyPT09MCAmJiAhaXNSZXN0KSB7XG5cdFx0XHRhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQobnVsbCwgZHgsIChzeW1ib2xXaWR0aCs0KSpzY2FsZSwgaSwge3R5cGU6XCJsZWRnZXJcIn0pKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgYWRkaXRpb25hbExlZGdlcnMubGVuZ3RoOyBpKyspIHsgLy8gUEVSOiBkcmF3IGFkZGl0aW9uYWwgbGVkZ2Vyc1xuXHRcdHZhciBvZnMgPSBzeW1ib2xXaWR0aDtcblx0XHRpZiAoZGlyID09PSAnZG93bicpIG9mcyA9IC1vZnM7XG5cdFx0YWJzZWxlbS5hZGRDaGlsZChuZXcgUmVsYXRpdmVFbGVtZW50KG51bGwsIG9mcytkeCwgKHN5bWJvbFdpZHRoKzQpKnNjYWxlLCBhZGRpdGlvbmFsTGVkZ2Vyc1tpXSwge3R5cGU6XCJsZWRnZXJcIn0pKTtcblx0fVxufTtcblxuXHRBYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5hZGRHcmFjZU5vdGVzID0gZnVuY3Rpb24gKGVsZW0sIHZvaWNlLCBhYnNlbGVtLCBub3RlaGVhZCwgc3RlbUhlaWdodCwgaXNCYWdwaXBlcywgcm9vbXRha2VuKSB7XG5cdFx0dmFyIGdyYWNlc2NhbGUgPSAzIC8gNTtcblx0XHR2YXIgZ3JhY2VTY2FsZVN0ZW0gPSAzLjUgLyA1OyAvLyBUT0RPLVBFUjogZW1waXJpY2FsbHkgZm91bmQgY29uc3RhbnQuXG5cdFx0dmFyIGdyYWNlYmVhbSA9IG51bGw7XG5cdFx0dmFyIGZsYWc7XG5cblx0XHRpZiAoZWxlbS5ncmFjZW5vdGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGdyYWNlYmVhbSA9IG5ldyBCZWFtRWxlbShzdGVtSGVpZ2h0ICogZ3JhY2VTY2FsZVN0ZW0sIFwiZ3JhY2VcIiwgaXNCYWdwaXBlcyk7XG5cdFx0XHRpZiAoaGludCkgZ3JhY2ViZWFtLnNldEhpbnQoKTtcblx0XHRcdGdyYWNlYmVhbS5tYWluTm90ZSA9IGFic2VsZW07XHQvLyB0aGlzIGdpdmVzIHVzIGEgcmVmZXJlbmNlIGJhY2sgdG8gdGhlIG5vdGUgdGhpcyBpcyBhdHRhY2hlZCB0byBzbyB0aGF0IHRoZSBzdGVtcyBjYW4gYmUgYXR0YWNoZWQgc29tZXdoZXJlLlxuXHRcdH1cblxuXHRcdHZhciBncmFjZW9mZnNldHMgPSBbXTtcblx0XHRmb3IgKGkgPSBlbGVtLmdyYWNlbm90ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgLy8gZmlndXJlIG91dCB3aGVyZSB0byBwbGFjZSBlYWNoIGdyYWNlbm90ZVxuXHRcdFx0cm9vbXRha2VuICs9IDEwO1xuXHRcdFx0Z3JhY2VvZmZzZXRzW2ldID0gcm9vbXRha2VuO1xuXHRcdFx0aWYgKGVsZW0uZ3JhY2Vub3Rlc1tpXS5hY2NpZGVudGFsKSB7XG5cdFx0XHRcdHJvb210YWtlbiArPSA3O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlbGVtLmdyYWNlbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBncmFjZXBpdGNoID0gZWxlbS5ncmFjZW5vdGVzW2ldLnZlcnRpY2FsUG9zO1xuXG5cdFx0XHRmbGFnID0gKGdyYWNlYmVhbSkgPyBudWxsIDogY2hhcnRhYmxlLnVmbGFnc1soaXNCYWdwaXBlcykgPyA1IDogM107XG5cdFx0XHR2YXIgYWNjaWRlbnRhbFNsb3QgPSBbXTtcblx0XHRcdHZhciByZXQgPSBjcmVhdGVOb3RlSGVhZChhYnNlbGVtLCBcIm5vdGVoZWFkcy5xdWFydGVyXCIsIGVsZW0uZ3JhY2Vub3Rlc1tpXSwgXCJ1cFwiLCAtZ3JhY2VvZmZzZXRzW2ldLCAtZ3JhY2VvZmZzZXRzW2ldLCBmbGFnLCAwLCAwLCBncmFjZXNjYWxlKnRoaXMudm9pY2VTY2FsZSwgYWNjaWRlbnRhbFNsb3QsIGZhbHNlKTtcblx0XHRcdHJldC5ub3RlaGVhZC5oaWdoZXN0VmVydCA9IHJldC5ub3RlaGVhZC5waXRjaCArIHN0ZW1IZWlnaHQgKiBncmFjZVNjYWxlU3RlbTtcblx0XHRcdHZhciBncmFjZSA9IHJldC5ub3RlaGVhZDtcblx0XHRcdHRoaXMuYWRkU2x1cnNBbmRUaWVzKGFic2VsZW0sIGVsZW0uZ3JhY2Vub3Rlc1tpXSwgZ3JhY2UsIHZvaWNlLCBcInVwXCIsIHRydWUpO1xuXG5cdFx0XHRhYnNlbGVtLmFkZEV4dHJhKGdyYWNlKTtcblx0XHRcdC8vIFBFUjogYWRkZWQgYWNjaWFjY2F0dXJhIHNsYXNoXG5cdFx0XHRpZiAoZWxlbS5ncmFjZW5vdGVzW2ldLmFjY2lhY2NhdHVyYSkge1xuXHRcdFx0XHR2YXIgcG9zID0gZWxlbS5ncmFjZW5vdGVzW2ldLnZlcnRpY2FsUG9zICsgNyAqIGdyYWNlc2NhbGU7ICAgICAgICAvLyB0aGUgc2FtZSBmb3JtdWxhIHRoYXQgZGV0ZXJtaW5lcyB0aGUgZmxhZyBwb3NpdGlvbi5cblx0XHRcdFx0dmFyIGRBY2NpYWNjYXR1cmEgPSBncmFjZWJlYW0gPyA1IDogNjsgICAgICAgIC8vIGp1c3QgYW4gb2Zmc2V0IHRvIG1ha2UgaXQgbGluZSB1cCBjb3JyZWN0bHkuXG5cdFx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChcImZsYWdzLnVncmFjZVwiLCAtZ3JhY2VvZmZzZXRzW2ldICsgZEFjY2lhY2NhdHVyYSwgMCwgcG9zLCB7c2NhbGV4OiBncmFjZXNjYWxlLCBzY2FsZXk6IGdyYWNlc2NhbGV9KSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3JhY2ViZWFtKSB7IC8vIGdpdmUgdGhlIGJlYW0gdGhlIG5lY2Vzc2FyeSBpbmZvXG5cdFx0XHRcdHZhciBncmFjZUR1cmF0aW9uID0gZWxlbS5ncmFjZW5vdGVzW2ldLmR1cmF0aW9uIC8gMjtcblx0XHRcdFx0aWYgKGlzQmFncGlwZXMpIGdyYWNlRHVyYXRpb24gLz0gMjtcblx0XHRcdFx0dmFyIHBzZXVkb2Fic2VsZW0gPSB7XG5cdFx0XHRcdFx0aGVhZHM6IFtncmFjZV0sXG5cdFx0XHRcdFx0YWJjZWxlbToge2F2ZXJhZ2VwaXRjaDogZ3JhY2VwaXRjaCwgbWlucGl0Y2g6IGdyYWNlcGl0Y2gsIG1heHBpdGNoOiBncmFjZXBpdGNoLCBkdXJhdGlvbjogZ3JhY2VEdXJhdGlvbn1cblx0XHRcdFx0fTtcblx0XHRcdFx0Z3JhY2ViZWFtLmFkZChwc2V1ZG9hYnNlbGVtKTtcblx0XHRcdH0gZWxzZSB7IC8vIGRyYXcgdGhlIHN0ZW1cblx0XHRcdFx0dmFyIHAxID0gZ3JhY2VwaXRjaCArIDEgLyAzICogZ3JhY2VzY2FsZTtcblx0XHRcdFx0dmFyIHAyID0gZ3JhY2VwaXRjaCArIDcgKiBncmFjZXNjYWxlO1xuXHRcdFx0XHR2YXIgZHggPSBncmFjZS5keCArIGdyYWNlLnc7XG5cdFx0XHRcdHZhciB3aWR0aCA9IC0wLjY7XG5cdFx0XHRcdGFic2VsZW0uYWRkRXh0cmEobmV3IFJlbGF0aXZlRWxlbWVudChudWxsLCBkeCwgMCwgcDEsIHtcInR5cGVcIjogXCJzdGVtXCIsIFwicGl0Y2gyXCI6IHAyLCBsaW5ld2lkdGg6IHdpZHRofSkpO1xuXHRcdFx0fVxuXHRcdFx0bGVkZ2VyTGluZXMoYWJzZWxlbSwgZ3JhY2VwaXRjaCwgZ3JhY2VwaXRjaCwgZmFsc2UsIGdseXBocy5nZXRTeW1ib2xXaWR0aChcIm5vdGVoZWFkcy5xdWFydGVyXCIpLCBbXSwgdHJ1ZSwgZ3JhY2UuZHggLSAxLCAwLjYpO1xuXG5cdFx0XHRpZiAoaSA9PT0gMCAmJiAhaXNCYWdwaXBlcyAmJiAhKGVsZW0ucmVzdCAmJiAoZWxlbS5yZXN0LnR5cGUgPT09IFwic3BhY2VyXCIgfHwgZWxlbS5yZXN0LnR5cGUgPT09IFwiaW52aXNpYmxlXCIpKSkge1xuXHRcdFx0XHQvLyBUaGlzIGlzIHRoZSBvdmVyYWxsIHNsdXIgdGhhdCBpcyB1bmRlciB0aGUgZ3JhY2Ugbm90ZXMuXG5cdFx0XHRcdHZhciBpc1RpZSA9IChlbGVtLmdyYWNlbm90ZXMubGVuZ3RoID09PSAxICYmIGdyYWNlLnBpdGNoID09PSBub3RlaGVhZC5waXRjaCk7XG5cdFx0XHRcdHZvaWNlLmFkZE90aGVyKG5ldyBUaWVFbGVtKHsgYW5jaG9yMTogZ3JhY2UsIGFuY2hvcjI6IG5vdGVoZWFkLCBpc0dyYWNlOiB0cnVlfSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChncmFjZWJlYW0pIHtcblx0XHRcdHZvaWNlLmFkZEJlYW0oZ3JhY2ViZWFtKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvb210YWtlbjtcblx0fTtcblxuXHRmdW5jdGlvbiBhZGRSZXN0VG9BYnNFbGVtZW50KGFic2VsZW0sIGVsZW0sIGR1cmF0aW9uLCBkb3QsIGlzTXVsdGlWb2ljZSwgc3RlbWRpciwgaXNTaW5nbGVMaW5lU3RhZmYsIGR1cmxvZywgdm9pY2VTY2FsZSkge1xuXHRcdHZhciBjO1xuXHRcdHZhciByZXN0cGl0Y2ggPSA3O1xuXHRcdHZhciBub3RlSGVhZDtcblx0XHR2YXIgcm9vbVRha2VuO1xuXHRcdHZhciByb29tVGFrZW5SaWdodDtcblxuXHRcdGlmIChpc011bHRpVm9pY2UpIHtcblx0XHRcdGlmIChzdGVtZGlyID09PSBcImRvd25cIikgcmVzdHBpdGNoID0gMztcblx0XHRcdGlmIChzdGVtZGlyID09PSBcInVwXCIpIHJlc3RwaXRjaCA9IDExO1xuXHRcdH1cblx0XHQvLyBUaGVyZSBpcyBzcGVjaWFsIHBsYWNlbWVudCBmb3IgdGhlIHBlcmN1c3Npb24gc3RhZmYuIElmIHRoZXJlIGlzIG9uZSBzdGFmZiBsaW5lLCB0aGVuIG1vdmUgdGhlIHJlc3QgcG9zaXRpb24uXG5cdFx0aWYgKGlzU2luZ2xlTGluZVN0YWZmKSB7XG5cdFx0XHQvLyBUaGUgaGFsZiBhbmQgd2hvbGUgcmVzdHMgYXJlIGF0dGFjaGVkIHRvIGRpZmZlcmVudCBsaW5lcyBub3JtYWxseSwgc28gd2UgbmVlZCB0byB0d2VhayB0aGVpciBwb3NpdGlvbiB0byBnZXQgdGhlbSB0byBib3RoIGJlIGF0dGFjaGVkIHRvIHRoZSBzYW1lIG9uZS5cblx0XHRcdGlmIChkdXJhdGlvbiA8IDAuNSlcblx0XHRcdFx0cmVzdHBpdGNoID0gNztcblx0XHRcdGVsc2UgaWYgKGR1cmF0aW9uIDwgMSlcblx0XHRcdFx0cmVzdHBpdGNoID0gNztcdC8vIGhhbGYgcmVzdFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXN0cGl0Y2ggPSA1OyAvLyB3aG9sZSByZXN0XG5cdFx0fVxuXHRcdHN3aXRjaCAoZWxlbS5yZXN0LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJ3aG9sZVwiOlxuXHRcdFx0XHRjID0gY2hhcnRhYmxlLnJlc3RbMF07XG5cdFx0XHRcdGVsZW0uYXZlcmFnZXBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRlbGVtLm1pbnBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRlbGVtLm1heHBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRkb3QgPSAwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJyZXN0XCI6XG5cdFx0XHRcdGlmIChlbGVtLnN0eWxlID09PSBcInJoeXRobVwiKSAvLyBzcGVjaWFsIGNhc2UgZm9yIHJoeXRobTogcmVzdHMgYXJlIGEgaGFuZHkgd2F5IHRvIGV4cHJlc3MgdGhlIHJoeXRobS5cblx0XHRcdFx0XHRjID0gY2hhcnRhYmxlLnJoeXRobVstZHVybG9nXTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGMgPSBjaGFydGFibGUucmVzdFstZHVybG9nXTtcblx0XHRcdFx0ZWxlbS5hdmVyYWdlcGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGVsZW0ubWlucGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGVsZW0ubWF4cGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImludmlzaWJsZVwiOlxuXHRcdFx0Y2FzZSBcInNwYWNlclwiOlxuXHRcdFx0XHRjID0gXCJcIjtcblx0XHRcdFx0ZWxlbS5hdmVyYWdlcGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGVsZW0ubWlucGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGVsZW0ubWF4cGl0Y2ggPSByZXN0cGl0Y2g7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm11bHRpbWVhc3VyZVwiOlxuXHRcdFx0XHRjID0gY2hhcnRhYmxlLnJlc3RbJ211bHRpJ107XG5cdFx0XHRcdGVsZW0uYXZlcmFnZXBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRlbGVtLm1pbnBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRlbGVtLm1heHBpdGNoID0gcmVzdHBpdGNoO1xuXHRcdFx0XHRkb3QgPSAwO1xuXHRcdFx0XHR2YXIgbW1XaWR0aCA9IGdseXBocy5nZXRTeW1ib2xXaWR0aChjKTtcblx0XHRcdFx0YWJzZWxlbS5hZGRIZWFkKG5ldyBSZWxhdGl2ZUVsZW1lbnQoYywgLW1tV2lkdGgsIG1tV2lkdGggKiAyLCA3KSk7XG5cdFx0XHRcdHZhciBudW1NZWFzdXJlcyA9IG5ldyBSZWxhdGl2ZUVsZW1lbnQoXCJcIiArIGVsZW0uZHVyYXRpb24sIDAsIG1tV2lkdGgsIDE2LCB7dHlwZTogXCJtdWx0aW1lYXN1cmUtdGV4dFwifSk7XG5cdFx0XHRcdGFic2VsZW0uYWRkRXh0cmEobnVtTWVhc3VyZXMpO1xuXHRcdH1cblx0XHRpZiAoZWxlbS5yZXN0LnR5cGUgIT09IFwibXVsdGltZWFzdXJlXCIpIHtcblx0XHRcdHZhciByZXQgPSBjcmVhdGVOb3RlSGVhZChhYnNlbGVtLCBjLCB7dmVydGljYWxQb3M6IHJlc3RwaXRjaH0sIG51bGwsIDAsIDAsIG51bGwsIGRvdCwgMCwgdm9pY2VTY2FsZSwgW10sIGZhbHNlKTtcblx0XHRcdG5vdGVIZWFkID0gcmV0Lm5vdGVoZWFkO1xuXHRcdFx0aWYgKG5vdGVIZWFkKSB7XG5cdFx0XHRcdGFic2VsZW0uYWRkSGVhZChub3RlSGVhZCk7XG5cdFx0XHRcdHJvb21UYWtlbiA9IHJldC5hY2NpZGVudGFsc2hpZnR4O1xuXHRcdFx0XHRyb29tVGFrZW5SaWdodCA9IHJldC5kb3RzaGlmdHg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7IG5vdGVIZWFkOiBub3RlSGVhZCwgcm9vbVRha2VuOiByb29tVGFrZW4sIHJvb21UYWtlblJpZ2h0OiByb29tVGFrZW5SaWdodCB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkSWZOb3RFeGlzdChhcnIsIGl0ZW0pIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKEpTT04uc3RyaW5naWZ5KGFycltpXSkgPT09IEpTT04uc3RyaW5naWZ5KGl0ZW0pKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGFyci5wdXNoKGl0ZW0pO1xuXHR9XG5cblx0QWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuYWRkTm90ZVRvQWJjRWxlbWVudCA9IGZ1bmN0aW9uKGFic2VsZW0sIGVsZW0sIGRvdCwgc3RlbWRpciwgc3R5bGUsIHplcm9EdXJhdGlvbiwgZHVybG9nLCBub3N0ZW0sIHZvaWNlKSB7XG5cdFx0dmFyIGRvdHNoaWZ0eCA9IDA7IC8vIHJvb20gdGFrZW4gYnkgY2hvcmRzIHdpdGggZGlzcGxhY2VkIG5vdGVoZWFkcyB3aGljaCBjYXVzZSBkb3RzIHRvIHNoaWZ0XG5cdFx0dmFyIG5vdGVIZWFkO1xuXHRcdHZhciByb29tVGFrZW4gPSAwO1xuXHRcdHZhciByb29tVGFrZW5SaWdodCA9IDA7XG5cdFx0dmFyIG1pbjtcblx0XHR2YXIgaTtcblx0XHR2YXIgYWRkaXRpb25hbExlZGdlcnMgPSBbXTtcblx0XHQvLyBUaGUgYWNjaWRlbnRhbFNsb3Qgd2lsbCBob2xkIGEgbGlzdCBvZiBhbGwgdGhlIGFjY2lkZW50YWxzIG9uIHRoaXMgY2hvcmQuIEVhY2ggZWxlbWVudCBpcyBhIHZlcnRpY2FsIHBsYWNlLFxuXHRcdC8vIGFuZCBjb250YWlucyBhIHBpdGNoLCB3aGljaCBpcyB0aGUgbGFzdCBwaXRjaCB0aGF0IGNvbnRhaW5zIGFuIGFjY2lkZW50YWwgaW4gdGhhdCBzbG90LiBUaGUgc2xvdHMgYXJlIG51bWJlcmVkXG5cdFx0Ly8gZnJvbSBjbG9zZXN0IHRvIHRoZSBub3RlIHRvIGZhcnRoZXIgbGVmdC4gV2Ugb25seSBuZWVkIHRvIGtub3cgdGhlIGxhc3QgYWNjaWRlbnRhbCB3ZSBwbGFjZWQgYmVjYXVzZVxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aGUgcGl0Y2hlcyBhcmUgc29ydGVkIGJ5IG5vdy5cblx0XHR2YXIgYWNjaWRlbnRhbFNsb3QgPSBbXTtcblx0XHR2YXIgc3ltYm9sV2lkdGggPSAwO1xuXG5cdFx0dmFyIGRpciA9IChlbGVtLmF2ZXJhZ2VwaXRjaD49NikgPyBcImRvd25cIjogXCJ1cFwiO1xuXHRcdGlmIChzdGVtZGlyKSBkaXI9c3RlbWRpcjtcblxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSA/IGVsZW0uc3R5bGUgOiBzdHlsZTsgLy8gZ2V0IHRoZSBzdHlsZSBvZiBub3RlIGhlYWQuXG5cdFx0aWYgKCFzdHlsZSB8fCBzdHlsZSA9PT0gXCJub3JtYWxcIikgc3R5bGUgPSBcIm5vdGVcIjtcblx0XHR2YXIgbm90ZVN5bWJvbDtcblx0XHRpZiAoemVyb0R1cmF0aW9uKVxuXHRcdFx0bm90ZVN5bWJvbCA9IGNoYXJ0YWJsZVtzdHlsZV0ubm9zdGVtO1xuXHRcdGVsc2Vcblx0XHRcdG5vdGVTeW1ib2wgPSBjaGFydGFibGVbc3R5bGVdWy1kdXJsb2ddO1xuXHRcdGlmICghbm90ZVN5bWJvbClcblx0XHRcdGNvbnNvbGUubG9nKFwibm90ZVN5bWJvbDpcIiwgc3R5bGUsIGR1cmxvZywgemVyb0R1cmF0aW9uKTtcblxuXHRcdC8vIGRldGVybWluZSBlbGVtZW50cyBvZiBjaG9yZHMgd2hpY2ggc2hvdWxkIGJlIHNoaWZ0ZWRcblx0XHR2YXIgcDtcblx0XHRmb3IgKHA9KGRpcj09PVwiZG93blwiKT9lbGVtLnBpdGNoZXMubGVuZ3RoLTI6MTsgKGRpcj09PVwiZG93blwiKT9wPj0wOnA8ZWxlbS5waXRjaGVzLmxlbmd0aDsgcD0oZGlyPT09XCJkb3duXCIpP3AtMTpwKzEpIHtcblx0XHRcdHZhciBwcmV2ID0gZWxlbS5waXRjaGVzWyhkaXI9PT1cImRvd25cIik/cCsxOnAtMV07XG5cdFx0XHR2YXIgY3VyciA9IGVsZW0ucGl0Y2hlc1twXTtcblx0XHRcdHZhciBkZWx0YSA9IChkaXI9PT1cImRvd25cIik/cHJldi5waXRjaC1jdXJyLnBpdGNoOmN1cnIucGl0Y2gtcHJldi5waXRjaDtcblx0XHRcdGlmIChkZWx0YTw9MSAmJiAhcHJldi5wcmludGVyX3NoaWZ0KSB7XG5cdFx0XHRcdGN1cnIucHJpbnRlcl9zaGlmdD0oZGVsdGEpP1wiZGlmZmVyZW50XCI6XCJzYW1lXCI7XG5cdFx0XHRcdGlmIChjdXJyLnZlcnRpY2FsUG9zID4gMTEgfHwgY3Vyci52ZXJ0aWNhbFBvcyA8IDEpIHsgICAgICAgIC8vIFBFUjogYWRkIGV4dHJhIGxlZGdlciBsaW5lXG5cdFx0XHRcdFx0YWRkaXRpb25hbExlZGdlcnMucHVzaChjdXJyLnZlcnRpY2FsUG9zIC0gKGN1cnIudmVydGljYWxQb3MlMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkaXI9PT1cImRvd25cIikge1xuXHRcdFx0XHRcdHJvb21UYWtlbiA9IGdseXBocy5nZXRTeW1ib2xXaWR0aChub3RlU3ltYm9sKSsyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvdHNoaWZ0eCA9IGdseXBocy5nZXRTeW1ib2xXaWR0aChub3RlU3ltYm9sKSsyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHBwID0gZWxlbS5waXRjaGVzLmxlbmd0aDtcblx0XHRmb3IgKHA9MDsgcDxlbGVtLnBpdGNoZXMubGVuZ3RoOyBwKyspIHtcblxuXHRcdFx0aWYgKCFub3N0ZW0pIHtcblx0XHRcdFx0dmFyIGZsYWc7XG5cdFx0XHRcdGlmICgoZGlyPT09XCJkb3duXCIgJiYgcCE9PTApIHx8IChkaXI9PT1cInVwXCIgJiYgcCE9PXBwLTEpKSB7IC8vIG5vdCB0aGUgc3RlbW1lZCBlbGVtIG9mIHRoZSBjaG9yZFxuXHRcdFx0XHRcdGZsYWcgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZsYWcgPSBjaGFydGFibGVbKGRpcj09PVwiZG93blwiKT9cImRmbGFnc1wiOlwidWZsYWdzXCJdWy1kdXJsb2ddO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgYztcblx0XHRcdGlmIChlbGVtLnBpdGNoZXNbcF0uc3R5bGUpIHsgLy8gVGhlcmUgaXMgYSBzdHlsZSBmb3IgdGhlIHdob2xlIGdyb3VwIG9mIHBpdGNoZXMsIGJ1dCB0aGVyZSBjb3VsZCBhbHNvIGJlIGFuIG92ZXJyaWRlIGZvciBhIHBhcnRpY3VsYXIgcGl0Y2guXG5cdFx0XHRcdGMgPSBjaGFydGFibGVbZWxlbS5waXRjaGVzW3BdLnN0eWxlXVstZHVybG9nXTtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRjID0gbm90ZVN5bWJvbDtcblx0XHRcdC8vIFRoZSBoaWdoZXN0IHBvc2l0aW9uIGZvciB0aGUgc2FrZSBvZiBwbGFjaW5nIHNsdXJzIGlzIGl0c2VsZiBpZiB0aGUgc2x1ciBpcyBpbnRlcm5hbC4gSXQgaXMgdGhlIGhpZ2hlc3QgcG9zaXRpb24gcG9zc2libGUgaWYgdGhlIHNsdXIgaXMgZm9yIHRoZSB3aG9sZSBjaG9yZC5cblx0XHRcdC8vIElmIHRoZSBub3RlIGlzIHRoZSBvbmx5IG9uZSBpbiB0aGUgY2hvcmQsIHRoZW4gYW55IHNsdXIgaXQgaGFzIGNvdW50cyBhcyBpZiBpdCB3ZXJlIG9uIHRoZSB3aG9sZSBjaG9yZC5cblx0XHRcdGVsZW0ucGl0Y2hlc1twXS5oaWdoZXN0VmVydCA9IGVsZW0ucGl0Y2hlc1twXS52ZXJ0aWNhbFBvcztcblx0XHRcdHZhciBpc1RvcFdoZW5TdGVtSXNEb3duID0gKHN0ZW1kaXI9PT1cInVwXCIgfHwgZGlyPT09XCJ1cFwiKSAmJiBwPT09MDtcblx0XHRcdHZhciBpc0JvdHRvbVdoZW5TdGVtSXNVcCA9IChzdGVtZGlyPT09XCJkb3duXCIgfHwgZGlyPT09XCJkb3duXCIpICYmIHA9PT1wcC0xO1xuXHRcdFx0aWYgKGlzVG9wV2hlblN0ZW1Jc0Rvd24gfHwgaXNCb3R0b21XaGVuU3RlbUlzVXApIHsgLy8gcGxhY2UgdG8gcHV0IHNsdXJzIGlmIG5vdCBhbHJlYWR5IG9uIHBpdGNoZXNcblxuXHRcdFx0XHRpZiAoZWxlbS5zdGFydFNsdXIgfHwgcHAgPT09IDEpIHtcblx0XHRcdFx0XHRlbGVtLnBpdGNoZXNbcF0uaGlnaGVzdFZlcnQgPSBlbGVtLnBpdGNoZXNbcHAtMV0udmVydGljYWxQb3M7XG5cdFx0XHRcdFx0aWYgKGdldER1cmF0aW9uKGVsZW0pIDwgMSAmJiAoc3RlbWRpcj09PVwidXBcIiB8fCBkaXI9PT1cInVwXCIpKVxuXHRcdFx0XHRcdFx0ZWxlbS5waXRjaGVzW3BdLmhpZ2hlc3RWZXJ0ICs9IDY7ICAgICAgICAvLyBJZiB0aGUgc3RlbSBpcyB1cCwgdGhlbiBjb21wZW5zYXRlIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBzdGVtXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVsZW0uc3RhcnRTbHVyKSB7XG5cdFx0XHRcdFx0aWYgKCFlbGVtLnBpdGNoZXNbcF0uc3RhcnRTbHVyKSBlbGVtLnBpdGNoZXNbcF0uc3RhcnRTbHVyID0gW107IC8vVE9ETyBwb3NzaWJseSByZWR1bmRhbnQsIHByb3ZpZGVkIGFycmF5IGlzIG5vdCBvcHRpb25hbFxuXHRcdFx0XHRcdGZvciAoaT0wOyBpPGVsZW0uc3RhcnRTbHVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRhZGRJZk5vdEV4aXN0KGVsZW0ucGl0Y2hlc1twXS5zdGFydFNsdXIsIGVsZW0uc3RhcnRTbHVyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbS5lbmRTbHVyKSB7XG5cdFx0XHRcdFx0ZWxlbS5waXRjaGVzW3BdLmhpZ2hlc3RWZXJ0ID0gZWxlbS5waXRjaGVzW3BwLTFdLnZlcnRpY2FsUG9zO1xuXHRcdFx0XHRcdGlmIChnZXREdXJhdGlvbihlbGVtKSA8IDEgJiYgKHN0ZW1kaXI9PT1cInVwXCIgfHwgZGlyPT09XCJ1cFwiKSlcblx0XHRcdFx0XHRcdGVsZW0ucGl0Y2hlc1twXS5oaWdoZXN0VmVydCArPSA2OyAgICAgICAgLy8gSWYgdGhlIHN0ZW0gaXMgdXAsIHRoZW4gY29tcGVuc2F0ZSBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgc3RlbVxuXHRcdFx0XHRcdGlmICghZWxlbS5waXRjaGVzW3BdLmVuZFNsdXIpIGVsZW0ucGl0Y2hlc1twXS5lbmRTbHVyID0gW107IC8vVE9ETyBwb3NzaWJseSByZWR1bmRhbnQsIHByb3ZpZGVkIGFycmF5IGlzIG5vdCBvcHRpb25hbFxuXHRcdFx0XHRcdGZvciAoaT0wOyBpPGVsZW0uZW5kU2x1ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YWRkSWZOb3RFeGlzdChlbGVtLnBpdGNoZXNbcF0uZW5kU2x1ciwgZWxlbS5lbmRTbHVyW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhc1N0ZW0gPSAhbm9zdGVtICYmIGR1cmxvZzw9LTE7XG5cdFx0XHR2YXIgcmV0ID0gY3JlYXRlTm90ZUhlYWQoYWJzZWxlbSwgYywgZWxlbS5waXRjaGVzW3BdLCBkaXIsIDAsIC1yb29tVGFrZW4sIGZsYWcsIGRvdCwgZG90c2hpZnR4LCB0aGlzLnZvaWNlU2NhbGUsIGFjY2lkZW50YWxTbG90LCAhc3RlbWRpcik7XG5cdFx0XHRzeW1ib2xXaWR0aCA9IE1hdGgubWF4KGdseXBocy5nZXRTeW1ib2xXaWR0aChjKSwgc3ltYm9sV2lkdGgpO1xuXHRcdFx0YWJzZWxlbS5leHRyYXcgLT0gcmV0LmV4dHJhTGVmdDtcblx0XHRcdG5vdGVIZWFkID0gcmV0Lm5vdGVoZWFkO1xuXHRcdFx0aWYgKG5vdGVIZWFkKSB7XG5cdFx0XHRcdHRoaXMuYWRkU2x1cnNBbmRUaWVzKGFic2VsZW0sIGVsZW0ucGl0Y2hlc1twXSwgbm90ZUhlYWQsIHZvaWNlLCBoYXNTdGVtID8gZGlyIDogbnVsbCwgZmFsc2UpO1xuXG5cdFx0XHRcdGlmIChlbGVtLmdyYWNlbm90ZXMgJiYgZWxlbS5ncmFjZW5vdGVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0bm90ZUhlYWQuYm90dG9tID0gbm90ZUhlYWQuYm90dG9tIC0gMTtcdCAvLyBJZiB0aGVyZSBpcyBhIHRpZSB0byB0aGUgZ3JhY2Ugbm90ZXMsIGxlYXZlIGEgbGl0dGxlIG1vcmUgcm9vbSBmb3IgdGhlIG5vdGUgdG8gYXZvaWQgY29sbGlzaW9ucy5cblx0XHRcdFx0YWJzZWxlbS5hZGRIZWFkKG5vdGVIZWFkKTtcblx0XHRcdH1cblx0XHRcdHJvb21UYWtlbiArPSByZXQuYWNjaWRlbnRhbHNoaWZ0eDtcblx0XHRcdHJvb21UYWtlblJpZ2h0ID0gTWF0aC5tYXgocm9vbVRha2VuUmlnaHQscmV0LmRvdHNoaWZ0eCk7XG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyBzdGVtIGZyb20gdGhlIGZ1cnRoZXN0IG5vdGUgdG8gYSBwaXRjaCBhYm92ZS9iZWxvdyB0aGUgc3RlbW1lZCBub3RlXG5cdFx0aWYgKGhhc1N0ZW0pIHtcblx0XHRcdHZhciBzdGVtSGVpZ2h0ID0gNyAqIHRoaXMudm9pY2VTY2FsZTtcblx0XHRcdHZhciBwMSA9IChkaXI9PT1cImRvd25cIikgPyBlbGVtLm1pbnBpdGNoLXN0ZW1IZWlnaHQgOiBlbGVtLm1pbnBpdGNoKzEvMztcblx0XHRcdC8vIFBFUiBhZGRlZCBzdGVtZGlyIHRlc3QgdG8gbWFrZSB0aGUgbGluZSBtZWV0IHRoZSBub3RlLlxuXHRcdFx0aWYgKHAxPjYgJiYgIXN0ZW1kaXIpIHAxPTY7XG5cdFx0XHR2YXIgcDIgPSAoZGlyPT09XCJkb3duXCIpID8gZWxlbS5tYXhwaXRjaC0xLzMgOiBlbGVtLm1heHBpdGNoK3N0ZW1IZWlnaHQ7XG5cdFx0XHQvLyBQRVIgYWRkZWQgc3RlbWRpciB0ZXN0IHRvIG1ha2UgdGhlIGxpbmUgbWVldCB0aGUgbm90ZS5cblx0XHRcdGlmIChwMjw2ICYmICFzdGVtZGlyKSBwMj02O1xuXHRcdFx0dmFyIGR4ID0gKGRpcj09PVwiZG93blwiIHx8IGFic2VsZW0uaGVhZHMubGVuZ3RoID09PSAwKT8wOmFic2VsZW0uaGVhZHNbMF0udztcblx0XHRcdHZhciB3aWR0aCA9IChkaXI9PT1cImRvd25cIik/MTotMTtcblx0XHRcdC8vIFRPRE8tUEVSLUhBQ0s6IE9uZSB0eXBlIG9mIG5vdGUgaGVhZCBoYXMgYSBkaWZmZXJlbnQgcGxhY2VtZW50IG9mIHRoZSBzdGVtLiBUaGlzIHNob3VsZCBiZSBtb3JlIGdlbmVyaWNhbGx5IGNhbGN1bGF0ZWQ6XG5cdFx0XHRpZiAobm90ZUhlYWQuYyA9PT0gJ25vdGVoZWFkcy5zbGFzaC5xdWFydGVyJykge1xuXHRcdFx0XHRpZiAoZGlyID09PSAnZG93bicpXG5cdFx0XHRcdFx0cDIgLT0gMTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHAxICs9IDE7XG5cdFx0XHR9XG5cdFx0XHRhYnNlbGVtLmFkZEV4dHJhKG5ldyBSZWxhdGl2ZUVsZW1lbnQobnVsbCwgZHgsIDAsIHAxLCB7XCJ0eXBlXCI6IFwic3RlbVwiLCBcInBpdGNoMlwiOnAyLCBsaW5ld2lkdGg6IHdpZHRofSkpO1xuXHRcdFx0Ly92YXIgUmVsYXRpdmVFbGVtZW50ID0gZnVuY3Rpb24gUmVsYXRpdmVFbGVtZW50KGMsIGR4LCB3LCBwaXRjaCwgb3B0KSB7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihwMSwgcDIpO1xuXHRcdH1cblx0XHRyZXR1cm4geyBub3RlSGVhZDogbm90ZUhlYWQsIHJvb21UYWtlbjogcm9vbVRha2VuLCByb29tVGFrZW5SaWdodDogcm9vbVRha2VuUmlnaHQsIG1pbjogbWluLCBhZGRpdGlvbmFsTGVkZ2VyczogYWRkaXRpb25hbExlZGdlcnMsIGRpcjogZGlyLCBzeW1ib2xXaWR0aDogc3ltYm9sV2lkdGggfTtcblx0fTtcblxuXHRBYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5hZGRMeXJpYyA9IGZ1bmN0aW9uKGFic2VsZW0sIGVsZW0pIHtcblx0XHR2YXIgbHlyaWNTdHIgPSBcIlwiO1xuXHRcdHBhcnNlQ29tbW9uLmVhY2goZWxlbS5seXJpYywgZnVuY3Rpb24obHkpIHtcblx0XHRcdHZhciBkaXYgPSBseS5kaXZpZGVyID09PSAnICcgPyBcIlwiIDogbHkuZGl2aWRlcjtcblx0XHRcdGx5cmljU3RyICs9IGx5LnN5bGxhYmxlICsgZGl2ICsgXCJcXG5cIjtcblx0XHR9KTtcblx0XHR2YXIgbHlyaWNEaW0gPSB0aGlzLnJlbmRlcmVyLmdldFRleHRTaXplKGx5cmljU3RyLCAndm9jYWxmb250JywgXCJseXJpY1wiKTtcblx0XHR2YXIgcG9zaXRpb24gPSBlbGVtLnBvc2l0aW9uaW5nID8gZWxlbS5wb3NpdGlvbmluZy52b2NhbFBvc2l0aW9uIDogJ2JlbG93Jztcblx0XHRhYnNlbGVtLmFkZENlbnRlcmVkKG5ldyBSZWxhdGl2ZUVsZW1lbnQobHlyaWNTdHIsIDAsIGx5cmljRGltLndpZHRoLCB1bmRlZmluZWQsIHt0eXBlOlwibHlyaWNcIiwgcG9zaXRpb246IHBvc2l0aW9uLCBoZWlnaHQ6IGx5cmljRGltLmhlaWdodCAvIHNwYWNpbmcuU1RFUCB9KSk7XG5cdH07XG5cblx0QWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuYWRkQ2hvcmQgPSBmdW5jdGlvbihhYnNlbGVtLCBlbGVtLCByb29tVGFrZW4sIHJvb21UYWtlblJpZ2h0KSB7XG5cdFx0dmFyIGNob3JkTWFyZ2luID0gODsgLy8gSWYgdGhlcmUgYXJlIGNob3JkcyBuZXh0IHRvIGVhY2ggb3RoZXIsIHRoaXMgaXMgaG93IGNsb3NlIHRoZXkgY2FuIGdldC5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hvcmQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4ID0gMDtcblx0XHRcdHZhciB5O1xuXHRcdFx0dmFyIGRpbSA9IHRoaXMucmVuZGVyZXIuZ2V0VGV4dFNpemUoZWxlbS5jaG9yZFtpXS5uYW1lLCAnYW5ub3RhdGlvbmZvbnQnLCBcImFubm90YXRpb25cIik7XG5cdFx0XHR2YXIgY2hvcmRXaWR0aCA9IGRpbS53aWR0aDtcblx0XHRcdHZhciBjaG9yZEhlaWdodCA9IGRpbS5oZWlnaHQgLyBzcGFjaW5nLlNURVA7XG5cdFx0XHRzd2l0Y2ggKGVsZW0uY2hvcmRbaV0ucG9zaXRpb24pIHtcblx0XHRcdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRcdFx0XHRyb29tVGFrZW4rPWNob3JkV2lkdGgrNztcblx0XHRcdFx0XHR4ID0gLXJvb21UYWtlbjsgICAgICAgIC8vIFRPRE8tUEVSOiBUaGlzIGlzIGp1c3QgYSBndWVzcyBmcm9tIHRyaWFsIGFuZCBlcnJvclxuXHRcdFx0XHRcdHkgPSBlbGVtLmF2ZXJhZ2VwaXRjaDtcblx0XHRcdFx0XHRhYnNlbGVtLmFkZEV4dHJhKG5ldyBSZWxhdGl2ZUVsZW1lbnQoZWxlbS5jaG9yZFtpXS5uYW1lLCB4LCBjaG9yZFdpZHRoKzQsIHksIHt0eXBlOlwidGV4dFwiLCBoZWlnaHQ6IGNob3JkSGVpZ2h0fSkpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRcdFx0XHRyb29tVGFrZW5SaWdodCs9NDtcblx0XHRcdFx0XHR4ID0gcm9vbVRha2VuUmlnaHQ7Ly8gVE9ETy1QRVI6IFRoaXMgaXMganVzdCBhIGd1ZXNzIGZyb20gdHJpYWwgYW5kIGVycm9yXG5cdFx0XHRcdFx0eSA9IGVsZW0uYXZlcmFnZXBpdGNoO1xuXHRcdFx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChlbGVtLmNob3JkW2ldLm5hbWUsIHgsIGNob3JkV2lkdGgrNCwgeSwge3R5cGU6XCJ0ZXh0XCIsIGhlaWdodDogY2hvcmRIZWlnaHR9KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJiZWxvd1wiOlxuXHRcdFx0XHRcdC8vIHNldHRpbmcgdGhlIHktY29vcmRpbmF0ZSB0byB1bmRlZmluZWQgZm9yIG5vdzogaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBsYXRlciBvbiwgYWZ0ZXIgd2UgZmlndXJlIG91dCB3aGF0IHRoZSBoaWdoZXN0IGVsZW1lbnQgb24gdGhlIGxpbmUgaXMuXG5cdFx0XHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KGVsZW0uY2hvcmRbaV0ubmFtZSwgMCwgY2hvcmRXaWR0aCtjaG9yZE1hcmdpbiwgdW5kZWZpbmVkLCB7dHlwZTogXCJ0ZXh0XCIsIHBvc2l0aW9uOiBcImJlbG93XCIsIGhlaWdodDogY2hvcmRIZWlnaHR9KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhYm92ZVwiOlxuXHRcdFx0XHRcdC8vIHNldHRpbmcgdGhlIHktY29vcmRpbmF0ZSB0byB1bmRlZmluZWQgZm9yIG5vdzogaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBsYXRlciBvbiwgYWZ0ZXIgd2UgZmlndXJlIG91dCB3aGF0IHRoZSBoaWdoZXN0IGVsZW1lbnQgb24gdGhlIGxpbmUgaXMuXG5cdFx0XHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KGVsZW0uY2hvcmRbaV0ubmFtZSwgMCwgY2hvcmRXaWR0aCtjaG9yZE1hcmdpbiwgdW5kZWZpbmVkLCB7dHlwZTogXCJ0ZXh0XCIsIGhlaWdodDogY2hvcmRIZWlnaHR9KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKGVsZW0uY2hvcmRbaV0ucmVsX3Bvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVsUG9zaXRpb25ZID0gZWxlbS5jaG9yZFtpXS5yZWxfcG9zaXRpb24ueSArIDMqc3BhY2luZy5TVEVQOyAvLyBUT0RPLVBFUjogdGhpcyBpcyBhIGZ1ZGdlIGZhY3RvciB0byBtYWtlIGl0IGxpbmUgdXAgd2l0aCBhYmNtMnBzXG5cdFx0XHRcdFx0XHRhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQoZWxlbS5jaG9yZFtpXS5uYW1lLCB4ICsgZWxlbS5jaG9yZFtpXS5yZWxfcG9zaXRpb24ueCwgMCwgZWxlbS5taW5waXRjaCArIHJlbFBvc2l0aW9uWSAvIHNwYWNpbmcuU1RFUCwge3R5cGU6IFwidGV4dFwiLCBoZWlnaHQ6IGNob3JkSGVpZ2h0fSkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBzZXR0aW5nIHRoZSB5LWNvb3JkaW5hdGUgdG8gdW5kZWZpbmVkIGZvciBub3c6IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gbGF0ZXIgb24sIGFmdGVyIHdlIGZpZ3VyZSBvdXQgd2hhdCB0aGUgaGlnaGVzdCBlbGVtZW50IG9uIHRoZSBsaW5lIGlzLlxuXHRcdFx0XHRcdFx0dmFyIHBvczIgPSAnYWJvdmUnO1xuXHRcdFx0XHRcdFx0aWYgKGVsZW0ucG9zaXRpb25pbmcgJiYgZWxlbS5wb3NpdGlvbmluZy5jaG9yZFBvc2l0aW9uKVxuXHRcdFx0XHRcdFx0XHRwb3MyID0gZWxlbS5wb3NpdGlvbmluZy5jaG9yZFBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0XHRkaW0gPSB0aGlzLnJlbmRlcmVyLmdldFRleHRTaXplKGVsZW0uY2hvcmRbaV0ubmFtZSwgJ2djaG9yZGZvbnQnLCBcImNob3JkXCIpO1xuXHRcdFx0XHRcdFx0Y2hvcmRIZWlnaHQgPSBkaW0uaGVpZ2h0IC8gc3BhY2luZy5TVEVQO1xuXHRcdFx0XHRcdFx0Y2hvcmRXaWR0aCA9IGRpbS53aWR0aDsgLy8gU2luY2UgdGhlIGNob3JkIGlzIGNlbnRlcmVkLCB3ZSBvbmx5IHVzZSBoYWxmIHRoZSB3aWR0aC5cblx0XHRcdFx0XHRcdGFic2VsZW0uYWRkQ2VudGVyZWQobmV3IFJlbGF0aXZlRWxlbWVudChlbGVtLmNob3JkW2ldLm5hbWUsIHgsIGNob3JkV2lkdGgsIHVuZGVmaW5lZCwge3R5cGU6IFwiY2hvcmRcIiwgcG9zaXRpb246IHBvczIsIGhlaWdodDogY2hvcmRIZWlnaHQgfSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHsgcm9vbVRha2VuOiByb29tVGFrZW4sIHJvb21UYWtlblJpZ2h0OiByb29tVGFrZW5SaWdodCB9O1xuXHR9O1xuXG5BYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5jcmVhdGVOb3RlID0gZnVuY3Rpb24oZWxlbSwgbm9zdGVtLCBpc1NpbmdsZUxpbmVTdGFmZiwgdm9pY2UpIHsgLy9zdGVtIHByZXNlbmNlOiB0cnVlIGZvciBkcmF3aW5nIHN0ZW1sZXNzIG5vdGVoZWFkXG4gIHZhciBub3RlaGVhZCA9IG51bGw7XG4gIHZhciByb29tdGFrZW4gPSAwOyAvLyByb29tIG5lZWRlZCB0byB0aGUgbGVmdCBvZiB0aGUgbm90ZVxuICB2YXIgcm9vbXRha2VucmlnaHQgPSAwOyAvLyByb29tIG5lZWRlZCB0byB0aGUgcmlnaHQgb2YgdGhlIG5vdGVcbiAgdmFyIHN5bWJvbFdpZHRoID0gMDtcbiAgdmFyIGFkZGl0aW9uYWxMZWRnZXJzID0gW107IC8vIFBFUjogaGFuZGxlIHRoZSBjYXNlIG9mIFtiYyddLCB3aGVyZSB0aGUgYiBkb2Vzbid0IGhhdmUgYSBsZWRnZXIgbGluZVxuXG4gIHZhciBpO1xuICB2YXIgZGlyO1xuXG5cdHZhciBkdXJhdGlvbiA9IGdldER1cmF0aW9uKGVsZW0pO1xuXHR2YXIgemVyb0R1cmF0aW9uID0gZmFsc2U7XG4gIGlmIChkdXJhdGlvbiA9PT0gMCkgeyB6ZXJvRHVyYXRpb24gPSB0cnVlOyBkdXJhdGlvbiA9IDAuMjU7IG5vc3RlbSA9IHRydWU7IH0gICAgICAgIC8vUEVSOiB6ZXJvIGR1cmF0aW9uIHdpbGwgZHJhdyBhIHF1YXJ0ZXIgbm90ZSBoZWFkLlxuICB2YXIgZHVybG9nID0gTWF0aC5mbG9vcihNYXRoLmxvZyhkdXJhdGlvbikvTWF0aC5sb2coMikpOyAvL1RPRE8gdXNlIGdldER1cmxvZ1xuICB2YXIgZG90PTA7XG5cbiAgZm9yICh2YXIgdG90ID0gTWF0aC5wb3coMixkdXJsb2cpLCBpbmM9dG90LzI7IHRvdDxkdXJhdGlvbjsgZG90KyssdG90Kz1pbmMsaW5jLz0yKTtcblxuXG5cdGlmIChlbGVtLnN0YXJ0VHJpcGxldCkge1xuXHRcdHRoaXMudHJpcGxldG11bHRpcGxpZXIgPSBlbGVtLnRyaXBsZXRNdWx0aXBsaWVyO1xuXHR9XG5cbiAgdmFyIGR1cmF0aW9uRm9yU3BhY2luZyA9IGR1cmF0aW9uICogdGhpcy50cmlwbGV0bXVsdGlwbGllcjtcbiAgaWYgKGVsZW0ucmVzdCAmJiBlbGVtLnJlc3QudHlwZSA9PT0gJ211bHRpbWVhc3VyZScpXG4gIFx0ZHVyYXRpb25Gb3JTcGFjaW5nID0gMTtcbiAgdmFyIGFic1R5cGUgPSBlbGVtLnJlc3QgPyBcInJlc3RcIiA6IFwibm90ZVwiO1xuICB2YXIgYWJzZWxlbSA9IG5ldyBBYnNvbHV0ZUVsZW1lbnQoZWxlbSwgZHVyYXRpb25Gb3JTcGFjaW5nLCAxLCBhYnNUeXBlLCB0aGlzLnR1bmVOdW1iZXIsIHsgZHVyYXRpb25DbGFzc092ZXJpZGU6IGVsZW0uZHVyYXRpb24gKiB0aGlzLnRyaXBsZXRtdWx0aXBsaWVyfSk7XG4gIGlmIChoaW50KSBhYnNlbGVtLnNldEhpbnQoKTtcblxuICBpZiAoZWxlbS5yZXN0KSB7XG4gIFx0aWYgKHRoaXMubWVhc3VyZUxlbmd0aCA9PT0gZHVyYXRpb24gJiYgZWxlbS5yZXN0LnR5cGUgIT09ICdpbnZpc2libGUnICYmIGVsZW0ucmVzdC50eXBlICE9PSAnc3BhY2VyJylcblx0ICAgIGVsZW0ucmVzdC50eXBlID0gJ3dob2xlJzsgLy8gSWYgdGhlIHJlc3QgaXMgZXhhY3RseSBhIG1lYXN1cmUsIGFsd2F5cyB1c2UgYSB3aG9sZSByZXN0XG5cdCAgdmFyIHJldDEgPSBhZGRSZXN0VG9BYnNFbGVtZW50KGFic2VsZW0sIGVsZW0sIGR1cmF0aW9uLCBkb3QsIHZvaWNlLnZvaWNldG90YWwgPiAxLCB0aGlzLnN0ZW1kaXIsIGlzU2luZ2xlTGluZVN0YWZmLCBkdXJsb2csIHRoaXMudm9pY2VTY2FsZSk7XG5cdCAgbm90ZWhlYWQgPSByZXQxLm5vdGVIZWFkO1xuXHQgIHJvb210YWtlbiA9IHJldDEucm9vbVRha2VuO1xuXHQgIHJvb210YWtlbnJpZ2h0ID0gcmV0MS5yb29tVGFrZW5SaWdodDtcbiAgfSBlbHNlIHtcblx0ICB2YXIgcmV0MiA9IHRoaXMuYWRkTm90ZVRvQWJjRWxlbWVudChhYnNlbGVtLCBlbGVtLCBkb3QsIHRoaXMuc3RlbWRpciwgdGhpcy5zdHlsZSwgemVyb0R1cmF0aW9uLCBkdXJsb2csIG5vc3RlbSwgdm9pY2UpO1xuXHQgIGlmIChyZXQyLm1pbiAhPT0gdW5kZWZpbmVkKVxuXHRcdCAgdGhpcy5taW5ZID0gTWF0aC5taW4ocmV0Mi5taW4sIHRoaXMubWluWSk7XG5cdCAgbm90ZWhlYWQgPSByZXQyLm5vdGVIZWFkO1xuXHQgIHJvb210YWtlbiA9IHJldDIucm9vbVRha2VuO1xuXHQgIHJvb210YWtlbnJpZ2h0ID0gcmV0Mi5yb29tVGFrZW5SaWdodDtcblx0ICBhZGRpdGlvbmFsTGVkZ2VycyA9IHJldDIuYWRkaXRpb25hbExlZGdlcnM7XG5cdCAgZGlyID0gcmV0Mi5kaXI7XG5cdCAgc3ltYm9sV2lkdGggPSByZXQyLnN5bWJvbFdpZHRoO1xuICB9XG5cbiAgaWYgKGVsZW0ubHlyaWMgIT09IHVuZGVmaW5lZCkge1xuICBcdHRoaXMuYWRkTHlyaWMoYWJzZWxlbSwgZWxlbSk7XG4gIH1cblxuICBpZiAoZWxlbS5ncmFjZW5vdGVzICE9PSB1bmRlZmluZWQpIHtcblx0cm9vbXRha2VuICs9IHRoaXMuYWRkR3JhY2VOb3RlcyhlbGVtLCB2b2ljZSwgYWJzZWxlbSwgbm90ZWhlYWQsIHRoaXMuc3RlbUhlaWdodCAqIHRoaXMudm9pY2VTY2FsZSwgdGhpcy5pc0JhZ3BpcGVzLCByb29tdGFrZW4pO1xuICB9XG5cbiAgaWYgKGVsZW0uZGVjb3JhdGlvbikge1xuXHQgIHRoaXMuZGVjb3JhdGlvbi5jcmVhdGVEZWNvcmF0aW9uKHZvaWNlLCBlbGVtLmRlY29yYXRpb24sIGFic2VsZW0udG9wLCAobm90ZWhlYWQpP25vdGVoZWFkLnc6MCwgYWJzZWxlbSwgcm9vbXRha2VuLCBkaXIsIGFic2VsZW0uYm90dG9tLCBlbGVtLnBvc2l0aW9uaW5nLCB0aGlzLmhhc1ZvY2Fscyk7XG4gIH1cblxuICBpZiAoZWxlbS5iYXJOdW1iZXIpIHtcbiAgICBhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQoZWxlbS5iYXJOdW1iZXIsIC0xMCwgMCwgMCwge3R5cGU6XCJiYXJOdW1iZXJcIn0pKTtcbiAgfVxuXG4gIC8vIGxlZGdlciBsaW5lc1xuXHRsZWRnZXJMaW5lcyhhYnNlbGVtLCBlbGVtLm1pbnBpdGNoLCBlbGVtLm1heHBpdGNoLCBlbGVtLnJlc3QsIHN5bWJvbFdpZHRoLCBhZGRpdGlvbmFsTGVkZ2VycywgZGlyLCAtMiwgMSk7XG5cbiAgaWYgKGVsZW0uY2hvcmQgIT09IHVuZGVmaW5lZCkge1xuICBcdHZhciByZXQzID0gdGhpcy5hZGRDaG9yZChhYnNlbGVtLCBlbGVtLCByb29tdGFrZW4sIHJvb210YWtlbnJpZ2h0KTtcblx0ICByb29tdGFrZW4gPSByZXQzLnJvb21UYWtlbjtcblx0ICByb29tdGFrZW5yaWdodCA9IHJldDMucm9vbVRha2VuUmlnaHQ7XG4gIH1cblxuXG4gIGlmIChlbGVtLnN0YXJ0VHJpcGxldCkge1xuICAgIHRoaXMudHJpcGxldCA9IG5ldyBUcmlwbGV0RWxlbShlbGVtLnN0YXJ0VHJpcGxldCwgbm90ZWhlYWQsIHsgZmxhdEJlYW1zOiB0aGlzLmZsYXRCZWFtcyB9KTsgLy8gYWJvdmUgaXMgb3Bwb3NpdGUgZnJvbSBjYXNlIG9mIHNsdXJzXG4gIH1cblxuICBpZiAoZWxlbS5lbmRUcmlwbGV0ICYmIHRoaXMudHJpcGxldCkge1xuICAgIHRoaXMudHJpcGxldC5zZXRDbG9zZUFuY2hvcihub3RlaGVhZCk7XG4gIH1cblxuICBpZiAodGhpcy50cmlwbGV0ICYmICFlbGVtLnN0YXJ0VHJpcGxldCAmJiAhZWxlbS5lbmRUcmlwbGV0KSB7XG4gIFx0dGhpcy50cmlwbGV0Lm1pZGRsZU5vdGUobm90ZWhlYWQpO1xuICB9XG5cblxuICByZXR1cm4gYWJzZWxlbTtcbn07XG5cblxuXG5cbnZhciBjcmVhdGVOb3RlSGVhZCA9IGZ1bmN0aW9uKGFic2VsZW0sIGMsIHBpdGNoZWxlbSwgZGlyLCBoZWFkeCwgZXh0cmF4LCBmbGFnLCBkb3QsIGRvdHNoaWZ0eCwgc2NhbGUsIGFjY2lkZW50YWxTbG90LCBzaG91bGRFeHRlbmRTdGVtKSB7XG4gIC8vIFRPRE8gc2NhbGUgdGhlIGRvdCBhcyB3ZWxsXG4gIHZhciBwaXRjaCA9IHBpdGNoZWxlbS52ZXJ0aWNhbFBvcztcbiAgdmFyIG5vdGVoZWFkO1xuICB2YXIgaTtcbiAgdmFyIGFjY2lkZW50YWxzaGlmdHggPSAwO1xuICB2YXIgbmV3RG90U2hpZnRYID0gMDtcbiAgdmFyIGV4dHJhTGVmdCA9IDA7XG4gIGlmIChjID09PSB1bmRlZmluZWQpXG4gICAgYWJzZWxlbS5hZGRDaGlsZChuZXcgUmVsYXRpdmVFbGVtZW50KFwicGl0Y2ggaXMgdW5kZWZpbmVkXCIsIDAsIDAsIDAsIHt0eXBlOlwiZGVidWdcIn0pKTtcbiAgZWxzZSBpZiAoYz09PVwiXCIpIHtcbiAgICBub3RlaGVhZCA9IG5ldyBSZWxhdGl2ZUVsZW1lbnQobnVsbCwgMCwgMCwgcGl0Y2gpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzaGlmdGhlYWR4ID0gaGVhZHg7XG4gICAgaWYgKHBpdGNoZWxlbS5wcmludGVyX3NoaWZ0KSB7XG4gICAgICB2YXIgYWRqdXN0ID0gKHBpdGNoZWxlbS5wcmludGVyX3NoaWZ0PT09XCJzYW1lXCIpPzE6MDtcbiAgICAgIHNoaWZ0aGVhZHggPSAoZGlyPT09XCJkb3duXCIpPy1nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoYykqc2NhbGUrYWRqdXN0OmdseXBocy5nZXRTeW1ib2xXaWR0aChjKSpzY2FsZS1hZGp1c3Q7XG4gICAgfVxuXHQgIHZhciBvcHRzID0ge3NjYWxleDpzY2FsZSwgc2NhbGV5OiBzY2FsZSwgdGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKGMpKnNjYWxlIH07XG4gICAgbm90ZWhlYWQgPSBuZXcgUmVsYXRpdmVFbGVtZW50KGMsIHNoaWZ0aGVhZHgsIGdseXBocy5nZXRTeW1ib2xXaWR0aChjKSpzY2FsZSwgcGl0Y2gsIG9wdHMpO1xuICAgIG5vdGVoZWFkLnN0ZW1EaXIgPSBkaXI7XG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIHZhciBwb3MgPSBwaXRjaCsoKGRpcj09PVwiZG93blwiKT8tNzo3KSpzY2FsZTtcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSByZWd1bGFyIG5vdGUsIChub3QgZ3JhY2Ugb3IgdGVtcG8gaW5kaWNhdG9yKSB0aGVuIHRoZSBzdGVtIHdpbGwgaGF2ZSBiZWVuIHN0cmV0Y2hlZCB0byB0aGUgbWlkZGxlIGxpbmUgaWYgaXQgaXMgZmFyIGZyb20gdGhlIGNlbnRlci5cblx0ICAgIGlmIChzaG91bGRFeHRlbmRTdGVtKSB7XG5cdCAgICBcdGlmIChkaXI9PT1cImRvd25cIiAmJiBwb3MgPiA2KVxuXHQgICAgXHRcdHBvcyA9IDY7XG5cdCAgICBcdGlmIChkaXI9PT1cInVwXCIgJiYgcG9zIDwgNilcblx0ICAgIFx0XHRwb3MgPSA2O1xuXHQgICAgfVxuICAgICAgLy9pZiAoc2NhbGU9PT0xICYmIChkaXI9PT1cImRvd25cIik/KHBvcz42KToocG9zPDYpKSBwb3M9NjtcbiAgICAgIHZhciB4ZGVsdGEgPSAoZGlyPT09XCJkb3duXCIpP2hlYWR4OmhlYWR4K25vdGVoZWFkLnctMC42O1xuICAgICAgYWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KGZsYWcsIHhkZWx0YSwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGZsYWcpKnNjYWxlLCBwb3MsIHtzY2FsZXg6c2NhbGUsIHNjYWxleTogc2NhbGV9KSk7XG4gICAgfVxuXHQgIG5ld0RvdFNoaWZ0WCA9IG5vdGVoZWFkLncrZG90c2hpZnR4LTIrNSpkb3Q7XG4gICAgZm9yICg7ZG90PjA7ZG90LS0pIHtcbiAgICAgIHZhciBkb3RhZGp1c3R5ID0gKDEtTWF0aC5hYnMocGl0Y2gpJTIpOyAvL1BFUjogdGFrZSBhYnMgdmFsdWUgb2YgdGhlIHBpdGNoLiBBbmQgdGhlIHNoaWZ0IHN0aWxsIGhhcHBlbnMgb24gbGVkZ2VyIGxpbmVzLlxuICAgICAgYWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwiZG90cy5kb3RcIiwgbm90ZWhlYWQudytkb3RzaGlmdHgtMis1KmRvdCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwiZG90cy5kb3RcIiksIHBpdGNoK2RvdGFkanVzdHkpKTtcbiAgICB9XG4gIH1cbiAgICAgICAgaWYgKG5vdGVoZWFkKVxuICAgICAgICAgICAgICAgIG5vdGVoZWFkLmhpZ2hlc3RWZXJ0ID0gcGl0Y2hlbGVtLmhpZ2hlc3RWZXJ0O1xuXG4gIGlmIChwaXRjaGVsZW0uYWNjaWRlbnRhbCkge1xuICAgIHZhciBzeW1iO1xuICAgIHN3aXRjaCAocGl0Y2hlbGVtLmFjY2lkZW50YWwpIHtcbiAgICBjYXNlIFwicXVhcnRlcnNoYXJwXCI6XG4gICAgICBzeW1iID0gXCJhY2NpZGVudGFscy5oYWxmc2hhcnBcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRibHNoYXJwXCI6XG4gICAgICBzeW1iID0gXCJhY2NpZGVudGFscy5kYmxzaGFycFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNoYXJwXCI6XG4gICAgICBzeW1iID0gXCJhY2NpZGVudGFscy5zaGFycFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInF1YXJ0ZXJmbGF0XCI6XG4gICAgICBzeW1iID0gXCJhY2NpZGVudGFscy5oYWxmZmxhdFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZsYXRcIjpcbiAgICAgIHN5bWIgPSBcImFjY2lkZW50YWxzLmZsYXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYmxmbGF0XCI6XG4gICAgICBzeW1iID0gXCJhY2NpZGVudGFscy5kYmxmbGF0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibmF0dXJhbFwiOlxuICAgICAgc3ltYiA9IFwiYWNjaWRlbnRhbHMubmF0XCI7XG4gICAgfVxuICAgICAgICAgLy8gaWYgYSBub3RlIGlzIGF0IGxlYXN0IGEgc2l4dGggYXdheSwgaXQgY2FuIHNoYXJlIGEgc2xvdCB3aXRoIGFub3RoZXIgYWNjaWRlbnRhbFxuICAgICAgICAgdmFyIGFjY1Nsb3RGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgdmFyIGFjY1BsYWNlID0gZXh0cmF4O1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY2NpZGVudGFsU2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICBpZiAocGl0Y2ggLSBhY2NpZGVudGFsU2xvdFtqXVswXSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgYWNjaWRlbnRhbFNsb3Rbal1bMF0gPSBwaXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICBhY2NQbGFjZSA9IGFjY2lkZW50YWxTbG90W2pdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGFjY1Nsb3RGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChhY2NTbG90Rm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgIGFjY1BsYWNlIC09IChnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoc3ltYikqc2NhbGUrMik7XG4gICAgICAgICAgICAgICAgIGFjY2lkZW50YWxTbG90LnB1c2goW3BpdGNoLGFjY1BsYWNlXSk7XG4gICAgICAgICAgICAgICAgIGFjY2lkZW50YWxzaGlmdHggPSAoZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHN5bWIpKnNjYWxlKzIpO1xuICAgICAgICAgfVxuICAgIGFic2VsZW0uYWRkRXh0cmEobmV3IFJlbGF0aXZlRWxlbWVudChzeW1iLCBhY2NQbGFjZSwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHN5bWIpLCBwaXRjaCwge3NjYWxleDpzY2FsZSwgc2NhbGV5OiBzY2FsZX0pKTtcblx0ICBleHRyYUxlZnQgPSBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoc3ltYikgLyAyOyAvLyBUT0RPLVBFUjogV2UgbmVlZCBhIGxpdHRsZSBleHRyYSB3aWR0aCBpZiB0aGVyZSBpcyBhbiBhY2NpZGVudGFsLCBidXQgSSdtIG5vdCBzdXJlIHdoeSBpdCBpc24ndCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgYWNjaWRlbnRhbC5cbiAgfVxuXG4gIHJldHVybiB7IG5vdGVoZWFkOiBub3RlaGVhZCwgYWNjaWRlbnRhbHNoaWZ0eDogYWNjaWRlbnRhbHNoaWZ0eCwgZG90c2hpZnR4OiBuZXdEb3RTaGlmdFgsIGV4dHJhTGVmdDogZXh0cmFMZWZ0IH07XG5cbn07XG5cblx0QWJzdHJhY3RFbmdyYXZlci5wcm90b3R5cGUuYWRkU2x1cnNBbmRUaWVzID0gZnVuY3Rpb24oYWJzZWxlbSwgcGl0Y2hlbGVtLCBub3RlaGVhZCwgdm9pY2UsIGRpciwgaXNHcmFjZSkge1xuXHRcdGlmIChwaXRjaGVsZW0uZW5kVGllKSB7XG5cdFx0XHRpZiAodGhpcy50aWVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIG9wZW4gdGllcywgZmluZCB0aGUgb25lIHRoYXQgYXBwbGllcyBieSBtYXRjaGluZyB0aGUgcGl0Y2gsIGlmIHBvc3NpYmxlLlxuXHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnRpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRpZiAodGhpcy50aWVzW2pdLmFuY2hvcjEgJiYgdGhpcy50aWVzW2pdLmFuY2hvcjEucGl0Y2ggPT09IG5vdGVoZWFkLnBpdGNoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRpZXNbal0uc2V0RW5kQW5jaG9yKG5vdGVoZWFkKTtcblx0XHRcdFx0XHRcdHRoaXMudGllcy5zcGxpY2UoaiwgMSk7XG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHRcdHRoaXMudGllc1swXS5zZXRFbmRBbmNob3Iobm90ZWhlYWQpO1xuXHRcdFx0XHRcdHRoaXMudGllcy5zcGxpY2UoMCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgdm9pY2VOdW1iZXIgPSB2b2ljZS52b2ljZXRvdGFsIDwgMiA/IC0xIDogdm9pY2Uudm9pY2VudW1iZXI7XG5cdFx0aWYgKHBpdGNoZWxlbS5zdGFydFRpZSkge1xuXHRcdFx0dmFyIHRpZSA9IG5ldyBUaWVFbGVtKHsgYW5jaG9yMTogbm90ZWhlYWQsIGZvcmNlOiAodGhpcy5zdGVtZGlyPT09XCJkb3duXCIgfHwgdGhpcy5zdGVtZGlyPT09XCJ1cFwiKSwgc3RlbURpcjogdGhpcy5zdGVtZGlyLCBpc0dyYWNlOiBpc0dyYWNlLCB2b2ljZU51bWJlcjogdm9pY2VOdW1iZXJ9KTtcblx0XHRcdGlmIChoaW50KSB0aWUuc2V0SGludCgpO1xuXG5cdFx0XHR0aGlzLnRpZXNbdGhpcy50aWVzLmxlbmd0aF09dGllO1xuXHRcdFx0dm9pY2UuYWRkT3RoZXIodGllKTtcblx0XHRcdC8vIEhBQ0stUEVSOiBGb3IgdGhlIGFuaW1hdGlvbiwgd2UgbmVlZCB0byBrbm93IGlmIGEgbm90ZSBpcyB0aWVkIHRvIHRoZSBuZXh0IG9uZSwgc28gaGVyZSdzIGEgZmxhZy5cblx0XHRcdC8vIFVuZm9ydHVuYXRlbHksIG9ubHkgc29tZSBvZiB0aGUgbm90ZXMgaW4gdGhlIGN1cnJlbnQgZXZlbnQgbWlnaHQgYmUgdGllZCwgYnV0IHRoaXMgd2lsbCBjb25zaWRlciBpdFxuXHRcdFx0Ly8gdGllZCBpZiBhbnkgb25lIG9mIHRoZW0gaXMuIFRoYXQgd2lsbCB3b3JrIGZvciBtb3N0IGNhc2VzLlxuXHRcdFx0YWJzZWxlbS5zdGFydFRpZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHBpdGNoZWxlbS5lbmRTbHVyKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8cGl0Y2hlbGVtLmVuZFNsdXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHNsdXJpZCA9IHBpdGNoZWxlbS5lbmRTbHVyW2ldO1xuXHRcdFx0XHR2YXIgc2x1cjtcblx0XHRcdFx0aWYgKHRoaXMuc2x1cnNbc2x1cmlkXSkge1xuXHRcdFx0XHRcdHNsdXIgPSB0aGlzLnNsdXJzW3NsdXJpZF07XG5cdFx0XHRcdFx0c2x1ci5zZXRFbmRBbmNob3Iobm90ZWhlYWQpO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnNsdXJzW3NsdXJpZF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2x1ciA9IG5ldyBUaWVFbGVtKHsgYW5jaG9yMjogbm90ZWhlYWQsIHN0ZW1EaXI6IHRoaXMuc3RlbWRpciwgdm9pY2VOdW1iZXI6IHZvaWNlTnVtYmVyfSk7XG5cdFx0XHRcdFx0aWYgKGhpbnQpIHNsdXIuc2V0SGludCgpO1xuXHRcdFx0XHRcdHZvaWNlLmFkZE90aGVyKHNsdXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnN0YXJ0bGltaXRlbGVtKSB7XG5cdFx0XHRcdFx0c2x1ci5zZXRTdGFydFgodGhpcy5zdGFydGxpbWl0ZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0dyYWNlKSB7XG5cdFx0XHRmb3IgKHZhciBzIGluIHRoaXMuc2x1cnMpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2x1cnMuaGFzT3duUHJvcGVydHkocykpIHtcblx0XHRcdFx0XHR0aGlzLnNsdXJzW3NdLmFkZEludGVybmFsTm90ZShub3RlaGVhZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGl0Y2hlbGVtLnN0YXJ0U2x1cikge1xuXHRcdFx0Zm9yIChpPTA7IGk8cGl0Y2hlbGVtLnN0YXJ0U2x1ci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgc2x1cmlkID0gcGl0Y2hlbGVtLnN0YXJ0U2x1cltpXS5sYWJlbDtcblx0XHRcdFx0dmFyIHNsdXIgPSBuZXcgVGllRWxlbSh7IGFuY2hvcjE6IG5vdGVoZWFkLCBzdGVtRGlyOiB0aGlzLnN0ZW1kaXIsIHZvaWNlTnVtYmVyOiB2b2ljZU51bWJlcn0pO1xuXHRcdFx0XHRpZiAoaGludCkgc2x1ci5zZXRIaW50KCk7XG5cdFx0XHRcdHRoaXMuc2x1cnNbc2x1cmlkXT1zbHVyO1xuXHRcdFx0XHR2b2ljZS5hZGRPdGhlcihzbHVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cbkFic3RyYWN0RW5ncmF2ZXIucHJvdG90eXBlLmFkZE1lYXN1cmVOdW1iZXIgPSBmdW5jdGlvbiAobnVtYmVyLCBhYnNlbGVtKSB7XG5cdHZhciBtZWFzdXJlTnVtSGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5nZXRUZXh0U2l6ZShudW1iZXIsIFwibWVhc3VyZWZvbnRcIiwgJ2Jhci1udW1iZXInKTtcblx0YWJzZWxlbS5hZGRDaGlsZChuZXcgUmVsYXRpdmVFbGVtZW50KG51bWJlciwgMCwgMCwgMTErbWVhc3VyZU51bUhlaWdodC5oZWlnaHQgLyBzcGFjaW5nLlNURVAsIHt0eXBlOlwiYmFyTnVtYmVyXCJ9KSk7XG59O1xuXG5BYnN0cmFjdEVuZ3JhdmVyLnByb3RvdHlwZS5jcmVhdGVCYXJMaW5lID0gZnVuY3Rpb24gKHZvaWNlLCBlbGVtLCBpc0ZpcnN0U3RhZmYpIHtcbi8vIGJhcl90aGluLCBiYXJfdGhpbl90aGljaywgYmFyX3RoaW5fdGhpbiwgYmFyX3RoaWNrX3RoaW4sIGJhcl9yaWdodF9yZXBlYXQsIGJhcl9sZWZ0X3JlcGVhdCwgYmFyX2RvdWJsZV9yZXBlYXRcblxuICB2YXIgYWJzZWxlbSA9IG5ldyBBYnNvbHV0ZUVsZW1lbnQoZWxlbSwgMCwgMTAsICdiYXInLCB0aGlzLnR1bmVOdW1iZXIpO1xuICB2YXIgYW5jaG9yID0gbnVsbDsgLy8gcGxhY2UgdG8gYXR0YWNoIHBhcnQgbGluZXNcbiAgdmFyIGR4ID0gMDtcblxuXHRpZiAoZWxlbS5iYXJOdW1iZXIpIHtcblx0XHR0aGlzLmFkZE1lYXN1cmVOdW1iZXIoZWxlbS5iYXJOdW1iZXIsIGFic2VsZW0pO1xuXHR9XG5cblxuICB2YXIgZmlyc3Rkb3RzID0gKGVsZW0udHlwZT09PVwiYmFyX3JpZ2h0X3JlcGVhdFwiIHx8IGVsZW0udHlwZT09PVwiYmFyX2RibF9yZXBlYXRcIik7XG4gIHZhciBmaXJzdHRoaW4gPSAoZWxlbS50eXBlIT09XCJiYXJfbGVmdF9yZXBlYXRcIiAmJiBlbGVtLnR5cGUhPT1cImJhcl90aGlja190aGluXCIgJiYgZWxlbS50eXBlIT09XCJiYXJfaW52aXNpYmxlXCIpO1xuICB2YXIgdGhpY2sgPSAoZWxlbS50eXBlPT09XCJiYXJfcmlnaHRfcmVwZWF0XCIgfHwgZWxlbS50eXBlPT09XCJiYXJfZGJsX3JlcGVhdFwiIHx8IGVsZW0udHlwZT09PVwiYmFyX2xlZnRfcmVwZWF0XCIgfHxcbiAgICAgICAgIGVsZW0udHlwZT09PVwiYmFyX3RoaW5fdGhpY2tcIiB8fCBlbGVtLnR5cGU9PT1cImJhcl90aGlja190aGluXCIpO1xuICB2YXIgc2Vjb25kdGhpbiA9IChlbGVtLnR5cGU9PT1cImJhcl9sZWZ0X3JlcGVhdFwiIHx8IGVsZW0udHlwZT09PVwiYmFyX3RoaWNrX3RoaW5cIiB8fCBlbGVtLnR5cGU9PT1cImJhcl90aGluX3RoaW5cIiB8fCBlbGVtLnR5cGU9PT1cImJhcl9kYmxfcmVwZWF0XCIpO1xuICB2YXIgc2Vjb25kZG90cyA9IChlbGVtLnR5cGU9PT1cImJhcl9sZWZ0X3JlcGVhdFwiIHx8IGVsZW0udHlwZT09PVwiYmFyX2RibF9yZXBlYXRcIik7XG5cbiAgLy8gbGltaXQgcG9zaXRpb25pbmcgb2Ygc2x1cnNcbiAgaWYgKGZpcnN0ZG90cyB8fCBzZWNvbmRkb3RzKSB7XG4gICAgZm9yICh2YXIgc2x1ciBpbiB0aGlzLnNsdXJzKSB7XG4gICAgICBpZiAodGhpcy5zbHVycy5oYXNPd25Qcm9wZXJ0eShzbHVyKSkge1xuICAgICAgICB0aGlzLnNsdXJzW3NsdXJdLnNldEVuZFgoYWJzZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhcnRsaW1pdGVsZW0gPSBhYnNlbGVtO1xuICB9XG5cbiAgaWYgKGZpcnN0ZG90cykge1xuICAgIGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChcImRvdHMuZG90XCIsIGR4LCAxLCA3KSk7XG4gICAgYWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwiZG90cy5kb3RcIiwgZHgsIDEsIDUpKTtcbiAgICBkeCs9NjsgLy8yIGhhcmRjb2RlZCwgdHdpY2U7XG4gIH1cblxuICBpZiAoZmlyc3R0aGluKSB7XG4gICAgYW5jaG9yID0gbmV3IFJlbGF0aXZlRWxlbWVudChudWxsLCBkeCwgMSwgMiwge1widHlwZVwiOiBcImJhclwiLCBcInBpdGNoMlwiOjEwLCBsaW5ld2lkdGg6MC42fSk7XG4gICAgYWJzZWxlbS5hZGRSaWdodChhbmNob3IpO1xuICB9XG5cbiAgaWYgKGVsZW0udHlwZT09PVwiYmFyX2ludmlzaWJsZVwiKSB7XG4gICAgYW5jaG9yID0gbmV3IFJlbGF0aXZlRWxlbWVudChudWxsLCBkeCwgMSwgMiwge1widHlwZVwiOiBcIm5vbmVcIiwgXCJwaXRjaDJcIjoxMCwgbGluZXdpZHRoOjAuNn0pO1xuICAgIGFic2VsZW0uYWRkUmlnaHQoYW5jaG9yKTtcbiAgfVxuXG4gIGlmIChlbGVtLmRlY29yYXRpb24pIHtcbiAgICB0aGlzLmRlY29yYXRpb24uY3JlYXRlRGVjb3JhdGlvbih2b2ljZSwgZWxlbS5kZWNvcmF0aW9uLCAxMiwgKHRoaWNrKT8zOjEsIGFic2VsZW0sIDAsIFwiZG93blwiLCAyLCBlbGVtLnBvc2l0aW9uaW5nLCB0aGlzLmhhc1ZvY2Fscyk7XG4gIH1cblxuICBpZiAodGhpY2spIHtcbiAgICBkeCs9NDsgLy8zIGhhcmRjb2RlZDtcbiAgICBhbmNob3IgPSBuZXcgUmVsYXRpdmVFbGVtZW50KG51bGwsIGR4LCA0LCAyLCB7XCJ0eXBlXCI6IFwiYmFyXCIsIFwicGl0Y2gyXCI6MTAsIGxpbmV3aWR0aDo0fSk7XG4gICAgYWJzZWxlbS5hZGRSaWdodChhbmNob3IpO1xuICAgIGR4Kz01O1xuICB9XG5cbi8vIGlmICh0aGlzLnBhcnRzdGFydGVsZW0gJiYgKHRoaWNrIHx8IChmaXJzdHRoaW4gJiYgc2Vjb25kdGhpbikpKSB7IC8vIG1lYW5zIGVuZCBvZiBudGggcGFydFxuLy8gdGhpcy5wYXJ0c3RhcnRlbGVtLmFuY2hvcjI9YW5jaG9yO1xuLy8gdGhpcy5wYXJ0c3RhcnRlbGVtID0gbnVsbDtcbi8vIH1cblxuICBpZiAodGhpcy5wYXJ0c3RhcnRlbGVtICYmIGVsZW0uZW5kRW5kaW5nKSB7XG4gICAgdGhpcy5wYXJ0c3RhcnRlbGVtLmFuY2hvcjI9YW5jaG9yO1xuICAgIHRoaXMucGFydHN0YXJ0ZWxlbSA9IG51bGw7XG4gIH1cblxuICBpZiAoc2Vjb25kdGhpbikge1xuICAgIGR4Kz0zOyAvLzMgaGFyZGNvZGVkO1xuICAgIGFuY2hvciA9IG5ldyBSZWxhdGl2ZUVsZW1lbnQobnVsbCwgZHgsIDEsIDIsIHtcInR5cGVcIjogXCJiYXJcIiwgXCJwaXRjaDJcIjoxMCwgbGluZXdpZHRoOjAuNn0pO1xuICAgIGFic2VsZW0uYWRkUmlnaHQoYW5jaG9yKTsgLy8gMyBpcyBoYXJkY29kZWRcbiAgfVxuXG4gIGlmIChzZWNvbmRkb3RzKSB7XG4gICAgZHgrPTM7IC8vMyBoYXJkY29kZWQ7XG4gICAgYWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwiZG90cy5kb3RcIiwgZHgsIDEsIDcpKTtcbiAgICBhYnNlbGVtLmFkZFJpZ2h0KG5ldyBSZWxhdGl2ZUVsZW1lbnQoXCJkb3RzLmRvdFwiLCBkeCwgMSwgNSkpO1xuICB9IC8vIDIgaXMgaGFyZGNvZGVkXG5cbiAgaWYgKGVsZW0uc3RhcnRFbmRpbmcgJiYgaXNGaXJzdFN0YWZmKSB7IC8vIG9ubHkgcHV0IHRoZSBmaXJzdCAmIHNlY29uZCBlbmRpbmcgbWFya3Mgb24gdGhlIGZpcnN0IHN0YWZmXG5cdCAgdmFyIHRleHRXaWR0aCA9IHRoaXMucmVuZGVyZXIuZ2V0VGV4dFNpemUoZWxlbS5zdGFydEVuZGluZywgXCJyZXBlYXRmb250XCIsICcnKS53aWR0aDtcblx0ICBhYnNlbGVtLm1pbnNwYWNpbmcgKz0gdGV4dFdpZHRoICsgMTA7IC8vIEdpdmUgcGxlbnR5IG9mIHJvb20gZm9yIHRoZSBlbmRpbmcgbnVtYmVyLlxuICAgIHRoaXMucGFydHN0YXJ0ZWxlbSA9IG5ldyBFbmRpbmdFbGVtKGVsZW0uc3RhcnRFbmRpbmcsIGFuY2hvciwgbnVsbCk7XG5cdCAgdm9pY2UuYWRkT3RoZXIodGhpcy5wYXJ0c3RhcnRlbGVtKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGxpdHRsZSBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgYmFyIGxpbmUgc28gdGhhdCBub3RoaW5nIGNhbiBjcm93ZCBpdC5cblx0YWJzZWxlbS5leHRyYXcgLT0gNTtcblxuXHRyZXR1cm4gYWJzZWxlbTtcblxufTtcblxuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0RW5ncmF2ZXI7XG4iLCIvLyAgICBhYmNfYmVhbV9lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBCZWFtRWxlbSBjbGFzcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEFic29sdXRlRWxlbWVudCA9IHJlcXVpcmUoJy4vYWJjX2Fic29sdXRlX2VsZW1lbnQnKTtcbnZhciBSZWxhdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCcuL2FiY19yZWxhdGl2ZV9lbGVtZW50Jyk7XG52YXIgc3BhY2luZyA9IHJlcXVpcmUoJy4vYWJjX3NwYWNpbmcnKTtcblxudmFyIGdldER1cmxvZyA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFRPRE8tUEVSOiBUaGlzIGlzIGEgaGFjayB0byBwcmV2ZW50IGEgQ2hyb21lIGxvY2t1cC4gRHVyYXRpb24gc2hvdWxkIGhhdmUgYmVlbiBkZWZpbmVkIGFscmVhZHksXG4gICAgICAgIC8vIGJ1dCB0aGVyZSdzIGRlZmluaXRlbHkgYSBjYXNlIHdoZXJlIGl0IGlzbid0LiBbUHJvYmFibHkgc29tZXRoaW5nIHRvIGRvIHdpdGggdHJpcGxldHMuXVxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4vLyAgICAgICAgY29uc29sZS5sb2coXCJnZXREdXJsb2c6IFwiICsgZHVyYXRpb24pO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZyhkdXJhdGlvbikvTWF0aC5sb2coMikpO1xufTtcblxuXG4vLyBNb3N0IGVsZW1lbnRzIG9uIHRoZSBwYWdlIGFyZSByZWxhdGVkIHRvIGEgcGFydGljdWxhciBhYnNvbHV0ZSBlbGVtZW50IC0tIG5vdGVzLCByZXN0cywgYmFycywgZXRjLiBCZWFtcywgaG93ZXZlciwgc3BhbiBtdWx0aXBsZSBlbGVtZW50cy5cbi8vIFRoaXMgbWVhbnMgdGhhdCBiZWFtcyBjYW4ndCBiZSBsYWlkIG91dCB1bnRpbCB0aGUgYWJzb2x1dGUgZWxlbWVudHMgYXJlIHBsYWNlZC4gVGhlcmUgaXMgdGhlIGZ1cnRoZXIgY29tcGxpY2F0aW9uIHRoYXQgdGhlIHN0ZW1zIGZvciBiZWFtZWRcbi8vIG5vdGVzIGNhbid0IGJlIGxhaWQgb3V0IHVudGlsIHRoZSBiZWFtcyBhcmUgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGhvdyBsb25nIHRoZXkgd2lsbCBiZSB1bnRpbCB3ZSBrbm93IHRoZSBzbG9wZSBvZiB0aGUgYmVhbSBhbmQgdGhlIGhvcml6b250YWxcbi8vIHNwYWNpbmcgb2YgdGhlIGFic29sdXRlIGVsZW1lbnRzLlxuLy9cbi8vIFNvLCB3aGVuIGEgYmVhbSBpcyBkZXRlY3RlZCwgYSBCZWFtRWxlbSBpcyBjcmVhdGVkLCB0aGVuIGFsbCBub3RlcyBiZWxvbmdpbmcgdG8gdGhhdCBiZWFtIGFyZSBhZGRlZCB0byBpdC4gVGhlc2Ugbm90ZXMgYXJlIG5vdCBnaXZlbiBzdGVtcyBhdCB0aGF0IHRpbWUuXG4vLyBUaGVuLCBhZnRlciB0aGUgaG9yaXpvbnRhbCBsYXlvdXQgaXMgY29tcGxldGUsIGFsbCBvZiB0aGUgQmVhbUVsZW0gYXJlIGl0ZXJhdGVkIHRvIHNldCB0aGUgYmVhbSBwb3NpdGlvbiwgdGhlbiBhbGwgb2YgdGhlIG5vdGVzIHRoYXQgYXJlIGJlYW1lZCBhcmUgZ2l2ZW5cbi8vIHN0ZW1zLiBBZnRlciB0aGF0LCB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBkcmF3aW5nIHN0ZXAuXG5cbi8vIFRoZXJlIGFyZSB0aHJlZSBwaGFzZXM6IHRoZSBzZXR1cCBwaGFzZSwgd2hlbiBuZXcgZWxlbWVudHMgYXJlIGJlaW5nIGRpc2NvdmVyZWQsIHRoZSBsYXlvdXQgcGhhc2UsIHdoZW4gZXZlcnl0aGluZyBpcyBjYWxjdWxhdGVkLCBhbmQgdGhlIGRyYXdpbmcgcGhhc2UsXG4vLyB3aGVuIHRoZSBvYmplY3QgaXMgbm90IGNoYW5nZWQsIGJ1dCBpcyB1c2VkIHRvIHB1dCB0aGUgZWxlbWVudHMgb24gdGhlIHBhZ2UuXG5cbnZhciBCZWFtRWxlbTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvL1xuXHQvLyBTZXR1cCBwaGFzZVxuXHQvL1xuXHRCZWFtRWxlbSA9IGZ1bmN0aW9uIEJlYW1FbGVtKHN0ZW1IZWlnaHQsIHR5cGUsIGZsYXQpIHtcblx0XHQvLyB0eXBlIGlzIFwiZ3JhY2VcIiwgXCJ1cFwiLCBcImRvd25cIiwgb3IgdW5kZWZpbmVkLiBmbGF0IGlzIHVzZWQgdG8gZm9yY2UgZmxhdCBiZWFtcywgYXMgaXQgY29tbW9ubHkgZm91bmQgaW4gdGhlIGdyYWNlIG5vdGVzIG9mIGJhZ3BpcGUgbXVzaWMuXG5cdFx0dGhpcy5pc2ZsYXQgPSBmbGF0O1xuXHRcdHRoaXMuaXNncmFjZSA9ICh0eXBlICYmIHR5cGUgPT09IFwiZ3JhY2VcIik7XG5cdFx0dGhpcy5mb3JjZXVwID0gdGhpcy5pc2dyYWNlIHx8ICh0eXBlICYmIHR5cGUgPT09IFwidXBcIik7XG5cdFx0dGhpcy5mb3JjZWRvd24gPSAodHlwZSAmJiB0eXBlID09PSBcImRvd25cIik7XG5cdFx0dGhpcy5lbGVtcyA9IFtdOyAvLyBhbGwgdGhlIEFic29sdXRlRWxlbWVudHMgdGhhdCB0aGlzIGJlYW0gdG91Y2hlcy4gSXQgbWF5IGluY2x1ZGUgZW1iZWRkZWQgcmVzdHMuXG5cdFx0dGhpcy50b3RhbCA9IDA7XG5cdFx0dGhpcy5hbGxyZXN0cyA9IHRydWU7XG5cdFx0dGhpcy5zdGVtSGVpZ2h0ID0gc3RlbUhlaWdodDtcblx0XHR0aGlzLmJlYW1zID0gW107IC8vIER1cmluZyB0aGUgbGF5b3V0IHBoYXNlLCB0aGlzIHdpbGwgYmVjb21lIGEgbGlzdCBvZiB0aGUgYmVhbXMgdGhhdCBuZWVkIHRvIGJlIGRyYXduLlxuXHR9O1xuXG5cdEJlYW1FbGVtLnByb3RvdHlwZS5zZXRIaW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuaGludCA9IHRydWU7XG5cdH07XG5cblx0QmVhbUVsZW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGFic2VsZW0pIHtcblx0XHR2YXIgcGl0Y2ggPSBhYnNlbGVtLmFiY2VsZW0uYXZlcmFnZXBpdGNoO1xuXHRcdGlmIChwaXRjaCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIGRvbid0IGluY2x1ZGUgZWxlbWVudHMgbGlrZSBzcGFjZXJzIGluIGJlYW1zXG5cdFx0dGhpcy5hbGxyZXN0cyA9IHRoaXMuYWxscmVzdHMgJiYgYWJzZWxlbS5hYmNlbGVtLnJlc3Q7XG5cdFx0YWJzZWxlbS5iZWFtID0gdGhpcztcblx0XHR0aGlzLmVsZW1zLnB1c2goYWJzZWxlbSk7XG5cdFx0Ly92YXIgcGl0Y2ggPSBhYnNlbGVtLmFiY2VsZW0uYXZlcmFnZXBpdGNoO1xuXHRcdHRoaXMudG90YWwgKz0gcGl0Y2g7IC8vIFRPRE8gQ0hPUkQgKGdldCBwaXRjaGVzIGZyb20gYWJzZWxlbS5oZWFkcylcblx0XHRpZiAodGhpcy5taW4gPT09IHVuZGVmaW5lZCB8fCBhYnNlbGVtLmFiY2VsZW0ubWlucGl0Y2ggPCB0aGlzLm1pbikge1xuXHRcdFx0dGhpcy5taW4gPSBhYnNlbGVtLmFiY2VsZW0ubWlucGl0Y2g7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1heCA9PT0gdW5kZWZpbmVkIHx8IGFic2VsZW0uYWJjZWxlbS5tYXhwaXRjaCA+IHRoaXMubWF4KSB7XG5cdFx0XHR0aGlzLm1heCA9IGFic2VsZW0uYWJjZWxlbS5tYXhwaXRjaDtcblx0XHR9XG5cdH07XG5cblx0dmFyIG1pZGRsZUxpbmUgPSA2O1x0Ly8gaGFyZGNvZGVkIDYgaXMgQlxuXG5cdEJlYW1FbGVtLnByb3RvdHlwZS5jYWxjRGlyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZm9yY2V1cCkgcmV0dXJuIHRydWU7XG5cdFx0aWYgKHRoaXMuZm9yY2Vkb3duKSByZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGF2ZXJhZ2UgPSBjYWxjQXZlcmFnZSh0aGlzLnRvdGFsLCB0aGlzLmVsZW1zLmxlbmd0aCk7XG5cdFx0cmV0dXJuIGF2ZXJhZ2UgPCBtaWRkbGVMaW5lO1xuXHR9O1xuXG5cdC8vXG5cdC8vIGxheW91dCBwaGFzZVxuXHQvL1xuXHRCZWFtRWxlbS5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuZWxlbXMubGVuZ3RoID09PSAwIHx8IHRoaXMuYWxscmVzdHMpIHJldHVybjtcblxuXHRcdHRoaXMuc3RlbXNVcCA9IHRoaXMuY2FsY0RpcigpOyAvLyBUcnVlIG1lYW5zIHRoZSBzdGVtcyBhcmUgZmFjaW5nIHVwLlxuXHRcdHZhciBkeSA9IGNhbGNEeSh0aGlzLnN0ZW1zVXAsIHRoaXMuaXNncmFjZSk7IC8vIFRoaXMgaXMgdGhlIHdpZHRoIG9mIHRoZSBiZWFtIGxpbmUuXG5cblx0XHQvLyBjcmVhdGUgdGhlIG1haW4gYmVhbVxuXHRcdHZhciBmaXJzdEVsZW1lbnQgPSB0aGlzLmVsZW1zWzBdO1xuXHRcdHZhciBsYXN0RWxlbWVudCA9IHRoaXMuZWxlbXNbdGhpcy5lbGVtcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgbWluU3RlbUhlaWdodCA9IDA7IC8vIFRoZSBmb2xsb3dpbmcgaXMgdG8gbGVhdmUgc3BhY2UgZm9yIFwiIS8vLyFcIiBtYXJrcy5cblx0XHR2YXIgcmVmZXJlbmNlUGl0Y2ggPSB0aGlzLnN0ZW1zVXAgPyBmaXJzdEVsZW1lbnQuYWJjZWxlbS5tYXhwaXRjaCA6IGZpcnN0RWxlbWVudC5hYmNlbGVtLm1pbnBpdGNoO1xuXHRcdG1pblN0ZW1IZWlnaHQgPSBtaW5TdGVtKGZpcnN0RWxlbWVudCwgdGhpcy5zdGVtc1VwLCByZWZlcmVuY2VQaXRjaCwgbWluU3RlbUhlaWdodCk7XG5cdFx0bWluU3RlbUhlaWdodCA9IG1pblN0ZW0obGFzdEVsZW1lbnQsIHRoaXMuc3RlbXNVcCwgcmVmZXJlbmNlUGl0Y2gsIG1pblN0ZW1IZWlnaHQpO1xuXHRcdG1pblN0ZW1IZWlnaHQgPSBNYXRoLm1heCh0aGlzLnN0ZW1IZWlnaHQsIG1pblN0ZW1IZWlnaHQgKyAzKTsgLy8gVE9ETy1QRVI6IFRoZSAzIGlzIHRoZSB3aWR0aCBvZiBhIDE2dGggYmVhbS4gVGhlIGFjdHVhbCBoZWlnaHQgb2YgdGhlIGJlYW0gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0XHR2YXIgeVBvcyA9IGNhbGNZUG9zKHRoaXMudG90YWwsIHRoaXMuZWxlbXMubGVuZ3RoLCBtaW5TdGVtSGVpZ2h0LCB0aGlzLnN0ZW1zVXAsIGZpcnN0RWxlbWVudC5hYmNlbGVtLmF2ZXJhZ2VwaXRjaCwgbGFzdEVsZW1lbnQuYWJjZWxlbS5hdmVyYWdlcGl0Y2gsIHRoaXMuaXNmbGF0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuaXNncmFjZSk7XG5cdFx0dmFyIHhQb3MgPSBjYWxjWFBvcyh0aGlzLnN0ZW1zVXAsIGZpcnN0RWxlbWVudCwgbGFzdEVsZW1lbnQpO1xuXHRcdHRoaXMuYmVhbXMucHVzaCh7IHN0YXJ0WDogeFBvc1swXSwgZW5kWDogeFBvc1sxXSwgc3RhcnRZOiB5UG9zWzBdLCBlbmRZOiB5UG9zWzFdLCBkeTogZHkgfSk7XG5cblx0XHQvLyBjcmVhdGUgdGhlIHJlc3Qgb2YgdGhlIGJlYW1zIChpbiB0aGUgY2FzZSBvZiAxLzE2dGggbm90ZXMsIGV0Yy5cblx0XHR2YXIgYmVhbXMgPSBjcmVhdGVBZGRpdGlvbmFsQmVhbXModGhpcy5lbGVtcywgdGhpcy5zdGVtc1VwLCB0aGlzLmJlYW1zWzBdLCB0aGlzLmlzZ3JhY2UsIGR5KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJlYW1zLmxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5iZWFtcy5wdXNoKGJlYW1zW2ldKTtcblxuXHRcdC8vIE5vdyB0aGF0IHRoZSBtYWluIGJlYW0gaXMgZGVmaW5lZCwgd2Uga25vdyBob3cgdGFsbCB0aGUgc3RlbXMgc2hvdWxkIGJlLCBzbyBjcmVhdGUgdGhlbSBhbmQgYXR0YWNoIHRoZW0gdG8gdGhlIG9yaWdpbmFsIG5vdGVzLlxuXHRcdGNyZWF0ZVN0ZW1zKHRoaXMuZWxlbXMsIHRoaXMuc3RlbXNVcCwgdGhpcy5iZWFtc1swXSwgZHksIHRoaXMubWFpbk5vdGUpO1xuXHR9O1xuXG5cdEJlYW1FbGVtLnByb3RvdHlwZS5pc0Fib3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RlbXNVcDtcblx0fTtcblxuXHQvLyBXZSBjYW4ndCBqdXN0IHVzZSB0aGUgZW50aXJlIGJlYW0gZm9yIHRoZSBjYWxjdWxhdGlvbi4gVGhlIHJhbmdlIGhhcyB0byBiZSBwYXNzZWQgaW4sIGJlY2F1c2UgdGhlIGJlYW0gbWlnaHQgZXh0ZW5kIGludG8gc29tZSB1bnJlbGF0ZWQgbm90ZXMuIGZvciBpbnN0YW5jZSwgKDNfYSdmJ2UnZicyIHdoZW4gTDoxNlxuXHRCZWFtRWxlbS5wcm90b3R5cGUuaGVpZ2h0QXRNaWRwb2ludCA9IGZ1bmN0aW9uKHN0YXJ0WCwgZW5kWCkge1xuXHRcdGlmICh0aGlzLmJlYW1zLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAwO1xuXHRcdHZhciBiZWFtID0gdGhpcy5iZWFtc1swXTtcblx0XHR2YXIgbWlkUG9pbnQgPSBzdGFydFggKyAoZW5kWCAtIHN0YXJ0WCkgLyAyO1xuXHRcdHJldHVybiBnZXRCYXJZQXQoYmVhbS5zdGFydFgsIGJlYW0uc3RhcnRZLCBiZWFtLmVuZFgsIGJlYW0uZW5kWSwgbWlkUG9pbnQpO1xuXHR9O1xuXG5cdEJlYW1FbGVtLnByb3RvdHlwZS55QXROb3RlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBiZWFtID0gdGhpcy5iZWFtc1swXTtcblx0XHRyZXR1cm4gZ2V0QmFyWUF0KGJlYW0uc3RhcnRYLCBiZWFtLnN0YXJ0WSwgYmVhbS5lbmRYLCBiZWFtLmVuZFksIGVsZW1lbnQueCk7XG5cdH07XG5cblx0QmVhbUVsZW0ucHJvdG90eXBlLnhBdE1pZHBvaW50ID0gZnVuY3Rpb24oc3RhcnRYLCBlbmRYKSB7XG5cdFx0cmV0dXJuIHN0YXJ0WCArIChlbmRYIC0gc3RhcnRYKS8yO1xuXHR9O1xuXG5cdC8vXG5cdC8vIERyYXdpbmcgcGhhc2Vcblx0Ly9cblx0QmVhbUVsZW0ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuXHRcdGlmICh0aGlzLmJlYW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG5cdFx0cmVuZGVyZXIuYmVnaW5Hcm91cCgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iZWFtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGJlYW0gPSB0aGlzLmJlYW1zW2ldO1xuXHRcdFx0ZHJhd0JlYW0ocmVuZGVyZXIsIGJlYW0uc3RhcnRYLCBiZWFtLnN0YXJ0WSwgYmVhbS5lbmRYLCBiZWFtLmVuZFksIGJlYW0uZHksIHRoaXMuaGludCk7XG5cdFx0fVxuXHRcdHJlbmRlcmVyLmVuZEdyb3VwKCdiZWFtLWVsZW0nKTtcblx0fTtcblxuXHQvL1xuXHQvLyBwcml2YXRlIGZ1bmN0aW9uc1xuXHQvL1xuXHRmdW5jdGlvbiBtaW5TdGVtKGVsZW1lbnQsIHN0ZW1zVXAsIHJlZmVyZW5jZVBpdGNoLCBtaW5TdGVtSGVpZ2h0KSB7XG5cdFx0aWYgKCFlbGVtZW50LmNoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG1pblN0ZW1IZWlnaHQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWxlbSA9IGVsZW1lbnQuY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoc3RlbXNVcCAmJiBlbGVtLnRvcCAhPT0gdW5kZWZpbmVkICYmIGVsZW0uYyA9PT0gXCJmbGFncy51Z3JhY2VcIilcblx0XHRcdFx0bWluU3RlbUhlaWdodCA9IE1hdGgubWF4KG1pblN0ZW1IZWlnaHQsIGVsZW0udG9wIC0gcmVmZXJlbmNlUGl0Y2gpO1xuXHRcdFx0ZWxzZSBpZiAoIXN0ZW1zVXAgJiYgZWxlbS5ib3R0b20gIT09IHVuZGVmaW5lZCAmJiBlbGVtLmMgPT09IFwiZmxhZ3MudWdyYWNlXCIpXG5cdFx0XHRcdG1pblN0ZW1IZWlnaHQgPSBNYXRoLm1heChtaW5TdGVtSGVpZ2h0LCByZWZlcmVuY2VQaXRjaCAtIGVsZW0uYm90dG9tICsgNyk7IC8vIFRoZSBleHRyYSA3IGlzIGJlY2F1c2Ugd2UgYXJlIG1lYXN1cmluZyB0aGUgc2xhc2ggZnJvbSB0aGUgdG9wLlxuXHRcdH1cblx0XHRyZXR1cm4gbWluU3RlbUhlaWdodDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGNTbGFudChsZWZ0QXZlcmFnZVBpdGNoLCByaWdodEF2ZXJhZ2VQaXRjaCwgbnVtU3RlbXMsIGlzRmxhdCkge1xuXHRcdGlmIChpc0ZsYXQpXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR2YXIgc2xhbnQgPSBsZWZ0QXZlcmFnZVBpdGNoIC0gcmlnaHRBdmVyYWdlUGl0Y2g7XG5cdFx0dmFyIG1heFNsYW50ID0gbnVtU3RlbXMgLyAyO1xuXG5cdFx0aWYgKHNsYW50ID4gbWF4U2xhbnQpIHNsYW50ID0gbWF4U2xhbnQ7XG5cdFx0aWYgKHNsYW50IDwgLW1heFNsYW50KSBzbGFudCA9IC1tYXhTbGFudDtcblx0XHRyZXR1cm4gc2xhbnQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxjQXZlcmFnZSh0b3RhbCwgbnVtRWxlbWVudHMpIHtcblx0XHRpZiAoIW51bUVsZW1lbnRzKVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0cmV0dXJuIHRvdGFsIC8gbnVtRWxlbWVudHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCYXJZQXQoc3RhcnR4LCBzdGFydHksIGVuZHgsIGVuZHksIHgpIHtcblx0XHRyZXR1cm4gc3RhcnR5ICsgKGVuZHkgLSBzdGFydHkpIC8gKGVuZHggLSBzdGFydHgpICogKHggLSBzdGFydHgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY0R5KGFzYywgaXNHcmFjZSkge1xuXHRcdHZhciBkeSA9IChhc2MpID8gc3BhY2luZy5TVEVQIDogLXNwYWNpbmcuU1RFUDtcblx0XHRpZiAoaXNHcmFjZSkgZHkgPSBkeSAqIDAuNDtcblx0XHRyZXR1cm4gZHk7XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3QmVhbShyZW5kZXJlciwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGR5LCBpc0hpbnQpIHtcblx0XHR2YXIga2xhc3MgPSAnYmVhbS1lbGVtJztcblx0XHRpZiAoaXNIaW50KVxuXHRcdFx0a2xhc3MgKz0gXCIgYWJjanMtaGludFwiO1xuXG5cdFx0Ly8gdGhlIFggY29vcmRpbmF0ZXMgYXJlIGFjdHVhbCBjb29yZGluYXRlcywgYnV0IHRoZSBZIGNvb3JkaW5hdGVzIGFyZSBpbiBwaXRjaGVzLlxuXHRcdHN0YXJ0WSA9IHJlbmRlcmVyLmNhbGNZKHN0YXJ0WSk7XG5cdFx0ZW5kWSA9IHJlbmRlcmVyLmNhbGNZKGVuZFkpO1xuXHRcdHZhciBwYXRoU3RyaW5nID0gXCJNXCIgKyBzdGFydFggKyBcIiBcIiArIHN0YXJ0WSArIFwiIExcIiArIGVuZFggKyBcIiBcIiArIGVuZFkgK1xuXHRcdFx0XCJMXCIgKyBlbmRYICsgXCIgXCIgKyAoZW5kWSArIGR5KSArIFwiIExcIiArIHN0YXJ0WCArIFwiIFwiICsgKHN0YXJ0WSArIGR5KSArIFwielwiO1xuXHRcdHJlbmRlcmVyLnByaW50UGF0aCh7XG5cdFx0XHRwYXRoOiBwYXRoU3RyaW5nLFxuXHRcdFx0c3Ryb2tlOiBcIm5vbmVcIixcblx0XHRcdGZpbGw6IFwiIzAwMDAwMFwiLFxuXHRcdFx0J2NsYXNzJzogcmVuZGVyZXIuYWRkQ2xhc3NlcyhrbGFzcylcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGNYUG9zKGFzYywgZmlyc3RFbGVtZW50LCBsYXN0RWxlbWVudCkge1xuXHRcdHZhciBzdGFydGhlYWQgPSBmaXJzdEVsZW1lbnQuaGVhZHNbYXNjID8gMCA6IGZpcnN0RWxlbWVudC5oZWFkcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgZW5kaGVhZCA9IGxhc3RFbGVtZW50LmhlYWRzW2FzYyA/IDAgOiBsYXN0RWxlbWVudC5oZWFkcy5sZW5ndGggLSAxXTtcblx0XHR2YXIgc3RhcnRYID0gc3RhcnRoZWFkLng7XG5cdFx0aWYgKGFzYykgc3RhcnRYICs9IHN0YXJ0aGVhZC53IC0gMC42O1xuXHRcdHZhciBlbmRYID0gZW5kaGVhZC54O1xuXHRcdGlmIChhc2MpIGVuZFggKz0gZW5kaGVhZC53O1xuXHRcdHJldHVybiBbIHN0YXJ0WCwgZW5kWCBdO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY1lQb3ModG90YWwsIG51bUVsZW1lbnRzLCBzdGVtSGVpZ2h0LCBhc2MsIGZpcnN0QXZlcmFnZVBpdGNoLCBsYXN0QXZlcmFnZVBpdGNoLCBpc0ZsYXQsIG1pblBpdGNoLCBtYXhQaXRjaCwgaXNHcmFjZSkge1xuXHRcdHZhciBhdmVyYWdlID0gY2FsY0F2ZXJhZ2UodG90YWwsIG51bUVsZW1lbnRzKTsgLy8gVGhpcyBpcyB0aGUgYXZlcmFnZSBwaXRjaCBmb3IgdGhlIGFsbCB0aGUgbm90ZXMgdGhhdCB3aWxsIGJlIGJlYW1lZC5cblx0XHR2YXIgYmFycG9zID0gc3RlbUhlaWdodCAtIDI7IC8vIChpc0dyYWNlKT8gNTo3O1xuXHRcdHZhciBiYXJtaW5wb3MgPSBzdGVtSGVpZ2h0IC0gMjtcblx0XHR2YXIgcG9zID0gTWF0aC5yb3VuZChhc2MgPyBNYXRoLm1heChhdmVyYWdlICsgYmFycG9zLCBtYXhQaXRjaCArIGJhcm1pbnBvcykgOiBNYXRoLm1pbihhdmVyYWdlIC0gYmFycG9zLCBtaW5QaXRjaCAtIGJhcm1pbnBvcykpO1xuXG5cdFx0dmFyIHNsYW50ID0gY2FsY1NsYW50KGZpcnN0QXZlcmFnZVBpdGNoLCBsYXN0QXZlcmFnZVBpdGNoLCBudW1FbGVtZW50cywgaXNGbGF0KTtcblx0XHR2YXIgc3RhcnRZID0gcG9zICsgTWF0aC5mbG9vcihzbGFudCAvIDIpO1xuXHRcdHZhciBlbmRZID0gcG9zICsgTWF0aC5mbG9vcigtc2xhbnQgLyAyKTtcblxuXHRcdC8vIElmIHRoZSBub3RlcyBhcmUgdG9vIGhpZ2ggb3IgdG9vIGxvdywgbWFrZSB0aGUgYmVhbSBnbyBkb3duIHRvIHRoZSBtaWRkbGVcblx0XHRpZiAoIWlzR3JhY2UpIHtcblx0XHRcdGlmIChhc2MgJiYgcG9zIDwgNikge1xuXHRcdFx0XHRzdGFydFkgPSA2O1xuXHRcdFx0XHRlbmRZID0gNjtcblx0XHRcdH0gZWxzZSBpZiAoIWFzYyAmJiBwb3MgPiA2KSB7XG5cdFx0XHRcdHN0YXJ0WSA9IDY7XG5cdFx0XHRcdGVuZFkgPSA2O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbIHN0YXJ0WSwgZW5kWV07XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVTdGVtcyhlbGVtcywgYXNjLCBiZWFtLCBkeSwgbWFpbk5vdGUpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWxlbSA9IGVsZW1zW2ldO1xuXHRcdFx0aWYgKGVsZW0uYWJjZWxlbS5yZXN0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdC8vIFRPRE8tUEVSOiBUaGlzIGlzIG9kZC4gSWYgaXQgaXMgYSByZWd1bGFyIGJlYW0gdGhlbiBlbGVtcyBpcyBhbiBhcnJheSBvZiBBYnNvbHV0ZUVsZW1lbnRzLCBpZiBpdCBpcyBhIGdyYWNlIGJlYW0gdGhlbiBpdCBpcyBhbiBhcnJheSBvZiBvYmplY3RzICwgc28gd2UgZGlyZWN0bHkgYXR0YWNoIHRoZSBlbGVtZW50IHRvIHRoZSBwYXJlbnQuIFdlIHRlbGwgaXQgaWYgaXMgYSBncmFjZSBub3RlIGJlY2F1c2UgdGhleSBhcmUgcGFzc2VkIGluIGFzIGEgZ2VuZXJpYyBvYmplY3QgaW5zdGVhZCBvZiBhbiBBYnNvbHV0ZUVsZW1lbnQuXG5cdFx0XHR2YXIgaXNHcmFjZSA9IGVsZW0uYWRkRXh0cmEgPyBmYWxzZSA6IHRydWU7XG5cdFx0XHR2YXIgcGFyZW50ID0gaXNHcmFjZSA/IG1haW5Ob3RlIDogZWxlbTtcblx0XHRcdHZhciBmdXJ0aGVzdEhlYWQgPSBlbGVtLmhlYWRzWyhhc2MpID8gMCA6IGVsZW0uaGVhZHMubGVuZ3RoIC0gMV07XG5cdFx0XHR2YXIgb3ZhbERlbHRhID0gMSAvIDU7Ly8oaXNHcmFjZSk/MS8zOjEvNTtcblx0XHRcdHZhciBwaXRjaCA9IGZ1cnRoZXN0SGVhZC5waXRjaCArICgoYXNjKSA/IG92YWxEZWx0YSA6IC1vdmFsRGVsdGEpO1xuXHRcdFx0dmFyIGR4ID0gYXNjID8gZnVydGhlc3RIZWFkLncgOiAwOyAvLyBkb3duLXBvaW50aW5nIHN0ZW1zIHN0YXJ0IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIG5vdGUsIHVwLXBvaW50aW5nIHN0ZW1zIHN0YXJ0IG9uIHRoZSByaWdodCBzaWRlLCBzbyB3ZSBvZmZzZXQgYnkgdGhlIG5vdGUgd2lkdGguXG5cdFx0XHR2YXIgeCA9IGZ1cnRoZXN0SGVhZC54ICsgZHg7IC8vIHRoaXMgaXMgbm93IHRoZSBhY3R1YWwgeCBsb2NhdGlvbiBpbiBwaXhlbHMuXG5cdFx0XHR2YXIgYmFyeSA9IGdldEJhcllBdChiZWFtLnN0YXJ0WCwgYmVhbS5zdGFydFksIGJlYW0uZW5kWCwgYmVhbS5lbmRZLCB4KTtcblx0XHRcdHZhciBsaW5lV2lkdGggPSAoYXNjKSA/IC0wLjYgOiAwLjY7XG5cdFx0XHRpZiAoIWFzYylcblx0XHRcdFx0YmFyeSAtPSAoZHkgLyAyKSAvIHNwYWNpbmcuU1RFUDtcdC8vIFRPRE8tUEVSOiBUaGlzIGlzIGp1c3QgYSBmdWRnZSBmYWN0b3Igc28gdGhlIGRvd24tcG9pbnRpbmcgc3RlbXMgZG9uJ3Qgb3ZlcmxhcC5cblx0XHRcdGlmIChpc0dyYWNlKVxuXHRcdFx0XHRkeCArPSBlbGVtLmhlYWRzWzBdLmR4O1xuXHRcdFx0Ly8gVE9ETy1QRVItSEFDSzogT25lIHR5cGUgb2Ygbm90ZSBoZWFkIGhhcyBhIGRpZmZlcmVudCBwbGFjZW1lbnQgb2YgdGhlIHN0ZW0uIFRoaXMgc2hvdWxkIGJlIG1vcmUgZ2VuZXJpY2FsbHkgY2FsY3VsYXRlZDpcblx0XHRcdGlmIChmdXJ0aGVzdEhlYWQuYyA9PT0gJ25vdGVoZWFkcy5zbGFzaC5xdWFydGVyJykge1xuXHRcdFx0XHRpZiAoYXNjKVxuXHRcdFx0XHRcdHBpdGNoICs9IDE7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwaXRjaCAtPSAxO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN0ZW0gPSBuZXcgUmVsYXRpdmVFbGVtZW50KG51bGwsIGR4LCAwLCBwaXRjaCwge1xuXHRcdFx0XHRcInR5cGVcIjogXCJzdGVtXCIsXG5cdFx0XHRcdFwicGl0Y2gyXCI6IGJhcnksXG5cdFx0XHRcdGxpbmV3aWR0aDogbGluZVdpZHRoXG5cdFx0XHR9KTtcblx0XHRcdHN0ZW0uc2V0WChwYXJlbnQueCk7IC8vIFRoaXMgaXMgYWZ0ZXIgdGhlIHggY29vcmRpbmF0ZXMgd2VyZSBzZXQsIHNvIHdlIGhhdmUgdG8gc2V0IGl0IGRpcmVjdGx5LlxuXHRcdFx0cGFyZW50LmFkZEV4dHJhKHN0ZW0pO1xuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQWRkaXRpb25hbEJlYW1zKGVsZW1zLCBhc2MsIGJlYW0sIGlzR3JhY2UsIGR5KSB7XG5cdFx0dmFyIGJlYW1zID0gW107XG5cdFx0dmFyIGF1eEJlYW1zID0gW107ICAvLyBhdXhiZWFtIHdpbGwgYmUge3gsIHksIGR1cmxvZywgc2luZ2xlfSBhdXhiZWFtWzBdIHNob3VsZCBtYXRjaCB3aXRoIGR1cmxvZz0tNCAoMTZ0aCkgKGo9LTQtZHVybG9nKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlbGVtID0gZWxlbXNbaV07XG5cdFx0XHRpZiAoZWxlbS5hYmNlbGVtLnJlc3QpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIGZ1cnRoZXN0SGVhZCA9IGVsZW0uaGVhZHNbKGFzYykgPyAwIDogZWxlbS5oZWFkcy5sZW5ndGggLSAxXTtcblx0XHRcdHZhciB4ID0gZnVydGhlc3RIZWFkLnggKyAoKGFzYykgPyBmdXJ0aGVzdEhlYWQudyA6IDApO1xuXHRcdFx0dmFyIGJhcnkgPSBnZXRCYXJZQXQoYmVhbS5zdGFydFgsIGJlYW0uc3RhcnRZLCBiZWFtLmVuZFgsIGJlYW0uZW5kWSwgeCk7XG5cblx0XHRcdHZhciBzeSA9IChhc2MpID8gLTEuNSA6IDEuNTtcblx0XHRcdGlmIChpc0dyYWNlKSBzeSA9IHN5ICogMiAvIDM7IC8vIFRoaXMgbWFrZXMgdGhlIHNlY29uZCBiZWFtIG9uIGdyYWNlIG5vdGVzIGNsb3NlciB0byB0aGUgZmlyc3Qgb25lLlxuXHRcdFx0dmFyIGR1cmF0aW9uID0gZWxlbS5hYmNlbGVtLmR1cmF0aW9uOyAvLyBnZXQgdGhlIGR1cmF0aW9uIHZpYSBhYmNlbGVtIGJlY2F1c2Ugb2YgdHJpcGxldHNcblx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgZHVyYXRpb24gPSAwLjI1OyAvLyBpZiB0aGlzIGlzIHN0ZW1sZXNzLCB0aGVuIHdlIHVzZSBxdWFydGVyIG5vdGUgYXMgdGhlIGR1cmF0aW9uLlxuXHRcdFx0Zm9yICh2YXIgZHVybG9nID0gZ2V0RHVybG9nKGR1cmF0aW9uKTsgZHVybG9nIDwgLTM7IGR1cmxvZysrKSB7XG5cdFx0XHRcdGlmIChhdXhCZWFtc1stNCAtIGR1cmxvZ10pIHtcblx0XHRcdFx0XHRhdXhCZWFtc1stNCAtIGR1cmxvZ10uc2luZ2xlID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXV4QmVhbXNbLTQgLSBkdXJsb2ddID0ge1xuXHRcdFx0XHRcdFx0eDogeCArICgoYXNjKSA/IC0wLjYgOiAwKSwgeTogYmFyeSArIHN5ICogKC00IC0gZHVybG9nICsgMSksXG5cdFx0XHRcdFx0XHRkdXJsb2c6IGR1cmxvZywgc2luZ2xlOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBqID0gYXV4QmVhbXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0aWYgKGkgPT09IGVsZW1zLmxlbmd0aCAtIDEgfHwgZ2V0RHVybG9nKGVsZW1zW2kgKyAxXS5hYmNlbGVtLmR1cmF0aW9uKSA+ICgtaiAtIDQpKSB7XG5cblx0XHRcdFx0XHR2YXIgYXV4QmVhbUVuZFggPSB4O1xuXHRcdFx0XHRcdHZhciBhdXhCZWFtRW5kWSA9IGJhcnkgKyBzeSAqIChqICsgMSk7XG5cblxuXHRcdFx0XHRcdGlmIChhdXhCZWFtc1tqXS5zaW5nbGUpIHtcblx0XHRcdFx0XHRcdGF1eEJlYW1FbmRYID0gKGkgPT09IDApID8geCArIDUgOiB4IC0gNTtcblx0XHRcdFx0XHRcdGF1eEJlYW1FbmRZID0gZ2V0QmFyWUF0KGJlYW0uc3RhcnRYLCBiZWFtLnN0YXJ0WSwgYmVhbS5lbmRYLCBiZWFtLmVuZFksIGF1eEJlYW1FbmRYKSArIHN5ICogKGogKyAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YmVhbXMucHVzaCh7IHN0YXJ0WDogYXV4QmVhbXNbal0ueCwgZW5kWDogYXV4QmVhbUVuZFgsIHN0YXJ0WTogYXV4QmVhbXNbal0ueSwgZW5kWTogYXV4QmVhbUVuZFksIGR5OiBkeSB9KTtcblx0XHRcdFx0XHRhdXhCZWFtcyA9IGF1eEJlYW1zLnNsaWNlKDAsIGopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBiZWFtcztcblx0fVxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWFtRWxlbTtcbiIsIi8vICAgIGFiY19icmFjZV9lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBCcmFjZUVsZW1lbnQgY2xhc3MuXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBHcmVnb3J5IER5a2UgKGdyZWdkeWtlIGF0IGdtYWlsIGRvdCBjb20pIGFuZCBQYXVsIFJvc2VuXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCcmFjZUVsZW0gPSBmdW5jdGlvbiBCcmFjZUVsZW0oKSB7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xufTtcblxuQnJhY2VFbGVtLnByb3RvdHlwZS5pbmNyZWFzZVN0YXZlc0luY2x1ZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sZW5ndGgrKztcbn07XG5cbkJyYWNlRWxlbS5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbih4KSB7XG5cdHRoaXMueCA9IHg7XG59O1xuXG5CcmFjZUVsZW0ucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAxMDsgLy8gVE9ETy1QRVI6IHJpZ2h0IG5vdyB0aGUgZHJhd2luZyBmdW5jdGlvbiBkb2Vzbid0IHZhcnkgdGhlIHdpZHRoIGF0IGFsbC4gSWYgaXQgZG9lcyBpbiB0aGUgZnV0dXJlIHRoZW4gdGhpcyB3aWxsIGNoYW5nZS5cbn07XG5cbkJyYWNlRWxlbS5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKHJlbmRlcmVyLCB0b3AsIGJvdHRvbSkge1xuICAgIHRoaXMuc3RhcnRZID0gdG9wO1xuICAgIHRoaXMuZW5kWSA9IGJvdHRvbTtcbn07XG5cbkJyYWNlRWxlbS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChyZW5kZXJlciwgdG9wLCBib3R0b20pIHtcbiAgICB0aGlzLmxheW91dChyZW5kZXJlciwgdG9wLCBib3R0b20pO1xuICAgIHJlbmRlcmVyLmRyYXdCcmFjZSh0aGlzLngsdGhpcy5zdGFydFksIHRoaXMuZW5kWSk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnJhY2VFbGVtO1xuIiwiLy8gICAgYWJjX2NyZWF0ZV9jbGVmLmpzXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBHcmVnb3J5IER5a2UgKGdyZWdkeWtlIGF0IGdtYWlsIGRvdCBjb20pIGFuZCBQYXVsIFJvc2VuXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBBYnNvbHV0ZUVsZW1lbnQgPSByZXF1aXJlKCcuL2FiY19hYnNvbHV0ZV9lbGVtZW50Jyk7XG52YXIgZ2x5cGhzID0gcmVxdWlyZSgnLi9hYmNfZ2x5cGhzJyk7XG52YXIgUmVsYXRpdmVFbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfcmVsYXRpdmVfZWxlbWVudCcpO1xuXG52YXIgY3JlYXRlQ2xlZjtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRjcmVhdGVDbGVmID0gZnVuY3Rpb24oZWxlbSwgdHVuZU51bWJlcikge1xuXHRcdHZhciBjbGVmO1xuXHRcdHZhciBvY3RhdmUgPSAwO1xuXHRcdHZhciBhYnNlbGVtID0gbmV3IEFic29sdXRlRWxlbWVudChlbGVtLDAsMTAsICdzdGFmZi1leHRyYScsIHR1bmVOdW1iZXIpO1xuXHRcdGFic2VsZW0uaXNDbGVmID0gdHJ1ZTtcblx0XHRzd2l0Y2ggKGVsZW0udHlwZSkge1xuXHRcdFx0Y2FzZSBcInRyZWJsZVwiOiBjbGVmID0gXCJjbGVmcy5HXCI7IGJyZWFrO1xuXHRcdFx0Y2FzZSBcInRlbm9yXCI6IGNsZWY9XCJjbGVmcy5DXCI7IGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFsdG9cIjogY2xlZj1cImNsZWZzLkNcIjsgYnJlYWs7XG5cdFx0XHRjYXNlIFwiYmFzc1wiOiBjbGVmPVwiY2xlZnMuRlwiOyBicmVhaztcblx0XHRcdGNhc2UgJ3RyZWJsZSs4JzogY2xlZiA9IFwiY2xlZnMuR1wiOyBvY3RhdmUgPSAxOyBicmVhaztcblx0XHRcdGNhc2UgJ3Rlbm9yKzgnOmNsZWY9XCJjbGVmcy5DXCI7IG9jdGF2ZSA9IDE7IGJyZWFrO1xuXHRcdFx0Y2FzZSAnYmFzcys4JzogY2xlZj1cImNsZWZzLkZcIjsgb2N0YXZlID0gMTsgYnJlYWs7XG5cdFx0XHRjYXNlICdhbHRvKzgnOiBjbGVmPVwiY2xlZnMuQ1wiOyBvY3RhdmUgPSAxOyBicmVhaztcblx0XHRcdGNhc2UgJ3RyZWJsZS04JzogY2xlZiA9IFwiY2xlZnMuR1wiOyBvY3RhdmUgPSAtMTsgYnJlYWs7XG5cdFx0XHRjYXNlICd0ZW5vci04JzpjbGVmPVwiY2xlZnMuQ1wiOyBvY3RhdmUgPSAtMTsgYnJlYWs7XG5cdFx0XHRjYXNlICdiYXNzLTgnOiBjbGVmPVwiY2xlZnMuRlwiOyBvY3RhdmUgPSAtMTsgYnJlYWs7XG5cdFx0XHRjYXNlICdhbHRvLTgnOiBjbGVmPVwiY2xlZnMuQ1wiOyBvY3RhdmUgPSAtMTsgYnJlYWs7XG5cdFx0XHRjYXNlICdub25lJzogcmV0dXJuIG51bGw7XG5cdFx0XHRjYXNlICdwZXJjJzogY2xlZj1cImNsZWZzLnBlcmNcIjsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiBhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQoXCJjbGVmPVwiK2VsZW0udHlwZSwgMCwgMCwgdW5kZWZpbmVkLCB7dHlwZTpcImRlYnVnXCJ9KSk7XG5cdFx0fVxuXHRcdC8vIGlmIChlbGVtLnZlcnRpY2FsUG9zKSB7XG5cdFx0Ly8gcGl0Y2ggPSBlbGVtLnZlcnRpY2FsUG9zO1xuXHRcdC8vIH1cblx0XHR2YXIgZHggPTU7XG5cdFx0aWYgKGNsZWYpIHtcblx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChjbGVmLCBkeCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGNsZWYpLCBlbGVtLmNsZWZQb3MpKTtcblxuXHRcdFx0aWYgKGNsZWYgPT09ICdjbGVmcy5HJykge1xuXHRcdFx0XHRhYnNlbGVtLnRvcCA9IDEzO1xuXHRcdFx0XHRhYnNlbGVtLmJvdHRvbSA9IC0xO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWJzZWxlbS50b3AgPSAxMDtcblx0XHRcdFx0YWJzZWxlbS5ib3R0b20gPSAyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9jdGF2ZSAhPT0gMCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSAyIC8gMztcblx0XHRcdFx0dmFyIGFkanVzdHNwYWNpbmcgPSAoZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGNsZWYpIC0gZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwiOFwiKSAqIHNjYWxlKSAvIDI7XG5cdFx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChcIjhcIiwgZHggKyBhZGp1c3RzcGFjaW5nLCBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoXCI4XCIpICogc2NhbGUsIChvY3RhdmUgPiAwKSA/IGFic2VsZW0udG9wICsgMyA6IGFic2VsZW0uYm90dG9tIC0gMSwge1xuXHRcdFx0XHRcdHNjYWxleDogc2NhbGUsXG5cdFx0XHRcdFx0c2NhbGV5OiBzY2FsZVxuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdGFic2VsZW0udG9wICs9IDI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhYnNlbGVtO1xuXHR9O1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNsZWY7XG4iLCIvLyAgICBhYmNfY3JlYXRlX2tleV9zaWduYXR1cmUuanNcbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEFic29sdXRlRWxlbWVudCA9IHJlcXVpcmUoJy4vYWJjX2Fic29sdXRlX2VsZW1lbnQnKTtcbnZhciBnbHlwaHMgPSByZXF1aXJlKCcuL2FiY19nbHlwaHMnKTtcbnZhciBSZWxhdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCcuL2FiY19yZWxhdGl2ZV9lbGVtZW50Jyk7XG5cbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2FiY19jb21tb24nKTtcblxudmFyIGNyZWF0ZUtleVNpZ25hdHVyZTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRjcmVhdGVLZXlTaWduYXR1cmUgPSBmdW5jdGlvbihlbGVtLCB0dW5lTnVtYmVyKSB7XG5cdFx0aWYgKCFlbGVtLmFjY2lkZW50YWxzIHx8IGVsZW0uYWNjaWRlbnRhbHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGFic2VsZW0gPSBuZXcgQWJzb2x1dGVFbGVtZW50KGVsZW0sIDAsIDEwLCAnc3RhZmYtZXh0cmEnLCB0dW5lTnVtYmVyKTtcblx0XHRhYnNlbGVtLmlzS2V5U2lnID0gdHJ1ZTtcblx0XHR2YXIgZHggPSAwO1xuXHRcdHBhcnNlQ29tbW9uLmVhY2goZWxlbS5hY2NpZGVudGFscywgZnVuY3Rpb24oYWNjKSB7XG5cdFx0XHR2YXIgc3ltYm9sO1xuXHRcdFx0c3dpdGNoKGFjYy5hY2MpIHtcblx0XHRcdFx0Y2FzZSBcInNoYXJwXCI6IHN5bWJvbCA9IFwiYWNjaWRlbnRhbHMuc2hhcnBcIjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJuYXR1cmFsXCI6IHN5bWJvbCA9IFwiYWNjaWRlbnRhbHMubmF0XCI7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZmxhdFwiOiBzeW1ib2wgPSBcImFjY2lkZW50YWxzLmZsYXRcIjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJxdWFydGVyc2hhcnBcIjogc3ltYm9sID0gXCJhY2NpZGVudGFscy5oYWxmc2hhcnBcIjsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJxdWFydGVyZmxhdFwiOiBzeW1ib2wgPSBcImFjY2lkZW50YWxzLmhhbGZmbGF0XCI7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiBzeW1ib2wgPSBcImFjY2lkZW50YWxzLmZsYXRcIjtcblx0XHRcdH1cblx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChzeW1ib2wsIGR4LCBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoc3ltYm9sKSwgYWNjLnZlcnRpY2FsUG9zLCB7dGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKHN5bWJvbCl9KSk7XG5cdFx0XHRkeCArPSBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoc3ltYm9sKSArIDI7XG5cdFx0fSwgdGhpcyk7XG5cdFx0cmV0dXJuIGFic2VsZW07XG5cdH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUtleVNpZ25hdHVyZTtcbiIsIi8vICAgIGFiY19jcmVhdGVfdGltZV9zaWduYXR1cmUuanNcbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEFic29sdXRlRWxlbWVudCA9IHJlcXVpcmUoJy4vYWJjX2Fic29sdXRlX2VsZW1lbnQnKTtcbnZhciBnbHlwaHMgPSByZXF1aXJlKCcuL2FiY19nbHlwaHMnKTtcbnZhciBSZWxhdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCcuL2FiY19yZWxhdGl2ZV9lbGVtZW50Jyk7XG5cbnZhciBjcmVhdGVUaW1lU2lnbmF0dXJlO1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGNyZWF0ZVRpbWVTaWduYXR1cmUgPSBmdW5jdGlvbihlbGVtLCB0dW5lTnVtYmVyKSB7XG5cdFx0dmFyIGFic2VsZW0gPSBuZXcgQWJzb2x1dGVFbGVtZW50KGVsZW0sMCwxMCwgJ3N0YWZmLWV4dHJhJywgdHVuZU51bWJlcik7XG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gXCJzcGVjaWZpZWRcIikge1xuXHRcdFx0dmFyIHggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KCcrJywgeCsxLCBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoXCIrXCIpLCA2LCB7dGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKFwiK1wiKX0pKTtcblx0XHRcdFx0XHR4ICs9IGdseXBocy5nZXRTeW1ib2xXaWR0aChcIitcIikrMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZWxlbS52YWx1ZVtpXS5kZW4pIHtcblx0XHRcdFx0XHR2YXIgbnVtV2lkdGggPSAwO1xuXHRcdFx0XHRcdGZvciAodmFyIGkyID0gMDsgaTIgPCBlbGVtLnZhbHVlW2ldLm51bS5sZW5ndGg7IGkyKyspXG5cdFx0XHRcdFx0XHRudW1XaWR0aCArPSBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoZWxlbS52YWx1ZVtpXS5udW0uY2hhckF0KGkyKSk7XG5cdFx0XHRcdFx0dmFyIGRlbldpZHRoID0gMDtcblx0XHRcdFx0XHRmb3IgKGkyID0gMDsgaTIgPCBlbGVtLnZhbHVlW2ldLm51bS5sZW5ndGg7IGkyKyspXG5cdFx0XHRcdFx0XHRkZW5XaWR0aCArPSBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoZWxlbS52YWx1ZVtpXS5kZW4uY2hhckF0KGkyKSk7XG5cdFx0XHRcdFx0dmFyIG1heFdpZHRoID0gTWF0aC5tYXgobnVtV2lkdGgsIGRlbldpZHRoKTtcblx0XHRcdFx0XHRhYnNlbGVtLmFkZFJpZ2h0KG5ldyBSZWxhdGl2ZUVsZW1lbnQoZWxlbS52YWx1ZVtpXS5udW0sIHgrKG1heFdpZHRoLW51bVdpZHRoKS8yLCBudW1XaWR0aCwgOCwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoZWxlbS52YWx1ZVtpXS5udW0uY2hhckF0KDApKSB9KSk7XG5cdFx0XHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KGVsZW0udmFsdWVbaV0uZGVuLCB4KyhtYXhXaWR0aC1kZW5XaWR0aCkvMiwgZGVuV2lkdGgsIDQsIHsgdGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKGVsZW0udmFsdWVbaV0uZGVuLmNoYXJBdCgwKSkgfSkpO1xuXHRcdFx0XHRcdHggKz0gbWF4V2lkdGhcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgdGhpc1dpZHRoID0gMDtcblx0XHRcdFx0XHRmb3IgKHZhciBpMyA9IDA7IGkzIDwgZWxlbS52YWx1ZVtpXS5udW0ubGVuZ3RoOyBpMysrKVxuXHRcdFx0XHRcdFx0dGhpc1dpZHRoICs9IGdseXBocy5nZXRTeW1ib2xXaWR0aChlbGVtLnZhbHVlW2ldLm51bS5jaGFyQXQoaTMpKTtcblx0XHRcdFx0XHRhYnNlbGVtLmFkZFJpZ2h0KG5ldyBSZWxhdGl2ZUVsZW1lbnQoZWxlbS52YWx1ZVtpXS5udW0sIHgsIHRoaXNXaWR0aCwgNiwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoZWxlbS52YWx1ZVtpXS5udW0uY2hhckF0KDApKSB9KSk7XG5cdFx0XHRcdFx0eCArPSB0aGlzV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gXCJjb21tb25fdGltZVwiKSB7XG5cdFx0XHRhYnNlbGVtLmFkZFJpZ2h0KG5ldyBSZWxhdGl2ZUVsZW1lbnQoXCJ0aW1lc2lnLmNvbW1vblwiLCAwLCBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoXCJ0aW1lc2lnLmNvbW1vblwiKSwgNiwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoXCJ0aW1lc2lnLmNvbW1vblwiKSB9KSk7XG5cblx0XHR9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gXCJjdXRfdGltZVwiKSB7XG5cdFx0XHRhYnNlbGVtLmFkZFJpZ2h0KG5ldyBSZWxhdGl2ZUVsZW1lbnQoXCJ0aW1lc2lnLmN1dFwiLCAwLCBnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoXCJ0aW1lc2lnLmN1dFwiKSwgNiwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoXCJ0aW1lc2lnLmN1dFwiKSB9KSk7XG5cdFx0fSBlbHNlIGlmIChlbGVtLnR5cGUgPT09IFwidGVtcHVzX2ltcGVyZmVjdHVtXCIpIHtcblx0XHRcdGFic2VsZW0uYWRkUmlnaHQobmV3IFJlbGF0aXZlRWxlbWVudChcInRpbWVzaWcuaW1wZXJmZWN0dW1cIiwgMCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwidGltZXNpZy5pbXBlcmZlY3R1bVwiKSwgNiwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoXCJ0aW1lc2lnLmltcGVyZmVjdHVtXCIpIH0pKTtcblx0XHR9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gXCJ0ZW1wdXNfaW1wZXJmZWN0dW1fcHJvbGF0aW9cIikge1xuXHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwidGltZXNpZy5pbXBlcmZlY3R1bTJcIiwgMCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwidGltZXNpZy5pbXBlcmZlY3R1bTJcIiksIDYsIHsgdGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKFwidGltZXNpZy5pbXBlcmZlY3R1bTJcIikgfSkpO1xuXHRcdH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSBcInRlbXB1c19wZXJmZWN0dW1cIikge1xuXHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwidGltZXNpZy5wZXJmZWN0dW1cIiwgMCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwidGltZXNpZy5wZXJmZWN0dW1cIiksIDYsIHsgdGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKFwidGltZXNpZy5wZXJmZWN0dW1cIikgfSkpO1xuXHRcdH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSBcInRlbXB1c19wZXJmZWN0dW1fcHJvbGF0aW9cIikge1xuXHRcdFx0YWJzZWxlbS5hZGRSaWdodChuZXcgUmVsYXRpdmVFbGVtZW50KFwidGltZXNpZy5wZXJmZWN0dW0yXCIsIDAsIGdseXBocy5nZXRTeW1ib2xXaWR0aChcInRpbWVzaWcucGVyZmVjdHVtMlwiKSwgNiwgeyB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoXCJ0aW1lc2lnLnBlcmZlY3R1bTJcIikgfSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInRpbWUgc2lnbmF0dXJlOlwiLGVsZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYWJzZWxlbTtcblx0fTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGltZVNpZ25hdHVyZTtcbiIsIi8vICAgIGFiY19jcmVzY2VuZG9fZWxlbWVudC5qczogRGVmaW5pdGlvbiBvZiB0aGUgQ3Jlc2NlbmRvRWxlbSBjbGFzcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHNwcmludGYgPSByZXF1aXJlKCcuL3NwcmludGYnKTtcblxudmFyIENyZXNjZW5kb0VsZW0gPSBmdW5jdGlvbiBDcmVzY2VuZG9FbGVtKGFuY2hvcjEsIGFuY2hvcjIsIGRpciwgcG9zaXRpb25pbmcpIHtcblx0dGhpcy5hbmNob3IxID0gYW5jaG9yMTsgLy8gbXVzdCBoYXZlIGEgLnggYW5kIGEgLnBhcmVudCBwcm9wZXJ0eSBvciBiZSBudWxsIChtZWFucyBzdGFydHMgYXQgdGhlIFwiYmVnaW5uaW5nXCIgb2YgdGhlIGxpbmUgLSBhZnRlciBrZXlzaWcpXG5cdHRoaXMuYW5jaG9yMiA9IGFuY2hvcjI7IC8vIG11c3QgaGF2ZSBhIC54IHByb3BlcnR5IG9yIGJlIG51bGwgKG1lYW5zIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSlcblx0dGhpcy5kaXIgPSBkaXI7IC8vIGVpdGhlciBcIjxcIiBvciBcIj5cIlxuXHRpZiAocG9zaXRpb25pbmcgPT09ICdhYm92ZScpXG5cdFx0dGhpcy5keW5hbWljSGVpZ2h0QWJvdmUgPSA0O1xuXHRlbHNlXG5cdFx0dGhpcy5keW5hbWljSGVpZ2h0QmVsb3cgPSA0O1xuXHR0aGlzLnBpdGNoID0gdW5kZWZpbmVkOyAvLyBUaGlzIHdpbGwgYmUgc2V0IGxhdGVyXG59O1xuXG5DcmVzY2VuZG9FbGVtLnByb3RvdHlwZS5zZXRVcHBlckFuZExvd2VyRWxlbWVudHMgPSBmdW5jdGlvbihwb3NpdGlvblkpIHtcblx0aWYgKHRoaXMuZHluYW1pY0hlaWdodEFib3ZlKVxuXHRcdHRoaXMucGl0Y2ggPSBwb3NpdGlvblkuZHluYW1pY0hlaWdodEFib3ZlO1xuXHRlbHNlXG5cdFx0dGhpcy5waXRjaCA9IHBvc2l0aW9uWS5keW5hbWljSGVpZ2h0QmVsb3c7XG59O1xuXG5DcmVzY2VuZG9FbGVtLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG5cdGlmICh0aGlzLnBpdGNoID09PSB1bmRlZmluZWQpXG5cdFx0d2luZG93LmNvbnNvbGUuZXJyb3IoXCJDcmVzY2VuZG8gRWxlbWVudCB5LWNvb3JkaW5hdGUgbm90IHNldC5cIik7XG5cdHZhciB5ID0gcmVuZGVyZXIuY2FsY1kodGhpcy5waXRjaCkgKyA0OyAvLyBUaGlzIGlzIHRoZSB0b3AgcGl4ZWwgdG8gdXNlIChpdCBpcyBvZmZzZXQgYSBsaXR0bGUgc28gdGhhdCBpdCBsb29rcyBnb29kIHdpdGggdGhlIHZvbHVtZSBtYXJrcy4pXG5cdHZhciBoZWlnaHQgPSA4O1xuXHRpZiAodGhpcy5kaXIgPT09IFwiPFwiKSB7XG5cdFx0dGhpcy5kcmF3TGluZShyZW5kZXJlciwgeStoZWlnaHQvMiwgeSk7XG5cdFx0dGhpcy5kcmF3TGluZShyZW5kZXJlciwgeStoZWlnaHQvMiwgeStoZWlnaHQpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZHJhd0xpbmUocmVuZGVyZXIsIHksIHkraGVpZ2h0LzIpO1xuXHRcdHRoaXMuZHJhd0xpbmUocmVuZGVyZXIsIHkraGVpZ2h0LCB5K2hlaWdodC8yKTtcblx0fVxufTtcblxuQ3Jlc2NlbmRvRWxlbS5wcm90b3R5cGUuZHJhd0xpbmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHkxLCB5Mikge1xuXHQvLyBUT0RPLVBFUjogVGhpcyBpcyBqdXN0IGEgcXVpY2sgaGFjayB0byBtYWtlIHRoZSBkeW5hbWljIG1hcmtzIG5vdCBjcmFzaCBpZiB0aGV5IGFyZSBtaXNtYXRjaGVkLiBTZWUgdGhlIHNsdXIgdHJlYXRtZW50IGZvciB0aGUgd2F5IHRvIGdldCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQuXG5cdHZhciBsZWZ0ID0gdGhpcy5hbmNob3IxID8gdGhpcy5hbmNob3IxLnggOiAwO1xuXHR2YXIgcmlnaHQgPSB0aGlzLmFuY2hvcjIgPyB0aGlzLmFuY2hvcjIueCA6IDgwMDtcblx0dmFyIHBhdGhTdHJpbmcgPSBzcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmXCIsXG5cdFx0bGVmdCwgeTEsIHJpZ2h0LCB5Mik7XG5cdHJlbmRlcmVyLnByaW50UGF0aCh7cGF0aDpwYXRoU3RyaW5nLCBzdHJva2U6XCIjMDAwMDAwXCIsICdjbGFzcyc6IHJlbmRlcmVyLmFkZENsYXNzZXMoJ2RlY29yYXRpb24nKX0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVzY2VuZG9FbGVtO1xuIiwiLy8gYWJjX2RlY29yYXRpb24uanM6IENyZWF0ZXMgYSBkYXRhIHN0cnVjdHVyZSBzdWl0YWJsZSBmb3IgcHJpbnRpbmcgYSBsaW5lIG9mIGFiY1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSAmIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLypnbG9iYWwgd2luZG93ICovXG5cbnZhciBEeW5hbWljRGVjb3JhdGlvbiA9IHJlcXVpcmUoJy4vYWJjX2R5bmFtaWNfZGVjb3JhdGlvbicpO1xudmFyIENyZXNjZW5kb0VsZW0gPSByZXF1aXJlKCcuL2FiY19jcmVzY2VuZG9fZWxlbWVudCcpO1xudmFyIGdseXBocyA9IHJlcXVpcmUoJy4vYWJjX2dseXBocycpO1xudmFyIFJlbGF0aXZlRWxlbWVudCA9IHJlcXVpcmUoJy4vYWJjX3JlbGF0aXZlX2VsZW1lbnQnKTtcbnZhciBUaWVFbGVtID0gcmVxdWlyZSgnLi9hYmNfdGllX2VsZW1lbnQnKTtcblxudmFyIERlY29yYXRpb247XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0RGVjb3JhdGlvbiA9IGZ1bmN0aW9uIERlY29yYXRpb24oKSB7XG5cdFx0dGhpcy5zdGFydERpbWludWVuZG9YID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc3RhcnRDcmVzY2VuZG9YID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubWluVG9wID0gMTI7XHQvLyBUT0RPLVBFUjogdGhpcyBpcyBhc3N1bWluZyBhIDUtbGluZSBzdGFmZi4gUGFzcyB0aGF0IGluZm8gaW4uXG5cdFx0dGhpcy5taW5Cb3R0b20gPSAwO1xuXHR9O1xuXG5cdHZhciBjbG9zZURlY29yYXRpb24gPSBmdW5jdGlvbih2b2ljZSwgZGVjb3JhdGlvbiwgcGl0Y2gsIHdpZHRoLCBhYnNlbGVtLCByb29tdGFrZW4sIGRpciwgbWluUGl0Y2gpIHtcblx0XHR2YXIgeVBvcztcblx0XHRmb3IgKHZhciBpPTA7aTxkZWNvcmF0aW9uLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZGVjb3JhdGlvbltpXT09PVwic3RhY2NhdG9cIiB8fCBkZWNvcmF0aW9uW2ldPT09XCJ0ZW51dG9cIiB8fCBkZWNvcmF0aW9uW2ldID09PSBcImFjY2VudFwiKSB7XG5cdFx0XHRcdHZhciBzeW1ib2wgPSBcInNjcmlwdHMuXCIgKyBkZWNvcmF0aW9uW2ldO1xuXHRcdFx0XHRpZiAoZGVjb3JhdGlvbltpXSA9PT0gXCJhY2NlbnRcIikgc3ltYm9sID0gXCJzY3JpcHRzLnNmb3J6YXRvXCI7XG5cdFx0XHRcdGlmICh5UG9zID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0eVBvcyA9IChkaXI9PT1cImRvd25cIikgPyBwaXRjaCsyOm1pblBpdGNoLTI7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR5UG9zID0gKGRpcj09PVwiZG93blwiKSA/IHlQb3MrMjp5UG9zLTI7XG5cdFx0XHRcdGlmIChkZWNvcmF0aW9uW2ldID09PSBcImFjY2VudFwiKSB7XG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHBsYWNlIHRoZSBhY2NlbnQgdGhyZWUgcGl0Y2hlcyBhd2F5LCBubyBtYXR0ZXIgd2hldGhlciB0aGF0IGlzIGEgbGluZSBvciBzcGFjZS5cblx0XHRcdFx0XHRpZiAoZGlyID09PSBcInVwXCIpIHlQb3MtLTtcblx0XHRcdFx0XHRlbHNlIHlQb3MrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBkb24ndCBwbGFjZSBvbiBhIHN0YXZlIGxpbmUuIFRoZSBzdGF2ZSBsaW5lcyBhcmUgMiw0LDYsOCwxMFxuXHRcdFx0XHRcdHN3aXRjaCAoeVBvcykge1xuXHRcdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0Y2FzZSA2OlxuXHRcdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0Y2FzZSAxMDpcblx0XHRcdFx0XHRcdFx0aWYgKGRpciA9PT0gXCJ1cFwiKSB5UG9zLS07XG5cdFx0XHRcdFx0XHRcdGVsc2UgeVBvcysrO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBpdGNoPjkpIHlQb3MrKzsgLy8gdGFrZSB1cCBzb21lIHJvb20gb2YgdGhvc2UgdGhhdCBhcmUgYWJvdmVcblx0XHRcdFx0dmFyIGRlbHRhWCA9IHdpZHRoLzI7XG5cdFx0XHRcdGlmIChnbHlwaHMuZ2V0U3ltYm9sQWxpZ24oc3ltYm9sKSE9PVwiY2VudGVyXCIpIHtcblx0XHRcdFx0XHRkZWx0YVggLT0gKGdseXBocy5nZXRTeW1ib2xXaWR0aChzeW1ib2wpLzIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFic2VsZW0uYWRkQ2hpbGQobmV3IFJlbGF0aXZlRWxlbWVudChzeW1ib2wsIGRlbHRhWCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHN5bWJvbCksIHlQb3MpKTtcblx0XHRcdH1cblx0XHRcdGlmIChkZWNvcmF0aW9uW2ldPT09XCJzbGlkZVwiICYmIGFic2VsZW0uaGVhZHNbMF0pIHtcblx0XHRcdFx0dmFyIHlQb3MyID0gYWJzZWxlbS5oZWFkc1swXS5waXRjaDtcblx0XHRcdFx0eVBvczIgLT0gMjsgLy8gVE9ETy1QRVI6IG5vdCBzdXJlIHdoYXQgdGhpcyBmdWRnZSBmYWN0b3IgaXMuXG5cdFx0XHRcdHZhciBibGFuazEgPSBuZXcgUmVsYXRpdmVFbGVtZW50KFwiXCIsIC1yb29tdGFrZW4tMTUsIDAsIHlQb3MyLTEpO1xuXHRcdFx0XHR2YXIgYmxhbmsyID0gbmV3IFJlbGF0aXZlRWxlbWVudChcIlwiLCAtcm9vbXRha2VuLTUsIDAsIHlQb3MyKzEpO1xuXHRcdFx0XHRhYnNlbGVtLmFkZENoaWxkKGJsYW5rMSk7XG5cdFx0XHRcdGFic2VsZW0uYWRkQ2hpbGQoYmxhbmsyKTtcblx0XHRcdFx0dm9pY2UuYWRkT3RoZXIobmV3IFRpZUVsZW0oeyBhbmNob3IxOiBibGFuazEsIGFuY2hvcjI6IGJsYW5rMiwgZml4ZWRZOiB0cnVlfSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoeVBvcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0eVBvcyA9IHBpdGNoO1xuXG5cdFx0cmV0dXJuIHsgYWJvdmU6IHlQb3MsIGJlbG93OiBhYnNlbGVtLmJvdHRvbSB9O1xuXHR9O1xuXG5cdHZhciB2b2x1bWVEZWNvcmF0aW9uID0gZnVuY3Rpb24odm9pY2UsIGRlY29yYXRpb24sIGFic2VsZW0sIHBvc2l0aW9uaW5nKSB7XG5cdFx0Zm9yICh2YXIgaT0wO2k8ZGVjb3JhdGlvbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0c3dpdGNoKGRlY29yYXRpb25baV0pIHtcblx0XHRcdFx0Y2FzZSBcInBcIjpcblx0XHRcdFx0Y2FzZSBcIm1wXCI6XG5cdFx0XHRcdGNhc2UgXCJwcFwiOlxuXHRcdFx0XHRjYXNlIFwicHBwXCI6XG5cdFx0XHRcdGNhc2UgXCJwcHBwXCI6XG5cdFx0XHRcdGNhc2UgXCJmXCI6XG5cdFx0XHRcdGNhc2UgXCJmZlwiOlxuXHRcdFx0XHRjYXNlIFwiZmZmXCI6XG5cdFx0XHRcdGNhc2UgXCJmZmZmXCI6XG5cdFx0XHRcdGNhc2UgXCJzZnpcIjpcblx0XHRcdFx0Y2FzZSBcIm1mXCI6XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBuZXcgRHluYW1pY0RlY29yYXRpb24oYWJzZWxlbSwgZGVjb3JhdGlvbltpXSwgcG9zaXRpb25pbmcpO1xuXHRcdFx0XHRcdHZvaWNlLmFkZE90aGVyKGVsZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgY29tcG91bmREZWNvcmF0aW9uID0gZnVuY3Rpb24oZGVjb3JhdGlvbiwgcGl0Y2gsIHdpZHRoLCBhYnNlbGVtLCBkaXIpIHtcblx0XHRmdW5jdGlvbiBoaWdoZXN0UGl0Y2goKSB7XG5cdFx0XHRpZiAoYWJzZWxlbS5oZWFkcy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAxMDtcdC8vIFRPRE8tUEVSOiBJIGRvbid0IGtub3cgaWYgdGhpcyBjYW4gaGFwcGVuLCBidXQgd2UnbGwgcmV0dXJuIHRoZSB0b3Agb2YgdGhlIHN0YWZmIGlmIHNvLlxuXHRcdFx0dmFyIHBpdGNoID0gYWJzZWxlbS5oZWFkc1swXS5waXRjaDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYWJzZWxlbS5oZWFkcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0cGl0Y2ggPSBNYXRoLm1heChwaXRjaCwgYWJzZWxlbS5oZWFkc1tpXS5waXRjaCk7XG5cdFx0XHRyZXR1cm4gcGl0Y2g7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGxvd2VzdFBpdGNoKCkge1xuXHRcdFx0aWYgKGFic2VsZW0uaGVhZHMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMjtcdC8vIFRPRE8tUEVSOiBJIGRvbid0IGtub3cgaWYgdGhpcyBjYW4gaGFwcGVuLCBidXQgd2UnbGwgcmV0dXJuIHRoZSBib3R0b20gb2YgdGhlIHN0YWZmIGlmIHNvLlxuXHRcdFx0dmFyIHBpdGNoID0gYWJzZWxlbS5oZWFkc1swXS5waXRjaDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYWJzZWxlbS5oZWFkcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0cGl0Y2ggPSBNYXRoLm1pbihwaXRjaCwgYWJzZWxlbS5oZWFkc1tpXS5waXRjaCk7XG5cdFx0XHRyZXR1cm4gcGl0Y2g7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNvbXBvdW5kRGVjb3JhdGlvbihzeW1ib2wsIGNvdW50KSB7XG5cdFx0XHR2YXIgcGxhY2VtZW50ID0gKGRpciA9PT0gJ2Rvd24nKSA/IGxvd2VzdFBpdGNoKCkrMTpoaWdoZXN0UGl0Y2goKSs5O1xuXHRcdFx0aWYgKGRpciAhPT0gJ2Rvd24nICYmIGNvdW50ID09PSAxKVxuXHRcdFx0XHRwbGFjZW1lbnQtLTtcblx0XHRcdHZhciBkZWx0YVggPSB3aWR0aC8yO1xuXHRcdFx0ZGVsdGFYICs9IChkaXIgPT09ICdkb3duJykgPyAtNSA6IDM7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0cGxhY2VtZW50IC09IDE7XG5cdFx0XHRcdGFic2VsZW0uYWRkQ2hpbGQobmV3IFJlbGF0aXZlRWxlbWVudChzeW1ib2wsIGRlbHRhWCwgZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHN5bWJvbCksIHBsYWNlbWVudCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGk9MDtpPGRlY29yYXRpb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHN3aXRjaChkZWNvcmF0aW9uW2ldKSB7XG5cdFx0XHRcdGNhc2UgXCIvXCI6IGNvbXBvdW5kRGVjb3JhdGlvbihcImZsYWdzLnVncmFjZVwiLCAxKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCIvL1wiOiBjb21wb3VuZERlY29yYXRpb24oXCJmbGFncy51Z3JhY2VcIiwgMik7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiLy8vXCI6IGNvbXBvdW5kRGVjb3JhdGlvbihcImZsYWdzLnVncmFjZVwiLCAzKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgXCIvLy8vXCI6IGNvbXBvdW5kRGVjb3JhdGlvbihcImZsYWdzLnVncmFjZVwiLCA0KTsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBzdGFja2VkRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKGRlY29yYXRpb24sIHdpZHRoLCBhYnNlbGVtLCB5UG9zLCBwb3NpdGlvbmluZywgbWluVG9wLCBtaW5Cb3R0b20pIHtcblx0XHRmdW5jdGlvbiBpbmNyZW1lbnRQbGFjZW1lbnQocGxhY2VtZW50LCBoZWlnaHQpIHtcblx0XHRcdGlmIChwbGFjZW1lbnQgPT09ICdhYm92ZScpXG5cdFx0XHRcdHlQb3MuYWJvdmUgKz0gaGVpZ2h0O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR5UG9zLmJlbG93IC09IGhlaWdodDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gZ2V0UGxhY2VtZW50KHBsYWNlbWVudCkge1xuXHRcdFx0dmFyIHk7XG5cdFx0XHRpZiAocGxhY2VtZW50ID09PSAnYWJvdmUnKSB7XG5cdFx0XHRcdHkgPSB5UG9zLmFib3ZlO1xuXHRcdFx0XHRpZiAoeSA8IG1pblRvcClcblx0XHRcdFx0XHR5ID0gbWluVG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eSA9IHlQb3MuYmVsb3c7XG5cdFx0XHRcdGlmICh5ID4gbWluQm90dG9tKVxuXHRcdFx0XHRcdHkgPSBtaW5Cb3R0b207XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdGV4dERlY29yYXRpb24odGV4dCwgcGxhY2VtZW50KSB7XG5cdFx0XHR2YXIgeSA9IGdldFBsYWNlbWVudChwbGFjZW1lbnQpO1xuXHRcdFx0dmFyIHRleHRGdWRnZSA9IDI7XG5cdFx0XHR2YXIgdGV4dEhlaWdodCA9IDU7XG5cdFx0XHQvLyBUT0RPLVBFUjogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGN1cnJlbnQgZm9udCBhbmQgdXNlIHRoYXQgZm9yIHRoZSB0aGlja25lc3MuXG5cdFx0XHRhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQodGV4dCwgd2lkdGgvMiwgMCwgeSt0ZXh0RnVkZ2UsIHt0eXBlOlwiZGVjb3JhdGlvblwiLCBrbGFzczogJ29ybmFtZW50JywgdGhpY2tuZXNzOiAzfSkpO1xuXG5cdFx0XHRpbmNyZW1lbnRQbGFjZW1lbnQocGxhY2VtZW50LCB0ZXh0SGVpZ2h0KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gc3ltYm9sRGVjb3JhdGlvbihzeW1ib2wsIHBsYWNlbWVudCkge1xuXHRcdFx0dmFyIGRlbHRhWCA9IHdpZHRoLzI7XG5cdFx0XHRpZiAoZ2x5cGhzLmdldFN5bWJvbEFsaWduKHN5bWJvbCkgIT09IFwiY2VudGVyXCIpIHtcblx0XHRcdFx0ZGVsdGFYIC09IChnbHlwaHMuZ2V0U3ltYm9sV2lkdGgoc3ltYm9sKSAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhlaWdodCA9IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoc3ltYm9sKSArIDE7IC8vIGFkZGluZyBhIGxpdHRsZSBwYWRkaW5nIHNvIG5vdGhpbmcgdG91Y2hlcy5cblx0XHRcdHZhciB5ID0gZ2V0UGxhY2VtZW50KHBsYWNlbWVudCk7XG5cdFx0XHR5ID0gKHBsYWNlbWVudCA9PT0gJ2Fib3ZlJykgPyB5ICsgaGVpZ2h0LzIgOiB5IC0gaGVpZ2h0LzI7Ly8gQ2VudGVyIHRoZSBlbGVtZW50IHZlcnRpY2FsbHkuXG5cdFx0XHRhYnNlbGVtLmFkZENoaWxkKG5ldyBSZWxhdGl2ZUVsZW1lbnQoc3ltYm9sLCBkZWx0YVgsIGdseXBocy5nZXRTeW1ib2xXaWR0aChzeW1ib2wpLCB5LCB7IGtsYXNzOiAnb3JuYW1lbnQnLCB0aGlja25lc3M6IGdseXBocy5zeW1ib2xIZWlnaHRJblBpdGNoZXMoc3ltYm9sKSB9KSk7XG5cblx0XHRcdGluY3JlbWVudFBsYWNlbWVudChwbGFjZW1lbnQsIGhlaWdodCk7XG5cdFx0fVxuXG5cdFx0dmFyIHN5bWJvbExpc3QgPSB7XG5cdFx0XHRcIitcIjogXCJzY3JpcHRzLnN0b3BwZWRcIixcblx0XHRcdFwib3BlblwiOiBcInNjcmlwdHMub3BlblwiLFxuXHRcdFx0XCJzbmFwXCI6IFwic2NyaXB0cy5zbmFwXCIsXG5cdFx0XHRcIndlZGdlXCI6IFwic2NyaXB0cy53ZWRnZVwiLFxuXHRcdFx0XCJ0aHVtYlwiOiBcInNjcmlwdHMudGh1bWJcIixcblx0XHRcdFwic2hvcnRwaHJhc2VcIjogXCJzY3JpcHRzLnNob3J0cGhyYXNlXCIsXG5cdFx0XHRcIm1lZGl1bXBocmFzZVwiOiBcInNjcmlwdHMubWVkaXVtcGhyYXNlXCIsXG5cdFx0XHRcImxvbmdwaHJhc2VcIjogXCJzY3JpcHRzLmxvbmdwaHJhc2VcIixcblx0XHRcdFwidHJpbGxcIjogXCJzY3JpcHRzLnRyaWxsXCIsXG5cdFx0XHRcInJvbGxcIjogXCJzY3JpcHRzLnJvbGxcIixcblx0XHRcdFwiaXJpc2hyb2xsXCI6IFwic2NyaXB0cy5yb2xsXCIsXG5cdFx0XHRcIm1hcmNhdG9cIjogXCJzY3JpcHRzLnVtYXJjYXRvXCIsXG5cdFx0XHRcImRtYXJjYXRvXCI6IFwic2NyaXB0cy5kbWFyY2F0b1wiLFxuXHRcdFx0XCJ1bWFyY2F0b1wiOiBcInNjcmlwdHMudW1hcmNhdG9cIixcblx0XHRcdFwidHVyblwiOiBcInNjcmlwdHMudHVyblwiLFxuXHRcdFx0XCJ1cHBlcm1vcmRlbnRcIjogXCJzY3JpcHRzLnByYWxsXCIsXG5cdFx0XHRcInByYWxsdHJpbGxlclwiOiBcInNjcmlwdHMucHJhbGxcIixcblx0XHRcdFwibW9yZGVudFwiOiBcInNjcmlwdHMubW9yZGVudFwiLFxuXHRcdFx0XCJsb3dlcm1vcmRlbnRcIjogXCJzY3JpcHRzLm1vcmRlbnRcIixcblx0XHRcdFwiZG93bmJvd1wiOiBcInNjcmlwdHMuZG93bmJvd1wiLFxuXHRcdFx0XCJ1cGJvd1wiOiBcInNjcmlwdHMudXBib3dcIixcblx0XHRcdFwiZmVybWF0YVwiOiBcInNjcmlwdHMudWZlcm1hdGFcIixcblx0XHRcdFwiaW52ZXJ0ZWRmZXJtYXRhXCI6IFwic2NyaXB0cy5kZmVybWF0YVwiLFxuXHRcdFx0XCJicmVhdGhcIjogXCIsXCIsXG5cdFx0XHRcImNvZGFcIjogXCJzY3JpcHRzLmNvZGFcIixcblx0XHRcdFwic2Vnbm9cIjogXCJzY3JpcHRzLnNlZ25vXCJcblx0XHR9O1xuXG5cdFx0dmFyIGhhc09uZSA9IGZhbHNlO1xuXHRcdGZvciAodmFyIGk9MDtpPGRlY29yYXRpb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHN3aXRjaChkZWNvcmF0aW9uW2ldKSB7XG5cdFx0XHRcdGNhc2UgXCIwXCI6XG5cdFx0XHRcdGNhc2UgXCIxXCI6XG5cdFx0XHRcdGNhc2UgXCIyXCI6XG5cdFx0XHRcdGNhc2UgXCIzXCI6XG5cdFx0XHRcdGNhc2UgXCI0XCI6XG5cdFx0XHRcdGNhc2UgXCI1XCI6XG5cdFx0XHRcdGNhc2UgXCJELkMuXCI6XG5cdFx0XHRcdGNhc2UgXCJELlMuXCI6XG5cdFx0XHRcdFx0dGV4dERlY29yYXRpb24oZGVjb3JhdGlvbltpXSwgcG9zaXRpb25pbmcpO1xuXHRcdFx0XHRcdGhhc09uZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmaW5lXCI6XG5cdFx0XHRcdFx0dGV4dERlY29yYXRpb24oXCJGSU5FXCIsIHBvc2l0aW9uaW5nKTtcblx0XHRcdFx0XHRoYXNPbmUgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiK1wiOlxuXHRcdFx0XHRjYXNlIFwib3BlblwiOlxuXHRcdFx0XHRjYXNlIFwic25hcFwiOlxuXHRcdFx0XHRjYXNlIFwid2VkZ2VcIjpcblx0XHRcdFx0Y2FzZSBcInRodW1iXCI6XG5cdFx0XHRcdGNhc2UgXCJzaG9ydHBocmFzZVwiOlxuXHRcdFx0XHRjYXNlIFwibWVkaXVtcGhyYXNlXCI6XG5cdFx0XHRcdGNhc2UgXCJsb25ncGhyYXNlXCI6XG5cdFx0XHRcdGNhc2UgXCJ0cmlsbFwiOlxuXHRcdFx0XHRjYXNlIFwicm9sbFwiOlxuXHRcdFx0XHRjYXNlIFwiaXJpc2hyb2xsXCI6XG5cdFx0XHRcdGNhc2UgXCJtYXJjYXRvXCI6XG5cdFx0XHRcdGNhc2UgXCJkbWFyY2F0b1wiOlxuXHRcdFx0XHRjYXNlIFwidHVyblwiOlxuXHRcdFx0XHRjYXNlIFwidXBwZXJtb3JkZW50XCI6XG5cdFx0XHRcdGNhc2UgXCJwcmFsbHRyaWxsZXJcIjpcblx0XHRcdFx0Y2FzZSBcIm1vcmRlbnRcIjpcblx0XHRcdFx0Y2FzZSBcImxvd2VybW9yZGVudFwiOlxuXHRcdFx0XHRjYXNlIFwiZG93bmJvd1wiOlxuXHRcdFx0XHRjYXNlIFwidXBib3dcIjpcblx0XHRcdFx0Y2FzZSBcImZlcm1hdGFcIjpcblx0XHRcdFx0Y2FzZSBcImJyZWF0aFwiOlxuXHRcdFx0XHRjYXNlIFwidW1hcmNhdG9cIjpcblx0XHRcdFx0Y2FzZSBcImNvZGFcIjpcblx0XHRcdFx0Y2FzZSBcInNlZ25vXCI6XG5cdFx0XHRcdFx0c3ltYm9sRGVjb3JhdGlvbihzeW1ib2xMaXN0W2RlY29yYXRpb25baV1dLCBwb3NpdGlvbmluZyk7XG5cdFx0XHRcdFx0aGFzT25lID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImludmVydGVkZmVybWF0YVwiOlxuXHRcdFx0XHRcdHN5bWJvbERlY29yYXRpb24oc3ltYm9sTGlzdFtkZWNvcmF0aW9uW2ldXSwgJ2JlbG93Jyk7XG5cdFx0XHRcdFx0aGFzT25lID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcIm1hcmtcIjpcblx0XHRcdFx0XHRhYnNlbGVtLmtsYXNzID0gXCJtYXJrXCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBoYXNPbmU7XG5cdH07XG5cblx0ZnVuY3Rpb24gbGVmdERlY29yYXRpb24oZGVjb3JhdGlvbiwgYWJzZWxlbSwgcm9vbXRha2VuKSB7XG5cdFx0Zm9yICh2YXIgaT0wO2k8ZGVjb3JhdGlvbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0c3dpdGNoIChkZWNvcmF0aW9uW2ldKSB7XG5cdFx0XHRcdGNhc2UgXCJhcnBlZ2dpb1wiOlxuXHRcdFx0XHRcdC8vIFRoZSBhcnBlZ2dpbyBzeW1ib2wgaXMgdGhlIGhlaWdodCBvZiBhIG5vdGUgKHRoYXQgaXMsIHR3byBZIHVuaXRzKS4gVGhpcyBzdGFja3MgYXMgbWFueSBhcyB3ZSBuZWVkIHRvIGdvIGZyb20gdGhlXG5cdFx0XHRcdFx0Ly8gdG9wIG5vdGUgdG8gdGhlIGJvdHRvbSBub3RlLiBUaGUgYXJwZWdnaW8gc2hvdWxkIGFsc28gYmUgYSBsaXR0bGUgdGFsbGVyIHRoYW4gdGhlIHN0YWNrZWQgbm90ZXMsIHNvIHRoZXJlIGlzIGFuIGV4dHJhXG5cdFx0XHRcdFx0Ly8gb25lIGRyYXduIGFuZCBpdCBpcyBvZmZzZXQgYnkgaGFsZiBvZiBhIG5vdGUgaGVpZ2h0ICh0aGF0IGlzLCBvbmUgWSB1bml0KS5cblx0XHRcdFx0XHRmb3IgKHZhciBqID0gYWJzZWxlbS5hYmNlbGVtLm1pbnBpdGNoIC0gMTsgaiA8PSBhYnNlbGVtLmFiY2VsZW0ubWF4cGl0Y2g7IGogKz0gMikge1xuXHRcdFx0XHRcdFx0YWJzZWxlbS5hZGRFeHRyYShcblx0XHRcdFx0XHRcdFx0bmV3IFJlbGF0aXZlRWxlbWVudChcblx0XHRcdFx0XHRcdFx0XHRcInNjcmlwdHMuYXJwZWdnaW9cIixcblx0XHRcdFx0XHRcdFx0XHQtZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwic2NyaXB0cy5hcnBlZ2dpb1wiKSoyIC0gcm9vbXRha2VuLFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0aisyLFxuXHRcdFx0XHRcdFx0XHRcdHtrbGFzczogJ29ybmFtZW50JywgdGhpY2tuZXNzOiBnbHlwaHMuc3ltYm9sSGVpZ2h0SW5QaXRjaGVzKFwic2NyaXB0cy5hcnBlZ2dpb1wiKX1cblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0RGVjb3JhdGlvbi5wcm90b3R5cGUuZHluYW1pY0RlY29yYXRpb24gPSBmdW5jdGlvbih2b2ljZSwgZGVjb3JhdGlvbiwgYWJzZWxlbSwgcG9zaXRpb25pbmcpIHtcblx0XHR2YXIgZGltaW51ZW5kbztcblx0XHR2YXIgY3Jlc2NlbmRvO1xuXHRcdGZvciAodmFyIGk9MDtpPGRlY29yYXRpb24ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHN3aXRjaChkZWNvcmF0aW9uW2ldKSB7XG5cdFx0XHRcdGNhc2UgXCJkaW1pbnVlbmRvKFwiOlxuXHRcdFx0XHRcdHRoaXMuc3RhcnREaW1pbnVlbmRvWCA9IGFic2VsZW07XG5cdFx0XHRcdFx0ZGltaW51ZW5kbyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpbWludWVuZG8pXCI6XG5cdFx0XHRcdFx0ZGltaW51ZW5kbyA9IHsgc3RhcnQ6IHRoaXMuc3RhcnREaW1pbnVlbmRvWCwgc3RvcDogYWJzZWxlbX07XG5cdFx0XHRcdFx0dGhpcy5zdGFydERpbWludWVuZG9YID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiY3Jlc2NlbmRvKFwiOlxuXHRcdFx0XHRcdHRoaXMuc3RhcnRDcmVzY2VuZG9YID0gYWJzZWxlbTtcblx0XHRcdFx0XHRjcmVzY2VuZG8gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJjcmVzY2VuZG8pXCI6XG5cdFx0XHRcdFx0Y3Jlc2NlbmRvID0geyBzdGFydDogdGhpcy5zdGFydENyZXNjZW5kb1gsIHN0b3A6IGFic2VsZW19O1xuXHRcdFx0XHRcdHRoaXMuc3RhcnRDcmVzY2VuZG9YID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZGltaW51ZW5kbykge1xuXHRcdFx0dm9pY2UuYWRkT3RoZXIobmV3IENyZXNjZW5kb0VsZW0oZGltaW51ZW5kby5zdGFydCwgZGltaW51ZW5kby5zdG9wLCBcIj5cIiwgcG9zaXRpb25pbmcpKTtcblx0XHR9XG5cdFx0aWYgKGNyZXNjZW5kbykge1xuXHRcdFx0dm9pY2UuYWRkT3RoZXIobmV3IENyZXNjZW5kb0VsZW0oY3Jlc2NlbmRvLnN0YXJ0LCBjcmVzY2VuZG8uc3RvcCwgXCI8XCIsIHBvc2l0aW9uaW5nKSk7XG5cdFx0fVxuXHR9O1xuXG5cdERlY29yYXRpb24ucHJvdG90eXBlLmNyZWF0ZURlY29yYXRpb24gPSBmdW5jdGlvbih2b2ljZSwgZGVjb3JhdGlvbiwgcGl0Y2gsIHdpZHRoLCBhYnNlbGVtLCByb29tdGFrZW4sIGRpciwgbWluUGl0Y2gsIHBvc2l0aW9uaW5nLCBoYXNWb2NhbHMpIHtcblx0XHRpZiAoIXBvc2l0aW9uaW5nKVxuXHRcdFx0cG9zaXRpb25pbmcgPSB7IG9ybmFtZW50UG9zaXRpb246ICdhYm92ZScsIHZvbHVtZVBvc2l0aW9uOiBoYXNWb2NhbHMgPyAnYWJvdmUnIDonYmVsb3cnLCBkeW5hbWljUG9zaXRpb246IGhhc1ZvY2FscyA/ICdhYm92ZScgOiAnYmVsb3cnIH07XG5cdFx0Ly8gVGhlc2UgZGVjb3JhdGlvbnMgZG9uJ3QgYWZmZWN0IHRoZSBwbGFjZW1lbnQgb2Ygb3RoZXIgZGVjb3JhdGlvbnNcblx0XHR2b2x1bWVEZWNvcmF0aW9uKHZvaWNlLCBkZWNvcmF0aW9uLCBhYnNlbGVtLCBwb3NpdGlvbmluZy52b2x1bWVQb3NpdGlvbik7XG5cdFx0dGhpcy5keW5hbWljRGVjb3JhdGlvbih2b2ljZSwgZGVjb3JhdGlvbiwgYWJzZWxlbSwgcG9zaXRpb25pbmcuZHluYW1pY1Bvc2l0aW9uKTtcblx0XHRjb21wb3VuZERlY29yYXRpb24oZGVjb3JhdGlvbiwgcGl0Y2gsIHdpZHRoLCBhYnNlbGVtLCBkaXIpO1xuXG5cdFx0Ly8gdHJlYXQgc3RhY2NhdG8sIGFjY2VudCwgYW5kIHRlbnV0byBmaXJzdCAobWF5IG5lZWQgdG8gc2hpZnQgb3RoZXIgbWFya2Vycylcblx0XHR2YXIgeVBvcyA9IGNsb3NlRGVjb3JhdGlvbih2b2ljZSwgZGVjb3JhdGlvbiwgcGl0Y2gsIHdpZHRoLCBhYnNlbGVtLCByb29tdGFrZW4sIGRpciwgbWluUGl0Y2gpO1xuXHRcdC8vIHlQb3MgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgJ2Fib3ZlJyBhbmQgJ2JlbG93Jy4gVGhhdCBpcyB0aGUgcGxhY2VtZW50IG9mIHRoZSBuZXh0IHN5bWJvbCBvbiBlaXRoZXIgc2lkZS5cblxuXHRcdHlQb3MuYWJvdmUgPSBNYXRoLm1heCh5UG9zLmFib3ZlLCB0aGlzLm1pblRvcCk7XG5cdFx0dmFyIGhhc09uZSA9IHN0YWNrZWREZWNvcmF0aW9uKGRlY29yYXRpb24sIHdpZHRoLCBhYnNlbGVtLCB5UG9zLCBwb3NpdGlvbmluZy5vcm5hbWVudFBvc2l0aW9uLCB0aGlzLm1pblRvcCwgdGhpcy5taW5Cb3R0b20pO1xuXHRcdGlmIChoYXNPbmUpIHtcbi8vXHRcdFx0YWJzZWxlbS50b3AgPSBNYXRoLm1heCh5UG9zLmFib3ZlICsgMywgYWJzZWxlbS50b3ApOyAvLyBUT0RPLVBFUjogTm90IHN1cmUgd2h5IHdlIG5lZWQgdGhpcyBmdWRnZSBmYWN0b3IuXG5cdFx0fVxuXHRcdGxlZnREZWNvcmF0aW9uKGRlY29yYXRpb24sIGFic2VsZW0sIHJvb210YWtlbik7XG5cdH07XG5cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjb3JhdGlvbjtcbiIsIi8vICAgIGFiY19keW5hbWljX2RlY29yYXRpb24uanM6IERlZmluaXRpb24gb2YgdGhlIER5bmFtaWNEZWNvcmF0aW9uIGNsYXNzLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSBhbmQgUGF1bCBSb3NlblxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgc3BhY2luZyA9IHJlcXVpcmUoJy4vYWJjX3NwYWNpbmcnKTtcblxudmFyIER5bmFtaWNEZWNvcmF0aW9uID0gZnVuY3Rpb24gRHluYW1pY0RlY29yYXRpb24oYW5jaG9yLCBkZWMsIHBvc2l0aW9uKSB7XG5cdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXHR0aGlzLmRlYyA9IGRlYztcblx0aWYgKHBvc2l0aW9uID09PSAnYmVsb3cnKVxuXHRcdHRoaXMudm9sdW1lSGVpZ2h0QmVsb3cgPSA1O1xuXHRlbHNlXG5cdFx0dGhpcy52b2x1bWVIZWlnaHRBYm92ZSA9IDU7XG5cdHRoaXMucGl0Y2ggPSB1bmRlZmluZWQ7IC8vIFRoaXMgd2lsbCBiZSBzZXQgbGF0ZXJcbn07XG5cbkR5bmFtaWNEZWNvcmF0aW9uLnByb3RvdHlwZS5zZXRVcHBlckFuZExvd2VyRWxlbWVudHMgPSBmdW5jdGlvbihwb3NpdGlvblkpIHtcblx0aWYgKHRoaXMudm9sdW1lSGVpZ2h0QWJvdmUpXG5cdFx0dGhpcy5waXRjaCA9IHBvc2l0aW9uWS52b2x1bWVIZWlnaHRBYm92ZTtcblx0ZWxzZVxuXHRcdHRoaXMucGl0Y2ggPSBwb3NpdGlvblkudm9sdW1lSGVpZ2h0QmVsb3c7XG59O1xuXG5EeW5hbWljRGVjb3JhdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHJlbmRlcmVyLCBsaW5lc3RhcnR4LCBsaW5lZW5keCkge1xuXHRpZiAodGhpcy5waXRjaCA9PT0gdW5kZWZpbmVkKVxuXHRcdHdpbmRvdy5jb25zb2xlLmVycm9yKFwiRHluYW1pYyBFbGVtZW50IHktY29vcmRpbmF0ZSBub3Qgc2V0LlwiKTtcblx0dmFyIHNjYWxleCA9IDE7XG5cdHZhciBzY2FsZXkgPSAxO1xuXHRyZW5kZXJlci5wcmludFN5bWJvbCh0aGlzLmFuY2hvci54LCB0aGlzLnBpdGNoLCB0aGlzLmRlYywgc2NhbGV4LCBzY2FsZXksIHJlbmRlcmVyLmFkZENsYXNzZXMoJ2RlY29yYXRpb24nKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IER5bmFtaWNEZWNvcmF0aW9uO1xuIiwiLy8gICAgYWJjX2VuZGluZ19lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBFbmRpbmdFbGVtZW50IGNsYXNzLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSBhbmQgUGF1bCBSb3NlblxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgc3ByaW50ZiA9IHJlcXVpcmUoJy4vc3ByaW50ZicpO1xuXG52YXIgRW5kaW5nRWxlbSA9IGZ1bmN0aW9uIEVuZGluZ0VsZW0odGV4dCwgYW5jaG9yMSwgYW5jaG9yMikge1xuXHR0aGlzLnRleHQgPSB0ZXh0OyAvLyB0ZXh0IHRvIGJlIGRpc3BsYXllZCB0b3AgbGVmdFxuXHR0aGlzLmFuY2hvcjEgPSBhbmNob3IxOyAvLyBtdXN0IGhhdmUgYSAueCBwcm9wZXJ0eSBvciBiZSBudWxsIChtZWFucyBzdGFydHMgYXQgdGhlIFwiYmVnaW5uaW5nXCIgb2YgdGhlIGxpbmUgLSBhZnRlciBrZXlzaWcpXG5cdHRoaXMuYW5jaG9yMiA9IGFuY2hvcjI7IC8vIG11c3QgaGF2ZSBhIC54IHByb3BlcnR5IG9yIGJlIG51bGwgKG1lYW5zIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSlcblx0dGhpcy5lbmRpbmdIZWlnaHRBYm92ZSA9IDU7XG5cdHRoaXMucGl0Y2ggPSB1bmRlZmluZWQ7IC8vIFRoaXMgd2lsbCBiZSBzZXQgbGF0ZXJcbn07XG5cbkVuZGluZ0VsZW0ucHJvdG90eXBlLnNldFVwcGVyQW5kTG93ZXJFbGVtZW50cyA9IGZ1bmN0aW9uKHBvc2l0aW9uWSkge1xuXHR0aGlzLnBpdGNoID0gcG9zaXRpb25ZLmVuZGluZ0hlaWdodEFib3ZlIC0gMjtcbn07XG5cbkVuZGluZ0VsZW0ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGxpbmVzdGFydHgsIGxpbmVlbmR4KSB7XG5cdGlmICh0aGlzLnBpdGNoID09PSB1bmRlZmluZWQpXG5cdFx0d2luZG93LmNvbnNvbGUuZXJyb3IoXCJFbmRpbmcgRWxlbWVudCB5LWNvb3JkaW5hdGUgbm90IHNldC5cIik7XG5cdHZhciB5ID0gcmVuZGVyZXIuY2FsY1kodGhpcy5waXRjaCk7XG5cdHZhciBoZWlnaHQgPSAyMDtcblx0dmFyIHBhdGhTdHJpbmc7XG5cdGlmICh0aGlzLmFuY2hvcjEpIHtcblx0XHRsaW5lc3RhcnR4ID0gdGhpcy5hbmNob3IxLngrdGhpcy5hbmNob3IxLnc7XG5cdFx0cGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIixcblx0XHRcdGxpbmVzdGFydHgsIHksIGxpbmVzdGFydHgsIHkraGVpZ2h0KTtcblx0XHRyZW5kZXJlci5wcmludFBhdGgoe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOlwiIzAwMDAwMFwiLCBmaWxsOlwiIzAwMDAwMFwiLCAnY2xhc3MnOiByZW5kZXJlci5hZGRDbGFzc2VzKCdlbmRpbmcnKX0pO1xuXHRcdHJlbmRlcmVyLnJlbmRlclRleHQobGluZXN0YXJ0eCs1LCByZW5kZXJlci5jYWxjWSh0aGlzLnBpdGNoLTAuNSksIHRoaXMudGV4dCwgJ3JlcGVhdGZvbnQnLCAnZW5kaW5nJyxcInN0YXJ0XCIpO1xuXHR9XG5cblx0aWYgKHRoaXMuYW5jaG9yMikge1xuXHRcdGxpbmVlbmR4ID0gdGhpcy5hbmNob3IyLng7XG5cdFx0cGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIixcblx0XHRcdGxpbmVlbmR4LCB5LCBsaW5lZW5keCwgeStoZWlnaHQpO1xuXHRcdHJlbmRlcmVyLnByaW50UGF0aCh7cGF0aDpwYXRoU3RyaW5nLCBzdHJva2U6XCIjMDAwMDAwXCIsIGZpbGw6XCIjMDAwMDAwXCIsICdjbGFzcyc6IHJlbmRlcmVyLmFkZENsYXNzZXMoJ2VuZGluZycpfSk7XG5cdH1cblxuXG5cdHBhdGhTdHJpbmcgPSBzcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmXCIsXG5cdFx0bGluZXN0YXJ0eCwgeSwgbGluZWVuZHgsIHkpO1xuXHRyZW5kZXJlci5wcmludFBhdGgoe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOlwiIzAwMDAwMFwiLCBmaWxsOlwiIzAwMDAwMFwiLCAnY2xhc3MnOiByZW5kZXJlci5hZGRDbGFzc2VzKCdlbmRpbmcnKX0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmRpbmdFbGVtO1xuIiwiLy8gICAgYWJjX2VuZ3JhdmVyX2NvbnRyb2xsZXIuanM6IENvbnRyb2xzIHRoZSBlbmdyYXZpbmcgcHJvY2VzcyBvZiBhbiBBQkNKUyBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBwcm9kdWNlZCBieSBBQkNKUy9wYXJzZVxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDE0LTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKVxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8qZ2xvYmFsIE1hdGggKi9cblxudmFyIHNwYWNpbmcgPSByZXF1aXJlKCcuL2FiY19zcGFjaW5nJyk7XG52YXIgQWJzdHJhY3RFbmdyYXZlciA9IHJlcXVpcmUoJy4vYWJjX2Fic3RyYWN0X2VuZ3JhdmVyJyk7XG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL2FiY19yZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQ29udHJvbHMgdGhlIGVuZ3JhdmluZyBwcm9jZXNzLCBmcm9tIEFCQ0pTIEFic3RyYWN0IFN5bnRheCBUcmVlIChBQkNKUyBBU1QpIHRvIHJlbmRlcmVkIHNjb3JlIHNoZWV0XG4gKlxuICogQ2FsbCBlbmdyYXZlQUJDIHRvIHJ1biB0aGUgcHJvY2Vzcy4gVGhpcyBjcmVhdGVzIGEgZ3JhcGhlbGVtcyBBQkNKUyBBYnN0cmFjdCBFbmdyYXZpbmcgU3RydWN0dXJlIChBQkNKUyBBRVMpIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggdGhpcy5zdGFmZmdyb3Vwc1xuICogdGhpcyBkYXRhIHN0cnVjdHVyZSBpcyBmaXJzdCBsYWlkIG91dCAoZ2l2aW5nIHRoZSBncmFwaGVsZW1zIHggYW5kIHkgY29vcmRpbmF0ZXMpIGFuZCB0aGVuIGRyYXduIG9udG8gdGhlIHJlbmRlcmVyXG4gKiBlYWNoIEFCQ0pTIEFFUyByZXByZXNlbnRzIGEgc2luZ2xlIHN0YWZmZ3JvdXAgLSBhbGwgZWxlbWVudHMgdGhhdCBhcmUgbm90IGluIGEgc3RhZmZncm91cCBhcmUgcmVuZGVyZWQgZGlyZWN0bHkgYnkgdGhlIGNvbnRyb2xsZXJcbiAqXG4gKiBlbGVtZW50cyBpbiBBQkNKUyBBRVMga25vdyB0aGVpciBcInNvdXJjZSBkYXRhXCIgaW4gdGhlIEFCQ0pTIEFTVCwgYW5kIHRoZWlyIFwidGFyZ2V0IHNoYXBlXCJcbiAqIGluIHRoZSByZW5kZXJlciBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcGVyIGRpdiBlbGVtZW50IHRoYXQgd2lsbCB3cmFwIHRoZSBTVkdcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWxsIHRoZSBwYXJhbXMgLS0gZG9jdW1lbnRlZCBvbiBnaXRodWIgLy9UT0RPLUdEIG1vdmUgc29tZSBvZiB0aGF0IGRvY3VtZW50YXRpb24gaGVyZVxuICovXG52YXIgRW5ncmF2ZXJDb250cm9sbGVyID0gZnVuY3Rpb24ocGFwZXIsIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIHRoaXMucmVzcG9uc2l2ZSA9IHBhcmFtcy5yZXNwb25zaXZlO1xuICB0aGlzLnNwYWNlID0gMypzcGFjaW5nLlNQQUNFO1xuICB0aGlzLnNjYWxlID0gcGFyYW1zLnNjYWxlID8gcGFyc2VGbG9hdChwYXJhbXMuc2NhbGUpIDogMDtcbiAgaWYgKCEodGhpcy5zY2FsZSA+IDAuMSkpXG4gIFx0dGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcblxuXHRpZiAocGFyYW1zLnN0YWZmd2lkdGgpIHtcblx0XHQvLyBOb3RlOiBOb3JtYWxseSBhbGwgbWVhc3VyZW1lbnRzIHRvIHRoZSBlbmdyYXZlciBhcmUgaW4gUE9JTlRTLiBIb3dldmVyLCBpZiBhIHBlcnNvbiBpcyBmb3JtYXR0aW5nIGZvciB0aGVcblx0XHQvLyBzY3JlZW4gYW5kIGRpcmVjdGx5IGlucHV0dGluZyB0aGUgd2lkdGgsIHRoZW4gaXQgaXMgbW9yZSBsb2dpY2FsIHRvIGhhdmUgdGhlIG1lYXN1cmVtZW50IGluIHBpeGVscy5cblx0XHR0aGlzLnN0YWZmd2lkdGhTY3JlZW4gPSBwYXJhbXMuc3RhZmZ3aWR0aDtcblx0XHR0aGlzLnN0YWZmd2lkdGhQcmludCA9IHBhcmFtcy5zdGFmZndpZHRoO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc3RhZmZ3aWR0aFNjcmVlbiA9IDc0MDsgLy8gVE9ETy1QRVI6IE5vdCBzdXJlIHdoZXJlIHRoaXMgbnVtYmVyIGNvbWVzIGZyb20sIGJ1dCB0aGlzIGlzIGhvdyBpdCdzIGFsd2F5cyBiZWVuLlxuXHRcdHRoaXMuc3RhZmZ3aWR0aFByaW50ID0gNjgwOyAvLyBUaGUgbnVtYmVyIG9mIHBpeGVscyBpbiA4LjVcIiwgYWZ0ZXIgMWNtIG9mIG1hcmdpbiBoYXMgYmVlbiByZW1vdmVkLlxuXHR9XG4gIHRoaXMuZWRpdGFibGUgPSBwYXJhbXMuZWRpdGFibGUgfHwgZmFsc2U7XG5cdHRoaXMubGlzdGVuZXJzID0gW107XG5cdGlmIChwYXJhbXMuY2xpY2tMaXN0ZW5lcilcblx0XHR0aGlzLmFkZFNlbGVjdExpc3RlbmVyKHBhcmFtcy5jbGlja0xpc3RlbmVyKTtcblxuICB0aGlzLnJlbmRlcmVyPW5ldyBSZW5kZXJlcihwYXBlciwgcGFyYW1zLnJlZ3Jlc3Npb24sIHBhcmFtcy5hZGRfY2xhc3Nlcyk7XG5cdHRoaXMucmVuZGVyZXIuc2V0UGFkZGluZ092ZXJyaWRlKHBhcmFtcyk7XG4gIHRoaXMucmVuZGVyZXIuY29udHJvbGxlciA9IHRoaXM7IC8vIFRPRE8tR0QgbmVlZGVkIGZvciBoaWdobGlnaHRpbmdcblxuXHR0aGlzLnJlc2V0KCk7XG59O1xuXG5FbmdyYXZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2VsZWN0ZWQgPSBbXTtcblx0dGhpcy5pbmdyb3VwID0gZmFsc2U7XG5cdHRoaXMuc3RhZmZncm91cHMgPSBbXTtcblx0dGhpcy5sYXN0U3RhZmZHcm91cEluZGV4ID0gLTE7XG5cdGlmICh0aGlzLmVuZ3JhdmVyKVxuXHRcdHRoaXMuZW5ncmF2ZXIucmVzZXQoKTtcblx0dGhpcy5lbmdyYXZlciA9IG51bGw7XG5cdHRoaXMucmVuZGVyZXIucmVzZXQoKTtcbn07XG5cbi8qKlxuICogcnVuIHRoZSBlbmdyYXZpbmcgcHJvY2Vzc1xuICogQHBhcmFtIHtBQkNKUy5UdW5lfEFCQ0pTLlR1bmVbXX0gYWJjdHVuZXNcbiAqL1xuRW5ncmF2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5lbmdyYXZlQUJDID0gZnVuY3Rpb24oYWJjdHVuZXMsIHR1bmVOdW1iZXIpIHtcbiAgaWYgKGFiY3R1bmVzWzBdPT09dW5kZWZpbmVkKSB7XG4gICAgYWJjdHVuZXMgPSBbYWJjdHVuZXNdO1xuICB9XG5cdHRoaXMucmVzZXQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFiY3R1bmVzLmxlbmd0aDsgaSsrKSB7XG4gIFx0aWYgKHR1bmVOdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgXHRcdHR1bmVOdW1iZXIgPSBpO1xuICAgIHRoaXMuZW5ncmF2ZVR1bmUoYWJjdHVuZXNbaV0sIHR1bmVOdW1iZXIpO1xuICB9XG5cdGlmICh0aGlzLnJlbmRlcmVyLmRvUmVncmVzc2lvbilcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlci5yZWdyZXNzaW9uTGluZXMuam9pbihcIlxcblwiKTtcbn07XG5cbi8qKlxuICogU29tZSBvZiB0aGUgaXRlbXMgb24gdGhlIHBhZ2UgYXJlIG5vdCBzY2FsZWQsIHNvIGFkanVzdCB0aGVtIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2Ygc2NhbGluZyB0byBjYW5jZWwgb3V0IHRoZSBzY2FsaW5nLlxuICogQHBhcmFtIHtmbG9hdH0gc2NhbGVcbiAqL1xuRW5ncmF2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGp1c3ROb25TY2FsZWRJdGVtcyA9IGZ1bmN0aW9uIChzY2FsZSkge1xuXHR0aGlzLndpZHRoIC89IHNjYWxlO1xuXHR0aGlzLnJlbmRlcmVyLmFkanVzdE5vblNjYWxlZEl0ZW1zKHNjYWxlKTtcbn07XG5cbkVuZ3JhdmVyQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWVhc3VyZVdpZHRocyA9IGZ1bmN0aW9uKGFiY1R1bmUpIHtcblx0dGhpcy5yZXNldCgpO1xuXG5cdHRoaXMucmVuZGVyZXIubGluZU51bWJlciA9IG51bGw7XG5cblx0dGhpcy5yZW5kZXJlci5uZXdUdW5lKGFiY1R1bmUpO1xuXHR0aGlzLmVuZ3JhdmVyID0gbmV3IEFic3RyYWN0RW5ncmF2ZXIodGhpcy5yZW5kZXJlciwgMCwgeyBiYWdwaXBlczogYWJjVHVuZS5mb3JtYXR0aW5nLmJhZ3BpcGVzLCBmbGF0YmVhbXM6IGFiY1R1bmUuZm9ybWF0dGluZy5mbGF0YmVhbXMgfSk7XG5cdHRoaXMuZW5ncmF2ZXIuc2V0U3RlbUhlaWdodCh0aGlzLnJlbmRlcmVyLnNwYWNpbmcuc3RlbUhlaWdodCk7XG5cdGlmIChhYmNUdW5lLmZvcm1hdHRpbmcuc3RhZmZ3aWR0aCkge1xuXHRcdHRoaXMud2lkdGggPSBhYmNUdW5lLmZvcm1hdHRpbmcuc3RhZmZ3aWR0aCAqIDEuMzM7IC8vIFRoZSB3aWR0aCBpcyBleHByZXNzZWQgaW4gcHQ7IGNvbnZlcnQgdG8gcHguXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy53aWR0aCA9IHRoaXMucmVuZGVyZXIuaXNQcmludCA/IHRoaXMuc3RhZmZ3aWR0aFByaW50IDogdGhpcy5zdGFmZndpZHRoU2NyZWVuO1xuXHR9XG5cblx0dmFyIHNjYWxlID0gYWJjVHVuZS5mb3JtYXR0aW5nLnNjYWxlID8gYWJjVHVuZS5mb3JtYXR0aW5nLnNjYWxlIDogdGhpcy5zY2FsZTtcblx0aWYgKHRoaXMucmVzcG9uc2l2ZSA9PT0gXCJyZXNpemVcIikgLy8gVGhlIHJlc2l6aW5nIHdpbGwgbWVzcyB3aXRoIHRoZSBzY2FsaW5nLCBzbyBqdXN0IGRvbid0IGRvIGl0IGV4cGxpY2l0bHkuXG5cdFx0c2NhbGUgPSB1bmRlZmluZWQ7XG5cdGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSBzY2FsZSA9IHRoaXMucmVuZGVyZXIuaXNQcmludCA/IDAuNzUgOiAxO1xuXHR0aGlzLmFkanVzdE5vblNjYWxlZEl0ZW1zKHNjYWxlKTtcblxuXHR2YXIgcmV0ID0geyBsZWZ0OiAwLCBtZWFzdXJlV2lkdGhzOiBbXSwgaGVpZ2h0OiAwLCB0b3RhbDogMCB9O1xuXHQvLyBUT0RPLVBFUjogbmVlZCB0byBhZGQgdGhlIGhlaWdodCBvZiB0aGUgdGl0bGUgYmxvY2ssIHRvby5cblx0cmV0LmhlaWdodCA9IHRoaXMucmVuZGVyZXIucGFkZGluZy50b3AgKyB0aGlzLnJlbmRlcmVyLnNwYWNpbmcubXVzaWMgKyB0aGlzLnJlbmRlcmVyLnBhZGRpbmcuYm90dG9tICsgMjQ7IC8vIHRoZSAyNCBpcyB0aGUgZW1waXJpY2FsIHZhbHVlIGFkZGVkIHRvIHRoZSBib3R0b20gb2YgYWxsIHR1bmVzLlxuXHR2YXIgZGVidWcgPSBmYWxzZTtcblx0dmFyIGhhc1ByaW50ZWRUZW1wbyA9IGZhbHNlO1xuXHRmb3IodmFyIGk9MDsgaTxhYmNUdW5lLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGFiY0xpbmUgPSBhYmNUdW5lLmxpbmVzW2ldO1xuXHRcdGlmIChhYmNMaW5lLnN0YWZmKSB7XG5cdFx0XHRhYmNMaW5lLnN0YWZmR3JvdXAgPSB0aGlzLmVuZ3JhdmVyLmNyZWF0ZUFCQ0xpbmUoYWJjTGluZS5zdGFmZiwgIWhhc1ByaW50ZWRUZW1wbyA/IGFiY1R1bmUubWV0YVRleHQudGVtcG86IG51bGwpO1xuXG5cdFx0XHRhYmNMaW5lLnN0YWZmR3JvdXAubGF5b3V0KDAsIHRoaXMucmVuZGVyZXIsIGRlYnVnKTtcblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIHRoZSB2b2ljZXMgYXJlIGxhaWQgb3V0IHNvIHRoYXQgdGhlIGJhciBsaW5lcyBhcmUgZXZlbiB3aXRoIGVhY2ggb3RoZXIuIFNvIHdlIGp1c3QgbmVlZCB0byBnZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgZmlyc3Qgdm9pY2UuXG5cdFx0XHRpZiAoYWJjTGluZS5zdGFmZkdyb3VwLnZvaWNlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciB2b2ljZSA9IGFiY0xpbmUuc3RhZmZHcm91cC52b2ljZXNbMF07XG5cdFx0XHRcdHZhciBmb3VuZE5vdFN0YWZmRXh0cmEgPSBmYWxzZTtcblx0XHRcdFx0dmFyIGxhc3RYUG9zaXRpb24gPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IHZvaWNlLmNoaWxkcmVuLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gdm9pY2UuY2hpbGRyZW5ba107XG5cdFx0XHRcdFx0aWYgKCFmb3VuZE5vdFN0YWZmRXh0cmEgJiYgIWNoaWxkLmlzQ2xlZiAmJiAhY2hpbGQuaXNLZXlTaWcpIHtcblx0XHRcdFx0XHRcdGZvdW5kTm90U3RhZmZFeHRyYSA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXQubGVmdCA9IGNoaWxkLng7XG5cdFx0XHRcdFx0XHRsYXN0WFBvc2l0aW9uID0gY2hpbGQueDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNoaWxkLnR5cGUgPT09ICdiYXInKSB7XG5cdFx0XHRcdFx0XHRyZXQubWVhc3VyZVdpZHRocy5wdXNoKGNoaWxkLnggLSBsYXN0WFBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdHJldC50b3RhbCArPSAoY2hpbGQueCAtIGxhc3RYUG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0bGFzdFhQb3NpdGlvbiA9IGNoaWxkLng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRoYXNQcmludGVkVGVtcG8gPSB0cnVlO1xuXHRcdFx0cmV0LmhlaWdodCArPSBhYmNMaW5lLnN0YWZmR3JvdXAuY2FsY0hlaWdodCgpICogc3BhY2luZy5TVEVQO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGVuZ3JhdmluZyBwcm9jZXNzIG9uIGEgc2luZ2xlIHR1bmVcbiAqIEBwYXJhbSB7QUJDSlMuVHVuZX0gYWJjdHVuZVxuICovXG5FbmdyYXZlckNvbnRyb2xsZXIucHJvdG90eXBlLmVuZ3JhdmVUdW5lID0gZnVuY3Rpb24gKGFiY3R1bmUsIHR1bmVOdW1iZXIpIHtcblx0dGhpcy5yZW5kZXJlci5saW5lTnVtYmVyID0gbnVsbDtcblxuXHR0aGlzLnJlbmRlcmVyLm5ld1R1bmUoYWJjdHVuZSk7XG5cdHRoaXMuZW5ncmF2ZXIgPSBuZXcgQWJzdHJhY3RFbmdyYXZlcih0aGlzLnJlbmRlcmVyLCB0dW5lTnVtYmVyLCB7IGJhZ3BpcGVzOiBhYmN0dW5lLmZvcm1hdHRpbmcuYmFncGlwZXMsIGZsYXRiZWFtczogYWJjdHVuZS5mb3JtYXR0aW5nLmZsYXRiZWFtcyB9KTtcblx0dGhpcy5lbmdyYXZlci5zZXRTdGVtSGVpZ2h0KHRoaXMucmVuZGVyZXIuc3BhY2luZy5zdGVtSGVpZ2h0KTtcblx0dGhpcy5lbmdyYXZlci5tZWFzdXJlTGVuZ3RoID0gYWJjdHVuZS5nZXRNZXRlckZyYWN0aW9uKCkubnVtL2FiY3R1bmUuZ2V0TWV0ZXJGcmFjdGlvbigpLmRlbjtcblx0aWYgKGFiY3R1bmUuZm9ybWF0dGluZy5zdGFmZndpZHRoKSB7XG5cdFx0dGhpcy53aWR0aCA9IGFiY3R1bmUuZm9ybWF0dGluZy5zdGFmZndpZHRoICogMS4zMzsgLy8gVGhlIHdpZHRoIGlzIGV4cHJlc3NlZCBpbiBwdDsgY29udmVydCB0byBweC5cblx0fSBlbHNlIHtcblx0XHR0aGlzLndpZHRoID0gdGhpcy5yZW5kZXJlci5pc1ByaW50ID8gdGhpcy5zdGFmZndpZHRoUHJpbnQgOiB0aGlzLnN0YWZmd2lkdGhTY3JlZW47XG5cdH1cblxuXHR2YXIgc2NhbGUgPSBhYmN0dW5lLmZvcm1hdHRpbmcuc2NhbGUgPyBhYmN0dW5lLmZvcm1hdHRpbmcuc2NhbGUgOiB0aGlzLnNjYWxlO1xuXHRpZiAodGhpcy5yZXNwb25zaXZlID09PSBcInJlc2l6ZVwiKSAvLyBUaGUgcmVzaXppbmcgd2lsbCBtZXNzIHdpdGggdGhlIHNjYWxpbmcsIHNvIGp1c3QgZG9uJ3QgZG8gaXQgZXhwbGljaXRseS5cblx0XHRzY2FsZSA9IHVuZGVmaW5lZDtcblx0aWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHNjYWxlID0gdGhpcy5yZW5kZXJlci5pc1ByaW50ID8gMC43NSA6IDE7XG5cdHRoaXMuYWRqdXN0Tm9uU2NhbGVkSXRlbXMoc2NhbGUpO1xuXG5cdC8vIEdlbmVyYXRlIHRoZSByYXcgc3RhZmYgbGluZSBkYXRhXG5cdHZhciBpO1xuXHR2YXIgYWJjTGluZTtcblx0dmFyIGhhc1ByaW50ZWRUZW1wbyA9IGZhbHNlO1xuXHRmb3IoaT0wOyBpPGFiY3R1bmUubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRhYmNMaW5lID0gYWJjdHVuZS5saW5lc1tpXTtcblx0XHRpZiAoYWJjTGluZS5zdGFmZikge1xuXHRcdFx0YWJjTGluZS5zdGFmZkdyb3VwID0gdGhpcy5lbmdyYXZlci5jcmVhdGVBQkNMaW5lKGFiY0xpbmUuc3RhZmYsICFoYXNQcmludGVkVGVtcG8gPyBhYmN0dW5lLm1ldGFUZXh0LnRlbXBvOiBudWxsKTtcblx0XHRcdGhhc1ByaW50ZWRUZW1wbyA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IHRoZSB4LWNvb3JkaW5hdGVzIHRvIHRoZWlyIGFic29sdXRlIHBvc2l0aW9uc1xuXHR2YXIgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuXHRmb3IoaT0wOyBpPGFiY3R1bmUubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHRhYmNMaW5lID0gYWJjdHVuZS5saW5lc1tpXTtcblx0XHRpZiAoYWJjTGluZS5zdGFmZikge1xuXHRcdFx0dGhpcy5zZXRYU3BhY2luZyhhYmNMaW5lLnN0YWZmR3JvdXAsIGFiY3R1bmUuZm9ybWF0dGluZywgaSA9PT0gYWJjdHVuZS5saW5lcy5sZW5ndGggLSAxLCBmYWxzZSk7XG5cdFx0XHRpZiAoYWJjTGluZS5zdGFmZkdyb3VwLncgPiBtYXhXaWR0aCkgbWF4V2lkdGggPSBhYmNMaW5lLnN0YWZmR3JvdXAudztcblx0XHR9XG5cdH1cblxuXHQvLyBMYXlvdXQgdGhlIGJlYW1zIGFuZCBhZGQgdGhlIHN0ZW1zIHRvIHRoZSBiZWFtZWQgbm90ZXMuXG5cdGZvcihpPTA7IGk8YWJjdHVuZS5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdGFiY0xpbmUgPSBhYmN0dW5lLmxpbmVzW2ldO1xuXHRcdGlmIChhYmNMaW5lLnN0YWZmR3JvdXAgJiYgYWJjTGluZS5zdGFmZkdyb3VwLnZvaWNlcykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhYmNMaW5lLnN0YWZmR3JvdXAudm9pY2VzLmxlbmd0aDsgaisrKVxuXHRcdFx0XHRhYmNMaW5lLnN0YWZmR3JvdXAudm9pY2VzW2pdLmxheW91dEJlYW1zKCk7XG5cdFx0XHRhYmNMaW5lLnN0YWZmR3JvdXAuc2V0VXBwZXJBbmRMb3dlckVsZW1lbnRzKHRoaXMucmVuZGVyZXIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgc3RhZmYgc3BhY2luZ1xuXHQvLyBUT0RPLVBFUjogd2Ugc2hvdWxkIGhhdmUgYmVlbiBhYmxlIHRvIGRvIHRoaXMgYnkgdGhlIHRpbWUgd2UgY2FsbGVkIHNldFVwcGVyQW5kTG93ZXJFbGVtZW50cywgYnV0IGZvciBzb21lIHJlYXNvbiB0aGUgXCJib3R0b21cIiBlbGVtZW50IHNlZW1zIHRvIGJlIHNldCBhcyBhIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcgdGhlIFggc3BhY2luZy5cblx0Zm9yKGk9MDsgaTxhYmN0dW5lLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YWJjTGluZSA9IGFiY3R1bmUubGluZXNbaV07XG5cdFx0aWYgKGFiY0xpbmUuc3RhZmZHcm91cCkge1xuXHRcdFx0YWJjTGluZS5zdGFmZkdyb3VwLmhlaWdodCA9IGFiY0xpbmUuc3RhZmZHcm91cC5jYWxjSGVpZ2h0KCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRG8gYWxsIHRoZSB3cml0aW5nIHRvIG91dHB1dFxuXHR0aGlzLnJlbmRlcmVyLnRvcE1hcmdpbihhYmN0dW5lKTtcblx0Ly90aGlzLnJlbmRlcmVyLnByaW50SG9yaXpvbnRhbExpbmUodGhpcy53aWR0aCArIHRoaXMucmVuZGVyZXIucGFkZGluZy5sZWZ0ICsgdGhpcy5yZW5kZXJlci5wYWRkaW5nLnJpZ2h0KTtcblx0dGhpcy5yZW5kZXJlci5lbmdyYXZlVG9wVGV4dCh0aGlzLndpZHRoLCBhYmN0dW5lKTtcblx0dGhpcy5yZW5kZXJlci5hZGRNdXNpY1BhZGRpbmcoKTtcblxuXHR0aGlzLnN0YWZmZ3JvdXBzID0gW107XG5cdHRoaXMubGFzdFN0YWZmR3JvdXBJbmRleCA9IC0xO1xuXHRmb3IgKHZhciBsaW5lID0gMDsgbGluZSA8IGFiY3R1bmUubGluZXMubGVuZ3RoOyBsaW5lKyspIHtcblx0XHR0aGlzLnJlbmRlcmVyLmxpbmVOdW1iZXIgPSBsaW5lO1xuXHRcdGFiY0xpbmUgPSBhYmN0dW5lLmxpbmVzW2xpbmVdO1xuXHRcdGlmIChhYmNMaW5lLnN0YWZmKSB7XG5cdFx0XHR0aGlzLmVuZ3JhdmVTdGFmZkxpbmUoYWJjTGluZS5zdGFmZkdyb3VwKTtcblx0XHR9IGVsc2UgaWYgKGFiY0xpbmUuc3VidGl0bGUgJiYgbGluZSAhPT0gMCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlci5vdXRwdXRTdWJ0aXRsZSh0aGlzLndpZHRoLCBhYmNMaW5lLnN1YnRpdGxlKTtcblx0XHR9IGVsc2UgaWYgKGFiY0xpbmUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLm91dHB1dEZyZWVUZXh0KGFiY0xpbmUudGV4dCwgYWJjTGluZS52c2tpcCk7XG5cdFx0fSBlbHNlIGlmIChhYmNMaW5lLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyLm91dHB1dFNlcGFyYXRvcihhYmNMaW5lLnNlcGFyYXRvcik7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5yZW5kZXJlci5tb3ZlWSgyNCk7IC8vIFRPRE8tUEVSOiBFbXBpcmljYWxseSBkaXNjb3ZlcmVkLiBXaGF0IHZhcmlhYmxlIHNob3VsZCB0aGlzIGJlP1xuXHR0aGlzLnJlbmRlcmVyLmVuZ3JhdmVFeHRyYVRleHQodGhpcy53aWR0aCwgYWJjdHVuZSk7XG5cdHRoaXMucmVuZGVyZXIuc2V0UGFwZXJTaXplKG1heFdpZHRoLCBzY2FsZSwgdGhpcy5yZXNwb25zaXZlKTtcbn07XG5cbmZ1bmN0aW9uIGNhbGNIb3Jpem9udGFsU3BhY2luZyhpc0xhc3RMaW5lLCBzdHJldGNoTGFzdCwgdGFyZ2V0V2lkdGgsIGxpbmVXaWR0aCwgc3BhY2luZywgc3BhY2luZ1VuaXRzLCBtaW5TcGFjZSkge1xuXHQvLyBUT0RPLVBFUjogVGhpcyB1c2VkIHRvIHN0cmV0Y2ggdGhlIGZpcnN0IGxpbmUgd2hlbiBpdCBpcyB0aGUgb25seSBsaW5lLCBidXQgSSdtIG5vdCBzdXJlIHdoeS4gYWJjbTJwcyBkb2Vzbid0IGRvIHRoYXRcblx0aWYgKGlzTGFzdExpbmUgJiYgbGluZVdpZHRoIC8gdGFyZ2V0V2lkdGggPCAwLjY2ICYmICFzdHJldGNoTGFzdCkgcmV0dXJuIG51bGw7IC8vIGRvbid0IHN0cmV0Y2ggbGFzdCBsaW5lIHRvbyBtdWNoXG5cdGlmIChNYXRoLmFicyh0YXJnZXRXaWR0aC1saW5lV2lkdGgpIDwgMikgcmV0dXJuIG51bGw7IC8vIGlmIHdlIGFyZSBhbHJlYWR5IG5lYXIgdGhlIHRhcmdldCB3aWR0aCwgd2UncmUgZG9uZS5cblx0dmFyIHJlbFNwYWNlID0gc3BhY2luZ1VuaXRzICogc3BhY2luZztcblx0dmFyIGNvbnN0U3BhY2UgPSBsaW5lV2lkdGggLSByZWxTcGFjZTtcblx0aWYgKHNwYWNpbmdVbml0cyA+IDApIHtcblx0XHRzcGFjaW5nID0gKHRhcmdldFdpZHRoIC0gY29uc3RTcGFjZSkgLyBzcGFjaW5nVW5pdHM7XG5cdFx0aWYgKHNwYWNpbmcgKiBtaW5TcGFjZSA+IDUwKSB7XG5cdFx0XHRzcGFjaW5nID0gNTAgLyBtaW5TcGFjZTtcblx0XHR9XG5cdFx0cmV0dXJuIHNwYWNpbmc7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRG8gdGhlIHgtYXhpcyBwb3NpdGlvbmluZyBmb3IgYSBzaW5nbGUgbGluZSAoYSBncm91cCBvZiByZWxhdGVkIHN0YWZmcylcbiAqIEBwYXJhbSB7QUJDSlMuVHVuZX0gYWJjdHVuZSBhbiBBQkNKUyBBU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFmZkdyb3VwIGFuIHN0YWZmR3JvdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXR0aW5nIGFuIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMYXN0TGluZSBpcyB0aGlzIHRoZSBsYXN0IGxpbmUgdG8gYmUgcHJpbnRlZD9cbiAqIEBwcml2YXRlXG4gKi9cbkVuZ3JhdmVyQ29udHJvbGxlci5wcm90b3R5cGUuc2V0WFNwYWNpbmcgPSBmdW5jdGlvbiAoc3RhZmZHcm91cCwgZm9ybWF0dGluZywgaXNMYXN0TGluZSwgZGVidWcpIHtcbiAgIHZhciBuZXdzcGFjZSA9IHRoaXMuc3BhY2U7XG4gIGZvciAodmFyIGl0ID0gMDsgaXQgPCA4OyBpdCsrKSB7IC8vIFRPRE8tUEVSOiBzaG91bGRuJ3QgbmVlZCBtdWx0aXBsZSBwYXNzZXMsIGJ1dCBlYWNoIHBhc3MgZ2V0cyBpdCBjbG9zZXIgdG8gdGhlIHJpZ2h0IHNwYWNpbmcuIChPbmx5IGFmZmVjdHMgbG9uZyBsaW5lczogbm9ybWFsIGxpbmVzIGJyZWFrIG91dCBvZiB0aGlzIGxvb3AgcXVpY2tseS4pXG5cdCAgdmFyIHJldCA9IHN0YWZmR3JvdXAubGF5b3V0KG5ld3NwYWNlLCB0aGlzLnJlbmRlcmVyLCBkZWJ1Zyk7XG5cdCAgdmFyIHN0cmV0Y2hMYXN0ID0gZm9ybWF0dGluZy5zdHJldGNobGFzdCA/IGZvcm1hdHRpbmcuc3RyZXRjaGxhc3QgOiBmYWxzZTtcblx0XHRuZXdzcGFjZSA9IGNhbGNIb3Jpem9udGFsU3BhY2luZyhpc0xhc3RMaW5lLCBzdHJldGNoTGFzdCwgdGhpcy53aWR0aCt0aGlzLnJlbmRlcmVyLnBhZGRpbmcubGVmdCwgc3RhZmZHcm91cC53LCBuZXdzcGFjZSwgcmV0LnNwYWNpbmdVbml0cywgcmV0Lm1pblNwYWNlKTtcblx0XHRpZiAoZGVidWcpXG5cdFx0XHRjb25zb2xlLmxvZyhcInNldFhTcGFjZVwiLCBpdCwgc3RhZmZHcm91cC53LCBuZXdzcGFjZSwgc3RhZmZHcm91cC5taW5zcGFjZSk7XG5cdFx0aWYgKG5ld3NwYWNlID09PSBudWxsKSBicmVhaztcbiAgfVxuXHRjZW50ZXJXaG9sZVJlc3RzKHN0YWZmR3JvdXAudm9pY2VzKTtcblx0Ly90aGlzLnJlbmRlcmVyLnByaW50SG9yaXpvbnRhbExpbmUodGhpcy53aWR0aCk7XG59O1xuXG4vKipcbiAqIEVuZ3JhdmUgYSBzaW5nbGUgbGluZSAoYSBncm91cCBvZiByZWxhdGVkIHN0YWZmcylcbiAqIEBwYXJhbSB7QUJDSlMuVHVuZX0gYWJjdHVuZSBhbiBBQkNKUyBBU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFmZkdyb3VwIGFuIHN0YWZmR3JvdXBcbiAqIEBwcml2YXRlXG4gKi9cbkVuZ3JhdmVyQ29udHJvbGxlci5wcm90b3R5cGUuZW5ncmF2ZVN0YWZmTGluZSA9IGZ1bmN0aW9uIChzdGFmZkdyb3VwKSB7XG5cdGlmICh0aGlzLmxhc3RTdGFmZkdyb3VwSW5kZXggPiAtMSlcblx0XHR0aGlzLnJlbmRlcmVyLmFkZFN0YWZmUGFkZGluZyh0aGlzLnN0YWZmZ3JvdXBzW3RoaXMubGFzdFN0YWZmR3JvdXBJbmRleF0sIHN0YWZmR3JvdXApO1xuXHR0aGlzLnJlbmRlcmVyLnZvaWNlTnVtYmVyID0gbnVsbDtcblx0c3RhZmZHcm91cC5kcmF3KHRoaXMucmVuZGVyZXIpO1xuXHR2YXIgaGVpZ2h0ID0gc3RhZmZHcm91cC5oZWlnaHQgKiBzcGFjaW5nLlNURVA7XG5cdC8vdGhpcy5yZW5kZXJlci5wcmludFZlcnRpY2FsTGluZSh0aGlzLndpZHRoK3RoaXMucmVuZGVyZXIucGFkZGluZy5sZWZ0LCB0aGlzLnJlbmRlcmVyLnksIHRoaXMucmVuZGVyZXIueStoZWlnaHQpO1xuICB0aGlzLnN0YWZmZ3JvdXBzW3RoaXMuc3RhZmZncm91cHMubGVuZ3RoXSA9IHN0YWZmR3JvdXA7XG5cdHRoaXMubGFzdFN0YWZmR3JvdXBJbmRleCA9IHRoaXMuc3RhZmZncm91cHMubGVuZ3RoLTE7XG5cdHRoaXMucmVuZGVyZXIueSArPSBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCBieSB0aGUgQWJzdHJhY3QgRW5ncmF2aW5nIFN0cnVjdHVyZSBvciBhbnkgb3RoZXIgKGUuZy4gbWlkaSBwbGF5YmFjaykgdG8gc2F5IGl0IHdhcyBzZWxlY3RlZCAobm90ZWhlYWQgY2xpY2tlZCBvbilcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuRW5ncmF2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5ub3RpZnlTZWxlY3QgPSBmdW5jdGlvbiAoYWJzZWxlbSwgdHVuZU51bWJlciwgY2xhc3Nlcykge1xuICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gIGlmIChhYnNlbGVtLmhpZ2hsaWdodCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBbYWJzZWxlbV07XG4gICAgYWJzZWxlbS5oaWdobGlnaHQoKTtcbiAgfVxuICB2YXIgYWJjZWxlbSA9IGFic2VsZW0uYWJjZWxlbSB8fCB7fTtcbiAgZm9yICh2YXIgaT0wOyBpPHRoaXMubGlzdGVuZXJzLmxlbmd0aDtpKyspIHtcblx0ICB0aGlzLmxpc3RlbmVyc1tpXShhYmNlbGVtLCB0dW5lTnVtYmVyLCBjbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgYnkgdGhlIEFic3RyYWN0IEVuZ3JhdmluZyBTdHJ1Y3R1cmUgdG8gc2F5IGl0IHdhcyBtb2RpZmllZCAoZS5nLiBub3RlaGVhZCBkcmFnZ2VkKVxuICogQHByb3RlY3RlZFxuICovXG4vLyBFbmdyYXZlckNvbnRyb2xsZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZSA9IGZ1bmN0aW9uICgvKmFic2VsZW0qLykge1xuLy8gICBmb3IgKHZhciBpPTA7IGk8dGhpcy5saXN0ZW5lcnMubGVuZ3RoO2krKykge1xuLy8gICAgIGlmICh0aGlzLmxpc3RlbmVyc1tpXS5tb2RlbENoYW5nZWQpXG4vLyAgICAgICB0aGlzLmxpc3RlbmVyc1tpXS5tb2RlbENoYW5nZWQoKTtcbi8vICAgfVxuLy8gfTtcblxuLyoqXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRW5ncmF2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaT0wO2k8dGhpcy5zZWxlY3RlZC5sZW5ndGg7aSsrKSB7XG4gICAgdGhpcy5zZWxlY3RlZFtpXS51bmhpZ2hsaWdodCgpO1xuICB9XG4gIHRoaXMuc2VsZWN0ZWQgPSBbXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lci5tb2RlbENoYW5nZWQgdGhlIG1vZGVsIHRoZSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBjb250cm9sbGVyIGhhcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lci5oaWdobGlnaHQgdGhlIGFiY2VsZW0gb2YgdGhlIG1vZGVsIHRoZSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBjb250cm9sbGVyIHNob3VsZCBiZSBoaWdobGlnaHRlZFxuICovXG5FbmdyYXZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZFNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24gKGNsaWNrTGlzdGVuZXIpIHtcbiAgdGhpcy5saXN0ZW5lcnNbdGhpcy5saXN0ZW5lcnMubGVuZ3RoXSA9IGNsaWNrTGlzdGVuZXI7XG59O1xuXG4vKipcbiAqIFRlbGwgdGhlIGNvbnRyb2xsZXIgdG8gaGlnaGxpZ2h0IHNvbWUgbm90ZWhlYWRzIG9mIGl0cyBlbmdyYXZlZCBzY29yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHRoZSBjaGFyYWN0ZXIgaW4gdGhlIHNvdXJjZSBhYmMgd2hlcmUgaGlnaGxpZ2h0aW5nIHNob3VsZCBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCB0aGUgY2hhcmFjdGVyIGluIHRoZSBzb3VyY2UgYWJjIHdoZXJlIGhpZ2hsaWdodGluZyBzaG91bGQgZW5kXG4gKi9cbkVuZ3JhdmVyQ29udHJvbGxlci5wcm90b3R5cGUucmFuZ2VIaWdobGlnaHQgPSBmdW5jdGlvbihzdGFydCxlbmQpXG57XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgIGZvciAodmFyIGxpbmU9MDtsaW5lPHRoaXMuc3RhZmZncm91cHMubGVuZ3RoOyBsaW5lKyspIHtcblx0dmFyIHZvaWNlcyA9IHRoaXMuc3RhZmZncm91cHNbbGluZV0udm9pY2VzO1xuXHRmb3IgKHZhciB2b2ljZT0wO3ZvaWNlPHZvaWNlcy5sZW5ndGg7dm9pY2UrKykge1xuXHQgICAgdmFyIGVsZW1zID0gdm9pY2VzW3ZvaWNlXS5jaGlsZHJlbjtcblx0ICAgIGZvciAodmFyIGVsZW09MDsgZWxlbTxlbGVtcy5sZW5ndGg7IGVsZW0rKykge1xuXHRcdC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBoaWdobGlnaHQgbW9yZSB0aGFuIGFuIGVsZW1lbnQsIG9yIHBhcnQgb2YgYW4gZWxlbWVudCwgYSBoaXQgaXMgaWYgYW55IG9mIHRoZSBlbmRwb2ludHNcblx0XHQvLyBpcyBpbnNpZGUgdGhlIG90aGVyIHJhbmdlLlxuXHRcdHZhciBlbFN0YXJ0ID0gZWxlbXNbZWxlbV0uYWJjZWxlbS5zdGFydENoYXI7XG5cdFx0dmFyIGVsRW5kID0gZWxlbXNbZWxlbV0uYWJjZWxlbS5lbmRDaGFyO1xuXHRcdGlmICgoZW5kPmVsU3RhcnQgJiYgc3RhcnQ8ZWxFbmQpIHx8ICgoZW5kPT09c3RhcnQpICYmIGVuZD09PWVsRW5kKSkge1xuXHRcdCAgICAvL1x0XHRpZiAoZWxlbXNbZWxlbV0uYWJjZWxlbS5zdGFydENoYXI+PXN0YXJ0ICYmIGVsZW1zW2VsZW1dLmFiY2VsZW0uZW5kQ2hhcjw9ZW5kKSB7XG5cdFx0ICAgIHRoaXMuc2VsZWN0ZWRbdGhpcy5zZWxlY3RlZC5sZW5ndGhdPWVsZW1zW2VsZW1dO1xuXHRcdCAgICBlbGVtc1tlbGVtXS5oaWdobGlnaHQoKTtcblx0XHR9XG5cdCAgICB9XG5cdH1cbiAgICB9XG59O1xuXG5cbmZ1bmN0aW9uIGNlbnRlcldob2xlUmVzdHModm9pY2VzKSB7XG5cdC8vIHdob2xlIHJlc3RzIGFyZSBhIHNwZWNpYWwgY2FzZTogaWYgdGhleSBhcmUgYnkgdGhlbXNlbHZlcyBpbiBhIG1lYXN1cmUsIHRoZW4gdGhleSBzaG91bGQgYmUgY2VudGVyZWQuXG5cdC8vIChJZiB0aGV5IGFyZSBub3QgYnkgdGhlbXNlbHZlcywgdGhhdCBpcyBwcm9iYWJseSBhIHVzZXIgZXJyb3IsIGJ1dCB3ZSdsbCBqdXN0IGNlbnRlciBpdCBiZXR3ZWVuIHRoZSB0d28gaXRlbXMgdG8gZWl0aGVyIHNpZGUgb2YgaXQuKVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB2b2ljZSA9IHZvaWNlc1tpXTtcblx0XHQvLyBMb29rIHRocm91Z2ggYWxsIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgZm9yIHRoZSBmaXJzdCBhbmQgbGFzdC4gSWYgdGhlIHdob2xlIG5vdGUgYXBwZWFycyB0aGVyZSB0aGVuIHRoZXJlIGlzbid0IGFueXRoaW5nIHRvIGNlbnRlciBpdCBiZXR3ZWVuIGFueXdheS5cblx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHZvaWNlLmNoaWxkcmVuLmxlbmd0aC0xOyBqKyspIHtcblx0XHRcdHZhciBhYnNFbGVtID0gdm9pY2UuY2hpbGRyZW5bal07XG5cdFx0XHRpZiAoYWJzRWxlbS5hYmNlbGVtLnJlc3QgJiYgKGFic0VsZW0uYWJjZWxlbS5yZXN0LnR5cGUgPT09ICd3aG9sZScgfHwgYWJzRWxlbS5hYmNlbGVtLnJlc3QudHlwZSA9PT0gJ211bHRpbWVhc3VyZScpKSB7XG5cdFx0XHRcdHZhciBiZWZvcmUgPSB2b2ljZS5jaGlsZHJlbltqLTFdO1xuXHRcdFx0XHR2YXIgYWZ0ZXIgPSB2b2ljZS5jaGlsZHJlbltqKzFdO1xuXHRcdFx0XHR2YXIgbWlkcG9pbnQgPSAoYWZ0ZXIueCAtIGJlZm9yZS54KSAvIDIgKyBiZWZvcmUueDtcblx0XHRcdFx0YWJzRWxlbS54ID0gbWlkcG9pbnQgLSBhYnNFbGVtLncgLyAyO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGFic0VsZW0uY2hpbGRyZW4ubGVuZ3RoOyBrKyspXG5cdFx0XHRcdFx0YWJzRWxlbS5jaGlsZHJlbltrXS54ID0gYWJzRWxlbS54O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ3JhdmVyQ29udHJvbGxlcjtcbiIsInZhciBzcGFjaW5nID0gcmVxdWlyZSgnLi9hYmNfc3BhY2luZycpO1xuXG4vKipcbiAqIEdseXBocyBhbmQgc29tZSBtZXRob2RzIHRvIGFkanVzdCBmb3IgdGhlaXIgeCBhbmQgeSBiYXNlbGluZVxuICovXG5cdHZhciBnbHlwaHMgPVxuXHR7JzAnOntkOltbJ00nLDQuODMsLTE0Ljk3XSxbJ2MnLDAuMzMsLTAuMDMsMS4xMSwwLjAwLDEuNDcsMC4wNl0sWydjJywxLjY4LDAuMzYsMi45NywxLjU5LDMuNzgsMy42MF0sWydjJywxLjIwLDIuOTcsMC44MSw2Ljk2LC0wLjkwLDkuMjddLFsnYycsLTAuNzgsMS4wOCwtMS43MSwxLjcxLC0yLjkxLDEuOTVdLFsnYycsLTAuNDUsMC4wOSwtMS4zMiwwLjA5LC0xLjc3LDAuMDBdLFsnYycsLTAuODEsLTAuMTgsLTEuNDcsLTAuNTEsLTIuMDcsLTEuMDJdLFsnYycsLTIuMzQsLTIuMDcsLTMuMTUsLTYuNzIsLTEuNzQsLTEwLjIwXSxbJ2MnLDAuODcsLTIuMTYsMi4yOCwtMy40Miw0LjE0LC0zLjY2XSxbJ3onXSxbJ20nLDEuMTEsMC44N10sWydjJywtMC4yMSwtMC4wNiwtMC42OSwtMC4wOSwtMC44NywtMC4wNl0sWydjJywtMC41NCwwLjEyLC0wLjg3LDAuNDIsLTEuMTcsMC45OV0sWydjJywtMC4zNiwwLjY2LC0wLjUxLDEuNTYsLTAuNjAsMy4wMF0sWydjJywtMC4wMywwLjc1LC0wLjAzLDQuNTksMC4wMCw1LjMxXSxbJ2MnLDAuMDksMS41MCwwLjI3LDIuNDAsMC42MCwzLjA2XSxbJ2MnLDAuMjQsMC40OCwwLjU3LDAuNzgsMC45NiwwLjkwXSxbJ2MnLDAuMjcsMC4wOSwwLjc4LDAuMDksMS4wNSwwLjAwXSxbJ2MnLDAuMzksLTAuMTIsMC43MiwtMC40MiwwLjk2LC0wLjkwXSxbJ2MnLDAuMzMsLTAuNjYsMC41MSwtMS41NiwwLjYwLC0zLjA2XSxbJ2MnLDAuMDMsLTAuNzIsMC4wMywtNC41NiwwLjAwLC01LjMxXSxbJ2MnLC0wLjA5LC0xLjQ3LC0wLjI3LC0yLjM3LC0wLjYwLC0zLjAzXSxbJ2MnLC0wLjI0LC0wLjQ4LC0wLjU0LC0wLjc4LC0wLjkzLC0wLjkwXSxbJ3onXV0sdzoxMC43OCxoOjE0Ljk1OX0sXG5cdFx0JzEnOntkOltbJ00nLDMuMzAsLTE1LjA2XSxbJ2MnLDAuMDYsLTAuMDYsMC4yMSwtMC4wMywwLjY2LDAuMTVdLFsnYycsMC44MSwwLjM5LDEuMDgsMC4zOSwxLjgzLDAuMDNdLFsnYycsMC4yMSwtMC4wOSwwLjM5LC0wLjE1LDAuNDIsLTAuMTVdLFsnYycsMC4xMiwwLjAwLDAuMjEsMC4wOSwwLjI3LDAuMjFdLFsnYycsMC4wNiwwLjEyLDAuMDYsMC4zMywwLjA2LDUuOTRdLFsnYycsMC4wMCwzLjkzLDAuMDAsNS44NSwwLjAzLDYuMDNdLFsnYycsMC4wNiwwLjM2LDAuMTUsMC42OSwwLjI3LDAuOTZdLFsnYycsMC4zNiwwLjc1LDAuOTMsMS4xNywxLjY4LDEuMjZdLFsnYycsMC4zMCwwLjAzLDAuMzksMC4wOSwwLjM5LDAuMzBdLFsnYycsMC4wMCwwLjE1LC0wLjAzLDAuMTgsLTAuMDksMC4yNF0sWydjJywtMC4wNiwwLjA2LC0wLjA5LDAuMDYsLTAuNDgsMC4wNl0sWydjJywtMC40MiwwLjAwLC0wLjY5LC0wLjAzLC0yLjEwLC0wLjI0XSxbJ2MnLC0wLjkwLC0wLjE1LC0xLjc3LC0wLjE1LC0yLjY3LDAuMDBdLFsnYycsLTEuNDEsMC4yMSwtMS42OCwwLjI0LC0yLjEwLDAuMjRdLFsnYycsLTAuMzksMC4wMCwtMC40MiwwLjAwLC0wLjQ4LC0wLjA2XSxbJ2MnLC0wLjA2LC0wLjA2LC0wLjA2LC0wLjA5LC0wLjA2LC0wLjI0XSxbJ2MnLDAuMDAsLTAuMjEsMC4wNiwtMC4yNywwLjM2LC0wLjMwXSxbJ2MnLDAuNzUsLTAuMDksMS4zMiwtMC41MSwxLjY4LC0xLjI2XSxbJ2MnLDAuMTIsLTAuMjcsMC4yMSwtMC42MCwwLjI3LC0wLjk2XSxbJ2MnLDAuMDMsLTAuMTgsMC4wMywtMS41OSwwLjAzLC00LjI5XSxbJ2MnLDAuMDAsLTMuODcsMC4wMCwtNC4wNSwtMC4wNiwtNC4xNF0sWydjJywtMC4wOSwtMC4xNSwtMC4xOCwtMC4yNCwtMC4zOSwtMC4yNF0sWydjJywtMC4xMiwwLjAwLC0wLjE1LDAuMDMsLTAuMjEsMC4wNl0sWydjJywtMC4wMywwLjA2LC0wLjQ1LDAuOTksLTAuOTYsMi4xM10sWydjJywtMC40OCwxLjE0LC0wLjkwLDIuMTAsLTAuOTMsMi4xNl0sWydjJywtMC4wNiwwLjE1LC0wLjIxLDAuMjQsLTAuMzMsMC4yNF0sWydjJywtMC4yNCwwLjAwLC0wLjQyLC0wLjE4LC0wLjQyLC0wLjM5XSxbJ2MnLDAuMDAsLTAuMDYsMy4yNywtNy42MiwzLjMzLC03Ljc0XSxbJ3onXV0sdzo4Ljk0LGg6MTUuMDU4fSxcblx0XHQnMic6e2Q6W1snTScsNC4yMywtMTQuOTddLFsnYycsMC41NywtMC4wNiwxLjY4LDAuMDAsMi4zNCwwLjE4XSxbJ2MnLDAuNjksMC4xOCwxLjUwLDAuNTQsMi4wMSwwLjkwXSxbJ2MnLDEuMzUsMC45NiwxLjk1LDIuMjUsMS43NywzLjgxXSxbJ2MnLC0wLjE1LDEuMzUsLTAuNjYsMi4zNCwtMS42OCwzLjE1XSxbJ2MnLC0wLjYwLDAuNDgsLTEuNDQsMC45MywtMy4xMiwxLjY1XSxbJ2MnLC0xLjMyLDAuNTcsLTEuODAsMC44MSwtMi4zNywxLjE0XSxbJ2MnLC0wLjU3LDAuMzMsLTAuNTcsMC4zMywtMC4yNCwwLjI3XSxbJ2MnLDAuMzksLTAuMDksMS4yNiwtMC4wOSwxLjY4LDAuMDBdLFsnYycsMC43MiwwLjE1LDEuNDEsMC40NSwyLjEwLDAuOTBdLFsnYycsMC45OSwwLjYzLDEuODYsMC44NywyLjU1LDAuNzVdLFsnYycsMC4yNCwtMC4wNiwwLjQyLC0wLjE1LDAuNTcsLTAuMzBdLFsnYycsMC4xMiwtMC4wOSwwLjMwLC0wLjQyLDAuMzAsLTAuNTFdLFsnYycsMC4wMCwtMC4wOSwwLjEyLC0wLjIxLDAuMjQsLTAuMjRdLFsnYycsMC4xOCwtMC4wMywwLjM5LDAuMTIsMC4zOSwwLjMwXSxbJ2MnLDAuMDAsMC4xMiwtMC4xNSwwLjU3LC0wLjMwLDAuODddLFsnYycsLTAuNTQsMS4wMiwtMS41NiwxLjc0LC0yLjc5LDIuMDFdLFsnYycsLTAuNDIsMC4wOSwtMS4yMywwLjA5LC0xLjYyLDAuMDNdLFsnYycsLTAuODEsLTAuMTgsLTEuMzIsLTAuNDUsLTIuMDEsLTEuMTFdLFsnYycsLTAuNDUsLTAuNDUsLTAuNjMsLTAuNTcsLTAuOTYsLTAuNjldLFsnYycsLTAuODQsLTAuMjcsLTEuODksMC4xMiwtMi4yNSwwLjkwXSxbJ2MnLC0wLjEyLDAuMjEsLTAuMjEsMC41NCwtMC4yMSwwLjcyXSxbJ2MnLDAuMDAsMC4xMiwtMC4xMiwwLjIxLC0wLjI3LDAuMjRdLFsnYycsLTAuMTUsMC4wMCwtMC4yNywtMC4wMywtMC4zMywtMC4xNV0sWydjJywtMC4wOSwtMC4yMSwwLjA5LC0xLjA4LDAuMzMsLTEuNzFdLFsnYycsMC4yNCwtMC42NiwwLjY2LC0xLjI2LDEuMjksLTEuODldLFsnYycsMC40NSwtMC40NSwwLjkwLC0wLjgxLDEuOTIsLTEuNTZdLFsnYycsMS4yOSwtMC45MywxLjg5LC0xLjQ0LDIuMzQsLTEuOThdLFsnYycsMC44NywtMS4wNSwxLjI2LC0yLjE5LDEuMjAsLTMuNjNdLFsnYycsLTAuMDYsLTEuMjksLTAuMzksLTIuMzEsLTAuOTYsLTIuOTFdLFsnYycsLTAuMzYsLTAuMzMsLTAuNzIsLTAuNTEsLTEuMTcsLTAuNTRdLFsnYycsLTAuODQsLTAuMDMsLTEuNTMsMC40MiwtMS41OSwxLjA1XSxbJ2MnLC0wLjAzLDAuMzMsMC4xMiwwLjYwLDAuNTcsMS4xNF0sWydjJywwLjQ1LDAuNTQsMC41NCwwLjg3LDAuNDIsMS40MV0sWydjJywtMC4xNSwwLjYzLC0wLjU0LDEuMTEsLTEuMDgsMS4zOF0sWydjJywtMC42MywwLjMzLC0xLjIwLDAuMzMsLTEuODMsMC4wMF0sWydjJywtMC4yNCwtMC4xMiwtMC4zMywtMC4xOCwtMC41NCwtMC4zOV0sWydjJywtMC4xOCwtMC4xOCwtMC4yNywtMC4zMCwtMC4zNiwtMC41MV0sWydjJywtMC4yNCwtMC40NSwtMC4yNywtMC44NCwtMC4yMSwtMS4zOF0sWydjJywwLjEyLC0wLjc1LDAuNDUsLTEuNDEsMS4wMiwtMS45OF0sWydjJywwLjcyLC0wLjcyLDEuNzQsLTEuMTcsMi44NSwtMS4zMl0sWyd6J11dLHc6MTAuNzY0LGg6MTQuOTd9LFxuXHRcdCczJzp7ZDpbWydNJywzLjc4LC0xNC45N10sWydjJywwLjMwLC0wLjAzLDEuNDEsMC4wMCwxLjgzLDAuMDZdLFsnYycsMi4yMiwwLjMwLDMuNTEsMS4zMiwzLjcyLDIuOTFdLFsnYycsMC4wMywwLjMzLDAuMDMsMS4yNiwtMC4wMywxLjY1XSxbJ2MnLC0wLjEyLDAuODQsLTAuNDgsMS40NywtMS4wNSwxLjc3XSxbJ2MnLC0wLjI3LDAuMTUsLTAuMzYsMC4yNCwtMC40NSwwLjM5XSxbJ2MnLC0wLjA5LDAuMjEsLTAuMDksMC4zNiwwLjAwLDAuNTddLFsnYycsMC4wOSwwLjE1LDAuMTgsMC4yNCwwLjUxLDAuMzldLFsnYycsMC43NSwwLjQyLDEuMjMsMS4xNCwxLjQxLDIuMTNdLFsnYycsMC4wNiwwLjQyLDAuMDYsMS4zNSwwLjAwLDEuNzFdLFsnYycsLTAuMTgsMC44MSwtMC40OCwxLjM4LC0xLjAyLDEuOTVdLFsnYycsLTAuNzUsMC43MiwtMS44MCwxLjIwLC0zLjE4LDEuMzhdLFsnYycsLTAuNDIsMC4wNiwtMS41NiwwLjA2LC0xLjk1LDAuMDBdLFsnYycsLTEuODksLTAuMzMsLTMuMTgsLTEuMjksLTMuNTEsLTIuNjRdLFsnYycsLTAuMDMsLTAuMTIsLTAuMDMsLTAuMzMsLTAuMDMsLTAuNjBdLFsnYycsMC4wMCwtMC4zNiwwLjAwLC0wLjQyLDAuMDYsLTAuNjNdLFsnYycsMC4xMiwtMC4zMCwwLjI3LC0wLjUxLDAuNTEsLTAuNzVdLFsnYycsMC4yNCwtMC4yNCwwLjQ1LC0wLjM5LDAuNzUsLTAuNTFdLFsnYycsMC4yMSwtMC4wNiwwLjI3LC0wLjA2LDAuNjAsLTAuMDZdLFsnYycsMC4zMywwLjAwLDAuMzksMC4wMCwwLjYwLDAuMDZdLFsnYycsMC4zMCwwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFdLFsnYycsMC4zNiwwLjMzLDAuNTcsMC43NSwwLjYwLDEuMjBdLFsnYycsMC4wMCwwLjIxLDAuMDAsMC4yNywtMC4wNiwwLjQyXSxbJ2MnLC0wLjA5LDAuMTgsLTAuMTIsMC4yNCwtMC41NCwwLjU0XSxbJ2MnLC0wLjUxLDAuMzYsLTAuNjMsMC41NCwtMC42MCwwLjg3XSxbJ2MnLDAuMDYsMC41NCwwLjU0LDAuOTAsMS4zOCwwLjk5XSxbJ2MnLDAuMzYsMC4wNiwwLjcyLDAuMDMsMC45NiwtMC4wNl0sWydjJywwLjgxLC0wLjI3LDEuMjksLTEuMjMsMS40NCwtMi43OV0sWydjJywwLjAzLC0wLjQ1LDAuMDMsLTEuOTUsLTAuMDMsLTIuMzddLFsnYycsLTAuMDksLTAuNzUsLTAuMzMsLTEuMjMsLTAuNzUsLTEuNDRdLFsnYycsLTAuMzMsLTAuMTgsLTAuNDUsLTAuMTgsLTEuOTgsLTAuMThdLFsnYycsLTEuMzUsMC4wMCwtMS40MSwwLjAwLC0xLjUwLC0wLjA2XSxbJ2MnLC0wLjE4LC0wLjEyLC0wLjI0LC0wLjM5LC0wLjEyLC0wLjYwXSxbJ2MnLDAuMTIsLTAuMTUsMC4xNSwtMC4xNSwxLjY4LC0wLjE1XSxbJ2MnLDEuNTAsMC4wMCwxLjYyLDAuMDAsMS44OSwtMC4xNV0sWydjJywwLjE4LC0wLjA5LDAuNDIsLTAuMzYsMC41NCwtMC41N10sWydjJywwLjE4LC0wLjQyLDAuMjcsLTAuOTAsMC4zMCwtMS45NV0sWydjJywwLjAzLC0xLjIwLC0wLjA2LC0xLjgwLC0wLjM2LC0yLjM3XSxbJ2MnLC0wLjI0LC0wLjQ4LC0wLjYzLC0wLjgxLC0xLjE0LC0wLjk2XSxbJ2MnLC0wLjMwLC0wLjA2LC0xLjA4LC0wLjA2LC0xLjM4LDAuMDNdLFsnYycsLTAuNjAsMC4xNSwtMC45MCwwLjQyLC0wLjk2LDAuODRdLFsnYycsLTAuMDMsMC4zMCwwLjA2LDAuNDUsMC42MywwLjg0XSxbJ2MnLDAuMzMsMC4yNCwwLjQyLDAuMzksMC40NSwwLjYzXSxbJ2MnLDAuMDMsMC43MiwtMC41NywxLjUwLC0xLjMyLDEuNjVdLFsnYycsLTEuMDUsMC4yNywtMi4xMCwtMC41NywtMi4xMCwtMS42NV0sWydjJywwLjAwLC0wLjQ1LDAuMTUsLTAuOTYsMC4zOSwtMS4zOF0sWydjJywwLjEyLC0wLjIxLDAuNTQsLTAuNjMsMC44MSwtMC44MV0sWydjJywwLjU3LC0wLjQyLDEuMzgsLTAuNjksMi4yNSwtMC44MV0sWyd6J11dLHc6OS43MzUsaDoxNC45Njd9LFxuXHRcdCc0Jzp7ZDpbWydNJyw4LjY0LC0xNC45NF0sWydjJywwLjI3LC0wLjA5LDAuNDIsLTAuMTIsMC41NCwtMC4wM10sWydjJywwLjA5LDAuMDYsMC4xNSwwLjIxLDAuMTUsMC4zMF0sWydjJywtMC4wMywwLjA2LC0xLjkyLDIuMzEsLTQuMjMsNS4wNF0sWydjJywtMi4zMSwyLjczLC00LjIzLDQuOTgsLTQuMjYsNS4wMV0sWydjJywtMC4wMywwLjA2LDAuMTIsMC4wNiwyLjU1LDAuMDZdLFsnbCcsMi42MSwwLjAwXSxbJ2wnLDAuMDAsLTIuMzddLFsnYycsMC4wMCwtMi4xOSwwLjAzLC0yLjM3LDAuMDYsLTIuNDZdLFsnYycsMC4wMywtMC4wNiwwLjIxLC0wLjE4LDAuNTcsLTAuNDJdLFsnYycsMS4wOCwtMC43MiwxLjM4LC0xLjA4LDEuODYsLTIuMTZdLFsnYycsMC4xMiwtMC4zMCwwLjI0LC0wLjU0LDAuMjcsLTAuNTddLFsnYycsMC4xMiwtMC4xMiwwLjM5LC0wLjA2LDAuNDUsMC4xMl0sWydjJywwLjA2LDAuMDksMC4wNiwwLjU3LDAuMDYsMy45Nl0sWydsJywwLjAwLDMuOTBdLFsnbCcsMS4wOCwwLjAwXSxbJ2MnLDEuMDUsMC4wMCwxLjExLDAuMDAsMS4yMCwwLjA2XSxbJ2MnLDAuMjQsMC4xNSwwLjI0LDAuNTQsMC4wMCwwLjY5XSxbJ2MnLC0wLjA5LDAuMDYsLTAuMTUsMC4wNiwtMS4yMCwwLjA2XSxbJ2wnLC0xLjA4LDAuMDBdLFsnbCcsMC4wMCwwLjMzXSxbJ2MnLDAuMDAsMC41NywwLjA5LDEuMTEsMC4zMCwxLjUzXSxbJ2MnLDAuMzYsMC43NSwwLjkzLDEuMTcsMS42OCwxLjI2XSxbJ2MnLDAuMzAsMC4wMywwLjM5LDAuMDksMC4zOSwwLjMwXSxbJ2MnLDAuMDAsMC4xNSwtMC4wMywwLjE4LC0wLjA5LDAuMjRdLFsnYycsLTAuMDYsMC4wNiwtMC4wOSwwLjA2LC0wLjQ4LDAuMDZdLFsnYycsLTAuNDIsMC4wMCwtMC42OSwtMC4wMywtMi4xMCwtMC4yNF0sWydjJywtMC45MCwtMC4xNSwtMS43NywtMC4xNSwtMi42NywwLjAwXSxbJ2MnLC0xLjQxLDAuMjEsLTEuNjgsMC4yNCwtMi4xMCwwLjI0XSxbJ2MnLC0wLjM5LDAuMDAsLTAuNDIsMC4wMCwtMC40OCwtMC4wNl0sWydjJywtMC4wNiwtMC4wNiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4yNF0sWydjJywwLjAwLC0wLjIxLDAuMDYsLTAuMjcsMC4zNiwtMC4zMF0sWydjJywwLjc1LC0wLjA5LDEuMzIsLTAuNTEsMS42OCwtMS4yNl0sWydjJywwLjIxLC0wLjQyLDAuMzAsLTAuOTYsMC4zMCwtMS41M10sWydsJywwLjAwLC0wLjMzXSxbJ2wnLC0yLjcwLDAuMDBdLFsnYycsLTIuOTEsMC4wMCwtMi44NSwwLjAwLC0zLjA5LC0wLjE1XSxbJ2MnLC0wLjE4LC0wLjEyLC0wLjMwLC0wLjM5LC0wLjI3LC0wLjU0XSxbJ2MnLDAuMDMsLTAuMDYsMC4xOCwtMC4yNCwwLjMzLC0wLjQ1XSxbJ2MnLDAuNzUsLTAuOTAsMS41OSwtMi4wNywyLjEzLC0zLjAzXSxbJ2MnLDAuMzMsLTAuNTQsMC44NCwtMS42MiwxLjA1LC0yLjE2XSxbJ2MnLDAuNTcsLTEuNDEsMC44NCwtMi42NCwwLjkwLC00LjA1XSxbJ2MnLDAuMDMsLTAuNjMsMC4wNiwtMC43MiwwLjI0LC0wLjgxXSxbJ2wnLDAuMTIsLTAuMDZdLFsnbCcsMC40NSwwLjEyXSxbJ2MnLDAuNjYsMC4xOCwxLjAyLDAuMjQsMS40NywwLjI3XSxbJ2MnLDAuNjAsMC4wMywxLjIzLC0wLjA5LDIuMDEsLTAuMzNdLFsneiddXSx3OjExLjc5NSxoOjE0Ljk5NH0sXG5cdFx0JzUnOntkOltbJ00nLDEuMDIsLTE0Ljk0XSxbJ2MnLDAuMTIsLTAuMDksMC4wMywtMC4wOSwxLjA4LDAuMDZdLFsnYycsMi40OSwwLjM2LDQuMzUsMC4zNiw2Ljk2LC0wLjA2XSxbJ2MnLDAuNTcsLTAuMDksMC42NiwtMC4wNiwwLjgxLDAuMDZdLFsnYycsMC4xNSwwLjE4LDAuMTIsMC4yNCwtMC4xNSwwLjUxXSxbJ2MnLC0xLjI5LDEuMjYsLTMuMjQsMi4wNCwtNS41OCwyLjMxXSxbJ2MnLC0wLjYwLDAuMDksLTEuMjAsMC4xMiwtMS43MSwwLjEyXSxbJ2MnLC0wLjM5LDAuMDAsLTAuNDUsMC4wMCwtMC41NywwLjA2XSxbJ2MnLC0wLjA5LDAuMDYsLTAuMTUsMC4xMiwtMC4yMSwwLjIxXSxbJ2wnLC0wLjA2LDAuMTJdLFsnbCcsMC4wMCwxLjY1XSxbJ2wnLDAuMDAsMS42NV0sWydsJywwLjIxLC0wLjIxXSxbJ2MnLDAuNjYsLTAuNTcsMS40MSwtMC45NiwyLjE5LC0xLjE0XSxbJ2MnLDAuMzMsLTAuMDYsMS40MSwtMC4wNiwxLjk1LDAuMDBdLFsnYycsMi42MSwwLjM2LDQuMDIsMS43NCw0LjI2LDQuMTRdLFsnYycsMC4wMywwLjQ1LDAuMDMsMS4wOCwtMC4wMywxLjQ0XSxbJ2MnLC0wLjE4LDEuMDIsLTAuNzgsMi4wMSwtMS41OSwyLjcwXSxbJ2MnLC0wLjcyLDAuNTcsLTEuNjIsMS4wMiwtMi40OSwxLjIwXSxbJ2MnLC0xLjM4LDAuMjcsLTMuMDMsMC4wNiwtNC4yMCwtMC41NF0sWydjJywtMS4wOCwtMC41NCwtMS43MSwtMS4zMiwtMS44NiwtMi4yOF0sWydjJywtMC4wOSwtMC42OSwwLjA5LC0xLjI5LDAuNTcsLTEuNzRdLFsnYycsMC4yNCwtMC4yNCwwLjQ1LC0wLjM5LDAuNzUsLTAuNTFdLFsnYycsMC4yMSwtMC4wNiwwLjI3LC0wLjA2LDAuNjAsLTAuMDZdLFsnYycsMC4zMywwLjAwLDAuMzksMC4wMCwwLjYwLDAuMDZdLFsnYycsMC4zMCwwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFdLFsnYycsMC4zNiwwLjMzLDAuNTcsMC43NSwwLjYwLDEuMjBdLFsnYycsMC4wMCwwLjIxLDAuMDAsMC4yNywtMC4wNiwwLjQyXSxbJ2MnLC0wLjA5LDAuMTgsLTAuMTIsMC4yNCwtMC41NCwwLjU0XSxbJ2MnLC0wLjE4LDAuMTIsLTAuMzYsMC4zMCwtMC40MiwwLjMzXSxbJ2MnLC0wLjM2LDAuNDIsLTAuMTgsMC45OSwwLjM2LDEuMjZdLFsnYycsMC41MSwwLjI3LDEuNDcsMC4zNiwyLjAxLDAuMjddLFsnYycsMC45MywtMC4yMSwxLjQ3LC0xLjE3LDEuNjUsLTIuOTFdLFsnYycsMC4wNiwtMC40NSwwLjA2LC0xLjg5LDAuMDAsLTIuMzFdLFsnYycsLTAuMTUsLTEuMjAsLTAuNTEsLTIuMTAsLTEuMDUsLTIuNTVdLFsnYycsLTAuMjEsLTAuMTgsLTAuNTQsLTAuMzYsLTAuODEsLTAuMzldLFsnYycsLTAuMzAsLTAuMDYsLTAuODQsLTAuMDMsLTEuMjYsMC4wNl0sWydjJywtMC45MywwLjE4LC0xLjY1LDAuNjAsLTIuMTYsMS4yMF0sWydjJywtMC4xNSwwLjIxLC0wLjI3LDAuMzAsLTAuMzksMC4zMF0sWydjJywtMC4xNSwwLjAwLC0wLjMwLC0wLjA5LC0wLjM2LC0wLjE4XSxbJ2MnLC0wLjA2LC0wLjA5LC0wLjA2LC0wLjE1LC0wLjA2LC0zLjY2XSxbJ2MnLDAuMDAsLTMuMzksMC4wMCwtMy41NywwLjA2LC0zLjY2XSxbJ2MnLDAuMDMsLTAuMDYsMC4wOSwtMC4xNSwwLjE1LC0wLjE4XSxbJ3onXV0sdzoxMC4yMTIsaDoxNC45OTd9LFxuXHRcdCc2Jzp7ZDpbWydNJyw0Ljk4LC0xNC45N10sWydjJywwLjM2LC0wLjAzLDEuMjAsMC4wMCwxLjU5LDAuMDZdLFsnYycsMC45MCwwLjE1LDEuNjgsMC41MSwyLjI1LDEuMDVdLFsnYycsMC41NywwLjUxLDAuODcsMS4yMywwLjg0LDEuOThdLFsnYycsLTAuMDMsMC41MSwtMC4yMSwwLjkwLC0wLjYwLDEuMjZdLFsnYycsLTAuMjQsMC4yNCwtMC40NSwwLjM5LC0wLjc1LDAuNTFdLFsnYycsLTAuMjEsMC4wNiwtMC4yNywwLjA2LC0wLjYwLDAuMDZdLFsnYycsLTAuMzMsMC4wMCwtMC4zOSwwLjAwLC0wLjYwLC0wLjA2XSxbJ2MnLC0wLjMwLC0wLjEyLC0wLjUxLC0wLjI3LC0wLjc1LC0wLjUxXSxbJ2MnLC0wLjM5LC0wLjM2LC0wLjU3LC0wLjc4LC0wLjU3LC0xLjI2XSxbJ2MnLDAuMDAsLTAuMjcsMC4wMCwtMC4zMCwwLjA5LC0wLjQyXSxbJ2MnLDAuMDMsLTAuMDksMC4xOCwtMC4yMSwwLjMwLC0wLjMwXSxbJ2MnLDAuMTIsLTAuMDksMC4zMCwtMC4yMSwwLjM5LC0wLjI3XSxbJ2MnLDAuMDksLTAuMDYsMC4yMSwtMC4xOCwwLjI3LC0wLjI0XSxbJ2MnLDAuMDYsLTAuMTIsMC4wOSwtMC4xNSwwLjA5LC0wLjMzXSxbJ2MnLDAuMDAsLTAuMTgsLTAuMDMsLTAuMjQsLTAuMDksLTAuMzZdLFsnYycsLTAuMjQsLTAuMzksLTAuNzUsLTAuNjAsLTEuMzgsLTAuNTddLFsnYycsLTAuNTQsMC4wMywtMC45MCwwLjE4LC0xLjIzLDAuNDhdLFsnYycsLTAuODEsMC43MiwtMS4wOCwyLjE2LC0wLjk2LDUuMzddLFsnbCcsMC4wMCwwLjYzXSxbJ2wnLDAuMzAsLTAuMTJdLFsnYycsMC43OCwtMC4yNywxLjI5LC0wLjMzLDIuMTAsLTAuMjddLFsnYycsMS40NywwLjEyLDIuNDksMC41NCwzLjI3LDEuMjldLFsnYycsMC40OCwwLjUxLDAuODEsMS4xMSwwLjk2LDEuODldLFsnYycsMC4wNiwwLjI3LDAuMDYsMC40MiwwLjA2LDAuOTNdLFsnYycsMC4wMCwwLjU0LDAuMDAsMC42OSwtMC4wNiwwLjk2XSxbJ2MnLC0wLjE1LDAuNzgsLTAuNDgsMS4zOCwtMC45NiwxLjg5XSxbJ2MnLC0wLjU0LDAuNTEsLTEuMTcsMC44NywtMS45OCwxLjA4XSxbJ2MnLC0xLjE0LDAuMzAsLTIuNDAsMC4zMywtMy4yNCwwLjAzXSxbJ2MnLC0xLjUwLC0wLjQ4LC0yLjY0LC0xLjg5LC0zLjI3LC00LjAyXSxbJ2MnLC0wLjM2LC0xLjIzLC0wLjUxLC0yLjgyLC0wLjQyLC00LjA4XSxbJ2MnLDAuMzAsLTMuNjYsMi4yOCwtNi4zMCw0Ljk1LC02LjY2XSxbJ3onXSxbJ20nLDAuNjYsNy40MV0sWydjJywtMC4yNywtMC4wOSwtMC44MSwtMC4xMiwtMS4wOCwtMC4wNl0sWydjJywtMC43MiwwLjE4LC0xLjA4LDAuNjksLTEuMjMsMS43MV0sWydjJywtMC4wNiwwLjU0LC0wLjA2LDMuMDAsMC4wMCwzLjU0XSxbJ2MnLDAuMTgsMS4yNiwwLjcyLDEuNzcsMS44MCwxLjc0XSxbJ2MnLDAuMzksLTAuMDMsMC42MywtMC4wOSwwLjkwLC0wLjI3XSxbJ2MnLDAuNjYsLTAuNDIsMC45MCwtMS4zMiwwLjkwLC0zLjI0XSxbJ2MnLDAuMDAsLTIuMjIsLTAuMzYsLTMuMTIsLTEuMjksLTMuNDJdLFsneiddXSx3OjkuOTU2LGg6MTQuOTgyfSxcblx0XHQnNyc6e2Q6W1snTScsMC4yMSwtMTQuOTddLFsnYycsMC4yMSwtMC4wNiwwLjQ1LDAuMDAsMC41NCwwLjE1XSxbJ2MnLDAuMDYsMC4wOSwwLjA2LDAuMTUsMC4wNiwwLjM5XSxbJ2MnLDAuMDAsMC4yNCwwLjAwLDAuMzMsMC4wNiwwLjQyXSxbJ2MnLDAuMDYsMC4xMiwwLjIxLDAuMjQsMC4yNywwLjI0XSxbJ2MnLDAuMDMsMC4wMCwwLjEyLC0wLjEyLDAuMjQsLTAuMjFdLFsnYycsMC45NiwtMS4yMCwyLjU4LC0xLjM1LDMuOTksLTAuNDJdLFsnYycsMC4xNSwwLjEyLDAuNDIsMC4zMCwwLjU0LDAuNDVdLFsnYycsMC40OCwwLjM5LDAuODEsMC41NywxLjI5LDAuNjBdLFsnYycsMC42OSwwLjAzLDEuNTAsLTAuMzAsMi4xMywtMC44N10sWydjJywwLjA5LC0wLjA5LDAuMjcsLTAuMzAsMC4zOSwtMC40NV0sWydjJywwLjEyLC0wLjE1LDAuMjQsLTAuMjcsMC4zMCwtMC4zMF0sWydjJywwLjE4LC0wLjA2LDAuMzksMC4wMywwLjUxLDAuMjFdLFsnYycsMC4wNiwwLjE4LDAuMDYsMC4yNCwtMC4yNywwLjcyXSxbJ2MnLC0wLjE4LDAuMjQsLTAuNTQsMC43OCwtMC43OCwxLjE3XSxbJ2MnLC0yLjM3LDMuNTQsLTMuNTQsNi4yNywtMy44Nyw5LjAwXSxbJ2MnLC0wLjAzLDAuMzMsLTAuMDMsMC42NiwtMC4wMywxLjI2XSxbJ2MnLDAuMDAsMC45MCwwLjAwLDEuMDgsMC4xNSwxLjg5XSxbJ2MnLDAuMDYsMC40NSwwLjA2LDAuNDgsMC4wMywwLjYwXSxbJ2MnLC0wLjA2LDAuMDksLTAuMjEsMC4yMSwtMC4zMCwwLjIxXSxbJ2MnLC0wLjAzLDAuMDAsLTAuMjcsLTAuMDYsLTAuNTQsLTAuMTVdLFsnYycsLTAuODQsLTAuMjcsLTEuMTEsLTAuMzAsLTEuNjUsLTAuMzBdLFsnYycsLTAuNTcsMC4wMCwtMC44NCwwLjAzLC0xLjU2LDAuMjddLFsnYycsLTAuNjAsMC4xOCwtMC42OSwwLjIxLC0wLjgxLDAuMTVdLFsnYycsLTAuMTIsLTAuMDYsLTAuMjEsLTAuMTgsLTAuMjEsLTAuMzBdLFsnYycsMC4wMCwtMC4xNSwwLjYwLC0xLjQ0LDEuMjAsLTIuNjFdLFsnYycsMS4xNCwtMi4yMiwyLjczLC00LjY4LDUuMTAsLTguMDFdLFsnYycsMC4yMSwtMC4yNywwLjM2LC0wLjQ4LDAuMzMsLTAuNDhdLFsnYycsMC4wMCwwLjAwLC0wLjEyLDAuMDYsLTAuMjcsMC4xMl0sWydjJywtMC41NCwwLjMwLC0wLjk5LDAuMzksLTEuNTYsMC4zOV0sWydjJywtMC43NSwwLjAzLC0xLjIwLC0wLjE4LC0xLjgzLC0wLjc1XSxbJ2MnLC0wLjk5LC0wLjkwLC0xLjgzLC0xLjE3LC0yLjMxLC0wLjcyXSxbJ2MnLC0wLjE4LDAuMTUsLTAuMzYsMC41MSwtMC40NSwwLjg0XSxbJ2MnLC0wLjA2LDAuMjQsLTAuMDYsMC4zMywtMC4wOSwxLjk4XSxbJ2MnLDAuMDAsMS42MiwtMC4wMywxLjc0LC0wLjA2LDEuODBdLFsnYycsLTAuMTUsMC4yNCwtMC41NCwwLjI0LC0wLjY5LDAuMDBdLFsnYycsLTAuMDYsLTAuMDksLTAuMDYsLTAuMTUsLTAuMDYsLTMuNTddLFsnYycsMC4wMCwtMy40MiwwLjAwLC0zLjQ4LDAuMDYsLTMuNTddLFsnYycsMC4wMywtMC4wNiwwLjA5LC0wLjEyLDAuMTUsLTAuMTVdLFsneiddXSx3OjEwLjU2MSxoOjE1LjA5M30sXG5cdFx0JzgnOntkOltbJ00nLDQuOTgsLTE0Ljk3XSxbJ2MnLDAuMzMsLTAuMDMsMS4wMiwtMC4wMywxLjMyLDAuMDBdLFsnYycsMS4zMiwwLjEyLDIuNDksMC42MCwzLjIxLDEuMzJdLFsnYycsMC4zOSwwLjM5LDAuNjYsMC44MSwwLjc4LDEuMjldLFsnYycsMC4wOSwwLjM2LDAuMDksMS4wOCwwLjAwLDEuNDRdLFsnYycsLTAuMjEsMC44NCwtMC42NiwxLjU5LC0xLjU5LDIuNTVdLFsnbCcsLTAuMzAsMC4zMF0sWydsJywwLjI3LDAuMThdLFsnYycsMS40NywwLjkzLDIuMzEsMi4zMSwyLjI1LDMuNzVdLFsnYycsLTAuMDMsMC43NSwtMC4yNCwxLjM1LC0wLjYzLDEuOTVdLFsnYycsLTAuNDUsMC42NiwtMS4wMiwxLjE0LC0xLjgzLDEuNTNdLFsnYycsLTEuODAsMC44NywtNC4yMCwwLjg3LC02LjAwLDAuMDNdLFsnYycsLTEuNjIsLTAuNzgsLTIuNTIsLTIuMTYsLTIuNDYsLTMuNjZdLFsnYycsMC4wNiwtMC45OSwwLjU0LC0xLjc3LDEuODAsLTIuOTddLFsnYycsMC41NCwtMC41MSwwLjU0LC0wLjU0LDAuNDgsLTAuNTddLFsnYycsLTAuMzksLTAuMjcsLTAuOTYsLTAuNzgsLTEuMjAsLTEuMTRdLFsnYycsLTAuNzUsLTEuMTEsLTAuODcsLTIuNDAsLTAuMzAsLTMuNjBdLFsnYycsMC42OSwtMS4zNSwyLjI1LC0yLjI1LDQuMjAsLTIuNDBdLFsneiddLFsnbScsMS41MywwLjY5XSxbJ2MnLC0wLjQyLC0wLjA5LC0xLjExLC0wLjEyLC0xLjM4LC0wLjA2XSxbJ2MnLC0wLjMwLDAuMDYsLTAuNjAsMC4xOCwtMC44MSwwLjMwXSxbJ2MnLC0wLjIxLDAuMTIsLTAuNjAsMC41MSwtMC43MiwwLjcyXSxbJ2MnLC0wLjUxLDAuODcsLTAuNDIsMS44OSwwLjIxLDIuNTJdLFsnYycsMC4yMSwwLjIxLDAuMzYsMC4zMCwxLjk1LDEuMjNdLFsnYycsMC45NiwwLjU0LDEuNzQsMC45OSwxLjc3LDEuMDJdLFsnYycsMC4wOSwwLjAwLDAuNjMsLTAuNjAsMC45OSwtMS4xMV0sWydjJywwLjIxLC0wLjM2LDAuNDgsLTAuODcsMC41NywtMS4yM10sWydjJywwLjA2LC0wLjI0LDAuMDYsLTAuMzYsMC4wNiwtMC43Ml0sWydjJywwLjAwLC0wLjQ1LC0wLjAzLC0wLjY2LC0wLjE1LC0wLjk5XSxbJ2MnLC0wLjM5LC0wLjgxLC0xLjI5LC0xLjQ0LC0yLjQ5LC0xLjY4XSxbJ3onXSxbJ20nLC0xLjQ0LDguMDddLFsnbCcsLTEuODksLTEuMDhdLFsnYycsLTAuMDMsMC4wMCwtMC4xOCwwLjE1LC0wLjM5LDAuMzNdLFsnYycsLTEuMjAsMS4wOCwtMS42NSwxLjk1LC0xLjU5LDMuMDBdLFsnYycsMC4wOSwxLjU5LDEuMzUsMi44NSwzLjIxLDMuMjRdLFsnYycsMC4zMywwLjA2LDAuNDUsMC4wNiwwLjkzLDAuMDZdLFsnYycsMC42MywwLjAwLDAuODEsLTAuMDMsMS4yOSwtMC4yN10sWydjJywwLjkwLC0wLjQyLDEuNDcsLTEuNDEsMS40MSwtMi40MF0sWydjJywtMC4wNiwtMC42NiwtMC4zOSwtMS4yOSwtMC45MCwtMS42NV0sWydjJywtMC4xMiwtMC4wOSwtMS4wNSwtMC42MywtMi4wNywtMS4yM10sWyd6J11dLHc6MTAuOTI2LGg6MTQuOTg5fSxcblx0XHQnOSc6e2Q6W1snTScsNC4yMywtMTQuOTddLFsnYycsMC40MiwtMC4wMywxLjI5LDAuMDAsMS42MiwwLjA2XSxbJ2MnLDAuNTEsMC4xMiwwLjkzLDAuMzAsMS4zOCwwLjU3XSxbJ2MnLDEuNTMsMS4wMiwyLjUyLDMuMjQsMi43Myw1Ljk0XSxbJ2MnLDAuMTgsMi41NSwtMC40OCw0Ljk4LC0xLjgzLDYuNTddLFsnYycsLTEuMDUsMS4yNiwtMi40MCwxLjg5LC0zLjkzLDEuODNdLFsnYycsLTEuMjMsLTAuMDYsLTIuMzEsLTAuNDUsLTMuMDMsLTEuMTRdLFsnYycsLTAuNTcsLTAuNTEsLTAuODcsLTEuMjMsLTAuODQsLTEuOThdLFsnYycsMC4wMywtMC41MSwwLjIxLC0wLjkwLDAuNjAsLTEuMjZdLFsnYycsMC4yNCwtMC4yNCwwLjQ1LC0wLjM5LDAuNzUsLTAuNTFdLFsnYycsMC4yMSwtMC4wNiwwLjI3LC0wLjA2LDAuNjAsLTAuMDZdLFsnYycsMC4zMywwLjAwLDAuMzksMC4wMCwwLjYwLDAuMDZdLFsnYycsMC4zMCwwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFdLFsnYycsMC4zOSwwLjM2LDAuNTcsMC43OCwwLjU3LDEuMjZdLFsnYycsMC4wMCwwLjI3LDAuMDAsMC4zMCwtMC4wOSwwLjQyXSxbJ2MnLC0wLjAzLDAuMDksLTAuMTgsMC4yMSwtMC4zMCwwLjMwXSxbJ2MnLC0wLjEyLDAuMDksLTAuMzAsMC4yMSwtMC4zOSwwLjI3XSxbJ2MnLC0wLjA5LDAuMDYsLTAuMjEsMC4xOCwtMC4yNywwLjI0XSxbJ2MnLC0wLjA2LDAuMTIsLTAuMDYsMC4xNSwtMC4wNiwwLjMzXSxbJ2MnLDAuMDAsMC4xOCwwLjAwLDAuMjQsMC4wNiwwLjM2XSxbJ2MnLDAuMjQsMC4zOSwwLjc1LDAuNjAsMS4zOCwwLjU3XSxbJ2MnLDAuNTQsLTAuMDMsMC45MCwtMC4xOCwxLjIzLC0wLjQ4XSxbJ2MnLDAuODEsLTAuNzIsMS4wOCwtMi4xNiwwLjk2LC01LjM3XSxbJ2wnLDAuMDAsLTAuNjNdLFsnbCcsLTAuMzAsMC4xMl0sWydjJywtMC43OCwwLjI3LC0xLjI5LDAuMzMsLTIuMTAsMC4yN10sWydjJywtMS40NywtMC4xMiwtMi40OSwtMC41NCwtMy4yNywtMS4yOV0sWydjJywtMC40OCwtMC41MSwtMC44MSwtMS4xMSwtMC45NiwtMS44OV0sWydjJywtMC4wNiwtMC4yNywtMC4wNiwtMC40MiwtMC4wNiwtMC45Nl0sWydjJywwLjAwLC0wLjUxLDAuMDAsLTAuNjYsMC4wNiwtMC45M10sWydjJywwLjE1LC0wLjc4LDAuNDgsLTEuMzgsMC45NiwtMS44OV0sWydjJywwLjE1LC0wLjEyLDAuMzMsLTAuMjcsMC40MiwtMC4zNl0sWydjJywwLjY5LC0wLjUxLDEuNjIsLTAuODEsMi43NiwtMC45M10sWyd6J10sWydtJywxLjE3LDAuNjZdLFsnYycsLTAuMjEsLTAuMDYsLTAuNTcsLTAuMDYsLTAuODEsLTAuMDNdLFsnYycsLTAuNzgsMC4xMiwtMS4yNiwwLjY5LC0xLjQxLDEuNzRdLFsnYycsLTAuMTIsMC42MywtMC4xNSwxLjk1LC0wLjA5LDIuNzldLFsnYycsMC4xMiwxLjcxLDAuNjMsMi40MCwxLjc3LDIuNDZdLFsnYycsMS4wOCwwLjAzLDEuNjIsLTAuNDgsMS44MCwtMS43NF0sWydjJywwLjA2LC0wLjU0LDAuMDYsLTMuMDAsMC4wMCwtMy41NF0sWydjJywtMC4xNSwtMS4wNSwtMC41MSwtMS41MywtMS4yNiwtMS42OF0sWyd6J11dLHc6OS45NTksaDoxNC45ODZ9LFxuXHRcdCdyZXN0cy5tdWx0aW1lYXN1cmUnOntkOltbJ00nLDAsLTRdLFsnbCcsMCwxNl0sWydsJywxLDBdLFsnbCcsMCwtNV0sWydsJyw0MCwwXSxbJ2wnLDAsNV0sWydsJywxLDBdLFsnbCcsMCwtMTZdLFsnbCcsLTEsMF0sWydsJywwLDVdLFsnbCcsLTQwLDBdLFsnbCcsMCwtNV0sWyd6J11dLHc6NDIsaDoxOH0sXG5cdFx0J3Jlc3RzLndob2xlJzp7ZDpbWydNJywwLjA2LDAuMDNdLFsnbCcsMC4wOSwtMC4wNl0sWydsJyw1LjQ2LDAuMDBdLFsnbCcsNS40OSwwLjAwXSxbJ2wnLDAuMDksMC4wNl0sWydsJywwLjA2LDAuMDldLFsnbCcsMC4wMCwyLjE5XSxbJ2wnLDAuMDAsMi4xOV0sWydsJywtMC4wNiwwLjA5XSxbJ2wnLC0wLjA5LDAuMDZdLFsnbCcsLTUuNDksMC4wMF0sWydsJywtNS40NiwwLjAwXSxbJ2wnLC0wLjA5LC0wLjA2XSxbJ2wnLC0wLjA2LC0wLjA5XSxbJ2wnLDAuMDAsLTIuMTldLFsnbCcsMC4wMCwtMi4xOV0sWyd6J11dLHc6MTEuMjUsaDo0LjY4fSxcblx0XHQncmVzdHMuaGFsZic6e2Q6W1snTScsMC4wNiwtNC42Ml0sWydsJywwLjA5LC0wLjA2XSxbJ2wnLDUuNDYsMC4wMF0sWydsJyw1LjQ5LDAuMDBdLFsnbCcsMC4wOSwwLjA2XSxbJ2wnLDAuMDYsMC4wOV0sWydsJywwLjAwLDIuMTldLFsnbCcsMC4wMCwyLjE5XSxbJ2wnLC0wLjA2LDAuMDldLFsnbCcsLTAuMDksMC4wNl0sWydsJywtNS40OSwwLjAwXSxbJ2wnLC01LjQ2LDAuMDBdLFsnbCcsLTAuMDksLTAuMDZdLFsnbCcsLTAuMDYsLTAuMDldLFsnbCcsMC4wMCwtMi4xOV0sWydsJywwLjAwLC0yLjE5XSxbJ3onXV0sdzoxMS4yNSxoOjQuNjh9LFxuXHRcdCdyZXN0cy5xdWFydGVyJzp7ZDpbWydNJywxLjg5LC0xMS44Ml0sWydjJywwLjEyLC0wLjA2LDAuMjQsLTAuMDYsMC4zNiwtMC4wM10sWydjJywwLjA5LDAuMDYsNC43NCw1LjU4LDQuODYsNS44Ml0sWydjJywwLjIxLDAuMzksMC4xNSwwLjc4LC0wLjE1LDEuMjZdLFsnYycsLTAuMjQsMC4zMywtMC43MiwwLjgxLC0xLjYyLDEuNTZdLFsnYycsLTAuNDUsMC4zNiwtMC44NywwLjc1LC0wLjk2LDAuODRdLFsnYycsLTAuOTMsMC45OSwtMS4xNCwyLjQ5LC0wLjYwLDMuNjNdLFsnYycsMC4xOCwwLjM5LDAuMjcsMC40OCwxLjMyLDEuNjhdLFsnYycsMS45MiwyLjI1LDEuODMsMi4xNiwxLjgzLDIuMzRdLFsnYycsMC4wMCwwLjE4LC0wLjE4LDAuMzYsLTAuMzYsMC4zOV0sWydjJywtMC4xNSwwLjAwLC0wLjI3LC0wLjA2LC0wLjQ4LC0wLjI3XSxbJ2MnLC0wLjc1LC0wLjc1LC0yLjQ2LC0xLjI5LC0zLjM5LC0xLjA4XSxbJ2MnLC0wLjQ1LDAuMDksLTAuNjksMC4yNywtMC45MCwwLjY5XSxbJ2MnLC0wLjEyLDAuMzAsLTAuMjEsMC42NiwtMC4yNCwxLjE0XSxbJ2MnLC0wLjAzLDAuNjYsMC4wOSwxLjM1LDAuMzAsMi4wMV0sWydjJywwLjE1LDAuNDIsMC4yNCwwLjY2LDAuNDUsMC45Nl0sWydjJywwLjE4LDAuMjQsMC4xOCwwLjMzLDAuMDMsMC40Ml0sWydjJywtMC4xMiwwLjA2LC0wLjE4LDAuMDMsLTAuNDUsLTAuMzBdLFsnYycsLTEuMDgsLTEuMzgsLTIuMDcsLTMuMzYsLTIuNDAsLTQuODNdLFsnYycsLTAuMjcsLTEuMDUsLTAuMTUsLTEuNzcsMC4yNywtMi4wN10sWydjJywwLjIxLC0wLjEyLDAuNDIsLTAuMTUsMC44NywtMC4xNV0sWydjJywwLjg3LDAuMDYsMi4xMCwwLjM5LDMuMzAsMC45MF0sWydsJywwLjM5LDAuMThdLFsnbCcsLTEuNjUsLTEuOTVdLFsnYycsLTIuNTIsLTIuOTcsLTIuNjEsLTMuMDksLTIuNzAsLTMuMjddLFsnYycsLTAuMDksLTAuMjQsLTAuMTIsLTAuNDgsLTAuMDMsLTAuNzVdLFsnYycsMC4xNSwtMC40OCwwLjU3LC0wLjk2LDEuODMsLTIuMDFdLFsnYycsMC40NSwtMC4zNiwwLjg0LC0wLjcyLDAuOTMsLTAuNzhdLFsnYycsMC42OSwtMC43NSwxLjAyLC0xLjgwLDAuOTAsLTIuNzldLFsnYycsLTAuMDYsLTAuMzMsLTAuMjEsLTAuODQsLTAuMzksLTEuMTFdLFsnYycsLTAuMDksLTAuMTUsLTAuNDUsLTAuNjAsLTAuODEsLTEuMDVdLFsnYycsLTAuMzYsLTAuNDIsLTAuNjksLTAuODEsLTAuNzIsLTAuODddLFsnYycsLTAuMDksLTAuMTgsMC4wMCwtMC40MiwwLjIxLC0wLjUxXSxbJ3onXV0sdzo3Ljg4OCxoOjIxLjQzNX0sXG5cdFx0J3Jlc3RzLjh0aCc6e2Q6W1snTScsMS42OCwtNi4xMl0sWydjJywwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFdLFsnYycsMC4yNywwLjMwLDAuMzksMC41NCwwLjU3LDEuMjZdLFsnYycsMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJdLFsnYycsMC4xMiwwLjI3LDAuMzMsMC40NSwwLjYwLDAuNDhdLFsnYycsMC4xMiwwLjAwLDAuMTgsMC4wMCwwLjMzLC0wLjA5XSxbJ2MnLDAuMzksLTAuMTgsMS4zMiwtMS4yOSwxLjY4LC0xLjk4XSxbJ2MnLDAuMDksLTAuMjEsMC4yNCwtMC4zMCwwLjM5LC0wLjMwXSxbJ2MnLDAuMTIsMC4wMCwwLjI3LDAuMDksMC4zMywwLjE4XSxbJ2MnLDAuMDMsMC4wNiwtMC4yNywxLjExLC0xLjg2LDYuNDJdLFsnYycsLTEuMDIsMy40OCwtMS44OSw2LjM5LC0xLjkyLDYuNDJdLFsnYycsMC4wMCwwLjAzLC0wLjEyLDAuMTIsLTAuMjQsMC4xNV0sWydjJywtMC4xOCwwLjA5LC0wLjIxLDAuMDksLTAuNDUsMC4wOV0sWydjJywtMC4yNCwwLjAwLC0wLjMwLDAuMDAsLTAuNDgsLTAuMDZdLFsnYycsLTAuMDksLTAuMDYsLTAuMjEsLTAuMTIsLTAuMjEsLTAuMTVdLFsnYycsLTAuMDYsLTAuMDMsMC4xNSwtMC41NywxLjY4LC00LjkyXSxbJ2MnLDAuOTYsLTIuNjcsMS43NCwtNC44OSwxLjcxLC00Ljg5XSxbJ2wnLC0wLjUxLDAuMTVdLFsnYycsLTEuMDgsMC4zNiwtMS43NCwwLjQ4LC0yLjU1LDAuNDhdLFsnYycsLTAuNjYsMC4wMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45MF0sWyd6J11dLHc6Ny41MzQsaDoxMy44ODN9LFxuXHRcdCdyZXN0cy4xNnRoJzp7ZDpbWydNJywzLjMzLC02LjEyXSxbJ2MnLDAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MV0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sWydjJywwLjE1LDAuMzksMC41NywwLjU3LDAuODcsMC40Ml0sWydjJywwLjM5LC0wLjE4LDEuMjAsLTEuMjMsMS42MiwtMi4wN10sWydjJywwLjA2LC0wLjE1LDAuMjQsLTAuMjQsMC4zNiwtMC4yNF0sWydjJywwLjEyLDAuMDAsMC4yNywwLjA5LDAuMzMsMC4xOF0sWydjJywwLjAzLDAuMDYsLTAuNDUsMS44NiwtMi42NywxMC4xN10sWydjJywtMS41MCw1LjU1LC0yLjczLDEwLjE0LC0yLjc2LDEwLjE3XSxbJ2MnLC0wLjAzLDAuMDMsLTAuMTIsMC4xMiwtMC4yNCwwLjE1XSxbJ2MnLC0wLjE4LDAuMDksLTAuMjEsMC4wOSwtMC40NSwwLjA5XSxbJ2MnLC0wLjI0LDAuMDAsLTAuMzAsMC4wMCwtMC40OCwtMC4wNl0sWydjJywtMC4wOSwtMC4wNiwtMC4yMSwtMC4xMiwtMC4yMSwtMC4xNV0sWydjJywtMC4wNiwtMC4wMywwLjEyLC0wLjU3LDEuNDQsLTQuOTJdLFsnYycsMC44MSwtMi42NywxLjQ3LC00Ljg2LDEuNDcsLTQuODldLFsnYycsLTAuMDMsMC4wMCwtMC4yNywwLjA2LC0wLjU0LDAuMTVdLFsnYycsLTEuMDgsMC4zNiwtMS43NywwLjQ4LC0yLjU4LDAuNDhdLFsnYycsLTAuNjYsMC4wMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjcyLC0xLjA1LDIuMjIsLTEuMjMsMy4wNiwtMC40Ml0sWydjJywwLjMwLDAuMzMsMC40MiwwLjYwLDAuNjAsMS4zOF0sWydjJywwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45MF0sWydjJywwLjA5LDAuMDksMC4yNywwLjE4LDAuNDUsMC4yMV0sWydjJywwLjEyLDAuMDAsMC4xOCwwLjAwLDAuMzMsLTAuMDldLFsnYycsMC4zMywtMC4xNSwxLjAyLC0wLjkzLDEuNDEsLTEuNTldLFsnYycsMC4xMiwtMC4yMSwwLjE4LC0wLjM5LDAuMzksLTEuMDhdLFsnYycsMC42NiwtMi4xMCwxLjE3LC0zLjg0LDEuMTcsLTMuODddLFsnYycsMC4wMCwwLjAwLC0wLjIxLDAuMDYsLTAuNDIsMC4xNV0sWydjJywtMC41MSwwLjE1LC0xLjIwLDAuMzMsLTEuNjgsMC40Ml0sWydjJywtMC4zMywwLjA2LC0wLjUxLDAuMDYsLTAuOTYsMC4wNl0sWydjJywtMC42NiwwLjAwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3XSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuMzMsLTAuNDUsMC44NCwtMC44MSwxLjM4LC0wLjkwXSxbJ3onXV0sdzo5LjcyNCxoOjIxLjM4M30sXG5cdFx0J3Jlc3RzLjMybmQnOntkOltbJ00nLDQuMjMsLTEzLjYyXSxbJ2MnLDAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MV0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sWydjJywwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNjAsMC40OF0sWydjJywwLjEyLDAuMDAsMC4xOCwwLjAwLDAuMjcsLTAuMDZdLFsnYycsMC4zMywtMC4yMSwwLjk5LC0xLjExLDEuNDQsLTEuOThdLFsnYycsMC4wOSwtMC4yNCwwLjIxLC0wLjMzLDAuMzksLTAuMzNdLFsnYycsMC4xMiwwLjAwLDAuMjcsMC4wOSwwLjMzLDAuMThdLFsnYycsMC4wMywwLjA2LC0wLjU3LDIuNjcsLTMuMjEsMTMuODldLFsnYycsLTEuODAsNy42MiwtMy4zMCwxMy44OSwtMy4zMCwxMy45Ml0sWydjJywtMC4wMywwLjA2LC0wLjEyLDAuMTIsLTAuMjQsMC4xOF0sWydjJywtMC4yMSwwLjA5LC0wLjI0LDAuMDksLTAuNDgsMC4wOV0sWydjJywtMC4yNCwwLjAwLC0wLjMwLDAuMDAsLTAuNDgsLTAuMDZdLFsnYycsLTAuMDksLTAuMDYsLTAuMjEsLTAuMTIsLTAuMjEsLTAuMTVdLFsnYycsLTAuMDYsLTAuMDMsMC4wOSwtMC41NywxLjIzLC00LjkyXSxbJ2MnLDAuNjksLTIuNjcsMS4yNiwtNC44NiwxLjI5LC00Ljg5XSxbJ2MnLDAuMDAsLTAuMDMsLTAuMTIsLTAuMDMsLTAuNDgsMC4xMl0sWydjJywtMS4xNywwLjM5LC0yLjIyLDAuNTcsLTMuMDAsMC41NF0sWydjJywtMC40MiwtMC4wMywtMC43NSwtMC4xMiwtMS4xMSwtMC4zMF0sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjcyLC0xLjA1LDIuMjIsLTEuMjMsMy4wNiwtMC40Ml0sWydjJywwLjMwLDAuMzMsMC40MiwwLjYwLDAuNjAsMS4zOF0sWydjJywwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45MF0sWydjJywwLjEyLDAuMDksMC4zMCwwLjE4LDAuNDgsMC4yMV0sWydjJywwLjEyLDAuMDAsMC4xOCwwLjAwLDAuMzAsLTAuMDldLFsnYycsMC40MiwtMC4yMSwxLjI5LC0xLjI5LDEuNTYsLTEuODldLFsnYycsMC4wMywtMC4xMiwxLjIzLC00LjU5LDEuMjMsLTQuNjVdLFsnYycsMC4wMCwtMC4wMywtMC4xOCwwLjAzLC0wLjM5LDAuMTJdLFsnYycsLTAuNjMsMC4xOCwtMS4yMCwwLjM2LC0xLjc0LDAuNDVdLFsnYycsLTAuMzksMC4wNiwtMC41NCwwLjA2LC0xLjAyLDAuMDZdLFsnYycsLTAuNjYsMC4wMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjcyLC0xLjA1LDIuMjIsLTEuMjMsMy4wNiwtMC40Ml0sWydjJywwLjMwLDAuMzMsMC40MiwwLjYwLDAuNjAsMS4zOF0sWydjJywwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45MF0sWydjJywwLjE4LDAuMTgsMC41MSwwLjI3LDAuNzIsMC4xNV0sWydjJywwLjMwLC0wLjEyLDAuNjksLTAuNTcsMS4wOCwtMS4xN10sWydjJywwLjQyLC0wLjYwLDAuMzksLTAuNTEsMS4wNSwtMy4wM10sWydjJywwLjMzLC0xLjI2LDAuNjAsLTIuMzEsMC42MCwtMi4zNF0sWydjJywwLjAwLDAuMDAsLTAuMjEsMC4wMywtMC40NSwwLjEyXSxbJ2MnLC0wLjU3LDAuMTgsLTEuMTQsMC4zMywtMS42MiwwLjQyXSxbJ2MnLC0wLjMzLDAuMDYsLTAuNTEsMC4wNiwtMC45NiwwLjA2XSxbJ2MnLC0wLjY2LDAuMDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjddLFsnYycsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuMzBdLFsnYycsMC4zMywtMC40NSwwLjg0LC0wLjgxLDEuMzgsLTAuOTBdLFsneiddXSx3OjExLjM3MyxoOjI4Ljg4M30sXG5cdFx0J3Jlc3RzLjY0dGgnOntkOltbJ00nLDUuMTMsLTEzLjYyXSxbJ2MnLDAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MV0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sWydjJywwLjE4LDAuMjEsMC41NCwwLjMwLDAuNzUsMC4xOF0sWydjJywwLjI0LC0wLjEyLDAuNjMsLTAuNjYsMS4wOCwtMS41Nl0sWydjJywwLjMzLC0wLjY2LDAuMzksLTAuNzIsMC42MCwtMC43Ml0sWydjJywwLjEyLDAuMDAsMC4yNywwLjA5LDAuMzMsMC4xOF0sWydjJywwLjAzLDAuMDYsLTAuNjksMy42NiwtMy41NCwxNy42NF0sWydjJywtMS45NSw5LjY2LC0zLjU3LDE3LjYxLC0zLjU3LDE3LjY0XSxbJ2MnLC0wLjAzLDAuMDYsLTAuMTIsMC4xMiwtMC4yNCwwLjE4XSxbJ2MnLC0wLjIxLDAuMDksLTAuMjQsMC4wOSwtMC40OCwwLjA5XSxbJ2MnLC0wLjI0LDAuMDAsLTAuMzAsMC4wMCwtMC40OCwtMC4wNl0sWydjJywtMC4wOSwtMC4wNiwtMC4yMSwtMC4xMiwtMC4yMSwtMC4xNV0sWydjJywtMC4wNiwtMC4wMywwLjA2LC0wLjU3LDEuMDUsLTQuOTVdLFsnYycsMC42MCwtMi43MCwxLjA4LC00Ljg5LDEuMDgsLTQuOTJdLFsnYycsMC4wMCwwLjAwLC0wLjI0LDAuMDYsLTAuNTEsMC4xNV0sWydjJywtMC42NiwwLjI0LC0xLjIwLDAuMzYsLTEuNzcsMC40OF0sWydjJywtMC40MiwwLjA2LC0wLjU3LDAuMDYsLTEuMDUsMC4wNl0sWydjJywtMC42OSwwLjAwLC0wLjg3LC0wLjAzLC0xLjM1LC0wLjI3XSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuNzIsLTEuMDUsMi4yMiwtMS4yMywzLjA2LC0wLjQyXSxbJ2MnLDAuMzAsMC4zMywwLjQyLDAuNjAsMC42MCwxLjM4XSxbJ2MnLDAuMDksMC40NSwwLjIxLDAuNzgsMC4zMywwLjkwXSxbJ2MnLDAuMDksMC4wOSwwLjI3LDAuMTgsMC40NSwwLjIxXSxbJ2MnLDAuMjEsMC4wMywwLjM5LC0wLjA5LDAuNzIsLTAuNDJdLFsnYycsMC40NSwtMC40NSwxLjAyLC0xLjI2LDEuMTcsLTEuNjVdLFsnYycsMC4wMywtMC4wOSwwLjI3LC0xLjE0LDAuNTQsLTIuMzRdLFsnYycsMC4yNywtMS4yMCwwLjQ4LC0yLjE5LDAuNTEsLTIuMjJdLFsnYycsMC4wMCwtMC4wMywtMC4wOSwtMC4wMywtMC40OCwwLjEyXSxbJ2MnLC0xLjE3LDAuMzksLTIuMjIsMC41NywtMy4wMCwwLjU0XSxbJ2MnLC0wLjQyLC0wLjAzLC0wLjc1LC0wLjEyLC0xLjExLC0wLjMwXSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzXSxbJ2MnLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sWydjJywwLjE1LDAuMzksMC41NywwLjU3LDAuOTAsMC40Ml0sWydjJywwLjM2LC0wLjE4LDEuMjAsLTEuMjYsMS40NywtMS44OV0sWydjJywwLjAzLC0wLjA5LDAuMzAsLTEuMjAsMC41NywtMi40M10sWydsJywwLjUxLC0yLjI4XSxbJ2wnLC0wLjU0LDAuMThdLFsnYycsLTEuMTEsMC4zNiwtMS44MCwwLjQ4LC0yLjYxLDAuNDhdLFsnYycsLTAuNjYsMC4wMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjM2LC0wLjU0LDAuOTYsLTAuODcsMS42NSwtMC45M10sWydjJywwLjU0LC0wLjAzLDEuMDIsMC4xNSwxLjQxLDAuNTRdLFsnYycsMC4yNywwLjMwLDAuMzksMC41NCwwLjU3LDEuMjZdLFsnYycsMC4xNSwwLjYzLDAuMjEsMC44MSwwLjMzLDAuOTZdLFsnYycsMC4yMSwwLjIxLDAuNTQsMC4zMCwwLjc1LDAuMThdLFsnYycsMC4zNiwtMC4xOCwwLjkzLC0wLjkzLDEuMjksLTEuNjhdLFsnYycsMC4xMiwtMC4yNCwwLjE4LC0wLjQ4LDAuNjMsLTIuNTVdLFsnbCcsMC41MSwtMi4zMV0sWydjJywwLjAwLC0wLjAzLC0wLjE4LDAuMDMsLTAuMzksMC4xMl0sWydjJywtMS4xNCwwLjM2LC0yLjEwLDAuNTQsLTIuODIsMC41MV0sWydjJywtMC40MiwtMC4wMywtMC43NSwtMC4xMiwtMS4xMSwtMC4zMF0sWydjJywtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zMF0sWydjJywwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45MF0sWyd6J11dLHc6MTIuNDUzLGg6MzYuMzgzfSxcblx0XHQncmVzdHMuMTI4dGgnOntkOltbJ00nLDYuMDMsLTIxLjEyXSxbJ2MnLDAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MV0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sWydjJywwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNjAsMC40OF0sWydjJywwLjIxLDAuMDAsMC4zMywtMC4wNiwwLjU0LC0wLjM2XSxbJ2MnLDAuMTUsLTAuMjEsMC41NCwtMC45MywwLjc4LC0xLjQ3XSxbJ2MnLDAuMTUsLTAuMzMsMC4xOCwtMC4zOSwwLjMwLC0wLjQ4XSxbJ2MnLDAuMTgsLTAuMDksMC40NSwwLjAwLDAuNTEsMC4xNV0sWydjJywwLjAzLDAuMDksLTcuMTEsNDIuNzUsLTcuMTcsNDIuODRdLFsnYycsLTAuMDMsMC4wMywtMC4xNSwwLjA5LC0wLjI0LDAuMTVdLFsnYycsLTAuMTgsMC4wNiwtMC4yNCwwLjA2LC0wLjQ1LDAuMDZdLFsnYycsLTAuMjQsMC4wMCwtMC4zMCwwLjAwLC0wLjQ4LC0wLjA2XSxbJ2MnLC0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1XSxbJ2MnLC0wLjA2LC0wLjAzLDAuMDMsLTAuNTcsMC44NCwtNC45OF0sWydjJywwLjUxLC0yLjcwLDAuOTMsLTQuOTIsMC45MCwtNC45Ml0sWydjJywwLjAwLDAuMDAsLTAuMTUsMC4wNiwtMC4zNiwwLjEyXSxbJ2MnLC0wLjc4LDAuMjcsLTEuNjIsMC40OCwtMi4zMSwwLjU3XSxbJ2MnLC0wLjE1LDAuMDMsLTAuNTQsMC4wMywtMC44MSwwLjAzXSxbJ2MnLC0wLjY2LDAuMDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjddLFsnYycsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuMzBdLFsnYycsMC4zNiwtMC41NCwwLjk2LC0wLjg3LDEuNjUsLTAuOTNdLFsnYycsMC41NCwtMC4wMywxLjAyLDAuMTUsMS40MSwwLjU0XSxbJ2MnLDAuMjcsMC4zMCwwLjM5LDAuNTQsMC41NywxLjI2XSxbJ2MnLDAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyXSxbJ2MnLDAuMTIsMC4yNywwLjMzLDAuNDUsMC42MywwLjQ4XSxbJ2MnLDAuMTIsMC4wMCwwLjE4LDAuMDAsMC4zMCwtMC4wOV0sWydjJywwLjQyLC0wLjIxLDEuMTQsLTEuMTEsMS41MCwtMS44M10sWydjJywwLjEyLC0wLjI3LDAuMTIsLTAuMjcsMC41NCwtMi41Ml0sWydjJywwLjI0LC0xLjIzLDAuNDIsLTIuMjUsMC4zOSwtMi4yNV0sWydjJywwLjAwLDAuMDAsLTAuMjQsMC4wNiwtMC41MSwwLjE4XSxbJ2MnLC0xLjI2LDAuMzksLTIuMjUsMC41NywtMy4wNiwwLjU0XSxbJ2MnLC0wLjQyLC0wLjAzLC0wLjc1LC0wLjEyLC0xLjExLC0wLjMwXSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzXSxbJ2MnLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sWydjJywwLjE4LDAuMjEsMC41MSwwLjMwLDAuNzUsMC4xOF0sWydjJywwLjM2LC0wLjE1LDEuMDUsLTAuOTksMS40MSwtMS43N10sWydsJywwLjE1LC0wLjMwXSxbJ2wnLDAuNDIsLTIuMjVdLFsnYycsMC4yMSwtMS4yNiwwLjQyLC0yLjI4LDAuMzksLTIuMjhdLFsnbCcsLTAuNTEsMC4xNV0sWydjJywtMS4xMSwwLjM5LC0xLjg5LDAuNTEsLTIuNzAsMC41MV0sWydjJywtMC42NiwwLjAwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3XSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzXSxbJ2MnLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sWydjJywwLjE4LDAuMTgsMC40OCwwLjI3LDAuNzIsMC4yMV0sWydjJywwLjMzLC0wLjEyLDEuMTQsLTEuMjYsMS40MSwtMS45NV0sWydjJywwLjAwLC0wLjA5LDAuMjEsLTEuMTEsMC40NSwtMi4zNF0sWydjJywwLjIxLC0xLjIwLDAuMzksLTIuMjIsMC4zOSwtMi4yOF0sWydjJywwLjAzLC0wLjAzLDAuMDAsLTAuMDMsLTAuNDUsMC4xMl0sWydjJywtMC41NywwLjE4LC0xLjIwLDAuMzMsLTEuNzEsMC40Ml0sWydjJywtMC4zMCwwLjA2LC0wLjUxLDAuMDYsLTAuOTMsMC4wNl0sWydjJywtMC42NiwwLjAwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3XSxbJ2MnLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjMwXSxbJ2MnLDAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzXSxbJ2MnLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sWydjJywwLjI3LDAuMzAsMC4zOSwwLjU0LDAuNTcsMS4yNl0sWydjJywwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sWydjJywwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNjAsMC40OF0sWydjJywwLjE4LDAuMDAsMC4zNiwtMC4wOSwwLjU3LC0wLjMzXSxbJ2MnLDAuMzMsLTAuMzYsMC43OCwtMS4xNCwwLjkzLC0xLjU2XSxbJ2MnLDAuMDMsLTAuMTIsMC4yNCwtMS4yMCwwLjQ1LC0yLjQwXSxbJ2MnLDAuMjQsLTEuMjAsMC40MiwtMi4yMiwwLjQyLC0yLjI4XSxbJ2MnLDAuMDMsLTAuMDMsMC4wMCwtMC4wMywtMC4zOSwwLjA5XSxbJ2MnLC0xLjA1LDAuMzYsLTEuODAsMC40OCwtMi41OCwwLjQ4XSxbJ2MnLC0wLjYzLDAuMDAsLTAuODQsLTAuMDMsLTEuMjksLTAuMjddLFsnYycsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuMzBdLFsnYycsMC4zMywtMC40NSwwLjg0LC0wLjgxLDEuMzgsLTAuOTBdLFsneiddXSx3OjEyLjk5MixoOjQzLjg4M30sXG5cdFx0J2FjY2lkZW50YWxzLnNoYXJwJzp7ZDpbWydNJyw1LjczLC0xMS4xOV0sWydjJywwLjIxLC0wLjEyLDAuNTQsLTAuMDMsMC42NiwwLjI0XSxbJ2MnLDAuMDYsMC4xMiwwLjA2LDAuMjEsMC4wNiwyLjMxXSxbJ2MnLDAuMDAsMS4yMywwLjAwLDIuMjIsMC4wMywyLjIyXSxbJ2MnLDAuMDAsMC4wMCwwLjI3LC0wLjEyLDAuNjAsLTAuMjRdLFsnYycsMC42OSwtMC4yNywwLjc4LC0wLjMwLDAuOTYsLTAuMTVdLFsnYycsMC4yMSwwLjE1LDAuMjEsMC4xOCwwLjIxLDEuMzhdLFsnYycsMC4wMCwxLjAyLDAuMDAsMS4xMSwtMC4wNiwxLjIwXSxbJ2MnLC0wLjAzLDAuMDYsLTAuMDksMC4xMiwtMC4xMiwwLjE1XSxbJ2MnLC0wLjA2LDAuMDMsLTAuNDIsMC4yMSwtMC44NCwwLjM2XSxbJ2wnLC0wLjc1LDAuMzNdLFsnbCcsLTAuMDMsMi40M10sWydjJywwLjAwLDEuMzIsMC4wMCwyLjQzLDAuMDMsMi40M10sWydjJywwLjAwLDAuMDAsMC4yNywtMC4xMiwwLjYwLC0wLjI0XSxbJ2MnLDAuNjksLTAuMjcsMC43OCwtMC4zMCwwLjk2LC0wLjE1XSxbJ2MnLDAuMjEsMC4xNSwwLjIxLDAuMTgsMC4yMSwxLjM4XSxbJ2MnLDAuMDAsMS4wMiwwLjAwLDEuMTEsLTAuMDYsMS4yMF0sWydjJywtMC4wMywwLjA2LC0wLjA5LDAuMTIsLTAuMTIsMC4xNV0sWydjJywtMC4wNiwwLjAzLC0wLjQyLDAuMjEsLTAuODQsMC4zNl0sWydsJywtMC43NSwwLjMzXSxbJ2wnLC0wLjAzLDIuNTJdLFsnYycsMC4wMCwyLjI4LC0wLjAzLDIuNTUsLTAuMDYsMi42NF0sWydjJywtMC4yMSwwLjM2LC0wLjcyLDAuMzYsLTAuOTMsMC4wMF0sWydjJywtMC4wMywtMC4wOSwtMC4wNiwtMC4zMywtMC4wNiwtMi40M10sWydsJywwLjAwLC0yLjMxXSxbJ2wnLC0xLjI5LDAuNTFdLFsnbCcsLTEuMjYsMC41MV0sWydsJywwLjAwLDIuNDNdLFsnYycsMC4wMCwyLjU4LDAuMDAsMi41MiwtMC4xNSwyLjY3XSxbJ2MnLC0wLjA2LDAuMDksLTAuMjcsMC4xOCwtMC4zNiwwLjE4XSxbJ2MnLC0wLjEyLDAuMDAsLTAuMzMsLTAuMDksLTAuMzksLTAuMThdLFsnYycsLTAuMTUsLTAuMTUsLTAuMTUsLTAuMDksLTAuMTUsLTIuNDNdLFsnYycsMC4wMCwtMS4yMywwLjAwLC0yLjIyLC0wLjAzLC0yLjIyXSxbJ2MnLDAuMDAsMC4wMCwtMC4yNywwLjEyLC0wLjYwLDAuMjRdLFsnYycsLTAuNjksMC4yNywtMC43OCwwLjMwLC0wLjk2LDAuMTVdLFsnYycsLTAuMjEsLTAuMTUsLTAuMjEsLTAuMTgsLTAuMjEsLTEuMzhdLFsnYycsMC4wMCwtMS4wMiwwLjAwLC0xLjExLDAuMDYsLTEuMjBdLFsnYycsMC4wMywtMC4wNiwwLjA5LC0wLjEyLDAuMTIsLTAuMTVdLFsnYycsMC4wNiwtMC4wMywwLjQyLC0wLjIxLDAuODQsLTAuMzZdLFsnbCcsMC43OCwtMC4zM10sWydsJywwLjAwLC0yLjQzXSxbJ2MnLDAuMDAsLTEuMzIsMC4wMCwtMi40MywtMC4wMywtMi40M10sWydjJywwLjAwLDAuMDAsLTAuMjcsMC4xMiwtMC42MCwwLjI0XSxbJ2MnLC0wLjY5LDAuMjcsLTAuNzgsMC4zMCwtMC45NiwwLjE1XSxbJ2MnLC0wLjIxLC0wLjE1LC0wLjIxLC0wLjE4LC0wLjIxLC0xLjM4XSxbJ2MnLDAuMDAsLTEuMDIsMC4wMCwtMS4xMSwwLjA2LC0xLjIwXSxbJ2MnLDAuMDMsLTAuMDYsMC4wOSwtMC4xMiwwLjEyLC0wLjE1XSxbJ2MnLDAuMDYsLTAuMDMsMC40MiwtMC4yMSwwLjg0LC0wLjM2XSxbJ2wnLDAuNzgsLTAuMzNdLFsnbCcsMC4wMCwtMi41Ml0sWydjJywwLjAwLC0yLjI4LDAuMDMsLTIuNTUsMC4wNiwtMi42NF0sWydjJywwLjIxLC0wLjM2LDAuNzIsLTAuMzYsMC45MywwLjAwXSxbJ2MnLDAuMDMsMC4wOSwwLjA2LDAuMzMsMC4wNiwyLjQzXSxbJ2wnLDAuMDMsMi4zMV0sWydsJywxLjI2LC0wLjUxXSxbJ2wnLDEuMjYsLTAuNTFdLFsnbCcsMC4wMCwtMi40M10sWydjJywwLjAwLC0yLjI4LDAuMDAsLTIuNDMsMC4wNiwtMi41NV0sWydjJywwLjA2LC0wLjEyLDAuMTIsLTAuMTgsMC4yNywtMC4yNF0sWyd6J10sWydtJywtMC4zMywxMC42NV0sWydsJywwLjAwLC0yLjQzXSxbJ2wnLC0xLjI5LDAuNTFdLFsnbCcsLTEuMjYsMC41MV0sWydsJywwLjAwLDIuNDZdLFsnbCcsMC4wMCwyLjQzXSxbJ2wnLDAuMDksLTAuMDNdLFsnYycsMC4wNiwtMC4wMywwLjYzLC0wLjI3LDEuMjksLTAuNTFdLFsnbCcsMS4xNywtMC40OF0sWydsJywwLjAwLC0yLjQ2XSxbJ3onXV0sdzo4LjI1LGg6MjIuNDYyfSxcblx0XHQnYWNjaWRlbnRhbHMuaGFsZnNoYXJwJzp7ZDpbWydNJywyLjQzLC0xMC4wNV0sWydjJywwLjIxLC0wLjEyLDAuNTQsLTAuMDMsMC42NiwwLjI0XSxbJ2MnLDAuMDYsMC4xMiwwLjA2LDAuMjEsMC4wNiwyLjAxXSxbJ2MnLDAuMDAsMS4wNSwwLjAwLDEuODksMC4wMywxLjg5XSxbJ2wnLDAuNzIsLTAuNDhdLFsnYycsMC42OSwtMC40OCwwLjY5LC0wLjUxLDAuODcsLTAuNTFdLFsnYycsMC4xNSwwLjAwLDAuMTgsMC4wMywwLjI3LDAuMDldLFsnYycsMC4yMSwwLjE1LDAuMjEsMC4xOCwwLjIxLDEuNDFdLFsnYycsMC4wMCwxLjExLC0wLjAzLDEuMTQsLTAuMDksMS4yM10sWydjJywtMC4wMywwLjAzLC0wLjQ4LDAuMzksLTEuMDIsMC43NV0sWydsJywtMC45OSwwLjY2XSxbJ2wnLDAuMDAsMi4zN10sWydjJywwLjAwLDEuMzIsMC4wMCwyLjM3LDAuMDMsMi4zN10sWydsJywwLjcyLC0wLjQ4XSxbJ2MnLDAuNjksLTAuNDgsMC42OSwtMC41MSwwLjg3LC0wLjUxXSxbJ2MnLDAuMTUsMC4wMCwwLjE4LDAuMDMsMC4yNywwLjA5XSxbJ2MnLDAuMjEsMC4xNSwwLjIxLDAuMTgsMC4yMSwxLjQxXSxbJ2MnLDAuMDAsMS4xMSwtMC4wMywxLjE0LC0wLjA5LDEuMjNdLFsnYycsLTAuMDMsMC4wMywtMC40OCwwLjM5LC0xLjAyLDAuNzVdLFsnbCcsLTAuOTksMC42Nl0sWydsJywwLjAwLDIuMjVdLFsnYycsMC4wMCwxLjk1LDAuMDAsMi4yOCwtMC4wNiwyLjM3XSxbJ2MnLC0wLjA2LDAuMTIsLTAuMTIsMC4yMSwtMC4yNCwwLjI3XSxbJ2MnLC0wLjI3LDAuMTIsLTAuNTQsMC4wMywtMC42OSwtMC4yNF0sWydjJywtMC4wNiwtMC4xMiwtMC4wNiwtMC4yMSwtMC4wNiwtMi4wMV0sWydjJywwLjAwLC0xLjA1LDAuMDAsLTEuODksLTAuMDMsLTEuODldLFsnbCcsLTAuNzIsMC40OF0sWydjJywtMC42OSwwLjQ4LC0wLjY5LDAuNDgsLTAuODcsMC40OF0sWydjJywtMC4xNSwwLjAwLC0wLjE4LDAuMDAsLTAuMjcsLTAuMDZdLFsnYycsLTAuMjEsLTAuMTUsLTAuMjEsLTAuMTgsLTAuMjEsLTEuNDFdLFsnYycsMC4wMCwtMS4xMSwwLjAzLC0xLjE0LDAuMDksLTEuMjNdLFsnYycsMC4wMywtMC4wMywwLjQ4LC0wLjM5LDEuMDIsLTAuNzVdLFsnbCcsMC45OSwtMC42Nl0sWydsJywwLjAwLC0yLjM3XSxbJ2MnLDAuMDAsLTEuMzIsMC4wMCwtMi4zNywtMC4wMywtMi4zN10sWydsJywtMC43MiwwLjQ4XSxbJ2MnLC0wLjY5LDAuNDgsLTAuNjksMC40OCwtMC44NywwLjQ4XSxbJ2MnLC0wLjE1LDAuMDAsLTAuMTgsMC4wMCwtMC4yNywtMC4wNl0sWydjJywtMC4yMSwtMC4xNSwtMC4yMSwtMC4xOCwtMC4yMSwtMS40MV0sWydjJywwLjAwLC0xLjExLDAuMDMsLTEuMTQsMC4wOSwtMS4yM10sWydjJywwLjAzLC0wLjAzLDAuNDgsLTAuMzksMS4wMiwtMC43NV0sWydsJywwLjk5LC0wLjY2XSxbJ2wnLDAuMDAsLTIuMjVdLFsnYycsMC4wMCwtMi4xMywwLjAwLC0yLjI4LDAuMDYsLTIuNDBdLFsnYycsMC4wNiwtMC4xMiwwLjEyLC0wLjE4LDAuMjcsLTAuMjRdLFsneiddXSx3OjUuMjUsaDoyMC4xNzR9LFxuXHRcdCdhY2NpZGVudGFscy5uYXQnOntkOltbJ00nLDAuMjEsLTExLjQwXSxbJ2MnLDAuMjQsLTAuMDYsMC43OCwwLjAwLDAuOTksMC4xNV0sWydjJywwLjAzLDAuMDMsMC4wMywwLjQ4LDAuMDAsMi42MV0sWydjJywtMC4wMywxLjQ0LC0wLjAzLDIuNjEsLTAuMDMsMi42MV0sWydjJywwLjAwLDAuMDMsMC43NSwtMC4wOSwxLjY4LC0wLjI0XSxbJ2MnLDAuOTYsLTAuMTgsMS43MSwtMC4yNywxLjc0LC0wLjI3XSxbJ2MnLDAuMTUsMC4wMywwLjI3LDAuMTUsMC4zNiwwLjMwXSxbJ2wnLDAuMDYsMC4xMl0sWydsJywwLjA5LDguNjddLFsnYycsMC4wOSw2Ljk2LDAuMTIsOC42NywwLjA5LDguNjddLFsnYycsLTAuMDMsMC4wMywtMC4xMiwwLjA2LC0wLjIxLDAuMDldLFsnYycsLTAuMjQsMC4wOSwtMC43MiwwLjA5LC0wLjk2LDAuMDBdLFsnYycsLTAuMDksLTAuMDMsLTAuMTgsLTAuMDYsLTAuMjEsLTAuMDldLFsnYycsLTAuMDMsLTAuMDMsLTAuMDMsLTAuNDgsMC4wMCwtMi42MV0sWydjJywwLjAzLC0xLjQ0LDAuMDMsLTIuNjEsMC4wMywtMi42MV0sWydjJywwLjAwLC0wLjAzLC0wLjc1LDAuMDksLTEuNjgsMC4yNF0sWydjJywtMC45NiwwLjE4LC0xLjcxLDAuMjcsLTEuNzQsMC4yN10sWydjJywtMC4xNSwtMC4wMywtMC4yNywtMC4xNSwtMC4zNiwtMC4zMF0sWydsJywtMC4wNiwtMC4xNV0sWydsJywtMC4wOSwtNy41M10sWydjJywtMC4wNiwtNC4xNCwtMC4wOSwtOC4wNCwtMC4xMiwtOC42N10sWydsJywwLjAwLC0xLjExXSxbJ2wnLDAuMTUsLTAuMDZdLFsnYycsMC4wOSwtMC4wMywwLjIxLC0wLjA2LDAuMjcsLTAuMDldLFsneiddLFsnbScsMy43NSw4LjQwXSxbJ2MnLDAuMDAsLTAuMzMsMC4wMCwtMC40MiwtMC4wMywtMC40Ml0sWydjJywtMC4xMiwwLjAwLC0yLjc5LDAuNDUsLTIuNzksMC40OF0sWydjJywtMC4wMywwLjAwLC0wLjA5LDYuMzAsLTAuMDksNi4zM10sWydjJywwLjAzLDAuMDAsMi43OSwtMC40NSwyLjgyLC0wLjQ4XSxbJ2MnLDAuMDAsMC4wMCwwLjA5LC00LjUzLDAuMDksLTUuOTFdLFsneiddXSx3OjUuNCxoOjIyLjh9LFxuXHRcdCdhY2NpZGVudGFscy5mbGF0Jzp7ZDpbWydNJywtMC4zNiwtMTQuMDddLFsnYycsMC4zMywtMC4wNiwwLjg3LDAuMDAsMS4wOCwwLjE1XSxbJ2MnLDAuMDYsMC4wMywwLjA2LDAuMzYsLTAuMDMsNS4yNV0sWydjJywtMC4wNiwyLjg1LC0wLjA5LDUuMTksLTAuMDksNS4xOV0sWydjJywwLjAwLDAuMDMsMC4xMiwtMC4wMywwLjI0LC0wLjEyXSxbJ2MnLDAuNjMsLTAuNDIsMS40MSwtMC42NiwyLjE5LC0wLjcyXSxbJ2MnLDAuODEsLTAuMDMsMS40NywwLjIxLDIuMDQsMC43OF0sWydjJywwLjU3LDAuNTQsMC44NywxLjI2LDAuOTMsMi4wNF0sWydjJywwLjAzLDAuNTcsLTAuMDksMS4wOCwtMC4zNiwxLjYyXSxbJ2MnLC0wLjQyLDAuODEsLTEuMDIsMS4zOCwtMi44MiwyLjYxXSxbJ2MnLC0xLjE0LDAuNzgsLTEuNDQsMS4wMiwtMS44MCwxLjQ0XSxbJ2MnLC0wLjE4LDAuMTgsLTAuMzksMC4zOSwtMC40NSwwLjQyXSxbJ2MnLC0wLjI3LDAuMTgsLTAuNTcsMC4xNSwtMC44MSwtMC4wNl0sWydjJywtMC4wNiwtMC4wOSwtMC4xMiwtMC4xOCwtMC4xNSwtMC4yN10sWydjJywtMC4wMywtMC4wNiwtMC4wOSwtMy4yNywtMC4xOCwtOC4zNF0sWydjJywtMC4wOSwtNC41MywtMC4xNSwtOC41OCwtMC4xOCwtOS4wM10sWydsJywwLjAwLC0wLjc4XSxbJ2wnLDAuMTIsLTAuMDZdLFsnYycsMC4wNiwtMC4wMywwLjE4LC0wLjA5LDAuMjcsLTAuMTJdLFsneiddLFsnbScsMy4xOCwxMS4wMV0sWydjJywtMC4yMSwtMC4xMiwtMC41NCwtMC4xNSwtMC44MSwtMC4wNl0sWydjJywtMC41NCwwLjE1LC0wLjk5LDAuNjMsLTEuMTcsMS4yNl0sWydjJywtMC4wNiwwLjMwLC0wLjEyLDIuODgsLTAuMDYsMy44N10sWydjJywwLjAzLDAuNDIsMC4wMywwLjgxLDAuMDYsMC45MF0sWydsJywwLjAzLDAuMTJdLFsnbCcsMC40NSwtMC4zOV0sWydjJywwLjYzLC0wLjU0LDEuMjYsLTEuMTcsMS41NiwtMS41OV0sWydjJywwLjMwLC0wLjQyLDAuNjAsLTAuOTksMC43MiwtMS40MV0sWydjJywwLjE4LC0wLjY5LDAuMDksLTEuNDcsLTAuMTgsLTIuMDddLFsnYycsLTAuMTUsLTAuMzAsLTAuMzMsLTAuNTEsLTAuNjAsLTAuNjNdLFsneiddXSx3OjYuNzUsaDoxOC44MDF9LFxuXHRcdCdhY2NpZGVudGFscy5oYWxmZmxhdCc6e2Q6W1snTScsNC44MywtMTQuMDddLFsnYycsMC4zMywtMC4wNiwwLjg3LDAuMDAsMS4wOCwwLjE1XSxbJ2MnLDAuMDYsMC4wMywwLjA2LDAuNjAsLTAuMTIsOS4wNl0sWydjJywtMC4wOSw1LjU1LC0wLjE1LDkuMDYsLTAuMTgsOS4xMl0sWydjJywtMC4wMywwLjA5LC0wLjA5LDAuMTgsLTAuMTUsMC4yN10sWydjJywtMC4yNCwwLjIxLC0wLjU0LDAuMjQsLTAuODEsMC4wNl0sWydjJywtMC4wNiwtMC4wMywtMC4yNywtMC4yNCwtMC40NSwtMC40Ml0sWydjJywtMC4zNiwtMC40MiwtMC42NiwtMC42NiwtMS44MCwtMS40NF0sWydjJywtMS4yMywtMC44NCwtMS44MywtMS4zMiwtMi4yNSwtMS43N10sWydjJywtMC42NiwtMC43OCwtMC45NiwtMS41NiwtMC45MywtMi40Nl0sWydjJywwLjA5LC0xLjQxLDEuMTEsLTIuNTgsMi40MCwtMi43OV0sWydjJywwLjMwLC0wLjA2LDAuODQsLTAuMDMsMS4yMywwLjA2XSxbJ2MnLDAuNTQsMC4xMiwxLjA4LDAuMzMsMS41MywwLjYzXSxbJ2MnLDAuMTIsMC4wOSwwLjI0LDAuMTUsMC4yNCwwLjEyXSxbJ2MnLDAuMDAsMC4wMCwtMC4xMiwtOC4zNywtMC4xOCwtOS43NV0sWydsJywwLjAwLC0wLjY2XSxbJ2wnLDAuMTIsLTAuMDZdLFsnYycsMC4wNiwtMC4wMywwLjE4LC0wLjA5LDAuMjcsLTAuMTJdLFsneiddLFsnbScsLTEuNjUsMTAuOTVdLFsnYycsLTAuNjAsLTAuMTgsLTEuMDgsMC4wOSwtMS4zOCwwLjY5XSxbJ2MnLC0wLjI3LDAuNjAsLTAuMzYsMS4zOCwtMC4xOCwyLjA3XSxbJ2MnLDAuMTIsMC40MiwwLjQyLDAuOTksMC43MiwxLjQxXSxbJ2MnLDAuMzAsMC40MiwwLjkzLDEuMDUsMS41NiwxLjU5XSxbJ2wnLDAuNDgsMC4zOV0sWydsJywwLjAwLC0wLjEyXSxbJ2MnLDAuMDMsLTAuMDksMC4wMywtMC40OCwwLjA2LC0wLjkwXSxbJ2MnLDAuMDMsLTAuNTcsMC4wMywtMS4wOCwwLjAwLC0yLjIyXSxbJ2MnLC0wLjAzLC0xLjYyLC0wLjAzLC0xLjYyLC0wLjI0LC0yLjA3XSxbJ2MnLC0wLjIxLC0wLjQyLC0wLjYwLC0wLjc1LC0xLjAyLC0wLjg0XSxbJ3onXV0sdzo2LjcyOCxoOjE4LjgwMX0sXG5cdFx0J2FjY2lkZW50YWxzLmRibGZsYXQnOntkOltbJ00nLC0wLjM2LC0xNC4wN10sWydjJywwLjMzLC0wLjA2LDAuODcsMC4wMCwxLjA4LDAuMTVdLFsnYycsMC4wNiwwLjAzLDAuMDYsMC4zMywtMC4wMyw0Ljg5XSxbJ2MnLC0wLjA2LDIuNjcsLTAuMDksNS4wMSwtMC4wOSw1LjIyXSxbJ2wnLDAuMDAsMC4zNl0sWydsJywwLjE1LC0wLjE1XSxbJ2MnLDAuMzYsLTAuMzAsMC43NSwtMC41MSwxLjIwLC0wLjYzXSxbJ2MnLDAuMzMsLTAuMDksMC45NiwtMC4wOSwxLjI2LC0wLjAzXSxbJ2MnLDAuMjcsMC4wOSwwLjYzLDAuMjcsMC44NywwLjQ1XSxbJ2wnLDAuMjEsMC4xNV0sWydsJywwLjAwLC0wLjI3XSxbJ2MnLDAuMDAsLTAuMTUsLTAuMDMsLTIuNDMsLTAuMDksLTUuMTBdLFsnYycsLTAuMDksLTQuNTYsLTAuMDksLTQuODYsLTAuMDMsLTQuODldLFsnYycsMC4xNSwtMC4xMiwwLjM5LC0wLjE1LDAuNzIsLTAuMTVdLFsnYycsMC4zMCwwLjAwLDAuNTQsMC4wMywwLjY5LDAuMTVdLFsnYycsMC4wNiwwLjAzLDAuMDYsMC4zMywtMC4wMyw0Ljk1XSxbJ2MnLC0wLjA2LDIuNzAsLTAuMDksNS4wNCwtMC4wOSw1LjIyXSxbJ2wnLDAuMDMsMC4zMF0sWydsJywwLjIxLC0wLjE1XSxbJ2MnLDAuNjksLTAuNDgsMS40NCwtMC42OSwyLjI4LC0wLjY5XSxbJ2MnLDAuNTEsMC4wMCwwLjc4LDAuMDMsMS4yMCwwLjIxXSxbJ2MnLDEuMzIsMC42MywyLjAxLDIuMjgsMS41MywzLjY5XSxbJ2MnLC0wLjIxLDAuNTcsLTAuNTEsMS4wMiwtMS4wNSwxLjU2XSxbJ2MnLC0wLjQyLDAuNDIsLTAuODEsMC43MiwtMS45MiwxLjUwXSxbJ2MnLC0xLjI2LDAuODcsLTEuNTAsMS4wOCwtMS44NiwxLjUwXSxbJ2MnLC0wLjM5LDAuNDUsLTAuNTQsMC41NCwtMC44MSwwLjUxXSxbJ2MnLC0wLjE4LDAuMDAsLTAuMjEsMC4wMCwtMC4zMywtMC4wNl0sWydsJywtMC4yMSwtMC4yMV0sWydsJywtMC4wNiwtMC4xMl0sWydsJywtMC4wMywtMC45OV0sWydjJywtMC4wMywtMC41NCwtMC4wMywtMS4yOSwtMC4wNiwtMS42OF0sWydsJywwLjAwLC0wLjY5XSxbJ2wnLC0wLjIxLDAuMjRdLFsnYycsLTAuMzYsMC40MiwtMC43NSwwLjc1LC0xLjgwLDEuNjJdLFsnYycsLTEuMDIsMC44NCwtMS4yMCwwLjk5LC0xLjQ0LDEuMzhdLFsnYycsLTAuMzYsMC41MSwtMC41NCwwLjYwLC0wLjkwLDAuNTFdLFsnYycsLTAuMTUsLTAuMDMsLTAuMzksLTAuMjcsLTAuNDIsLTAuNDJdLFsnYycsLTAuMDMsLTAuMDYsLTAuMDksLTMuMjcsLTAuMTgsLTguMzRdLFsnYycsLTAuMDksLTQuNTMsLTAuMTUsLTguNTgsLTAuMTgsLTkuMDNdLFsnbCcsMC4wMCwtMC43OF0sWydsJywwLjEyLC0wLjA2XSxbJ2MnLDAuMDYsLTAuMDMsMC4xOCwtMC4wOSwwLjI3LC0wLjEyXSxbJ3onXSxbJ20nLDIuNTIsMTAuOThdLFsnYycsLTAuMTgsLTAuMDksLTAuNDgsLTAuMTIsLTAuNjYsLTAuMDZdLFsnYycsLTAuMzksMC4xNSwtMC42OSwwLjU0LC0wLjg0LDEuMTRdLFsnYycsLTAuMDYsMC4yNCwtMC4wNiwwLjM5LC0wLjA5LDEuNzRdLFsnYycsLTAuMDMsMS40NCwwLjAwLDIuNzMsMC4wNiwzLjE4XSxbJ2wnLDAuMDMsMC4xNV0sWydsJywwLjI3LC0wLjI3XSxbJ2MnLDAuOTMsLTAuOTYsMS41MCwtMS45NSwxLjc0LC0zLjA2XSxbJ2MnLDAuMDYsLTAuMjcsMC4wNiwtMC4zOSwwLjA2LC0wLjk2XSxbJ2MnLDAuMDAsLTAuNTQsMC4wMCwtMC42OSwtMC4wNiwtMC45M10sWydjJywtMC4wOSwtMC41MSwtMC4yNywtMC44MSwtMC41MSwtMC45M10sWyd6J10sWydtJyw1LjQzLDAuMDBdLFsnYycsLTAuMTgsLTAuMDksLTAuNTEsLTAuMTIsLTAuNzIsLTAuMDZdLFsnYycsLTAuNTQsMC4xMiwtMC45NiwwLjYzLC0xLjE3LDEuMjZdLFsnYycsLTAuMDYsMC4zMCwtMC4xMiwyLjg4LC0wLjA2LDMuOTBdLFsnYycsMC4wMywwLjQyLDAuMDMsMC44MSwwLjA2LDAuOTBdLFsnbCcsMC4wMywwLjEyXSxbJ2wnLDAuMzYsLTAuMzBdLFsnYycsMC40MiwtMC4zNiwxLjAyLC0wLjk2LDEuMjksLTEuMjldLFsnYycsMC4zNiwtMC40NSwwLjY2LC0wLjk5LDAuODEsLTEuNDFdLFsnYycsMC40MiwtMS4yMywwLjE1LC0yLjc2LC0wLjYwLC0zLjEyXSxbJ3onXV0sdzoxMS42MTMsaDoxOC44MDR9LFxuXHRcdCdhY2NpZGVudGFscy5kYmxzaGFycCc6e2Q6W1snTScsLTAuMTgsLTMuOTZdLFsnYycsMC4wNiwtMC4wMywwLjEyLC0wLjA2LDAuMTUsLTAuMDZdLFsnYycsMC4wOSwwLjAwLDIuNzYsMC4yNywyLjc5LDAuMzBdLFsnYycsMC4xMiwwLjAzLDAuMTUsMC4xMiwwLjE1LDAuNTFdLFsnYycsMC4wNiwwLjk2LDAuMjQsMS41OSwwLjU3LDIuMTBdLFsnYycsMC4wNiwwLjA5LDAuMTUsMC4yMSwwLjE4LDAuMjRdLFsnbCcsMC4wOSwwLjA2XSxbJ2wnLDAuMDksLTAuMDZdLFsnYycsMC4wMywtMC4wMywwLjEyLC0wLjE1LDAuMTgsLTAuMjRdLFsnYycsMC4zMywtMC41MSwwLjUxLC0xLjE0LDAuNTcsLTIuMTBdLFsnYycsMC4wMCwtMC4zOSwwLjAzLC0wLjQ1LDAuMTIsLTAuNTFdLFsnYycsMC4wMywwLjAwLDAuNjYsLTAuMDksMS40NCwtMC4xNV0sWydjJywxLjQ3LC0wLjE1LDEuNTAsLTAuMTUsMS41NiwtMC4wM10sWydjJywwLjAzLDAuMDYsMC4wMCwwLjQyLC0wLjA5LDEuNDRdLFsnYycsLTAuMDksMC43MiwtMC4xNSwxLjM1LC0wLjE1LDEuMzhdLFsnYycsMC4wMCwwLjAzLC0wLjAzLDAuMDksLTAuMDYsMC4xMl0sWydjJywtMC4wNiwwLjA2LC0wLjEyLDAuMDksLTAuNTEsMC4wOV0sWydjJywtMS4wOCwwLjA2LC0xLjgwLDAuMzAsLTIuMjgsMC43NV0sWydsJywtMC4xMiwwLjA5XSxbJ2wnLDAuMDksMC4wOV0sWydjJywwLjEyLDAuMTUsMC4zOSwwLjMzLDAuNjMsMC40NV0sWydjJywwLjQyLDAuMTgsMC45NiwwLjI3LDEuNjgsMC4zM10sWydjJywwLjM5LDAuMDAsMC40NSwwLjAzLDAuNTEsMC4wOV0sWydjJywwLjAzLDAuMDMsMC4wNiwwLjA5LDAuMDYsMC4xMl0sWydjJywwLjAwLDAuMDMsMC4wNiwwLjY2LDAuMTUsMS4zOF0sWydjJywwLjA5LDEuMDIsMC4xMiwxLjM4LDAuMDksMS40NF0sWydjJywtMC4wNiwwLjEyLC0wLjA5LDAuMTIsLTEuNTYsLTAuMDNdLFsnYycsLTAuNzgsLTAuMDYsLTEuNDEsLTAuMTUsLTEuNDQsLTAuMTVdLFsnYycsLTAuMDksLTAuMDYsLTAuMTIsLTAuMTIsLTAuMTIsLTAuNTRdLFsnYycsLTAuMDYsLTAuOTMsLTAuMjQsLTEuNTYsLTAuNTcsLTIuMDddLFsnYycsLTAuMDYsLTAuMDksLTAuMTUsLTAuMjEsLTAuMTgsLTAuMjRdLFsnbCcsLTAuMDksLTAuMDZdLFsnbCcsLTAuMDksMC4wNl0sWydjJywtMC4wMywwLjAzLC0wLjEyLDAuMTUsLTAuMTgsMC4yNF0sWydjJywtMC4zMywwLjUxLC0wLjUxLDEuMTQsLTAuNTcsMi4wN10sWydjJywwLjAwLDAuNDIsLTAuMDMsMC40OCwtMC4xMiwwLjU0XSxbJ2MnLC0wLjAzLDAuMDAsLTAuNjYsMC4wOSwtMS40NCwwLjE1XSxbJ2MnLC0xLjQ3LDAuMTUsLTEuNTAsMC4xNSwtMS41NiwwLjAzXSxbJ2MnLC0wLjAzLC0wLjA2LDAuMDAsLTAuNDIsMC4wOSwtMS40NF0sWydjJywwLjA5LC0wLjcyLDAuMTUsLTEuMzUsMC4xNSwtMS4zOF0sWydjJywwLjAwLC0wLjAzLDAuMDMsLTAuMDksMC4wNiwtMC4xMl0sWydjJywwLjA2LC0wLjA2LDAuMTIsLTAuMDksMC41MSwtMC4wOV0sWydjJywwLjcyLC0wLjA2LDEuMjYsLTAuMTUsMS42OCwtMC4zM10sWydjJywwLjI0LC0wLjEyLDAuNTEsLTAuMzAsMC42MywtMC40NV0sWydsJywwLjA5LC0wLjA5XSxbJ2wnLC0wLjEyLC0wLjA5XSxbJ2MnLC0wLjQ4LC0wLjQ1LC0xLjIwLC0wLjY5LC0yLjI4LC0wLjc1XSxbJ2MnLC0wLjM5LDAuMDAsLTAuNDUsLTAuMDMsLTAuNTEsLTAuMDldLFsnYycsLTAuMDMsLTAuMDMsLTAuMDYsLTAuMDksLTAuMDYsLTAuMTJdLFsnYycsMC4wMCwtMC4wMywtMC4wNiwtMC42MywtMC4xMiwtMS4zOF0sWydjJywtMC4wOSwtMC43MiwtMC4xNSwtMS4zNSwtMC4xNSwtMS4zOF0sWyd6J11dLHc6Ny45NSxoOjcuOTc3fSxcblx0XHQnZG90cy5kb3QnOntkOltbJ00nLDEuMzIsLTEuNjhdLFsnYycsMC4wOSwtMC4wMywwLjI3LC0wLjA2LDAuMzksLTAuMDZdLFsnYycsMC45NiwwLjAwLDEuNzQsMC43OCwxLjc0LDEuNzFdLFsnYycsMC4wMCwwLjk2LC0wLjc4LDEuNzQsLTEuNzEsMS43NF0sWydjJywtMC45NiwwLjAwLC0xLjc0LC0wLjc4LC0xLjc0LC0xLjcxXSxbJ2MnLDAuMDAsLTAuNzgsMC41NCwtMS41MCwxLjMyLC0xLjY4XSxbJ3onXV0sdzozLjQ1LGg6My40NX0sXG5cdFx0J25vdGVoZWFkcy5kYmwnOntkOltbJ00nLC0wLjY5LC00LjAyXSxbJ2MnLDAuMTgsLTAuMDksMC4zNiwtMC4wOSwwLjU0LDAuMDBdLFsnYycsMC4xOCwwLjA5LDAuMjQsMC4xNSwwLjMzLDAuMzBdLFsnYycsMC4wNiwwLjE1LDAuMDYsMC4xOCwwLjA2LDEuNDFdLFsnbCcsMC4wMCwxLjIzXSxbJ2wnLDAuMTIsLTAuMThdLFsnYycsMC43MiwtMS4yNiwyLjY0LC0yLjMxLDQuODYsLTIuNjRdLFsnYycsMC44MSwtMC4xNSwxLjExLC0wLjE1LDIuMTMsLTAuMTVdLFsnYycsMC45OSwwLjAwLDEuMjksMC4wMCwyLjEwLDAuMTVdLFsnYycsMC43NSwwLjEyLDEuMzgsMC4yNywyLjA0LDAuNTRdLFsnYycsMS4zNSwwLjUxLDIuMzQsMS4yNiwyLjgyLDIuMTBdLFsnbCcsMC4xMiwwLjE4XSxbJ2wnLDAuMDAsLTEuMjNdLFsnYycsMC4wMCwtMS4yMCwwLjAwLC0xLjI2LDAuMDYsLTEuMzhdLFsnYycsMC4wOSwtMC4xOCwwLjE1LC0wLjI0LDAuMzMsLTAuMzNdLFsnYycsMC4xOCwtMC4wOSwwLjM2LC0wLjA5LDAuNTQsMC4wMF0sWydjJywwLjE4LDAuMDksMC4yNCwwLjE1LDAuMzMsMC4zMF0sWydsJywwLjA2LDAuMTVdLFsnbCcsMC4wMCwzLjU0XSxbJ2wnLDAuMDAsMy41NF0sWydsJywtMC4wNiwwLjE1XSxbJ2MnLC0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zMywwLjMzXSxbJ2MnLC0wLjE4LDAuMDksLTAuMzYsMC4wOSwtMC41NCwwLjAwXSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbJ2MnLC0wLjA2LC0wLjEyLC0wLjA2LC0wLjE4LC0wLjA2LC0xLjM4XSxbJ2wnLDAuMDAsLTEuMjNdLFsnbCcsLTAuMTIsMC4xOF0sWydjJywtMC40OCwwLjg0LC0xLjQ3LDEuNTksLTIuODIsMi4xMF0sWydjJywtMC44NCwwLjMzLC0xLjcxLDAuNTQsLTIuODUsMC42Nl0sWydjJywtMC40NSwwLjA2LC0yLjE2LDAuMDYsLTIuNjEsMC4wMF0sWydjJywtMS4xNCwtMC4xMiwtMi4wMSwtMC4zMywtMi44NSwtMC42Nl0sWydjJywtMS4zNSwtMC41MSwtMi4zNCwtMS4yNiwtMi44MiwtMi4xMF0sWydsJywtMC4xMiwtMC4xOF0sWydsJywwLjAwLDEuMjNdLFsnYycsMC4wMCwxLjIzLDAuMDAsMS4yNiwtMC4wNiwxLjM4XSxbJ2MnLC0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zMywwLjMzXSxbJ2MnLC0wLjE4LDAuMDksLTAuMzYsMC4wOSwtMC41NCwwLjAwXSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbJ2wnLC0wLjA2LC0wLjE1XSxbJ2wnLDAuMDAsLTMuNTRdLFsnYycsMC4wMCwtMy40OCwwLjAwLC0zLjU0LDAuMDYsLTMuNjZdLFsnYycsMC4wOSwtMC4xOCwwLjE1LC0wLjI0LDAuMzMsLTAuMzNdLFsneiddLFsnbScsNy43MSwwLjYzXSxbJ2MnLC0wLjM2LC0wLjA2LC0wLjkwLC0wLjA2LC0xLjE0LDAuMDBdLFsnYycsLTAuMzAsMC4wMywtMC42NiwwLjI0LC0wLjg3LDAuNDJdLFsnYycsLTAuNjAsMC41NCwtMC45MCwxLjYyLC0wLjc1LDIuODJdLFsnYycsMC4xMiwwLjkzLDAuNTEsMS42OCwxLjExLDIuMzFdLFsnYycsMC43NSwwLjcyLDEuODMsMS4yMCwyLjg1LDEuMjZdLFsnYycsMS4wNSwwLjA2LDEuODMsLTAuNTQsMi4xMCwtMS42NV0sWydjJywwLjIxLC0wLjkwLDAuMTIsLTEuOTUsLTAuMjQsLTIuODJdLFsnYycsLTAuMzYsLTAuODEsLTEuMDgsLTEuNTMsLTEuOTUsLTEuOTVdLFsnYycsLTAuMzAsLTAuMTUsLTAuNzgsLTAuMzAsLTEuMTEsLTAuMzldLFsneiddXSx3OjE2LjgzLGg6OC4xNDV9LFxuXHRcdCdub3RlaGVhZHMud2hvbGUnOntkOltbJ00nLDYuNTEsLTQuMDVdLFsnYycsMC41MSwtMC4wMywyLjAxLDAuMDAsMi41MiwwLjAzXSxbJ2MnLDEuNDEsMC4xOCwyLjY0LDAuNTEsMy43MiwxLjA4XSxbJ2MnLDEuMjAsMC42MywxLjk1LDEuNDEsMi4xOSwyLjMxXSxbJ2MnLDAuMDksMC4zMywwLjA5LDAuOTAsMC4wMCwxLjIzXSxbJ2MnLC0wLjI0LDAuOTAsLTAuOTksMS42OCwtMi4xOSwyLjMxXSxbJ2MnLC0xLjA4LDAuNTcsLTIuMjgsMC45MCwtMy43NSwxLjA4XSxbJ2MnLC0wLjY2LDAuMDYsLTIuMzEsMC4wNiwtMi45NywwLjAwXSxbJ2MnLC0xLjQ3LC0wLjE4LC0yLjY3LC0wLjUxLC0zLjc1LC0xLjA4XSxbJ2MnLC0xLjIwLC0wLjYzLC0xLjk1LC0xLjQxLC0yLjE5LC0yLjMxXSxbJ2MnLC0wLjA5LC0wLjMzLC0wLjA5LC0wLjkwLDAuMDAsLTEuMjNdLFsnYycsMC4yNCwtMC45MCwwLjk5LC0xLjY4LDIuMTksLTIuMzFdLFsnYycsMS4yMCwtMC42MywyLjYxLC0wLjk5LDQuMjMsLTEuMTFdLFsneiddLFsnbScsMC41NywwLjY2XSxbJ2MnLC0wLjg3LC0wLjE1LC0xLjUzLDAuMDAsLTIuMDQsMC41MV0sWydjJywtMC4xNSwwLjE1LC0wLjI0LDAuMjcsLTAuMzMsMC40OF0sWydjJywtMC4yNCwwLjUxLC0wLjM2LDEuMDgsLTAuMzMsMS43N10sWydjJywwLjAzLDAuNjksMC4xOCwxLjI2LDAuNDIsMS43N10sWydjJywwLjYwLDEuMTcsMS43NCwxLjk4LDMuMTgsMi4yMl0sWydjJywxLjExLDAuMjEsMS45NSwtMC4xNSwyLjM0LC0wLjk5XSxbJ2MnLDAuMjQsLTAuNTEsMC4zNiwtMS4wOCwwLjMzLC0xLjgwXSxbJ2MnLC0wLjA2LC0xLjExLC0wLjQ1LC0yLjA0LC0xLjE3LC0yLjc2XSxbJ2MnLC0wLjYzLC0wLjYzLC0xLjQ3LC0xLjA1LC0yLjQwLC0xLjIwXSxbJ3onXV0sdzoxNC45ODUsaDo4LjA5N30sXG5cdFx0J25vdGVoZWFkcy5oYWxmJzp7ZDpbWydNJyw3LjQ0LC00LjA1XSxbJ2MnLDAuMDYsLTAuMDMsMC4yNywtMC4wMywwLjQ4LC0wLjAzXSxbJ2MnLDEuMDUsMC4wMCwxLjcxLDAuMjQsMi4xMCwwLjgxXSxbJ2MnLDAuNDIsMC42MCwwLjQ1LDEuMzUsMC4xOCwyLjQwXSxbJ2MnLC0wLjQyLDEuNTksLTEuMTQsMi43MywtMi4xNiwzLjM5XSxbJ2MnLC0xLjQxLDAuOTMsLTMuMTgsMS40NCwtNS40MCwxLjUzXSxbJ2MnLC0xLjE3LDAuMDMsLTEuODksLTAuMjEsLTIuMjgsLTAuODFdLFsnYycsLTAuNDIsLTAuNjAsLTAuNDUsLTEuMzUsLTAuMTgsLTIuNDBdLFsnYycsMC40MiwtMS41OSwxLjE0LC0yLjczLDIuMTYsLTMuMzldLFsnYycsMC42MywtMC40MiwxLjIzLC0wLjcyLDEuOTgsLTAuOTZdLFsnYycsMC45MCwtMC4zMCwxLjY1LC0wLjQyLDMuMTIsLTAuNTRdLFsneiddLFsnbScsMS4yOSwwLjg3XSxbJ2MnLC0wLjI3LC0wLjA5LC0wLjYzLC0wLjEyLC0wLjkwLC0wLjAzXSxbJ2MnLC0wLjcyLDAuMjQsLTEuNTMsMC42OSwtMy4yNywxLjgwXSxbJ2MnLC0yLjM0LDEuNTAsLTMuMzAsMi4yNSwtMy41NywyLjc5XSxbJ2MnLC0wLjM2LDAuNzIsLTAuMDYsMS41MCwwLjY2LDEuNzddLFsnYycsMC4yNCwwLjEyLDAuNjksMC4wOSwwLjk5LDAuMDBdLFsnYycsMC44NCwtMC4zMCwxLjkyLC0wLjkzLDQuMTQsLTIuMzddLFsnYycsMS42MiwtMS4wOCwyLjM3LC0xLjcxLDIuNjEsLTIuMTldLFsnYycsMC4zNiwtMC43MiwwLjA2LC0xLjUwLC0wLjY2LC0xLjc3XSxbJ3onXV0sdzoxMC4zNyxoOjguMTMyfSxcblx0XHQnbm90ZWhlYWRzLnF1YXJ0ZXInOntkOltbJ00nLDYuMDksLTQuMDVdLFsnYycsMC4zNiwtMC4wMywxLjIwLDAuMDAsMS41MywwLjA2XSxbJ2MnLDEuMTcsMC4yNCwxLjg5LDAuODQsMi4xNiwxLjgzXSxbJ2MnLDAuMDYsMC4xOCwwLjA2LDAuMzAsMC4wNiwwLjY2XSxbJ2MnLDAuMDAsMC40NSwwLjAwLDAuNjMsLTAuMTUsMS4wOF0sWydjJywtMC42NiwyLjA0LC0zLjA2LDMuOTMsLTUuNTIsNC4zOF0sWydjJywtMC41NCwwLjA5LC0xLjQ0LDAuMDksLTEuODMsMC4wM10sWydjJywtMS4yMywtMC4yNywtMS45OCwtMC44NywtMi4yNSwtMS44Nl0sWydjJywtMC4wNiwtMC4xOCwtMC4wNiwtMC4zMCwtMC4wNiwtMC42Nl0sWydjJywwLjAwLC0wLjQ1LDAuMDAsLTAuNjMsMC4xNSwtMS4wOF0sWydjJywwLjI0LC0wLjc4LDAuNzUsLTEuNTMsMS40NCwtMi4yMl0sWydjJywxLjIwLC0xLjIwLDIuODUsLTIuMDEsNC40NywtMi4yMl0sWyd6J11dLHc6OS44MSxoOjguMDk0fSxcblx0XHQnbm90ZWhlYWRzLnNsYXNoLm5vc3RlbSc6e2Q6W1snTScsOS4zMCwtNy43N10sWydjJywwLjA2LC0wLjA2LDAuMTgsLTAuMDYsMS43MSwtMC4wNl0sWydsJywxLjY1LDAuMDBdLFsnbCcsMC4wOSwwLjA5XSxbJ2MnLDAuMDYsMC4wNiwwLjA2LDAuMDksMC4wNiwwLjE1XSxbJ2MnLC0wLjAzLDAuMTIsLTkuMjEsMTUuMjQsLTkuMzAsMTUuMzNdLFsnYycsLTAuMDYsMC4wNiwtMC4xOCwwLjA2LC0xLjcxLDAuMDZdLFsnbCcsLTEuNjUsMC4wMF0sWydsJywtMC4wOSwtMC4wOV0sWydjJywtMC4wNiwtMC4wNiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4xNV0sWydjJywwLjAzLC0wLjEyLDkuMjEsLTE1LjI0LDkuMzAsLTE1LjMzXSxbJ3onXV0sdzoxMi44MSxoOjE1LjYzfSxcblx0XHQnbm90ZWhlYWRzLmluZGV0ZXJtaW5hdGUnOntkOltbJ00nLDAuNzgsLTQuMDVdLFsnYycsMC4xMiwtMC4wMywwLjI0LC0wLjAzLDAuMzYsMC4wM10sWydjJywwLjAzLDAuMDMsMC45MywwLjcyLDEuOTUsMS41Nl0sWydsJywxLjg2LDEuNTBdLFsnbCcsMS44NiwtMS41MF0sWydjJywxLjAyLC0wLjg0LDEuOTIsLTEuNTMsMS45NSwtMS41Nl0sWydjJywwLjIxLC0wLjEyLDAuMzMsLTAuMDksMC43NSwwLjI0XSxbJ2MnLDAuMzAsMC4yNywwLjM2LDAuMzYsMC4zNiwwLjU0XSxbJ2MnLDAuMDAsMC4wMywtMC4wMywwLjEyLC0wLjA2LDAuMThdLFsnYycsLTAuMDMsMC4wNiwtMC45MCwwLjc1LC0xLjg5LDEuNTZdLFsnbCcsLTEuODAsMS40N10sWydjJywwLjAwLDAuMDMsMC44MSwwLjY5LDEuODAsMS41MF0sWydjJywwLjk5LDAuODEsMS44NiwxLjUwLDEuODksMS41Nl0sWydjJywwLjAzLDAuMDYsMC4wNiwwLjE1LDAuMDYsMC4xOF0sWydjJywwLjAwLDAuMTgsLTAuMDYsMC4yNywtMC4zNiwwLjU0XSxbJ2MnLC0wLjQyLDAuMzMsLTAuNTQsMC4zNiwtMC43NSwwLjI0XSxbJ2MnLC0wLjAzLC0wLjAzLC0wLjkzLC0wLjcyLC0xLjk1LC0xLjU2XSxbJ2wnLC0xLjg2LC0xLjUwXSxbJ2wnLC0xLjg2LDEuNTBdLFsnYycsLTEuMDIsMC44NCwtMS45MiwxLjUzLC0xLjk1LDEuNTZdLFsnYycsLTAuMjEsMC4xMiwtMC4zMywwLjA5LC0wLjc1LC0wLjI0XSxbJ2MnLC0wLjMwLC0wLjI3LC0wLjM2LC0wLjM2LC0wLjM2LC0wLjU0XSxbJ2MnLDAuMDAsLTAuMDMsMC4wMywtMC4xMiwwLjA2LC0wLjE4XSxbJ2MnLDAuMDMsLTAuMDYsMC45MCwtMC43NSwxLjg5LC0xLjU2XSxbJ2wnLDEuODAsLTEuNDddLFsnYycsMC4wMCwtMC4wMywtMC44MSwtMC42OSwtMS44MCwtMS41MF0sWydjJywtMC45OSwtMC44MSwtMS44NiwtMS41MCwtMS44OSwtMS41Nl0sWydjJywtMC4wNiwtMC4xMiwtMC4wOSwtMC4yMSwtMC4wMywtMC4zNl0sWydjJywwLjAzLC0wLjA5LDAuNTcsLTAuNTcsMC43MiwtMC42M10sWyd6J11dLHc6OS44NDMsaDo4LjEzOX0sXG5cdFx0J3NjcmlwdHMudWZlcm1hdGEnOntkOltbJ00nLC0wLjc1LC0xMC43N10sWydjJywwLjEyLDAuMDAsMC40NSwtMC4wMywwLjY5LC0wLjAzXSxbJ2MnLDIuOTEsLTAuMDMsNS41NSwxLjUzLDcuNDEsNC4zNV0sWydjJywxLjE3LDEuNzEsMS45NSwzLjcyLDIuNDMsNi4wM10sWydjJywwLjEyLDAuNTEsMC4xMiwwLjU3LDAuMDMsMC42OV0sWydjJywtMC4xMiwwLjIxLC0wLjQ4LDAuMjcsLTAuNjksMC4xMl0sWydjJywtMC4xMiwtMC4wOSwtMC4xOCwtMC4yNCwtMC4yNywtMC42OV0sWydjJywtMC43OCwtMy42MywtMy40MiwtNi41NCwtNi43OCwtNy4zOF0sWydjJywtMC43OCwtMC4yMSwtMS4yMCwtMC4yNCwtMi4wNywtMC4yNF0sWydjJywtMC42MywwLjAwLC0wLjg0LDAuMDAsLTEuMjAsMC4wNl0sWydjJywtMS44MywwLjI3LC0zLjQyLDEuMDgsLTQuODAsMi4zN10sWydjJywtMS40MSwxLjM1LC0yLjQwLDMuMjEsLTIuODUsNS4xOV0sWydjJywtMC4wOSwwLjQ1LC0wLjE1LDAuNjAsLTAuMjcsMC42OV0sWydjJywtMC4yMSwwLjE1LC0wLjU3LDAuMDksLTAuNjksLTAuMTJdLFsnYycsLTAuMDksLTAuMTIsLTAuMDksLTAuMTgsMC4wMywtMC42OV0sWydjJywwLjMzLC0xLjYyLDAuNzgsLTMuMDAsMS40NywtNC4zOF0sWydjJywxLjc3LC0zLjU0LDQuNDQsLTUuNjcsNy41NiwtNS45N10sWyd6J10sWydtJywwLjMzLDcuNDddLFsnYycsMS4zOCwtMC4zMCwyLjU4LDAuOTAsMi4zMSwyLjI1XSxbJ2MnLC0wLjE1LDAuNzIsLTAuNzgsMS4zNSwtMS40NywxLjUwXSxbJ2MnLC0xLjM4LDAuMjcsLTIuNTgsLTAuOTMsLTIuMzEsLTIuMzFdLFsnYycsMC4xNSwtMC42OSwwLjc4LC0xLjI5LDEuNDcsLTEuNDRdLFsneiddXSx3OjE5Ljc0OCxoOjExLjI4OX0sXG5cdFx0J3NjcmlwdHMuZGZlcm1hdGEnOntkOltbJ00nLC05LjYzLC0wLjQyXSxbJ2MnLDAuMTUsLTAuMDksMC4zNiwtMC4wNiwwLjUxLDAuMDNdLFsnYycsMC4xMiwwLjA5LDAuMTgsMC4yNCwwLjI3LDAuNjZdLFsnYycsMC43OCwzLjY2LDMuNDIsNi41Nyw2Ljc4LDcuNDFdLFsnYycsMC43OCwwLjIxLDEuMjAsMC4yNCwyLjA3LDAuMjRdLFsnYycsMC42MywwLjAwLDAuODQsMC4wMCwxLjIwLC0wLjA2XSxbJ2MnLDEuODMsLTAuMjcsMy40MiwtMS4wOCw0LjgwLC0yLjM3XSxbJ2MnLDEuNDEsLTEuMzUsMi40MCwtMy4yMSwyLjg1LC01LjIyXSxbJ2MnLDAuMDksLTAuNDIsMC4xNSwtMC41NywwLjI3LC0wLjY2XSxbJ2MnLDAuMjEsLTAuMTUsMC41NywtMC4wOSwwLjY5LDAuMTJdLFsnYycsMC4wOSwwLjEyLDAuMDksMC4xOCwtMC4wMywwLjY5XSxbJ2MnLC0wLjMzLDEuNjIsLTAuNzgsMy4wMCwtMS40Nyw0LjM4XSxbJ2MnLC0xLjkyLDMuODQsLTQuODksNi4wMCwtOC4zMSw2LjAwXSxbJ2MnLC0zLjQyLDAuMDAsLTYuMzksLTIuMTYsLTguMzEsLTYuMDBdLFsnYycsLTAuNDgsLTAuOTYsLTAuODQsLTEuOTIsLTEuMTQsLTIuOTddLFsnYycsLTAuMTgsLTAuNjksLTAuNDIsLTEuNzQsLTAuNDIsLTEuOTJdLFsnYycsMC4wMCwtMC4xMiwwLjA5LC0wLjI3LDAuMjQsLTAuMzNdLFsneiddLFsnbScsOS4yMSwwLjAwXSxbJ2MnLDEuMjAsLTAuMjcsMi4zNCwwLjYzLDIuMzQsMS44Nl0sWydjJywwLjAwLDAuOTAsLTAuNjYsMS42OCwtMS41MCwxLjg5XSxbJ2MnLC0xLjM4LDAuMjcsLTIuNTgsLTAuOTMsLTIuMzEsLTIuMzFdLFsnYycsMC4xNSwtMC42OSwwLjc4LC0xLjI5LDEuNDcsLTEuNDRdLFsneiddXSx3OjE5Ljc0NCxoOjExLjI3NH0sXG5cdFx0J3NjcmlwdHMuc2ZvcnphdG8nOntkOltbJ00nLC02LjQ1LC0zLjY5XSxbJ2MnLDAuMDYsLTAuMDMsMC4xNSwtMC4wNiwwLjE4LC0wLjA2XSxbJ2MnLDAuMDYsMC4wMCwyLjg1LDAuNzIsNi4yNCwxLjU5XSxbJ2wnLDYuMzMsMS42NV0sWydjJywwLjMzLDAuMDYsMC40NSwwLjIxLDAuNDUsMC41MV0sWydjJywwLjAwLDAuMzAsLTAuMTIsMC40NSwtMC40NSwwLjUxXSxbJ2wnLC02LjMzLDEuNjVdLFsnYycsLTMuMzksMC44NywtNi4xOCwxLjU5LC02LjIxLDEuNTldLFsnYycsLTAuMjEsMC4wMCwtMC40OCwtMC4yNCwtMC41MSwtMC40NV0sWydjJywwLjAwLC0wLjE1LDAuMDYsLTAuMzYsMC4xOCwtMC40NV0sWydjJywwLjA5LC0wLjA2LDAuODcsLTAuMjcsMy44NCwtMS4wNV0sWydjJywyLjA0LC0wLjU0LDMuODQsLTAuOTksNC4wMiwtMS4wMl0sWydjJywwLjE1LC0wLjA2LDEuMTQsLTAuMjQsMi4yMiwtMC40Ml0sWydjJywxLjA1LC0wLjE4LDEuOTIsLTAuMzYsMS45MiwtMC4zNl0sWydjJywwLjAwLDAuMDAsLTAuODcsLTAuMTgsLTEuOTIsLTAuMzZdLFsnYycsLTEuMDgsLTAuMTgsLTIuMDcsLTAuMzYsLTIuMjIsLTAuNDJdLFsnYycsLTAuMTgsLTAuMDMsLTEuOTgsLTAuNDgsLTQuMDIsLTEuMDJdLFsnYycsLTIuOTcsLTAuNzgsLTMuNzUsLTAuOTksLTMuODQsLTEuMDVdLFsnYycsLTAuMTIsLTAuMDksLTAuMTgsLTAuMzAsLTAuMTgsLTAuNDVdLFsnYycsMC4wMywtMC4xNSwwLjE1LC0wLjMwLDAuMzAsLTAuMzldLFsneiddXSx3OjEzLjUsaDo3LjV9LFxuXHRcdCdzY3JpcHRzLnN0YWNjYXRvJzp7ZDpbWydNJywtMC4zNiwtMS40N10sWydjJywwLjkzLC0wLjIxLDEuODYsMC41MSwxLjg2LDEuNDddLFsnYycsMC4wMCwwLjkzLC0wLjg3LDEuNjUsLTEuODAsMS40N10sWydjJywtMC41NCwtMC4xMiwtMS4wMiwtMC41NywtMS4xNCwtMS4wOF0sWydjJywtMC4yMSwtMC44MSwwLjI3LC0xLjY1LDEuMDgsLTEuODZdLFsneiddXSx3OjIuOTg5LGg6My4wMDR9LFxuXHRcdCdzY3JpcHRzLnRlbnV0byc6e2Q6W1snTScsLTQuMjAsLTAuNDhdLFsnbCcsMC4xMiwtMC4wNl0sWydsJyw0LjA4LDAuMDBdLFsnbCcsNC4wOCwwLjAwXSxbJ2wnLDAuMTIsMC4wNl0sWydjJywwLjM5LDAuMjEsMC4zOSwwLjc1LDAuMDAsMC45Nl0sWydsJywtMC4xMiwwLjA2XSxbJ2wnLC00LjA4LDAuMDBdLFsnbCcsLTQuMDgsMC4wMF0sWydsJywtMC4xMiwtMC4wNl0sWydjJywtMC4zOSwtMC4yMSwtMC4zOSwtMC43NSwwLjAwLC0wLjk2XSxbJ3onXV0sdzo4Ljk4NSxoOjEuMDh9LFxuXHRcdCdzY3JpcHRzLnVtYXJjYXRvJzp7ZDpbWydNJywtMC4xNSwtOC4xOV0sWydjJywwLjE1LC0wLjEyLDAuMzYsLTAuMDMsMC40NSwwLjE1XSxbJ2MnLDAuMjEsMC40MiwzLjQ1LDcuNjUsMy40NSw3LjcxXSxbJ2MnLDAuMDAsMC4xMiwtMC4xMiwwLjI3LC0wLjIxLDAuMzBdLFsnYycsLTAuMDMsMC4wMywtMC41MSwwLjAzLC0xLjE0LDAuMDNdLFsnYycsLTEuMDUsMC4wMCwtMS4wOCwwLjAwLC0xLjE3LC0wLjA2XSxbJ2MnLC0wLjA5LC0wLjA2LC0wLjI0LC0wLjM2LC0xLjE3LC0yLjQwXSxbJ2MnLC0wLjU3LC0xLjI5LC0xLjA1LC0yLjM0LC0xLjA4LC0yLjM0XSxbJ2MnLDAuMDAsLTAuMDMsLTAuNTEsMS4wMiwtMS4wOCwyLjM0XSxbJ2MnLC0wLjkzLDIuMDcsLTEuMDgsMi4zNCwtMS4xNCwyLjQwXSxbJ2MnLC0wLjA2LDAuMDMsLTAuMTUsMC4wNiwtMC4xOCwwLjA2XSxbJ2MnLC0wLjE1LDAuMDAsLTAuMzMsLTAuMTgsLTAuMzMsLTAuMzNdLFsnYycsMC4wMCwtMC4wNiwzLjI0LC03LjMyLDMuNDUsLTcuNzFdLFsnYycsMC4wMywtMC4wNiwwLjA5LC0wLjE1LDAuMTUsLTAuMTVdLFsneiddXSx3OjcuNSxoOjguMjQ1fSxcblx0XHQnc2NyaXB0cy5kbWFyY2F0byc6e2Q6W1snTScsLTMuNTcsMC4wM10sWydjJywwLjAzLDAuMDAsMC41NywtMC4wMywxLjE3LC0wLjAzXSxbJ2MnLDEuMDUsMC4wMCwxLjA4LDAuMDAsMS4xNywwLjA2XSxbJ2MnLDAuMDksMC4wNiwwLjI0LDAuMzYsMS4xNywyLjQwXSxbJ2MnLDAuNTcsMS4yOSwxLjA1LDIuMzQsMS4wOCwyLjM0XSxbJ2MnLDAuMDAsMC4wMywwLjUxLC0xLjAyLDEuMDgsLTIuMzRdLFsnYycsMC45MywtMi4wNywxLjA4LC0yLjM0LDEuMTQsLTIuNDBdLFsnYycsMC4wNiwtMC4wMywwLjE1LC0wLjA2LDAuMTgsLTAuMDZdLFsnYycsMC4xNSwwLjAwLDAuMzMsMC4xOCwwLjMzLDAuMzNdLFsnYycsMC4wMCwwLjA5LC0zLjQ1LDcuNzQsLTMuNTQsNy44M10sWydjJywtMC4xMiwwLjEyLC0wLjMwLDAuMTIsLTAuNDIsMC4wMF0sWydjJywtMC4wOSwtMC4wOSwtMy41NCwtNy43NCwtMy41NCwtNy44M10sWydjJywwLjAwLC0wLjA5LDAuMTIsLTAuMjcsMC4xOCwtMC4zMF0sWyd6J11dLHc6Ny41LGg6OC4yNX0sXG5cdFx0J3NjcmlwdHMuc3RvcHBlZCc6e2Q6W1snTScsLTAuMjcsLTQuMDhdLFsnYycsMC4xOCwtMC4wOSwwLjM2LC0wLjA5LDAuNTQsMC4wMF0sWydjJywwLjE4LDAuMDksMC4yNCwwLjE1LDAuMzMsMC4zMF0sWydsJywwLjA2LDAuMTVdLFsnbCcsMC4wMCwxLjUwXSxbJ2wnLDAuMDAsMS40N10sWydsJywxLjQ3LDAuMDBdLFsnbCcsMS41MCwwLjAwXSxbJ2wnLDAuMTUsMC4wNl0sWydjJywwLjE1LDAuMDksMC4yMSwwLjE1LDAuMzAsMC4zM10sWydjJywwLjA5LDAuMTgsMC4wOSwwLjM2LDAuMDAsMC41NF0sWydjJywtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM10sWydjJywtMC4xMiwwLjA2LC0wLjE4LDAuMDYsLTEuNjIsMC4wNl0sWydsJywtMS40NywwLjAwXSxbJ2wnLDAuMDAsMS40N10sWydsJywwLjAwLDEuNDddLFsnbCcsLTAuMDYsMC4xNV0sWydjJywtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM10sWydjJywtMC4xOCwwLjA5LC0wLjM2LDAuMDksLTAuNTQsMC4wMF0sWydjJywtMC4xOCwtMC4wOSwtMC4yNCwtMC4xNSwtMC4zMywtMC4zM10sWydsJywtMC4wNiwtMC4xNV0sWydsJywwLjAwLC0xLjQ3XSxbJ2wnLDAuMDAsLTEuNDddLFsnbCcsLTEuNDcsMC4wMF0sWydjJywtMS40NCwwLjAwLC0xLjUwLDAuMDAsLTEuNjIsLTAuMDZdLFsnYycsLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNdLFsnYycsLTAuMDksLTAuMTgsLTAuMDksLTAuMzYsMC4wMCwtMC41NF0sWydjJywwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sWydsJywwLjE1LC0wLjA2XSxbJ2wnLDEuNDcsMC4wMF0sWydsJywxLjQ3LDAuMDBdLFsnbCcsMC4wMCwtMS40N10sWydjJywwLjAwLC0xLjQ0LDAuMDAsLTEuNTAsMC4wNiwtMS42Ml0sWydjJywwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sWyd6J11dLHc6OC4yOTUsaDo4LjI5NX0sXG5cdFx0J3NjcmlwdHMudXBib3cnOntkOltbJ00nLC00LjY1LC0xNS41NF0sWydjJywwLjEyLC0wLjA5LDAuMzYsLTAuMDYsMC40OCwwLjAzXSxbJ2MnLDAuMDMsMC4wMywwLjA5LDAuMDksMC4xMiwwLjE1XSxbJ2MnLDAuMDMsMC4wNiwwLjY2LDIuMTMsMS40MSw0LjYyXSxbJ2MnLDEuMzUsNC40MSwxLjM4LDQuNTYsMi4wMSw2Ljk2XSxbJ2wnLDAuNjMsMi40Nl0sWydsJywwLjYzLC0yLjQ2XSxbJ2MnLDAuNjMsLTIuNDAsMC42NiwtMi41NSwyLjAxLC02Ljk2XSxbJ2MnLDAuNzUsLTIuNDksMS4zOCwtNC41NiwxLjQxLC00LjYyXSxbJ2MnLDAuMDYsLTAuMTUsMC4xOCwtMC4yMSwwLjM2LC0wLjI0XSxbJ2MnLDAuMTUsMC4wMCwwLjMwLDAuMDYsMC4zOSwwLjE4XSxbJ2MnLDAuMTUsMC4yMSwwLjI0LC0wLjE4LC0yLjEwLDcuNTZdLFsnYycsLTEuMjAsMy45NiwtMi4yMiw3LjMyLC0yLjI1LDcuNDFdLFsnYycsMC4wMCwwLjEyLC0wLjA2LDAuMjcsLTAuMDksMC4zMF0sWydjJywtMC4xMiwwLjIxLC0wLjYwLDAuMjEsLTAuNzIsMC4wMF0sWydjJywtMC4wMywtMC4wMywtMC4wOSwtMC4xOCwtMC4wOSwtMC4zMF0sWydjJywtMC4wMywtMC4wOSwtMS4wNSwtMy40NSwtMi4yNSwtNy40MV0sWydjJywtMi4zNCwtNy43NCwtMi4yNSwtNy4zNSwtMi4xMCwtNy41Nl0sWydjJywwLjAzLC0wLjAzLDAuMDksLTAuMDksMC4xNSwtMC4xMl0sWyd6J11dLHc6OS43MyxoOjE1LjYwOH0sXG5cdFx0J3NjcmlwdHMuZG93bmJvdyc6e2Q6W1snTScsLTUuNTUsLTkuOTNdLFsnbCcsMC4wOSwtMC4wNl0sWydsJyw1LjQ2LDAuMDBdLFsnbCcsNS40NiwwLjAwXSxbJ2wnLDAuMDksMC4wNl0sWydsJywwLjA2LDAuMDldLFsnbCcsMC4wMCw0Ljc3XSxbJ2MnLDAuMDAsNS4yOCwwLjAwLDQuODksLTAuMTgsNS4wMV0sWydjJywtMC4xOCwwLjEyLC0wLjQyLDAuMDYsLTAuNTQsLTAuMTJdLFsnYycsLTAuMDYsLTAuMDksLTAuMDYsLTAuMTgsLTAuMDYsLTIuOTddLFsnbCcsMC4wMCwtMi44NV0sWydsJywtNC44MywwLjAwXSxbJ2wnLC00LjgzLDAuMDBdLFsnbCcsMC4wMCwyLjg1XSxbJ2MnLDAuMDAsMi43OSwwLjAwLDIuODgsLTAuMDYsMi45N10sWydjJywtMC4xNSwwLjI0LC0wLjUxLDAuMjQsLTAuNjYsMC4wMF0sWydjJywtMC4wNiwtMC4wOSwtMC4wNiwtMC4yMSwtMC4wNiwtNC44OV0sWydsJywwLjAwLC00Ljc3XSxbJ3onXV0sdzoxMS4yMixoOjkuOTkyfSxcblx0XHQnc2NyaXB0cy50dXJuJzp7ZDpbWydNJywtNC43NywtMy45MF0sWydjJywwLjM2LC0wLjA2LDEuMDUsLTAuMDYsMS40NCwwLjAzXSxbJ2MnLDAuNzgsMC4xNSwxLjUwLDAuNTEsMi4zNCwxLjE0XSxbJ2MnLDAuNjAsMC40NSwxLjA1LDAuODcsMi4yMiwyLjAxXSxbJ2MnLDEuMTEsMS4wOCwxLjYyLDEuNTAsMi4yMiwxLjg2XSxbJ2MnLDAuNjAsMC4zNiwxLjMyLDAuNTcsMS45MiwwLjU3XSxbJ2MnLDAuOTAsMC4wMCwxLjcxLC0wLjU3LDEuODksLTEuMzVdLFsnYycsMC4yNCwtMC45MywtMC4zOSwtMS44OSwtMS4zNSwtMi4xMF0sWydsJywtMC4xNSwtMC4wNl0sWydsJywtMC4wOSwwLjE1XSxbJ2MnLC0wLjAzLDAuMDksLTAuMTUsMC4yNCwtMC4yNCwwLjMzXSxbJ2MnLC0wLjcyLDAuNzIsLTIuMDQsMC41NCwtMi40OSwtMC4zNl0sWydjJywtMC40OCwtMC45MywwLjAzLC0xLjg2LDEuMTcsLTIuMTldLFsnYycsMC4zMCwtMC4wOSwxLjAyLC0wLjA5LDEuMzUsMC4wMF0sWydjJywwLjk5LDAuMjcsMS43NCwwLjg3LDIuMjUsMS44M10sWydjJywwLjY5LDEuNDEsMC42MywzLjAwLC0wLjIxLDQuMjZdLFsnYycsLTAuMjEsMC4zMCwtMC42OSwwLjgxLC0wLjk5LDEuMDJdLFsnYycsLTAuMzAsMC4yMSwtMC44NCwwLjQ1LC0xLjE3LDAuNTRdLFsnYycsLTEuMjMsMC4zNiwtMi40OSwwLjE1LC0zLjcyLC0wLjYwXSxbJ2MnLC0wLjc1LC0wLjQ4LC0xLjQxLC0xLjAyLC0yLjg1LC0yLjQ2XSxbJ2MnLC0xLjExLC0xLjA4LC0xLjYyLC0xLjUwLC0yLjIyLC0xLjg2XSxbJ2MnLC0wLjYwLC0wLjM2LC0xLjMyLC0wLjU3LC0xLjkyLC0wLjU3XSxbJ2MnLC0wLjkwLDAuMDAsLTEuNzEsMC41NywtMS44OSwxLjM1XSxbJ2MnLC0wLjI0LDAuOTMsMC4zOSwxLjg5LDEuMzUsMi4xMF0sWydsJywwLjE1LDAuMDZdLFsnbCcsMC4wOSwtMC4xNV0sWydjJywwLjAzLC0wLjA5LDAuMTUsLTAuMjQsMC4yNCwtMC4zM10sWydjJywwLjcyLC0wLjcyLDIuMDQsLTAuNTQsMi40OSwwLjM2XSxbJ2MnLDAuNDgsMC45MywtMC4wMywxLjg2LC0xLjE3LDIuMTldLFsnYycsLTAuMzAsMC4wOSwtMS4wMiwwLjA5LC0xLjM1LDAuMDBdLFsnYycsLTAuOTksLTAuMjcsLTEuNzQsLTAuODcsLTIuMjUsLTEuODNdLFsnYycsLTAuNjksLTEuNDEsLTAuNjMsLTMuMDAsMC4yMSwtNC4yNl0sWydjJywwLjIxLC0wLjMwLDAuNjksLTAuODEsMC45OSwtMS4wMl0sWydjJywwLjQ4LC0wLjMzLDEuMTEsLTAuNTcsMS43NCwtMC42Nl0sWyd6J11dLHc6MTYuMzY2LGg6Ny44OTN9LFxuXHRcdCdzY3JpcHRzLnRyaWxsJzp7ZDpbWydNJywtMC41MSwtMTYuMDJdLFsnYycsMC4xMiwtMC4wOSwwLjIxLC0wLjE4LDAuMjEsLTAuMThdLFsnbCcsLTAuODEsNC4wMl0sWydsJywtMC44MSw0LjAyXSxbJ2MnLDAuMDMsMC4wMCwwLjUxLC0wLjI3LDEuMDgsLTAuNjBdLFsnYycsMC42MCwtMC4zMCwxLjE0LC0wLjYzLDEuMjYsLTAuNjZdLFsnYycsMS4xNCwtMC41NCwyLjMxLC0wLjYwLDMuMDksLTAuMThdLFsnYycsMC4yNywwLjE1LDAuNTQsMC4zNiwwLjYwLDAuNTFdLFsnbCcsMC4wNiwwLjEyXSxbJ2wnLDAuMjEsLTAuMjFdLFsnYycsMC45MCwtMC44MSwyLjIyLC0wLjk5LDMuMTIsLTAuNDJdLFsnYycsMC42MCwwLjQyLDAuOTAsMS4xNCwwLjc4LDIuMDddLFsnYycsLTAuMTUsMS4yOSwtMS4wNSwyLjMxLC0xLjk1LDIuMjVdLFsnYycsLTAuNDgsLTAuMDMsLTAuNzgsLTAuMzAsLTAuOTYsLTAuODFdLFsnYycsLTAuMDksLTAuMjcsLTAuMDksLTAuOTAsLTAuMDMsLTEuMjBdLFsnYycsMC4yMSwtMC43NSwwLjgxLC0xLjIzLDEuNTksLTEuMzJdLFsnbCcsMC4yNCwtMC4wM10sWydsJywtMC4wOSwtMC4xMl0sWydjJywtMC41MSwtMC42NiwtMS42MiwtMC42MywtMi4zMSwwLjAzXSxbJ2MnLC0wLjM5LDAuNDIsLTAuMzAsMC4wOSwtMS4yMyw0Ljc3XSxbJ2wnLC0wLjgxLDQuMTRdLFsnYycsLTAuMDMsMC4wMCwtMC4xMiwtMC4wMywtMC4yMSwtMC4wOV0sWydjJywtMC4zMywtMC4xNSwtMC41NCwtMC4xOCwtMC45OSwtMC4xOF0sWydjJywtMC40MiwwLjAwLC0wLjY2LDAuMDMsLTEuMDUsMC4xOF0sWydjJywtMC4xMiwwLjA2LC0wLjIxLDAuMDksLTAuMjEsMC4wOV0sWydjJywwLjAwLC0wLjAzLDAuMzYsLTEuODYsMC44MSwtNC4xMV0sWydjJywwLjkwLC00LjQ3LDAuODcsLTQuMjYsMC42OSwtNC41M10sWydjJywtMC4yMSwtMC4zNiwtMC42NiwtMC41MSwtMS4xNywtMC4zNl0sWydjJywtMC4xNSwwLjA2LC0yLjIyLDEuMTQsLTIuNTgsMS4zOF0sWydjJywtMC4xMiwwLjA5LC0wLjEyLDAuMDksLTAuMjEsMC42MF0sWydsJywtMC4wOSwwLjUxXSxbJ2wnLDAuMjEsMC4yNF0sWydjJywwLjYzLDAuNzUsMS4wMiwxLjQ3LDEuMjAsMi4xOV0sWydjJywwLjA2LDAuMjcsMC4wNiwwLjM2LDAuMDYsMC44MV0sWydjJywwLjAwLDAuNDIsMC4wMCwwLjU0LC0wLjA2LDAuNzhdLFsnYycsLTAuMTUsMC41NCwtMC4zMywwLjkzLC0wLjYzLDEuMzVdLFsnYycsLTAuMTgsMC4yNCwtMC41NywwLjYzLC0wLjgxLDAuNzhdLFsnYycsLTAuMjQsMC4xNSwtMC42MywwLjM2LC0wLjg0LDAuNDJdLFsnYycsLTAuMjcsMC4wNiwtMC42NiwwLjA2LC0wLjg3LDAuMDNdLFsnYycsLTAuODEsLTAuMTgsLTEuMzIsLTEuMDUsLTEuMzgsLTIuNDZdLFsnYycsLTAuMDMsLTAuNjAsMC4wMywtMC45OSwwLjMzLC0yLjQ2XSxbJ2MnLDAuMjEsLTEuMDgsMC4yNCwtMS4zMiwwLjIxLC0xLjI5XSxbJ2MnLC0xLjIwLDAuNDgsLTIuNDAsMC43NSwtMy4yMSwwLjcyXSxbJ2MnLC0wLjY5LC0wLjA2LC0xLjE3LC0wLjMwLC0xLjQxLC0wLjcyXSxbJ2MnLC0wLjM5LC0wLjc1LC0wLjEyLC0xLjgwLDAuNjYsLTIuNDZdLFsnYycsMC4yNCwtMC4xOCwwLjY5LC0wLjQyLDEuMDIsLTAuNTFdLFsnYycsMC42OSwtMC4xOCwxLjUzLC0wLjE1LDIuMzEsMC4wOV0sWydjJywwLjMwLDAuMDksMC43NSwwLjMwLDAuOTksMC40NV0sWydjJywwLjEyLDAuMDksMC4xNSwwLjA5LDAuMTUsMC4wM10sWydjJywwLjAzLC0wLjAzLDAuMzMsLTEuNTksMC43MiwtMy40NV0sWydjJywwLjM2LC0xLjg2LDAuNjYsLTMuNDIsMC42OSwtMy40NV0sWydjJywwLjAwLC0wLjAzLDAuMDMsLTAuMDMsMC4yMSwwLjAzXSxbJ2MnLDAuMjEsMC4wNiwwLjI3LDAuMDYsMC40OCwwLjA2XSxbJ2MnLDAuNDIsLTAuMDMsMC43OCwtMC4xOCwxLjI2LC0wLjQ4XSxbJ2MnLDAuMTUsLTAuMTIsMC4zNiwtMC4yNywwLjQ4LC0wLjM5XSxbJ3onXSxbJ20nLC01LjczLDcuNjhdLFsnYycsLTAuMjcsLTAuMDMsLTAuOTYsLTAuMDYsLTEuMjAsLTAuMDNdLFsnYycsLTAuODEsMC4xMiwtMS4zNSwwLjU3LC0xLjUwLDEuMjBdLFsnYycsLTAuMTgsMC42NiwwLjEyLDEuMTQsMC43NSwxLjI5XSxbJ2MnLDAuNjYsMC4xMiwxLjkyLC0wLjEyLDMuMTgsLTAuNjZdLFsnbCcsMC4zMywtMC4xNV0sWydsJywwLjA5LC0wLjM5XSxbJ2MnLDAuMDYsLTAuMjEsMC4wOSwtMC40MiwwLjA5LC0wLjQ1XSxbJ2MnLDAuMDAsLTAuMDMsLTAuNDUsLTAuMzAsLTAuNzUsLTAuNDVdLFsnYycsLTAuMjcsLTAuMTUsLTAuNjYsLTAuMjcsLTAuOTksLTAuMzZdLFsneiddLFsnbScsNC4yOSwzLjYzXSxbJ2MnLC0wLjI0LC0wLjM5LC0wLjUxLC0wLjc1LC0wLjUxLC0wLjY5XSxbJ2MnLC0wLjA2LDAuMTIsLTAuMzksMS45MiwtMC40NSwyLjI4XSxbJ2MnLC0wLjA5LDAuNTQsLTAuMTIsMS4xNCwtMC4wNiwxLjM4XSxbJ2MnLDAuMDYsMC40MiwwLjIxLDAuNjAsMC41MSwwLjU3XSxbJ2MnLDAuMzksLTAuMDYsMC43NSwtMC40OCwwLjkzLC0xLjE0XSxbJ2MnLDAuMDksLTAuMzMsMC4wOSwtMS4wNSwwLjAwLC0xLjM4XSxbJ2MnLC0wLjA5LC0wLjM5LC0wLjI0LC0wLjY5LC0wLjQyLC0xLjAyXSxbJ3onXV0sdzoxNy45NjMsaDoxNi40OX0sXG5cdFx0J3NjcmlwdHMuc2Vnbm8nOntkOltbJ00nLC0zLjcyLC0xMS4yMl0sWydjJywwLjc4LC0wLjA5LDEuNTksMC4wMywyLjMxLDAuNDJdLFsnYycsMS4yMCwwLjYwLDIuMDEsMS43MSwyLjMxLDMuMDldLFsnYycsMC4wOSwwLjQyLDAuMDksMS4yMCwwLjAzLDEuNTBdLFsnYycsLTAuMTUsMC40NSwtMC4zOSwwLjgxLC0wLjY2LDAuOTNdLFsnYycsLTAuMzMsMC4xOCwtMC44NCwwLjIxLC0xLjIzLDAuMTVdLFsnYycsLTAuODEsLTAuMTgsLTEuMzIsLTAuOTMsLTEuMjYsLTEuODldLFsnYycsMC4wMywtMC4zNiwwLjA5LC0wLjU3LDAuMjQsLTAuOTBdLFsnYycsMC4xNSwtMC4zMywwLjQ1LC0wLjYwLDAuNzIsLTAuNzVdLFsnYycsMC4xMiwtMC4wNiwwLjE4LC0wLjA5LDAuMTgsLTAuMTJdLFsnYycsMC4wMCwtMC4wMywtMC4wMywtMC4xNSwtMC4wOSwtMC4yNF0sWydjJywtMC4xOCwtMC40NSwtMC41NCwtMC44NywtMC45NiwtMS4wOF0sWydjJywtMS4xMSwtMC41NywtMi4zNCwtMC4xOCwtMi44OCwwLjkwXSxbJ2MnLC0wLjI0LDAuNTEsLTAuMzMsMS4xMSwtMC4yNCwxLjgzXSxbJ2MnLDAuMjcsMS45MiwxLjUwLDMuNTQsMy45Myw1LjEzXSxbJ2MnLDAuNDgsMC4zMywxLjI2LDAuNzgsMS4yOSwwLjc4XSxbJ2MnLDAuMDMsMC4wMCwxLjM1LC0yLjE5LDIuOTQsLTQuODldLFsnbCcsMi44OCwtNC44OV0sWydsJywwLjg0LDAuMDBdLFsnbCcsMC44NywwLjAwXSxbJ2wnLC0wLjAzLDAuMDZdLFsnYycsLTAuMTUsMC4yMSwtNi4xNSwxMC40MSwtNi4xNSwxMC40NF0sWydjJywwLjAwLDAuMDAsMC4yMSwwLjE1LDAuNDgsMC4yN10sWydjJywyLjYxLDEuNDcsNC4zNSwzLjAzLDUuMTMsNC42NV0sWydjJywxLjE0LDIuMzQsMC41MSw1LjA3LC0xLjQ0LDYuMzldLFsnYycsLTAuNjYsMC40MiwtMS4zMiwwLjYzLC0yLjEzLDAuNjldLFsnYycsLTIuMDEsMC4wOSwtMy44MSwtMS40MSwtNC4yNiwtMy41NF0sWydjJywtMC4wOSwtMC40MiwtMC4wOSwtMS4yMCwtMC4wMywtMS41MF0sWydjJywwLjE1LC0wLjQ1LDAuMzksLTAuODEsMC42NiwtMC45M10sWydjJywwLjMzLC0wLjE4LDAuODQsLTAuMjEsMS4yMywtMC4xNV0sWydjJywwLjgxLDAuMTgsMS4zMiwwLjkzLDEuMjYsMS44OV0sWydjJywtMC4wMywwLjM2LC0wLjA5LDAuNTcsLTAuMjQsMC45MF0sWydjJywtMC4xNSwwLjMzLC0wLjQ1LDAuNjAsLTAuNzIsMC43NV0sWydjJywtMC4xMiwwLjA2LC0wLjE4LDAuMDksLTAuMTgsMC4xMl0sWydjJywwLjAwLDAuMDMsMC4wMywwLjE1LDAuMDksMC4yNF0sWydjJywwLjE4LDAuNDUsMC41NCwwLjg3LDAuOTYsMS4wOF0sWydjJywxLjExLDAuNTcsMi4zNCwwLjE4LDIuODgsLTAuOTBdLFsnYycsMC4yNCwtMC41MSwwLjMzLC0xLjExLDAuMjQsLTEuODNdLFsnYycsLTAuMjcsLTEuOTIsLTEuNTAsLTMuNTQsLTMuOTMsLTUuMTNdLFsnYycsLTAuNDgsLTAuMzMsLTEuMjYsLTAuNzgsLTEuMjksLTAuNzhdLFsnYycsLTAuMDMsMC4wMCwtMS4zNSwyLjE5LC0yLjkxLDQuODldLFsnbCcsLTIuODgsNC44OV0sWydsJywtMC44NywwLjAwXSxbJ2wnLC0wLjg3LDAuMDBdLFsnbCcsMC4wMywtMC4wNl0sWydjJywwLjE1LC0wLjIxLDYuMTUsLTEwLjQxLDYuMTUsLTEwLjQ0XSxbJ2MnLDAuMDAsMC4wMCwtMC4yMSwtMC4xNSwtMC40OCwtMC4zMF0sWydjJywtMi42MSwtMS40NCwtNC4zNSwtMy4wMCwtNS4xMywtNC42Ml0sWydjJywtMC45MCwtMS44OSwtMC43MiwtNC4wMiwwLjQ4LC01LjUyXSxbJ2MnLDAuNjksLTAuODQsMS42OCwtMS40MSwyLjczLC0xLjUzXSxbJ3onXSxbJ20nLDguNzYsOS4wOV0sWydjJywwLjAzLC0wLjAzLDAuMTUsLTAuMDMsMC4yNywtMC4wM10sWydjJywwLjMzLDAuMDMsMC41NywwLjE4LDAuNzIsMC40OF0sWydjJywwLjA5LDAuMTgsMC4wOSwwLjU3LDAuMDAsMC43NV0sWydjJywtMC4wOSwwLjE4LC0wLjIxLDAuMzAsLTAuMzYsMC4zOV0sWydjJywtMC4xNSwwLjA2LC0wLjIxLDAuMDYsLTAuMzksMC4wNl0sWydjJywtMC4yMSwwLjAwLC0wLjI3LDAuMDAsLTAuMzksLTAuMDZdLFsnYycsLTAuMzAsLTAuMTUsLTAuNDgsLTAuNDUsLTAuNDgsLTAuNzVdLFsnYycsMC4wMCwtMC4zOSwwLjI0LC0wLjcyLDAuNjMsLTAuODRdLFsneiddLFsnbScsLTEwLjUzLDIuNjFdLFsnYycsMC4wMywtMC4wMywwLjE1LC0wLjAzLDAuMjcsLTAuMDNdLFsnYycsMC4zMywwLjAzLDAuNTcsMC4xOCwwLjcyLDAuNDhdLFsnYycsMC4wOSwwLjE4LDAuMDksMC41NywwLjAwLDAuNzVdLFsnYycsLTAuMDksMC4xOCwtMC4yMSwwLjMwLC0wLjM2LDAuMzldLFsnYycsLTAuMTUsMC4wNiwtMC4yMSwwLjA2LC0wLjM5LDAuMDZdLFsnYycsLTAuMjEsMC4wMCwtMC4yNywwLjAwLC0wLjM5LC0wLjA2XSxbJ2MnLC0wLjMwLC0wLjE1LC0wLjQ4LC0wLjQ1LC0wLjQ4LC0wLjc1XSxbJ2MnLDAuMDAsLTAuMzksMC4yNCwtMC43MiwwLjYzLC0wLjg0XSxbJ3onXV0sdzoxNSxoOjIyLjUwNH0sXG5cdFx0J3NjcmlwdHMuY29kYSc6e2Q6W1snTScsLTAuMjEsLTEwLjQ3XSxbJ2MnLDAuMTgsLTAuMTIsMC40MiwtMC4wNiwwLjU0LDAuMTJdLFsnYycsMC4wNiwwLjA5LDAuMDYsMC4xOCwwLjA2LDEuNTBdLFsnbCcsMC4wMCwxLjM4XSxbJ2wnLDAuMTgsMC4wMF0sWydjJywwLjM5LDAuMDYsMC45NiwwLjI0LDEuMzgsMC40OF0sWydjJywxLjY4LDAuOTMsMi44MiwzLjI0LDMuMDMsNi4xMl0sWydjJywwLjAzLDAuMjQsMC4wMywwLjQ1LDAuMDMsMC40NV0sWydjJywwLjAwLDAuMDMsMC42MCwwLjAzLDEuMzUsMC4wM10sWydjJywxLjUwLDAuMDAsMS40NywwLjAwLDEuNTksMC4xOF0sWydjJywwLjA5LDAuMTIsMC4wOSwwLjMwLDAuMDAsMC40Ml0sWydjJywtMC4xMiwwLjE4LC0wLjA5LDAuMTgsLTEuNTksMC4xOF0sWydjJywtMC43NSwwLjAwLC0xLjM1LDAuMDAsLTEuMzUsMC4wM10sWydjJywwLjAwLDAuMDAsMC4wMCwwLjIxLC0wLjAzLDAuNDJdLFsnYycsLTAuMjQsMy4xNSwtMS41Myw1LjU4LC0zLjQ1LDYuMzZdLFsnYycsLTAuMjcsMC4xMiwtMC43MiwwLjI0LC0wLjk2LDAuMjddLFsnbCcsLTAuMTgsMC4wMF0sWydsJywwLjAwLDEuMzhdLFsnYycsMC4wMCwxLjMyLDAuMDAsMS40MSwtMC4wNiwxLjUwXSxbJ2MnLC0wLjE1LDAuMjQsLTAuNTEsMC4yNCwtMC42NiwwLjAwXSxbJ2MnLC0wLjA2LC0wLjA5LC0wLjA2LC0wLjE4LC0wLjA2LC0xLjUwXSxbJ2wnLDAuMDAsLTEuMzhdLFsnbCcsLTAuMTgsMC4wMF0sWydjJywtMC4zOSwtMC4wNiwtMC45NiwtMC4yNCwtMS4zOCwtMC40OF0sWydjJywtMS42OCwtMC45MywtMi44MiwtMy4yNCwtMy4wMywtNi4xNV0sWydjJywtMC4wMywtMC4yMSwtMC4wMywtMC40MiwtMC4wMywtMC40Ml0sWydjJywwLjAwLC0wLjAzLC0wLjYwLC0wLjAzLC0xLjM1LC0wLjAzXSxbJ2MnLC0xLjUwLDAuMDAsLTEuNDcsMC4wMCwtMS41OSwtMC4xOF0sWydjJywtMC4wOSwtMC4xMiwtMC4wOSwtMC4zMCwwLjAwLC0wLjQyXSxbJ2MnLDAuMTIsLTAuMTgsMC4wOSwtMC4xOCwxLjU5LC0wLjE4XSxbJ2MnLDAuNzUsMC4wMCwxLjM1LDAuMDAsMS4zNSwtMC4wM10sWydjJywwLjAwLDAuMDAsMC4wMCwtMC4yMSwwLjAzLC0wLjQ1XSxbJ2MnLDAuMjQsLTMuMTIsMS41MywtNS41NSwzLjQ1LC02LjMzXSxbJ2MnLDAuMjcsLTAuMTIsMC43MiwtMC4yNCwwLjk2LC0wLjI3XSxbJ2wnLDAuMTgsMC4wMF0sWydsJywwLjAwLC0xLjM4XSxbJ2MnLDAuMDAsLTEuNTMsMC4wMCwtMS41MCwwLjE4LC0xLjYyXSxbJ3onXSxbJ20nLC0wLjE4LDYuOTNdLFsnYycsMC4wMCwtMi45NywwLjAwLC0zLjE1LC0wLjA2LC0zLjE1XSxbJ2MnLC0wLjA5LDAuMDAsLTAuNTEsMC4xNSwtMC42NiwwLjIxXSxbJ2MnLC0wLjg3LDAuNTEsLTEuMzgsMS42MiwtMS41NiwzLjUxXSxbJ2MnLC0wLjA2LDAuNTQsLTAuMTIsMS41OSwtMC4xMiwyLjE2XSxbJ2wnLDAuMDAsMC40Ml0sWydsJywxLjIwLDAuMDBdLFsnbCcsMS4yMCwwLjAwXSxbJ2wnLDAuMDAsLTMuMTVdLFsneiddLFsnbScsMS4xNywtMy4wNl0sWydjJywtMC4wOSwtMC4wMywtMC4yMSwtMC4wNiwtMC4yNywtMC4wOV0sWydsJywtMC4xMiwwLjAwXSxbJ2wnLDAuMDAsMy4xNV0sWydsJywwLjAwLDMuMTVdLFsnbCcsMS4yMCwwLjAwXSxbJ2wnLDEuMjAsMC4wMF0sWydsJywwLjAwLC0wLjgxXSxbJ2MnLC0wLjA2LC0yLjQwLC0wLjMzLC0zLjY5LC0wLjkzLC00LjU5XSxbJ2MnLC0wLjI3LC0wLjM5LC0wLjY2LC0wLjY5LC0xLjA4LC0wLjgxXSxbJ3onXSxbJ20nLC0xLjE3LDEwLjE0XSxbJ2wnLDAuMDAsLTMuMTVdLFsnbCcsLTEuMjAsMC4wMF0sWydsJywtMS4yMCwwLjAwXSxbJ2wnLDAuMDAsMC44MV0sWydjJywwLjAzLDAuOTYsMC4wNiwxLjQ3LDAuMTUsMi4xM10sWydjJywwLjI0LDIuMDQsMC45NiwzLjEyLDIuMTMsMy4zNl0sWydsJywwLjEyLDAuMDBdLFsnbCcsMC4wMCwtMy4xNV0sWyd6J10sWydtJywzLjE4LC0yLjM0XSxbJ2wnLDAuMDAsLTAuODFdLFsnbCcsLTEuMjAsMC4wMF0sWydsJywtMS4yMCwwLjAwXSxbJ2wnLDAuMDAsMy4xNV0sWydsJywwLjAwLDMuMTVdLFsnbCcsMC4xMiwwLjAwXSxbJ2MnLDEuMTcsLTAuMjQsMS44OSwtMS4zMiwyLjEzLC0zLjM2XSxbJ2MnLDAuMDksLTAuNjYsMC4xMiwtMS4xNywwLjE1LC0yLjEzXSxbJ3onXV0sdzoxNi4wMzUsaDoyMS4wNjJ9LFxuXHRcdCdzY3JpcHRzLmNvbW1hJzp7ZDpbWydNJywxLjE0LC00LjYyXSxbJ2MnLDAuMzAsLTAuMTIsMC42OSwtMC4wMywwLjkzLDAuMTVdLFsnYycsMC4xMiwwLjEyLDAuMzYsMC40NSwwLjUxLDAuNzhdLFsnYycsMC45MCwxLjc3LDAuNTQsNC4wNSwtMS4wOCw2Ljc1XSxbJ2MnLC0wLjM2LDAuNjMsLTAuODcsMS4zOCwtMC45NiwxLjQ0XSxbJ2MnLC0wLjE4LDAuMTIsLTAuNDIsMC4wNiwtMC41NCwtMC4xMl0sWydjJywtMC4wOSwtMC4xOCwtMC4wOSwtMC4zMCwwLjEyLC0wLjYwXSxbJ2MnLDAuOTYsLTEuNDQsMS40NCwtMi45NywxLjM4LC00LjM1XSxbJ2MnLC0wLjA2LC0wLjkzLC0wLjMwLC0xLjY4LC0wLjc4LC0yLjQ2XSxbJ2MnLC0wLjI3LC0wLjM5LC0wLjMzLC0wLjYzLC0wLjI0LC0wLjk2XSxbJ2MnLDAuMDksLTAuMjcsMC4zNiwtMC41NCwwLjY2LC0wLjYzXSxbJ3onXV0sdzozLjA0MixoOjkuMjM3fSxcblx0XHQnc2NyaXB0cy5yb2xsJzp7ZDpbWydNJywxLjk1LC02LjAwXSxbJ2MnLDAuMjEsLTAuMDksMC4zNiwtMC4wOSwwLjU3LDAuMDBdLFsnYycsMC4zOSwwLjE1LDAuNjMsMC4zOSwxLjQ3LDEuMzVdLFsnYycsMC42NiwwLjc1LDAuNzgsMC44NywxLjA4LDEuMDVdLFsnYycsMC43NSwwLjQ1LDEuNjUsMC40MiwyLjQwLC0wLjA2XSxbJ2MnLDAuMTIsLTAuMDksMC4yNywtMC4yNywwLjU0LC0wLjYwXSxbJ2MnLDAuNDIsLTAuNTQsMC41MSwtMC42MywwLjY5LC0wLjYzXSxbJ2MnLDAuMDksMC4wMCwwLjMwLDAuMTIsMC4zNiwwLjIxXSxbJ2MnLDAuMDksMC4xMiwwLjEyLDAuMzAsMC4wMywwLjQyXSxbJ2MnLC0wLjA2LDAuMTIsLTMuMTUsMy45MCwtMy4zMCw0LjA4XSxbJ2MnLC0wLjA2LDAuMDYsLTAuMTgsMC4xMiwtMC4yNywwLjE4XSxbJ2MnLC0wLjI3LDAuMTIsLTAuNjAsMC4wNiwtMC45OSwtMC4yN10sWydjJywtMC4yNywtMC4yMSwtMC40MiwtMC4zOSwtMS4wOCwtMS4xNF0sWydjJywtMC42MywtMC43MiwtMC44MSwtMC45MCwtMS4xNywtMS4wOF0sWydjJywtMC4zNiwtMC4xOCwtMC41NywtMC4yMSwtMC45OSwtMC4yMV0sWydjJywtMC4zOSwwLjAwLC0wLjYzLDAuMDMsLTAuOTMsMC4xOF0sWydjJywtMC4zNiwwLjE1LC0wLjUxLDAuMjcsLTAuOTAsMC44MV0sWydjJywtMC4yNCwwLjI3LC0wLjQ1LDAuNTEsLTAuNDgsMC41NF0sWydjJywtMC4xMiwwLjA5LC0wLjI3LDAuMDYsLTAuMzksMC4wMF0sWydjJywtMC4yNCwtMC4xNSwtMC4zMywtMC4zOSwtMC4yMSwtMC42MF0sWydjJywwLjA5LC0wLjEyLDMuMTgsLTMuODcsMy4zMywtNC4wMl0sWydjJywwLjA2LC0wLjA2LDAuMTgsLTAuMTUsMC4yNCwtMC4yMV0sWyd6J11dLHc6MTAuODE3LGg6Ni4xMjV9LFxuXHRcdCdzY3JpcHRzLnByYWxsJzp7ZDpbWydNJywtNC4zOCwtMy42OV0sWydjJywwLjA2LC0wLjAzLDAuMTgsLTAuMDYsMC4yNCwtMC4wNl0sWydjJywwLjMwLDAuMDAsMC4yNywtMC4wMywxLjg5LDEuOTVdLFsnbCcsMS41MywxLjgzXSxbJ2MnLDAuMDMsMC4wMCwwLjU3LC0wLjg0LDEuMjMsLTEuODNdLFsnYycsMS4xNCwtMS42OCwxLjIzLC0xLjgzLDEuMzUsLTEuODldLFsnYycsMC4wNiwtMC4wMywwLjE4LC0wLjA2LDAuMjQsLTAuMDZdLFsnYycsMC4zMCwwLjAwLDAuMjcsLTAuMDMsMS44OSwxLjk1XSxbJ2wnLDEuNTMsMS44M10sWydsJywwLjQ4LC0wLjY5XSxbJ2MnLDAuNTEsLTAuNzgsMC41NCwtMC44NCwwLjY5LC0wLjkwXSxbJ2MnLDAuNDIsLTAuMTgsMC44NywwLjE1LDAuODEsMC42MF0sWydjJywtMC4wMywwLjEyLC0wLjMwLDAuNTEsLTEuNTAsMi4zN10sWydjJywtMS4zOCwyLjA3LC0xLjUwLDIuMjIsLTEuNjIsMi4yOF0sWydjJywtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNl0sWydjJywtMC4zMCwwLjAwLC0wLjI3LDAuMDMsLTEuODksLTEuOTVdLFsnbCcsLTEuNTMsLTEuODNdLFsnYycsLTAuMDMsMC4wMCwtMC41NywwLjg0LC0xLjIzLDEuODNdLFsnYycsLTEuMTQsMS42OCwtMS4yMywxLjgzLC0xLjM1LDEuODldLFsnYycsLTAuMDYsMC4wMywtMC4xOCwwLjA2LC0wLjI0LDAuMDZdLFsnYycsLTAuMzAsMC4wMCwtMC4yNywwLjAzLC0xLjg5LC0xLjk1XSxbJ2wnLC0xLjUzLC0xLjgzXSxbJ2wnLC0wLjQ4LDAuNjldLFsnYycsLTAuNTEsMC43OCwtMC41NCwwLjg0LC0wLjY5LDAuOTBdLFsnYycsLTAuNDIsMC4xOCwtMC44NywtMC4xNSwtMC44MSwtMC42MF0sWydjJywwLjAzLC0wLjEyLDAuMzAsLTAuNTEsMS41MCwtMi4zN10sWydjJywxLjM4LC0yLjA3LDEuNTAsLTIuMjIsMS42MiwtMi4yOF0sWyd6J11dLHc6MTUuMDExLGg6Ny41fSxcblx0XHQnc2NyaXB0cy5hcnBlZ2dpbyc6e2Q6W1snTScsMS41LDBdLFsnYycsMS41LDIsMS41LDMsMS41LDNdLFsncycsMCwxLC0yLDEuNV0sWydzJywtMC41LDMsMSw1LjVdLFsnbCcsMS41LDBdLFsncycsLTEuNzUsLTIsLTEuOSwtMy4yNV0sWydzJywyLjE1LC0wLjYsMi45NSwtMS42XSxbJ3MnLDAuNDUsLTEsMC41LC0xLjI1XSxbJ3MnLDAsLTEsLTIsLTMuOV0sWydsJywtMS41LDBdLFsneiddXSx3OjUsaDoxMH0sXG5cdFx0J3NjcmlwdHMubW9yZGVudCc6e2Q6W1snTScsLTAuMjEsLTQuOTVdLFsnYycsMC4yNywtMC4xNSwwLjYzLDAuMDAsMC43NSwwLjI3XSxbJ2MnLDAuMDYsMC4xMiwwLjA2LDAuMjQsMC4wNiwxLjQ0XSxbJ2wnLDAuMDAsMS4yOV0sWydsJywwLjU3LC0wLjg0XSxbJ2MnLDAuNTEsLTAuNzUsMC41NywtMC44NCwwLjY5LC0wLjkwXSxbJ2MnLDAuMDYsLTAuMDMsMC4xOCwtMC4wNiwwLjI0LC0wLjA2XSxbJ2MnLDAuMzAsMC4wMCwwLjI3LC0wLjAzLDEuODksMS45NV0sWydsJywxLjUzLDEuODNdLFsnbCcsMC40OCwtMC42OV0sWydjJywwLjUxLC0wLjc4LDAuNTQsLTAuODQsMC42OSwtMC45MF0sWydjJywwLjQyLC0wLjE4LDAuODcsMC4xNSwwLjgxLDAuNjBdLFsnYycsLTAuMDMsMC4xMiwtMC4zMCwwLjUxLC0xLjUwLDIuMzddLFsnYycsLTEuMzgsMi4wNywtMS41MCwyLjIyLC0xLjYyLDIuMjhdLFsnYycsLTAuMDYsMC4wMywtMC4xOCwwLjA2LC0wLjI0LDAuMDZdLFsnYycsLTAuMzAsMC4wMCwtMC4yNywwLjAzLC0xLjgzLC0xLjg5XSxbJ2MnLC0wLjgxLC0wLjk5LC0xLjUwLC0xLjgwLC0xLjUzLC0xLjg2XSxbJ2MnLC0wLjA2LC0wLjAzLC0wLjA2LC0wLjAzLC0wLjEyLDAuMDNdLFsnYycsLTAuMDYsMC4wNiwtMC4wNiwwLjE1LC0wLjA2LDIuMjhdLFsnYycsMC4wMCwxLjk1LDAuMDAsMi4yNSwtMC4wNiwyLjM0XSxbJ2MnLC0wLjE4LDAuNDUsLTAuODEsMC40OCwtMS4wNSwwLjAzXSxbJ2MnLC0wLjAzLC0wLjA2LC0wLjA2LC0wLjI0LC0wLjA2LC0xLjQxXSxbJ2wnLDAuMDAsLTEuMzVdLFsnbCcsLTAuNTcsMC44NF0sWydjJywtMC41NCwwLjc4LC0wLjYwLDAuODcsLTAuNzIsMC45M10sWydjJywtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNl0sWydjJywtMC4zMCwwLjAwLC0wLjI3LDAuMDMsLTEuODksLTEuOTVdLFsnbCcsLTEuNTMsLTEuODNdLFsnbCcsLTAuNDgsMC42OV0sWydjJywtMC41MSwwLjc4LC0wLjU0LDAuODQsLTAuNjksMC45MF0sWydjJywtMC40MiwwLjE4LC0wLjg3LC0wLjE1LC0wLjgxLC0wLjYwXSxbJ2MnLDAuMDMsLTAuMTIsMC4zMCwtMC41MSwxLjUwLC0yLjM3XSxbJ2MnLDEuMzgsLTIuMDcsMS41MCwtMi4yMiwxLjYyLC0yLjI4XSxbJ2MnLDAuMDYsLTAuMDMsMC4xOCwtMC4wNiwwLjI0LC0wLjA2XSxbJ2MnLDAuMzAsMC4wMCwwLjI3LC0wLjAzLDEuODksMS45NV0sWydsJywxLjUzLDEuODNdLFsnYycsMC4wMywwLjAwLDAuMDYsLTAuMDYsMC4wOSwtMC4wOV0sWydjJywwLjA2LC0wLjEyLDAuMDYsLTAuMTUsMC4wNiwtMi4yOF0sWydjJywwLjAwLC0xLjkyLDAuMDAsLTIuMjIsMC4wNiwtMi4zMV0sWydjJywwLjA2LC0wLjE1LDAuMTUsLTAuMjQsMC4zMCwtMC4zMF0sWyd6J11dLHc6MTUuMDExLGg6MTAuMDEyfSxcblx0XHQnZmxhZ3MudTh0aCc6e2Q6W1snTScsLTAuNDIsMy43NV0sWydsJywwLjAwLC0zLjc1XSxbJ2wnLDAuMjEsMC4wMF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4wMCwwLjE4XSxbJ2MnLDAuMDAsMC4zMCwwLjA2LDAuODQsMC4xMiwxLjIzXSxbJ2MnLDAuMjQsMS41MywwLjkwLDMuMTIsMi4xMyw1LjE2XSxbJ2wnLDAuOTksMS41OV0sWydjJywwLjg3LDEuNDQsMS4zOCwyLjM0LDEuNzcsMy4wOV0sWydjJywwLjgxLDEuNjgsMS4yMCwzLjA2LDEuMjYsNC41M10sWydjJywwLjAzLDEuNTMsLTAuMjEsMy4yNywtMC43NSw1LjAxXSxbJ2MnLC0wLjIxLDAuNjksLTAuNTEsMS41MCwtMC42MCwxLjU5XSxbJ2MnLC0wLjA5LDAuMTIsLTAuMjcsMC4yMSwtMC40MiwwLjIxXSxbJ2MnLC0wLjE1LDAuMDAsLTAuNDIsLTAuMTIsLTAuNTEsLTAuMjFdLFsnYycsLTAuMTUsLTAuMTgsLTAuMTgsLTAuNDIsLTAuMDksLTAuNjZdLFsnYycsMC4xNSwtMC4zMywwLjQ1LC0xLjIwLDAuNTcsLTEuNjJdLFsnYycsMC40MiwtMS4zOCwwLjYwLC0yLjU4LDAuNjAsLTMuOTBdLFsnYycsMC4wMCwtMC42NiwwLjAwLC0wLjgxLC0wLjA2LC0xLjExXSxbJ2MnLC0wLjM5LC0yLjA3LC0xLjgwLC00LjI2LC00LjU5LC03LjE0XSxbJ2wnLC0wLjQyLC0wLjQ1XSxbJ2wnLC0wLjIxLDAuMDBdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywwLjAwLC0zLjc1XSxbJ3onXV0sdzo2LjY5MixoOjIyLjU5fSxcblx0XHQnZmxhZ3MudTE2dGgnOntkOltbJ00nLC0wLjQyLDcuNTBdLFsnbCcsMC4wMCwtNy41MF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4yMSwwLjAwXSxbJ2wnLDAuMDAsMC4zOV0sWydjJywwLjA2LDEuMDgsMC4zOSwyLjE5LDAuOTksMy4zOV0sWydjJywwLjQ1LDAuOTAsMC44NywxLjU5LDEuOTUsMy4xMl0sWydjJywxLjI5LDEuODYsMS43NywyLjY0LDIuMjIsMy41N10sWydjJywwLjQ1LDAuOTMsMC43MiwxLjgwLDAuODcsMi42NF0sWydjJywwLjA2LDAuNTEsMC4wNiwxLjUwLDAuMDAsMS45Ml0sWydjJywtMC4xMiwwLjYwLC0wLjMwLDEuMjAsLTAuNTQsMS43MV0sWydsJywtMC4wOSwwLjI0XSxbJ2wnLDAuMTgsMC40NV0sWydjJywwLjUxLDEuMjAsMC43MiwyLjIyLDAuNjksMy40Ml0sWydjJywtMC4wNiwxLjUzLC0wLjM5LDMuMDMsLTAuOTksNC41M10sWydjJywtMC4zMCwwLjc1LC0wLjM2LDAuODEsLTAuNTcsMC45MF0sWydjJywtMC4xNSwwLjA5LC0wLjMzLDAuMDYsLTAuNDgsMC4wMF0sWydjJywtMC4xOCwtMC4wOSwtMC4yNywtMC4xOCwtMC4zMywtMC4zM10sWydjJywtMC4wOSwtMC4xOCwtMC4wNiwtMC4zMCwwLjEyLC0wLjc1XSxbJ2MnLDAuNjYsLTEuNDEsMS4wMiwtMi44OCwxLjA4LC00LjMyXSxbJ2MnLDAuMDAsLTAuNjAsLTAuMDMsLTEuMDUsLTAuMTgsLTEuNTldLFsnYycsLTAuMzAsLTEuMjAsLTAuOTksLTIuNDAsLTIuMjUsLTMuODddLFsnYycsLTAuNDIsLTAuNDgsLTEuNTMsLTEuNjIsLTIuMTksLTIuMjJdLFsnbCcsLTAuNDUsLTAuNDJdLFsnbCcsLTAuMDMsMS4xMV0sWydsJywwLjAwLDEuMTFdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywtMC4yMSwwLjAwXSxbJ2wnLDAuMDAsLTcuNTBdLFsneiddLFsnbScsMS42NSwwLjA5XSxbJ2MnLC0wLjMwLC0wLjMwLC0wLjY5LC0wLjcyLC0wLjkwLC0wLjg3XSxbJ2wnLC0wLjMzLC0wLjMzXSxbJ2wnLDAuMDAsMC4xNV0sWydjJywwLjAwLDAuMzAsMC4wNiwwLjgxLDAuMTUsMS4yNl0sWydjJywwLjI3LDEuMjksMC44NywyLjYxLDIuMDQsNC4yOV0sWydjJywwLjE1LDAuMjQsMC42MCwwLjg3LDAuOTYsMS4zOF0sWydsJywxLjA4LDEuNTNdLFsnbCcsMC40MiwwLjYzXSxbJ2MnLDAuMDMsMC4wMCwwLjEyLC0wLjM2LDAuMjEsLTAuNzJdLFsnYycsMC4wNiwtMC4zMywwLjA2LC0xLjIwLDAuMDAsLTEuNjJdLFsnYycsLTAuMzMsLTEuNzEsLTEuNDQsLTMuNDgsLTMuNjMsLTUuNzBdLFsneiddXSx3OjYuNjkzLGg6MjYuMzM3fSxcblx0XHQnZmxhZ3MudTMybmQnOntkOltbJ00nLC0wLjQyLDExLjI1XSxbJ2wnLDAuMDAsLTExLjI1XSxbJ2wnLDAuMjEsMC4wMF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4wMCwwLjM2XSxbJ2MnLDAuMDksMS42OCwwLjY5LDMuMjcsMi4wNyw1LjQ2XSxbJ2wnLDAuODcsMS4zNV0sWydjJywxLjAyLDEuNjIsMS40NywyLjM3LDEuODYsMy4xOF0sWydjJywwLjQ4LDEuMDIsMC43OCwxLjkyLDAuOTMsMi44OF0sWydjJywwLjA2LDAuNDgsMC4wNiwxLjUwLDAuMDAsMS44OV0sWydjJywtMC4wOSwwLjQyLC0wLjIxLDAuODcsLTAuMzYsMS4yNl0sWydsJywtMC4xMiwwLjMwXSxbJ2wnLDAuMTUsMC4zOV0sWydjJywwLjY5LDEuNTYsMC44NCwyLjg4LDAuNTQsNC4zOF0sWydjJywtMC4wOSwwLjQ1LC0wLjI3LDEuMDgsLTAuNDUsMS40N10sWydsJywtMC4xMiwwLjI0XSxbJ2wnLDAuMTgsMC4zNl0sWydjJywwLjMzLDAuNzIsMC41NywxLjU2LDAuNjksMi4zNF0sWydjJywwLjEyLDEuMDIsLTAuMDYsMi41MiwtMC40MiwzLjg0XSxbJ2MnLC0wLjI3LDAuOTMsLTAuNzUsMi4xMywtMC45MywyLjMxXSxbJ2MnLC0wLjE4LDAuMTUsLTAuNDUsMC4xOCwtMC42NiwwLjA5XSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI3LC0wLjE4LC0wLjMzLC0wLjMzXSxbJ2MnLC0wLjA5LC0wLjE4LC0wLjA2LC0wLjMwLDAuMDYsLTAuNjBdLFsnYycsMC4yMSwtMC4zNiwwLjQyLC0wLjkwLDAuNTcsLTEuMzhdLFsnYycsMC41MSwtMS40MSwwLjY5LC0zLjA2LDAuNDgsLTQuMDhdLFsnYycsLTAuMTUsLTAuODEsLTAuNTcsLTEuNjgsLTEuMjAsLTIuNTVdLFsnYycsLTAuNzIsLTAuOTksLTEuODMsLTIuMTMsLTMuMzAsLTMuMzNdLFsnbCcsLTAuNDgsLTAuNDJdLFsnbCcsLTAuMDMsMS41M10sWydsJywwLjAwLDEuNTZdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywtMC4yMSwwLjAwXSxbJ2wnLDAuMDAsLTExLjI1XSxbJ3onXSxbJ20nLDEuMjYsLTMuOTZdLFsnYycsLTAuMjcsLTAuMzAsLTAuNTQsLTAuNjAsLTAuNjYsLTAuNzJdLFsnbCcsLTAuMTgsLTAuMjFdLFsnbCcsMC4wMCwwLjQyXSxbJ2MnLDAuMDYsMC44NywwLjI0LDEuNzQsMC42NiwyLjY3XSxbJ2MnLDAuMzYsMC44NywwLjk2LDEuODYsMS45MiwzLjE4XSxbJ2MnLDAuMjEsMC4zMywwLjYzLDAuODcsMC44NywxLjIzXSxbJ2MnLDAuMjcsMC4zOSwwLjYwLDAuODQsMC43NSwxLjA4XSxbJ2wnLDAuMjcsMC4zOV0sWydsJywwLjAzLC0wLjEyXSxbJ2MnLDAuMTIsLTAuNDUsMC4xNSwtMS4wNSwwLjA5LC0xLjU5XSxbJ2MnLC0wLjI3LC0xLjg2LC0xLjM4LC0zLjc4LC0zLjc1LC02LjMzXSxbJ3onXSxbJ20nLC0wLjI3LDYuMDldLFsnYycsLTAuMjcsLTAuMjEsLTAuNDgsLTAuNDIsLTAuNTEsLTAuNDVdLFsnYycsLTAuMDYsLTAuMDMsLTAuMDYsLTAuMDMsLTAuMDYsMC4yMV0sWydjJywwLjAwLDAuOTAsMC4zMCwyLjA0LDAuODEsMy4wOV0sWydjJywwLjQ4LDEuMDIsMC45NiwxLjc3LDIuMzcsMy42M10sWydjJywwLjYwLDAuNzgsMS4wNSwxLjQ0LDEuMjksMS43N10sWydjJywwLjA2LDAuMTIsMC4xNSwwLjIxLDAuMTUsMC4xOF0sWydjJywwLjAzLC0wLjAzLDAuMTgsLTAuNTcsMC4yNCwtMC44N10sWydjJywwLjA2LC0wLjQ1LDAuMDYsLTEuMzIsLTAuMDMsLTEuNzRdLFsnYycsLTAuMDksLTAuNDgsLTAuMjQsLTAuOTAsLTAuNTEsLTEuNDRdLFsnYycsLTAuNjYsLTEuMzUsLTEuODMsLTIuNzAsLTMuNzUsLTQuMzhdLFsneiddXSx3OjYuNjk3LGg6MzIuMTQ1fSxcblx0XHQnZmxhZ3MudTY0dGgnOntkOltbJ00nLC0wLjQyLDE1LjAwXSxbJ2wnLDAuMDAsLTE1LjAwXSxbJ2wnLDAuMjEsMC4wMF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4wMCwwLjM2XSxbJ2MnLDAuMDYsMS4yMCwwLjM5LDIuMzcsMS4wMiwzLjY2XSxbJ2MnLDAuMzksMC44MSwwLjg0LDEuNTYsMS44MCwzLjA5XSxbJ2MnLDAuODEsMS4yNiwxLjA1LDEuNjgsMS4zNSwyLjIyXSxbJ2MnLDAuODcsMS41MCwxLjM1LDIuNzksMS41Niw0LjA4XSxbJ2MnLDAuMDYsMC41NCwwLjA2LDEuNTYsLTAuMDMsMi4wNF0sWydjJywtMC4wOSwwLjQ4LC0wLjIxLDAuOTksLTAuMzYsMS4zNV0sWydsJywtMC4xMiwwLjI3XSxbJ2wnLDAuMTIsMC4yN10sWydjJywwLjA5LDAuMTUsMC4yMSwwLjQ1LDAuMjcsMC42Nl0sWydjJywwLjY5LDEuODksMC42MywzLjY2LC0wLjE4LDUuNDZdLFsnbCcsLTAuMTgsMC4zOV0sWydsJywwLjE1LDAuMzNdLFsnYycsMC4zMCwwLjY2LDAuNTEsMS40NCwwLjYzLDIuMTBdLFsnYycsMC4wNiwwLjQ4LDAuMDYsMS4zNSwwLjAwLDEuNzFdLFsnYycsLTAuMTUsMC41NywtMC40MiwxLjIwLC0wLjc4LDEuNjhdLFsnbCcsLTAuMjEsMC4yN10sWydsJywwLjE4LDAuMzNdLFsnYycsMC41NywxLjA1LDAuOTMsMi4xMywxLjAyLDMuMThdLFsnYycsMC4wNiwwLjcyLDAuMDAsMS44MywtMC4yMSwyLjc5XSxbJ2MnLC0wLjE4LDEuMDIsLTAuNjMsMi4zNCwtMS4wMiwzLjA5XSxbJ2MnLC0wLjE1LDAuMzMsLTAuNDgsMC40NSwtMC43OCwwLjMwXSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI3LC0wLjE4LC0wLjMzLC0wLjMzXSxbJ2MnLC0wLjA5LC0wLjE4LC0wLjA2LC0wLjMwLDAuMDMsLTAuNTRdLFsnYycsMC43NSwtMS41MCwxLjIzLC0zLjQ1LDEuMTcsLTQuODldLFsnYycsLTAuMDYsLTEuMDIsLTAuNDIsLTIuMDEsLTEuMTcsLTMuMTVdLFsnYycsLTAuNDgsLTAuNzIsLTEuMDIsLTEuMzUsLTEuODksLTIuMjJdLFsnYycsLTAuNTcsLTAuNTcsLTEuNTYsLTEuNTAsLTEuOTIsLTEuNzddLFsnbCcsLTAuMTIsLTAuMDldLFsnbCcsMC4wMCwxLjY4XSxbJ2wnLDAuMDAsMS42OF0sWydsJywtMC4yMSwwLjAwXSxbJ2wnLC0wLjIxLDAuMDBdLFsnbCcsMC4wMCwtMTUuMDBdLFsneiddLFsnbScsMC45MywtOC4wN10sWydjJywtMC4yNywtMC4zMCwtMC40OCwtMC41NCwtMC41MSwtMC41NF0sWydjJywwLjAwLDAuMDAsMC4wMCwwLjY5LDAuMDMsMS4wMl0sWydjJywwLjE1LDEuNDcsMC43NSwyLjk0LDIuMDQsNC44M10sWydsJywxLjA4LDEuNTNdLFsnYycsMC4zOSwwLjU3LDAuODQsMS4yMCwwLjk5LDEuNDRdLFsnYycsMC4xNSwwLjI0LDAuMzAsMC40NSwwLjMwLDAuNDVdLFsnYycsMC4wMCwwLjAwLDAuMDMsLTAuMDksMC4wNiwtMC4yMV0sWydjJywwLjM2LC0xLjU5LC0wLjE1LC0zLjMzLC0xLjQ3LC01LjQwXSxbJ2MnLC0wLjYzLC0wLjkzLC0xLjM1LC0xLjgzLC0yLjUyLC0zLjEyXSxbJ3onXSxbJ20nLDAuMDYsNi43Ml0sWydjJywtMC4yNCwtMC4yMSwtMC40OCwtMC40MiwtMC41MSwtMC40NV0sWydsJywtMC4wNiwtMC4wNl0sWydsJywwLjAwLDAuMzNdLFsnYycsMC4wMCwxLjIwLDAuMzAsMi4zNCwwLjkzLDMuNjBdLFsnYycsMC40NSwwLjkwLDAuOTYsMS42OCwyLjI1LDMuNTFdLFsnYycsMC4zOSwwLjU0LDAuODQsMS4xNywxLjAyLDEuNDRdLFsnYycsMC4yMSwwLjMzLDAuMzMsMC41MSwwLjMzLDAuNDhdLFsnYycsMC4wNiwtMC4wOSwwLjIxLC0wLjYzLDAuMzAsLTAuOTldLFsnYycsMC4wNiwtMC4zMywwLjA2LC0wLjQ1LDAuMDYsLTAuOTZdLFsnYycsMC4wMCwtMC42MCwtMC4wMywtMC44NCwtMC4xOCwtMS4zNV0sWydjJywtMC4zMCwtMS4wOCwtMS4wMiwtMi4yOCwtMi4xMywtMy41N10sWydjJywtMC4zOSwtMC40NSwtMS40NCwtMS40NywtMi4wMSwtMS45OF0sWyd6J10sWydtJywwLjAwLDYuNzJdLFsnYycsLTAuMjQsLTAuMjEsLTAuNDgsLTAuMzksLTAuNTEsLTAuNDJdLFsnbCcsLTAuMDYsLTAuMDZdLFsnbCcsMC4wMCwwLjMzXSxbJ2MnLDAuMDAsMS40MSwwLjQ1LDIuODIsMS4zOCw0LjM1XSxbJ2MnLDAuNDIsMC43MiwwLjcyLDEuMTQsMS44NiwyLjczXSxbJ2MnLDAuMzYsMC40NSwwLjc1LDAuOTksMC44NywxLjIwXSxbJ2MnLDAuMTUsMC4yMSwwLjMwLDAuMzYsMC4zMCwwLjM2XSxbJ2MnLDAuMDYsMC4wMCwwLjMwLC0wLjQ4LDAuMzksLTAuNzVdLFsnYycsMC4wOSwtMC4zNiwwLjEyLC0wLjYzLDAuMTIsLTEuMDVdLFsnYycsLTAuMDYsLTEuMDUsLTAuNDUsLTIuMDQsLTEuMjAsLTMuMThdLFsnYycsLTAuNTcsLTAuODcsLTEuMTEsLTEuNTMsLTIuMDcsLTIuNDldLFsnYycsLTAuMzYsLTAuMzMsLTAuODQsLTAuNzgsLTEuMDgsLTEuMDJdLFsneiddXSx3OjYuNjgyLGg6MzkuNjk0fSxcblx0XHQnZmxhZ3MuZDh0aCc6e2Q6W1snTScsNS42NywtMjEuNjNdLFsnYycsMC4yNCwtMC4xMiwwLjU0LC0wLjA2LDAuNjksMC4xNV0sWydjJywwLjA2LDAuMDYsMC4yMSwwLjM2LDAuMzksMC42Nl0sWydjJywwLjg0LDEuNzcsMS4yNiwzLjM2LDEuMzIsNS4xMF0sWydjJywwLjAzLDEuMjksLTAuMjEsMi4zNywtMC44MSwzLjYzXSxbJ2MnLC0wLjYwLDEuMjMsLTEuMjYsMi4xMywtMy4yMSw0LjM4XSxbJ2MnLC0xLjM1LDEuNTMsLTEuODYsMi4xOSwtMi40MCwyLjk3XSxbJ2MnLC0wLjYzLDAuOTMsLTEuMTEsMS45MiwtMS4zOCwyLjc5XSxbJ2MnLC0wLjE1LDAuNTQsLTAuMjcsMS4zNSwtMC4yNywxLjgwXSxbJ2wnLDAuMDAsMC4xNV0sWydsJywtMC4yMSwwLjAwXSxbJ2wnLC0wLjIxLDAuMDBdLFsnbCcsMC4wMCwtMy43NV0sWydsJywwLjAwLC0zLjc1XSxbJ2wnLDAuMjEsMC4wMF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC40OCwtMC4zMF0sWydjJywxLjgzLC0xLjExLDMuMTIsLTIuMTAsNC4xNywtMy4xMl0sWydjJywwLjc4LC0wLjgxLDEuMzIsLTEuNTMsMS43MSwtMi4zMV0sWydjJywwLjQ1LC0wLjkzLDAuNjAsLTEuNzQsMC41MSwtMi44OF0sWydjJywtMC4xMiwtMS41NiwtMC42MywtMy4xOCwtMS40NywtNC42OF0sWydjJywtMC4xMiwtMC4yMSwtMC4xNSwtMC4zMywtMC4wNiwtMC41MV0sWydjJywwLjA2LC0wLjE1LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sWyd6J11dLHc6OC40OTIsaDoyMS42OTF9LFxuXHRcdCdmbGFncy51Z3JhY2UnOntkOltbJ00nLDYuMDMsNi45M10sWydjJywwLjE1LC0wLjA5LDAuMzMsLTAuMDYsMC41MSwwLjAwXSxbJ2MnLDAuMTUsMC4wOSwwLjIxLDAuMTUsMC4zMCwwLjMzXSxbJ2MnLDAuMDksMC4xOCwwLjA2LDAuMzksLTAuMDMsMC41NF0sWydjJywtMC4wNiwwLjE1LC0xMC44OSw4Ljg4LC0xMS4wNyw4Ljk3XSxbJ2MnLC0wLjE1LDAuMDksLTAuMzMsMC4wNiwtMC40OCwwLjAwXSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbJ2MnLC0wLjA5LC0wLjE4LC0wLjA2LC0wLjM5LDAuMDMsLTAuNTRdLFsnYycsMC4wNiwtMC4xNSwxMC44OSwtOC44OCwxMS4wNywtOC45N10sWyd6J11dLHc6MTIuMDE5LGg6OS45NTR9LFxuXHRcdCdmbGFncy5kZ3JhY2UnOntkOltbJ00nLC02LjA2LC0xNS45M10sWydjJywwLjE4LC0wLjA5LDAuMzMsLTAuMTIsMC40OCwtMC4wNl0sWydjJywwLjE4LDAuMDksMTQuMDEsOC4wNCwxNC4xMCw4LjEwXSxbJ2MnLDAuMTIsMC4xMiwwLjE4LDAuMzMsMC4xOCwwLjUxXSxbJ2MnLC0wLjAzLDAuMjEsLTAuMTUsMC4zOSwtMC4zNiwwLjQ4XSxbJ2MnLC0wLjE4LDAuMDksLTAuMzMsMC4xMiwtMC40OCwwLjA2XSxbJ2MnLC0wLjE4LC0wLjA5LC0xNC4wMSwtOC4wNCwtMTQuMTAsLTguMTBdLFsnYycsLTAuMTIsLTAuMTIsLTAuMTgsLTAuMzMsLTAuMTgsLTAuNTFdLFsnYycsMC4wMywtMC4yMSwwLjE1LC0wLjM5LDAuMzYsLTAuNDhdLFsneiddXSx3OjE1LjEyLGg6OS4yMTJ9LFxuXHRcdCdmbGFncy5kMTZ0aCc6e2Q6W1snTScsNi44NCwtMjIuNTNdLFsnYycsMC4yNywtMC4xMiwwLjU3LC0wLjA2LDAuNzIsMC4xNV0sWydjJywwLjE1LDAuMTUsMC4zMywwLjg3LDAuNDUsMS41Nl0sWydjJywwLjA2LDAuMzMsMC4wNiwxLjM1LDAuMDAsMS42NV0sWydjJywtMC4wNiwwLjMzLC0wLjE1LDAuNzgsLTAuMjcsMS4xMV0sWydjJywtMC4xMiwwLjMzLC0wLjQ1LDAuOTYsLTAuNjYsMS4zMl0sWydsJywtMC4xOCwwLjI3XSxbJ2wnLDAuMDksMC4xOF0sWydjJywwLjQ4LDEuMDIsMC43MiwyLjI1LDAuNjksMy4zMF0sWydjJywtMC4wNiwxLjIzLC0wLjQyLDIuMjgsLTEuMjYsMy40NV0sWydjJywtMC41NywwLjg3LC0wLjk5LDEuMzIsLTMuMDAsMy4zOV0sWydjJywtMS41NiwxLjU2LC0yLjIyLDIuNDAsLTIuNzYsMy40NV0sWydjJywtMC40MiwwLjg0LC0wLjY2LDEuODAsLTAuNjYsMi41NV0sWydsJywwLjAwLDAuMTVdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywtMC4yMSwwLjAwXSxbJ2wnLDAuMDAsLTcuNTBdLFsnbCcsMC4wMCwtNy41MF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4yMSwwLjAwXSxbJ2wnLDAuMDAsMS4xNF0sWydsJywwLjAwLDEuMTFdLFsnbCcsMC4yNywtMC4xNV0sWydjJywxLjExLC0wLjU3LDEuNzcsLTAuOTksMi41MiwtMS40N10sWydjJywyLjM3LC0xLjU2LDMuNjksLTMuMTUsNC4wNSwtNC44M10sWydjJywwLjAzLC0wLjE4LDAuMDMsLTAuMzksMC4wMywtMC43OF0sWydjJywwLjAwLC0wLjYwLC0wLjAzLC0wLjkzLC0wLjI0LC0xLjUwXSxbJ2MnLC0wLjA2LC0wLjE4LC0wLjEyLC0wLjM5LC0wLjE1LC0wLjQ1XSxbJ2MnLC0wLjAzLC0wLjI0LDAuMTIsLTAuNDgsMC4zNiwtMC42MF0sWyd6J10sWydtJywtMC42Myw3LjUwXSxbJ2MnLC0wLjA2LC0wLjE4LC0wLjE1LC0wLjM2LC0wLjE1LC0wLjM2XSxbJ2MnLC0wLjAzLDAuMDAsLTAuMDMsMC4wMywtMC4wNiwwLjA2XSxbJ2MnLC0wLjA2LDAuMTIsLTAuOTYsMS4wMiwtMS45NSwxLjk4XSxbJ2MnLC0wLjYzLDAuNTcsLTEuMjYsMS4xNywtMS40NCwxLjM1XSxbJ2MnLC0xLjUzLDEuNjIsLTIuMjgsMi44NSwtMi41NSw0LjMyXSxbJ2MnLC0wLjAzLDAuMTgsLTAuMDMsMC41NCwtMC4wNiwwLjk5XSxbJ2wnLDAuMDAsMC42OV0sWydsJywwLjE4LC0wLjA5XSxbJ2MnLDAuOTMsLTAuNTQsMi4xMCwtMS4yOSwyLjgyLC0xLjgzXSxbJ2MnLDAuNjksLTAuNTEsMS4wMiwtMC44MSwxLjUzLC0xLjI5XSxbJ2MnLDEuODYsLTEuODksMi4zNywtMy42NiwxLjY4LC01LjgyXSxbJ3onXV0sdzo4LjQ3NSxoOjIyLjU5MX0sXG5cdFx0J2ZsYWdzLmQzMm5kJzp7ZDpbWydNJyw2Ljg0LC0yOS4xM10sWydjJywwLjI3LC0wLjEyLDAuNTcsLTAuMDYsMC43MiwwLjE1XSxbJ2MnLDAuMTIsMC4xMiwwLjI3LDAuNjMsMC4zNiwxLjExXSxbJ2MnLDAuMzMsMS41OSwwLjA2LDMuMDYsLTAuODEsNC40N10sWydsJywtMC4xOCwwLjI3XSxbJ2wnLDAuMDksMC4xNV0sWydjJywwLjEyLDAuMjQsMC4zMywwLjY5LDAuNDUsMS4wNV0sWydjJywwLjYzLDEuODMsMC40NSwzLjU3LC0wLjU3LDUuMjJdLFsnbCcsLTAuMTgsMC4zMF0sWydsJywwLjE1LDAuMjddLFsnYycsMC40MiwwLjg3LDAuNjAsMS43MSwwLjU3LDIuNjFdLFsnYycsLTAuMDYsMS4yOSwtMC40OCwyLjQ2LC0xLjM1LDMuNzhdLFsnYycsLTAuNTQsMC44MSwtMC45MywxLjI5LC0yLjQ2LDMuMDBdLFsnYycsLTAuNTEsMC41NCwtMS4wNSwxLjE3LC0xLjI2LDEuNDFdLFsnYycsLTEuNTYsMS44NiwtMi4yNSwzLjM2LC0yLjM3LDUuMDFdLFsnbCcsMC4wMCwwLjMzXSxbJ2wnLC0wLjIxLDAuMDBdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywwLjAwLC0xMS4yNV0sWydsJywwLjAwLC0xMS4yNV0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4yMSwwLjAwXSxbJ2wnLDAuMDAsMS4zNV0sWydsJywwLjAzLDEuMzVdLFsnbCcsMC43OCwtMC4zOV0sWydjJywxLjM4LC0wLjY5LDIuMzQsLTEuMjYsMy4yNCwtMS45Ml0sWydjJywxLjM4LC0xLjAyLDIuMjgsLTIuMTMsMi42NCwtMy4yMV0sWydjJywwLjE1LC0wLjQ4LDAuMTgsLTAuNzIsMC4xOCwtMS4yOV0sWydjJywwLjAwLC0wLjU3LC0wLjA2LC0wLjkwLC0wLjI0LC0xLjQ3XSxbJ2MnLC0wLjA2LC0wLjE4LC0wLjEyLC0wLjM5LC0wLjE1LC0wLjQ1XSxbJ2MnLC0wLjAzLC0wLjI0LDAuMTIsLTAuNDgsMC4zNiwtMC42MF0sWyd6J10sWydtJywtMC42Myw3LjIwXSxbJ2MnLC0wLjA5LC0wLjE4LC0wLjEyLC0wLjIxLC0wLjEyLC0wLjE1XSxbJ2MnLC0wLjAzLDAuMDksLTEuMDIsMS4wOCwtMi4wNCwyLjA0XSxbJ2MnLC0xLjE3LDEuMDgsLTEuNjUsMS41NiwtMi4wNywyLjA0XSxbJ2MnLC0wLjg0LDAuOTYsLTEuMzgsMS44NiwtMS42OCwyLjc2XSxbJ2MnLC0wLjIxLDAuNTcsLTAuMjcsMC45OSwtMC4zMCwxLjY1XSxbJ2wnLDAuMDAsMC41NF0sWydsJywwLjY2LC0wLjMzXSxbJ2MnLDMuNTcsLTEuODYsNS40OSwtMy42OSw1Ljk0LC01LjcwXSxbJ2MnLDAuMDYsLTAuMzksMC4wNiwtMS4yMCwtMC4wMywtMS42NV0sWydjJywtMC4wNiwtMC4zOSwtMC4yNCwtMC45MCwtMC4zNiwtMS4yMF0sWyd6J10sWydtJywtMC4wNiw3LjIwXSxbJ2MnLC0wLjA2LC0wLjE1LC0wLjEyLC0wLjMzLC0wLjE1LC0wLjQ1XSxbJ2wnLC0wLjA2LC0wLjE4XSxbJ2wnLC0wLjE4LDAuMjFdLFsnbCcsLTEuODMsMS44M10sWydjJywtMC44NywwLjkwLC0xLjc3LDEuODAsLTEuOTUsMi4wMV0sWydjJywtMS4wOCwxLjI5LC0xLjYyLDIuMzEsLTEuODksMy41MV0sWydjJywtMC4wNiwwLjMwLC0wLjA2LDAuNTEsLTAuMDksMC45M10sWydsJywwLjAwLDAuNTddLFsnbCcsMC4wOSwtMC4wNl0sWydjJywwLjc1LC0wLjQ1LDEuODksLTEuMjYsMi41MiwtMS43NF0sWydjJywwLjgxLC0wLjY2LDEuNzQsLTEuNTMsMi4yMiwtMi4xNl0sWydjJywxLjI2LC0xLjUzLDEuNjgsLTMuMDYsMS4zMiwtNC40N10sWyd6J11dLHc6OC4zODUsaDoyOS4xOTF9LFxuXHRcdCdmbGFncy5kNjR0aCc6e2Q6W1snTScsNy4wOCwtMzIuODhdLFsnYycsMC4zMCwtMC4xMiwwLjY2LC0wLjAzLDAuNzgsMC4yNF0sWydjJywwLjE4LDAuMzMsMC4yNywyLjEwLDAuMTUsMi42NF0sWydjJywtMC4wOSwwLjM5LC0wLjIxLDAuNzgsLTAuMzksMS4wOF0sWydsJywtMC4xNSwwLjMwXSxbJ2wnLDAuMDksMC4yN10sWydjJywwLjAzLDAuMTIsMC4wOSwwLjQ1LDAuMTIsMC42OV0sWydjJywwLjI3LDEuNDQsMC4xOCwyLjU1LC0wLjMwLDMuNjBdLFsnbCcsLTAuMTIsMC4zM10sWydsJywwLjA2LDAuNDJdLFsnYycsMC4yNywxLjM1LDAuMzMsMi44MiwwLjIxLDMuNjNdLFsnYycsLTAuMTIsMC42MCwtMC4zMCwxLjIzLC0wLjU3LDEuODBdLFsnbCcsLTAuMTUsMC4yN10sWydsJywwLjAzLDAuNDJdLFsnYycsMC4wNiwxLjAyLDAuMDYsMi43MCwwLjAzLDMuMDZdLFsnYycsLTAuMTUsMS40NywtMC42NiwyLjc2LC0xLjc0LDQuNDFdLFsnYycsLTAuNDUsMC42OSwtMC43NSwxLjExLC0xLjc0LDIuMzddLFsnYycsLTEuMDUsMS4zOCwtMS41MCwxLjk4LC0xLjk1LDIuNzNdLFsnYycsLTAuOTMsMS41MCwtMS4zOCwyLjgyLC0xLjQ0LDQuMjBdLFsnbCcsMC4wMCwwLjQyXSxbJ2wnLC0wLjIxLDAuMDBdLFsnbCcsLTAuMjEsMC4wMF0sWydsJywwLjAwLC0xNS4wMF0sWydsJywwLjAwLC0xNS4wMF0sWydsJywwLjIxLDAuMDBdLFsnbCcsMC4yMSwwLjAwXSxbJ2wnLDAuMDAsMS44Nl0sWydsJywwLjAwLDEuODldLFsnYycsMC4wMCwwLjAwLDAuMjEsLTAuMDMsMC40NSwtMC4wOV0sWydjJywyLjIyLC0wLjM5LDQuMDgsLTEuMTEsNS4xOSwtMi4wMV0sWydjJywwLjYzLC0wLjU0LDEuMDIsLTEuMTQsMS4yMCwtMS44MF0sWydjJywwLjA2LC0wLjMwLDAuMDYsLTEuMTQsLTAuMDMsLTEuNjVdLFsnYycsLTAuMDMsLTAuMTgsLTAuMDYsLTAuMzksLTAuMDksLTAuNDhdLFsnYycsLTAuMDMsLTAuMjQsMC4xMiwtMC40OCwwLjM2LC0wLjYwXSxbJ3onXSxbJ20nLC0wLjQ1LDYuMTVdLFsnYycsLTAuMDMsLTAuMTgsLTAuMDYsLTAuNDIsLTAuMDYsLTAuNTRdLFsnbCcsLTAuMDMsLTAuMThdLFsnbCcsLTAuMzMsMC4zMF0sWydjJywtMC40MiwwLjM2LC0wLjg3LDAuNzIsLTEuNjgsMS4yOV0sWydjJywtMS45OCwxLjM4LC0yLjI1LDEuNTksLTIuODUsMi4xNl0sWydjJywtMC43NSwwLjY5LC0xLjIzLDEuNDQsLTEuNDcsMi4xOV0sWydjJywtMC4xNSwwLjQ1LC0wLjE4LDAuNjMsLTAuMjEsMS4zNV0sWydsJywwLjAwLDAuNjZdLFsnbCcsMC4zOSwtMC4xOF0sWydjJywxLjgzLC0wLjkwLDMuNDUsLTEuOTUsNC40NywtMi45MV0sWydjJywwLjkzLC0wLjkwLDEuNTMsLTEuODMsMS43NCwtMi44Ml0sWydjJywwLjA2LC0wLjMzLDAuMDYsLTAuODcsMC4wMywtMS4zMl0sWyd6J10sWydtJywtMC4yNyw0Ljg2XSxbJ2MnLC0wLjAzLC0wLjIxLC0wLjA2LC0wLjM2LC0wLjA2LC0wLjM2XSxbJ2MnLDAuMDAsLTAuMDMsLTAuMTIsMC4wOSwtMC4yNCwwLjI0XSxbJ2MnLC0wLjM5LDAuNDgsLTAuOTksMS4wOCwtMi4xNiwyLjE5XSxbJ2MnLC0xLjQ3LDEuMzgsLTEuOTIsMS44MywtMi40NiwyLjQ5XSxbJ2MnLC0wLjY2LDAuODcsLTEuMDgsMS43NCwtMS4yOSwyLjU4XSxbJ2MnLC0wLjA5LDAuNDIsLTAuMTUsMC44NywtMC4xNSwxLjQ0XSxbJ2wnLDAuMDAsMC41NF0sWydsJywwLjQ4LC0wLjMzXSxbJ2MnLDEuNTAsLTEuMDIsMi41OCwtMS44OSwzLjUxLC0yLjgyXSxbJ2MnLDEuNDcsLTEuNDcsMi4yNSwtMi44NSwyLjQwLC00LjI2XSxbJ2MnLDAuMDMsLTAuMzksMC4wMywtMS4xNywtMC4wMywtMS43MV0sWyd6J10sWydtJywtMC42Niw3LjY4XSxbJ2MnLDAuMDMsLTAuMTUsMC4wMywtMC42MCwwLjAzLC0wLjk5XSxbJ2wnLDAuMDAsLTAuNzJdLFsnbCcsLTAuMjcsMC4zM10sWydsJywtMS43NCwxLjk4XSxbJ2MnLC0xLjc3LDEuOTIsLTIuNDMsMi43NiwtMi45NywzLjkwXSxbJ2MnLC0wLjUxLDEuMDIsLTAuNzIsMS43NywtMC43NSwyLjkxXSxbJ2MnLDAuMDAsMC42MywwLjAwLDAuNjMsMC4wNiwwLjYwXSxbJ2MnLDAuMDMsLTAuMDMsMC4zMCwtMC4yNywwLjYzLC0wLjU0XSxbJ2MnLDAuNjYsLTAuNjAsMS44NiwtMS44MCwyLjMxLC0yLjMxXSxbJ2MnLDEuNjUsLTEuODksMi41MiwtMy41NCwyLjcwLC01LjE2XSxbJ3onXV0sdzo4LjQ4NSxoOjMyLjkzMn0sXG5cdFx0J2NsZWZzLkMnOntkOltbJ00nLDAuMDYsLTE0Ljk0XSxbJ2wnLDAuMDksLTAuMDZdLFsnbCcsMS45MiwwLjAwXSxbJ2wnLDEuOTIsMC4wMF0sWydsJywwLjA5LDAuMDZdLFsnbCcsMC4wNiwwLjA5XSxbJ2wnLDAuMDAsMTQuODVdLFsnbCcsMC4wMCwxNC44Ml0sWydsJywtMC4wNiwwLjA5XSxbJ2wnLC0wLjA5LDAuMDZdLFsnbCcsLTEuOTIsMC4wMF0sWydsJywtMS45MiwwLjAwXSxbJ2wnLC0wLjA5LC0wLjA2XSxbJ2wnLC0wLjA2LC0wLjA5XSxbJ2wnLDAuMDAsLTE0LjgyXSxbJ2wnLDAuMDAsLTE0Ljg1XSxbJ3onXSxbJ20nLDUuMzcsMC4wMF0sWydjJywwLjA5LC0wLjA2LDAuMDksLTAuMDYsMC41NywtMC4wNl0sWydjJywwLjQ1LDAuMDAsMC40NSwwLjAwLDAuNTQsMC4wNl0sWydsJywwLjA2LDAuMDldLFsnbCcsMC4wMCw3LjE0XSxbJ2wnLDAuMDAsNy4xMV0sWydsJywwLjA5LC0wLjA2XSxbJ2MnLDAuMTgsLTAuMTgsMC43MiwtMC44NCwwLjk2LC0xLjIwXSxbJ2MnLDAuMzAsLTAuNDUsMC42NiwtMS4xNywwLjg0LC0xLjY1XSxbJ2MnLDAuMzYsLTAuOTAsMC41NywtMS44MywwLjYwLC0yLjc5XSxbJ2MnLDAuMDMsLTAuNDgsMC4wMywtMC41NCwwLjA5LC0wLjYzXSxbJ2MnLDAuMTIsLTAuMTgsMC4zNiwtMC4yMSwwLjU0LC0wLjEyXSxbJ2MnLDAuMTgsMC4wOSwwLjIxLDAuMTUsMC4yNCwwLjY2XSxbJ2MnLDAuMDYsMC44NywwLjIxLDEuNTYsMC41NywyLjIyXSxbJ2MnLDAuNTEsMS4wMiwxLjI2LDEuNjgsMi4yMiwxLjkyXSxbJ2MnLDAuMjEsMC4wNiwwLjMzLDAuMDYsMC43OCwwLjA2XSxbJ2MnLDAuNDUsMC4wMCwwLjU3LDAuMDAsMC44NCwtMC4wNl0sWydjJywwLjQ1LC0wLjEyLDAuODEsLTAuMzMsMS4wOCwtMC42MF0sWydjJywwLjU3LC0wLjU3LDAuODcsLTEuNDEsMC45OSwtMi44OF0sWydjJywwLjA2LC0wLjU0LDAuMDYsLTMuMDAsMC4wMCwtMy41N10sWydjJywtMC4yMSwtMi41OCwtMC44NCwtMy44NywtMi4xNiwtNC41MF0sWydjJywtMC40OCwtMC4yMSwtMS4xNywtMC4zNiwtMS43NywtMC4zNl0sWydjJywtMC42OSwwLjAwLC0xLjI5LDAuMjcsLTEuNTAsMC43Ml0sWydjJywtMC4wNiwwLjE1LC0wLjA2LDAuMjEsLTAuMDYsMC40Ml0sWydjJywwLjAwLDAuMjQsMC4wMCwwLjMwLDAuMDYsMC40NV0sWydjJywwLjEyLDAuMjQsMC4yNCwwLjM5LDAuNjMsMC42Nl0sWydjJywwLjQyLDAuMzAsMC41NywwLjQ4LDAuNjksMC43Ml0sWydjJywwLjA2LDAuMTUsMC4wNiwwLjIxLDAuMDYsMC40OF0sWydjJywwLjAwLDAuMzksLTAuMDMsMC42MywtMC4yMSwwLjk2XSxbJ2MnLC0wLjMwLDAuNjAsLTAuODcsMS4wOCwtMS41MCwxLjI2XSxbJ2MnLC0wLjI3LDAuMDYsLTAuODcsMC4wNiwtMS4xNCwwLjAwXSxbJ2MnLC0wLjc4LC0wLjI0LC0xLjQ0LC0wLjg3LC0xLjY1LC0xLjY4XSxbJ2MnLC0wLjEyLC0wLjQyLC0wLjA5LC0xLjE3LDAuMDksLTEuNzFdLFsnYycsMC41MSwtMS42NSwxLjk4LC0yLjgyLDMuODEsLTMuMDldLFsnYycsMC44NCwtMC4wOSwyLjQ2LDAuMDMsMy41MSwwLjI3XSxbJ2MnLDIuMjIsMC41NywzLjY5LDEuODAsNC40NCwzLjc1XSxbJ2MnLDAuMzYsMC45MywwLjU3LDIuMTMsMC41NywzLjM2XSxbJ2MnLDAuMDAsMS40NCwtMC40OCwyLjczLC0xLjM4LDMuODFdLFsnYycsLTEuMjYsMS41MCwtMy4yNywyLjQzLC01LjI4LDIuNDNdLFsnYycsLTAuNDgsMC4wMCwtMC41MSwwLjAwLC0wLjc1LC0wLjA5XSxbJ2MnLC0wLjE1LC0wLjAzLC0wLjQ4LC0wLjIxLC0wLjc4LC0wLjM2XSxbJ2MnLC0wLjY5LC0wLjM2LC0wLjg3LC0wLjQyLC0xLjI2LC0wLjQyXSxbJ2MnLC0wLjI3LDAuMDAsLTAuMzAsMC4wMCwtMC41MSwwLjA5XSxbJ2MnLC0wLjU3LDAuMzAsLTAuODEsMC45MCwtMC44MSwyLjEwXSxbJ2MnLDAuMDAsMS4yMywwLjI0LDEuODMsMC44MSwyLjEzXSxbJ2MnLDAuMjEsMC4wOSwwLjI0LDAuMDksMC41MSwwLjA5XSxbJ2MnLDAuMzksMC4wMCwwLjU3LC0wLjA2LDEuMjYsLTAuNDJdLFsnYycsMC4zMCwtMC4xNSwwLjYzLC0wLjMzLDAuNzgsLTAuMzZdLFsnYycsMC4yNCwtMC4wOSwwLjI3LC0wLjA5LDAuNzUsLTAuMDldLFsnYycsMi4wMSwwLjAwLDQuMDIsMC45Myw1LjI4LDIuNDBdLFsnYycsMC45MCwxLjExLDEuMzgsMi40MCwxLjM4LDMuODRdLFsnYycsMC4wMCwxLjUwLC0wLjMwLDIuODgsLTAuODQsMy45Nl0sWydjJywtMC43OCwxLjU5LC0yLjE5LDIuNjQsLTQuMTcsMy4xNV0sWydjJywtMS4wNSwwLjI0LC0yLjY3LDAuMzYsLTMuNTEsMC4yN10sWydjJywtMS44MywtMC4yNywtMy4zMCwtMS40NCwtMy44MSwtMy4wOV0sWydjJywtMC4xOCwtMC41NCwtMC4yMSwtMS4yOSwtMC4wOSwtMS43NF0sWydjJywwLjE1LC0wLjYwLDAuNjMsLTEuMjAsMS4yMywtMS40N10sWydjJywwLjM2LC0wLjE4LDAuNTcsLTAuMjEsMC45OSwtMC4yMV0sWydjJywwLjQyLDAuMDAsMC42MywwLjAzLDEuMDIsMC4yMV0sWydjJywwLjQyLDAuMjEsMC44NCwwLjYzLDEuMDUsMS4wNV0sWydjJywwLjE4LDAuMzYsMC4yMSwwLjYwLDAuMjEsMC45Nl0sWydjJywwLjAwLDAuMzAsMC4wMCwwLjM2LC0wLjA2LDAuNTFdLFsnYycsLTAuMTIsMC4yNCwtMC4yNywwLjQyLC0wLjY5LDAuNzJdLFsnYycsLTAuNTcsMC40MiwtMC42OSwwLjYzLC0wLjY5LDEuMDhdLFsnYycsMC4wMCwwLjI0LDAuMDAsMC4zMCwwLjA2LDAuNDVdLFsnYycsMC4xMiwwLjIxLDAuMzAsMC4zOSwwLjU3LDAuNTRdLFsnYycsMC40MiwwLjE4LDAuODcsMC4yMSwxLjUzLDAuMTVdLFsnYycsMS4wOCwtMC4xNSwxLjgwLC0wLjU3LDIuMzQsLTEuMzJdLFsnYycsMC41NCwtMC43NSwwLjg0LC0xLjgzLDAuOTksLTMuNTFdLFsnYycsMC4wNiwtMC41NywwLjA2LC0zLjAzLDAuMDAsLTMuNTddLFsnYycsLTAuMTIsLTEuNDcsLTAuNDIsLTIuMzEsLTAuOTksLTIuODhdLFsnYycsLTAuMjcsLTAuMjcsLTAuNjMsLTAuNDgsLTEuMDgsLTAuNjBdLFsnYycsLTAuMjcsLTAuMDYsLTAuMzksLTAuMDYsLTAuODQsLTAuMDZdLFsnYycsLTAuNDUsMC4wMCwtMC41NywwLjAwLC0wLjc4LDAuMDZdLFsnYycsLTEuMTQsMC4yNywtMi4wMSwxLjE3LC0yLjQ2LDIuNDldLFsnYycsLTAuMjEsMC41NywtMC4zMCwwLjk5LC0wLjMzLDEuNjVdLFsnYycsLTAuMDMsMC41MSwtMC4wNiwwLjU3LC0wLjI0LDAuNjZdLFsnYycsLTAuMTIsMC4wNiwtMC4yNywwLjA2LC0wLjM5LDAuMDBdLFsnYycsLTAuMjEsLTAuMDksLTAuMjEsLTAuMTUsLTAuMjQsLTAuNzVdLFsnYycsLTAuMDksLTEuOTIsLTAuNzgsLTMuNzIsLTIuMDEsLTUuMTldLFsnYycsLTAuMTgsLTAuMjEsLTAuMzYsLTAuNDIsLTAuMzksLTAuNDVdLFsnbCcsLTAuMDksLTAuMDZdLFsnbCcsMC4wMCw3LjExXSxbJ2wnLDAuMDAsNy4xNF0sWydsJywtMC4wNiwwLjA5XSxbJ2MnLC0wLjA5LDAuMDYsLTAuMDksMC4wNiwtMC41NCwwLjA2XSxbJ2MnLC0wLjQ4LDAuMDAsLTAuNDgsMC4wMCwtMC41NywtMC4wNl0sWydsJywtMC4wNiwtMC4wOV0sWydsJywwLjAwLC0xNC44Ml0sWydsJywwLjAwLC0xNC44NV0sWyd6J11dLHc6MjAuMzEsaDoyOS45N30sXG5cdFx0J2NsZWZzLkYnOntkOltbJ00nLDYuMzAsLTcuODBdLFsnYycsMC4zNiwtMC4wMywxLjY1LDAuMDAsMi4xMywwLjAzXSxbJ2MnLDMuNjAsMC40Miw2LjAzLDIuMTAsNi45Myw0Ljg2XSxbJ2MnLDAuMjcsMC44NCwwLjM2LDEuNTAsMC4zNiwyLjU4XSxbJ2MnLDAuMDAsMC45MCwtMC4wMywxLjM1LC0wLjE4LDIuMTZdLFsnYycsLTAuNzgsMy43OCwtMy41NCw3LjA4LC04LjM3LDkuOTZdLFsnYycsLTEuNzQsMS4wNSwtMy44NywyLjEzLC02LjE4LDMuMTJdLFsnYycsLTAuMzksMC4xOCwtMC43NSwwLjMzLC0wLjgxLDAuMzZdLFsnYycsLTAuMDYsMC4wMywtMC4xNSwwLjA2LC0wLjE4LDAuMDZdLFsnYycsLTAuMTUsMC4wMCwtMC4zMywtMC4xOCwtMC4zMywtMC4zM10sWydjJywwLjAwLC0wLjE1LDAuMDYsLTAuMjEsMC41MSwtMC40OF0sWydjJywzLjAwLC0xLjc3LDUuMTMsLTMuMjEsNi44NCwtNC43NF0sWydjJywwLjUxLC0wLjQ1LDEuNTksLTEuNTAsMS45NSwtMS45NV0sWydjJywxLjg5LC0yLjE5LDIuODgsLTQuMzIsMy4xNSwtNi43OF0sWydjJywwLjA2LC0wLjQyLDAuMDYsLTEuNzcsMC4wMCwtMi4xOV0sWydjJywtMC4yNCwtMi4wMSwtMC45MywtMy42MywtMi4wNCwtNC43MV0sWydjJywtMC42MywtMC42MywtMS4yOSwtMS4wMiwtMi4wNywtMS4yMF0sWydjJywtMS42MiwtMC4zOSwtMy4zNiwwLjE1LC00LjU2LDEuNDRdLFsnYycsLTAuNTQsMC42MCwtMS4wNSwxLjQ3LC0xLjMyLDIuMjJdLFsnbCcsLTAuMDksMC4yMV0sWydsJywwLjI0LC0wLjEyXSxbJ2MnLDAuMzksLTAuMjEsMC42MywtMC4yNCwxLjExLC0wLjI0XSxbJ2MnLDAuMzAsMC4wMCwwLjQ1LDAuMDAsMC42NiwwLjA2XSxbJ2MnLDEuOTIsMC40OCwyLjg1LDIuNTUsMS45NSw0LjM4XSxbJ2MnLC0wLjQ1LDAuOTksLTEuNDEsMS42MiwtMi40NiwxLjcxXSxbJ2MnLC0xLjQ3LDAuMDksLTIuOTEsLTAuODcsLTMuMzksLTIuMjVdLFsnYycsLTAuMTgsLTAuNTcsLTAuMjEsLTEuMzIsLTAuMDMsLTIuMjhdLFsnYycsMC4zOSwtMi4yNSwxLjgzLC00LjIwLDMuODEsLTUuMTldLFsnYycsMC42OSwtMC4zNiwxLjU5LC0wLjYwLDIuMzcsLTAuNjldLFsneiddLFsnbScsMTEuNTgsMi41Ml0sWydjJywwLjg0LC0wLjIxLDEuNzEsMC4zMCwxLjg5LDEuMTRdLFsnYycsMC4zMCwxLjE3LC0wLjcyLDIuMTksLTEuODksMS44OV0sWydjJywtMC45OSwtMC4yMSwtMS41MCwtMS4zMiwtMS4wMiwtMi4yNV0sWydjJywwLjE4LC0wLjM5LDAuNjAsLTAuNjksMS4wMiwtMC43OF0sWyd6J10sWydtJywwLjAwLDcuNTBdLFsnYycsMC44NCwtMC4yMSwxLjcxLDAuMzAsMS44OSwxLjE0XSxbJ2MnLDAuMjEsMC44NywtMC4zMCwxLjcxLC0xLjE0LDEuODldLFsnYycsLTAuODcsMC4yMSwtMS43MSwtMC4zMCwtMS44OSwtMS4xNF0sWydjJywtMC4yMSwtMC44NCwwLjMwLC0xLjcxLDEuMTQsLTEuODldLFsneiddXSx3OjIwLjE1MyxoOjIzLjE0Mn0sXG5cdFx0J2NsZWZzLkcnOntkOltbJ00nLDkuNjksLTM3LjQxXSxbJ2MnLDAuMDksLTAuMDksMC4yNCwtMC4wNiwwLjM2LDAuMDBdLFsnYycsMC4xMiwwLjA5LDAuNTcsMC42MCwwLjk2LDEuMTFdLFsnYycsMS43NywyLjM0LDMuMjEsNS44NSwzLjU3LDguNzNdLFsnYycsMC4yMSwxLjU2LDAuMDMsMy4yNywtMC40NSw0Ljg2XSxbJ2MnLC0wLjY5LDIuMzEsLTEuOTIsNC40NywtNC4yMyw3LjQ0XSxbJ2MnLC0wLjMwLDAuMzksLTAuNTcsMC43MiwtMC42MCwwLjc1XSxbJ2MnLC0wLjAzLDAuMDYsMC4wMCwwLjE1LDAuMTgsMC43OF0sWydjJywwLjU0LDEuNjgsMS4zOCw0LjQ0LDEuNjgsNS40OV0sWydsJywwLjA5LDAuNDJdLFsnbCcsMC4zOSwwLjAwXSxbJ2MnLDEuNDcsMC4wOSwyLjc2LDAuNTEsMy45NiwxLjI5XSxbJ2MnLDEuODMsMS4yMywzLjA2LDMuMjEsMy4zOSw1LjUyXSxbJ2MnLDAuMDksMC40NSwwLjEyLDEuMjksMC4wNiwxLjc0XSxbJ2MnLC0wLjA5LDEuMDIsLTAuMzMsMS44MywtMC43NSwyLjczXSxbJ2MnLC0wLjg0LDEuNzEsLTIuMjgsMy4wNiwtNC4wMiwzLjcyXSxbJ2wnLC0wLjMzLDAuMTJdLFsnbCcsMC4wMywxLjI2XSxbJ2MnLDAuMDAsMS43NCwtMC4wNiwzLjYzLC0wLjIxLDQuNjJdLFsnYycsLTAuNDUsMy4wNiwtMi4xOSw1LjQ5LC00LjQ3LDYuMjFdLFsnYycsLTAuNTcsMC4xOCwtMC45MCwwLjIxLC0xLjU5LDAuMjFdLFsnYycsLTAuNjksMC4wMCwtMS4wMiwtMC4wMywtMS42NSwtMC4yMV0sWydjJywtMS4xNCwtMC4yNywtMi4xMywtMC44NCwtMi45NCwtMS42NV0sWydjJywtMC45OSwtMC45OSwtMS41NiwtMi4xNiwtMS43MSwtMy41NF0sWydjJywtMC4wOSwtMC44MSwwLjA2LC0xLjUzLDAuNDUsLTIuMTNdLFsnYycsMC42MywtMC45OSwxLjgzLC0xLjU2LDMuMDAsLTEuNTNdLFsnYycsMS41MCwwLjA5LDIuNjQsMS4zMiwyLjczLDIuOTRdLFsnYycsMC4wNiwxLjQ3LC0wLjkzLDIuNzAsLTIuMzcsMi45N10sWydjJywtMC40NSwwLjA2LC0wLjg0LDAuMDMsLTEuMjksLTAuMDldLFsnbCcsLTAuMjEsLTAuMDldLFsnbCcsMC4wOSwwLjEyXSxbJ2MnLDAuMzksMC41NCwwLjc4LDAuOTMsMS4zMiwxLjI2XSxbJ2MnLDEuMzUsMC44NywzLjA2LDEuMDIsNC4zNSwwLjM2XSxbJ2MnLDEuNDQsLTAuNzIsMi41MiwtMi4yOCwyLjk3LC00LjM1XSxbJ2MnLDAuMTUsLTAuNjYsMC4yNCwtMS41MCwwLjMwLC0zLjAzXSxbJ2MnLDAuMDMsLTAuODQsMC4wMywtMi45NCwwLjAwLC0zLjAwXSxbJ2MnLC0wLjAzLDAuMDAsLTAuMTgsMC4wMCwtMC4zNiwwLjAzXSxbJ2MnLC0wLjY2LDAuMTIsLTAuOTksMC4xMiwtMS44MywwLjEyXSxbJ2MnLC0xLjA1LDAuMDAsLTEuNzEsLTAuMDYsLTIuNjEsLTAuMzBdLFsnYycsLTQuMDIsLTAuOTksLTcuMTEsLTQuMzUsLTcuODAsLTguNDZdLFsnYycsLTAuMTIsLTAuNjYsLTAuMTIsLTAuOTksLTAuMTIsLTEuODNdLFsnYycsMC4wMCwtMC44NCwwLjAwLC0xLjE0LDAuMTUsLTEuOTJdLFsnYycsMC4zNiwtMi4yOCwxLjQxLC00LjYyLDMuMzAsLTcuMjldLFsnbCcsMi43OSwtMy42MF0sWydjJywwLjU0LC0wLjY2LDAuOTYsLTEuMjAsMC45NiwtMS4yM10sWydjJywwLjAwLC0wLjAzLC0wLjA5LC0wLjMzLC0wLjE4LC0wLjY5XSxbJ2MnLC0wLjk2LC0zLjIxLC0xLjQxLC01LjI4LC0xLjU5LC03LjY4XSxbJ2MnLC0wLjEyLC0xLjM4LC0wLjE1LC0zLjA5LC0wLjA2LC0zLjk2XSxbJ2MnLDAuMzMsLTIuNjcsMS4zOCwtNS4wNywzLjEyLC03LjA4XSxbJ2MnLDAuMzYsLTAuNDIsMC45OSwtMS4wNSwxLjE3LC0xLjE0XSxbJ3onXSxbJ20nLDIuMDEsNC43MV0sWydjJywtMC4xNSwtMC4zMCwtMC4zMCwtMC41NCwtMC4zMCwtMC41NF0sWydjJywtMC4wMywwLjAwLC0wLjE4LDAuMDksLTAuMzAsMC4yMV0sWydjJywtMi40MCwxLjc0LC0zLjg3LDQuMjAsLTQuMjYsNy4xMV0sWydjJywtMC4wNiwwLjU0LC0wLjA2LDEuNDEsLTAuMDMsMS44OV0sWydjJywwLjA5LDEuMjksMC40OCwzLjEyLDEuMDgsNS4yMl0sWydjJywwLjE1LDAuNDIsMC4yNCwwLjc4LDAuMjQsMC44MV0sWydjJywwLjAwLDAuMDMsMC44NCwtMS4xMSwxLjIzLC0xLjY4XSxbJ2MnLDEuODksLTIuNzMsMi44OCwtNS4wNywzLjE1LC03LjUzXSxbJ2MnLDAuMDksLTAuNTcsMC4xMiwtMS43NCwwLjA2LC0yLjM3XSxbJ2MnLC0wLjA5LC0xLjIzLC0wLjI3LC0xLjkyLC0wLjg3LC0zLjEyXSxbJ3onXSxbJ20nLC0yLjk0LDIwLjcwXSxbJ2MnLC0wLjIxLC0wLjcyLC0wLjM5LC0xLjMyLC0wLjQyLC0xLjMyXSxbJ2MnLDAuMDAsMC4wMCwtMS4yMCwxLjQ3LC0xLjg2LDIuMzddLFsnYycsLTIuNzksMy42MywtNC4wMiw2LjMwLC00LjM1LDkuMzBdLFsnYycsLTAuMDMsMC4yMSwtMC4wMywwLjY5LC0wLjAzLDEuMDhdLFsnYycsMC4wMCwwLjY5LDAuMDAsMC43NSwwLjA2LDEuMTFdLFsnYycsMC4xMiwwLjU0LDAuMjcsMC45OSwwLjUxLDEuNDddLFsnYycsMC42OSwxLjM4LDEuODMsMi41NSwzLjQyLDMuNDJdLFsnYycsMC45NiwwLjU0LDIuMDcsMC45MCwzLjIxLDEuMDhdLFsnYycsMC43OCwwLjEyLDIuMDQsMC4xMiwyLjk0LC0wLjAzXSxbJ2MnLDAuNTEsLTAuMDYsMC40NSwtMC4wMywwLjQyLC0wLjMwXSxbJ2MnLC0wLjI0LC0zLjMzLC0wLjcyLC02LjMzLC0xLjYyLC0xMC4wOF0sWydjJywtMC4wOSwtMC4zOSwtMC4xOCwtMC43NSwtMC4xOCwtMC43OF0sWydjJywtMC4wMywtMC4wMywtMC40MiwwLjAwLC0wLjgxLDAuMDldLFsnYycsLTAuOTAsMC4xOCwtMS42NSwwLjU3LC0yLjIyLDEuMTRdLFsnYycsLTAuNzIsMC43MiwtMS4wOCwxLjY1LC0xLjA1LDIuNjRdLFsnYycsMC4wNiwwLjk2LDAuNDgsMS44MywxLjIzLDIuNThdLFsnYycsMC4zNiwwLjM2LDAuNzIsMC42MywxLjE3LDAuOTBdLFsnYycsMC4zMywwLjE4LDAuMzYsMC4yMSwwLjQyLDAuMzNdLFsnYycsMC4xOCwwLjQyLC0wLjE4LDAuOTAsLTAuNjAsMC44N10sWydjJywtMC4xOCwtMC4wMywtMC44NCwtMC4zNiwtMS4yNiwtMC42M10sWydjJywtMC43OCwtMC41MSwtMS4zOCwtMS4xMSwtMS44NiwtMS44M10sWydjJywtMS43NywtMi43MCwtMC45OSwtNi40MiwxLjcxLC04LjE5XSxbJ2MnLDAuMzAsLTAuMjEsMC44MSwtMC40OCwxLjE3LC0wLjYzXSxbJ2MnLDAuMzAsLTAuMDksMS4wMiwtMC4zMCwxLjE0LC0wLjMwXSxbJ2MnLDAuMDYsMC4wMCwwLjA5LDAuMDAsMC4wOSwtMC4wM10sWydjJywwLjAzLC0wLjAzLC0wLjUxLC0xLjkyLC0xLjIzLC00LjI2XSxbJ3onXSxbJ20nLDMuNzgsNy40MV0sWydjJywtMC4xOCwtMC4wMywtMC4zNiwtMC4wNiwtMC4zOSwtMC4wNl0sWydjJywtMC4wMywwLjAwLDAuMDAsMC4yMSwwLjE4LDEuMDJdLFsnYycsMC43NSwzLjE4LDEuMjYsNi4zMCwxLjUwLDkuMDldLFsnYycsMC4wNiwwLjcyLDAuMDAsMC42OSwwLjUxLDAuNDJdLFsnYycsMC43OCwtMC4zNiwxLjQ0LC0wLjk2LDEuOTgsLTEuNzddLFsnYycsMS4wOCwtMS42MiwxLjIwLC0zLjY5LDAuMzAsLTUuNTVdLFsnYycsLTAuODEsLTEuNjIsLTIuMzEsLTIuNzksLTQuMDgsLTMuMTVdLFsneiddXSx3OjE5LjA1MSxoOjU3LjA1N30sXG5cdFx0J2NsZWZzLnBlcmMnOntkOltbJ00nLDUuMDcsLTcuNDRdLFsnbCcsMC4wOSwtMC4wNl0sWydsJywxLjUzLDAuMDBdLFsnbCcsMS41MywwLjAwXSxbJ2wnLDAuMDksMC4wNl0sWydsJywwLjA2LDAuMDldLFsnbCcsMC4wMCw3LjM1XSxbJ2wnLDAuMDAsNy4zMl0sWydsJywtMC4wNiwwLjA5XSxbJ2wnLC0wLjA5LDAuMDZdLFsnbCcsLTEuNTMsMC4wMF0sWydsJywtMS41MywwLjAwXSxbJ2wnLC0wLjA5LC0wLjA2XSxbJ2wnLC0wLjA2LC0wLjA5XSxbJ2wnLDAuMDAsLTcuMzJdLFsnbCcsMC4wMCwtNy4zNV0sWyd6J10sWydtJyw2LjYzLDAuMDBdLFsnbCcsMC4wOSwtMC4wNl0sWydsJywxLjUzLDAuMDBdLFsnbCcsMS41MywwLjAwXSxbJ2wnLDAuMDksMC4wNl0sWydsJywwLjA2LDAuMDldLFsnbCcsMC4wMCw3LjM1XSxbJ2wnLDAuMDAsNy4zMl0sWydsJywtMC4wNiwwLjA5XSxbJ2wnLC0wLjA5LDAuMDZdLFsnbCcsLTEuNTMsMC4wMF0sWydsJywtMS41MywwLjAwXSxbJ2wnLC0wLjA5LC0wLjA2XSxbJ2wnLC0wLjA2LC0wLjA5XSxbJ2wnLDAuMDAsLTcuMzJdLFsnbCcsMC4wMCwtNy4zNV0sWyd6J11dLHc6OS45OSxoOjE0Ljk3fSxcblx0XHQndGltZXNpZy5jb21tb24nOntkOltbJ00nLDYuNjYsLTcuODNdLFsnYycsMC43MiwtMC4wNiwxLjQxLC0wLjAzLDEuOTgsMC4wOV0sWydjJywxLjIwLDAuMjcsMi4zNCwwLjk2LDMuMDksMS45Ml0sWydjJywwLjYzLDAuODEsMS4wOCwxLjg2LDEuMTQsMi43M10sWydjJywwLjA2LDEuMDIsLTAuNTEsMS45MiwtMS40NCwyLjIyXSxbJ2MnLC0wLjI0LDAuMDksLTAuMzAsMC4wOSwtMC42MywwLjA5XSxbJ2MnLC0wLjMzLDAuMDAsLTAuNDIsMC4wMCwtMC42MywtMC4wNl0sWydjJywtMC42NiwtMC4yNCwtMS4xNCwtMC42MywtMS40MSwtMS4yMF0sWydjJywtMC4xNSwtMC4zMCwtMC4yMSwtMC41MSwtMC4yNCwtMC45MF0sWydjJywtMC4wNiwtMS4wOCwwLjU3LC0yLjA0LDEuNTYsLTIuMzddLFsnYycsMC4xOCwtMC4wNiwwLjI3LC0wLjA2LDAuNjMsLTAuMDZdLFsnbCcsMC40NSwwLjAwXSxbJ2MnLDAuMDYsMC4wMywwLjA5LDAuMDMsMC4wOSwwLjAwXSxbJ2MnLDAuMDAsMC4wMCwtMC4wOSwtMC4xMiwtMC4yNCwtMC4yN10sWydjJywtMS4wMiwtMS4xMSwtMi41NSwtMS42OCwtNC4wOCwtMS41MF0sWydjJywtMS4yOSwwLjE1LC0yLjA0LDAuNjksLTIuNDAsMS43NF0sWydjJywtMC4zNiwwLjkzLC0wLjQyLDEuODksLTAuNDIsNS4zN10sWydjJywwLjAwLDIuOTcsMC4wNiwzLjk2LDAuMjQsNC43N10sWydjJywwLjI0LDEuMDgsMC42MywxLjY4LDEuNDEsMi4wN10sWydjJywwLjgxLDAuMzksMi4xNiwwLjQ1LDMuMTgsMC4wOV0sWydjJywxLjI5LC0wLjQ1LDIuMzcsLTEuNTMsMy4wMywtMi45N10sWydjJywwLjE1LC0wLjMzLDAuMzMsLTAuODcsMC4zOSwtMS4xN10sWydjJywwLjA5LC0wLjI0LDAuMTUsLTAuMzYsMC4zMCwtMC4zOV0sWydjJywwLjIxLC0wLjAzLDAuNDIsMC4xNSwwLjM5LDAuMzZdLFsnYycsLTAuMDYsMC4zOSwtMC40MiwxLjM4LC0wLjY5LDEuODldLFsnYycsLTAuOTYsMS44MCwtMi40OSwyLjk0LC00LjIzLDMuMThdLFsnYycsLTAuOTksMC4xMiwtMi41OCwtMC4wNiwtMy42MywtMC40NV0sWydjJywtMC45NiwtMC4zNiwtMS43MSwtMC44NCwtMi40MCwtMS41MF0sWydjJywtMS4xMSwtMS4xMSwtMS44MCwtMi42MSwtMi4wNCwtNC41Nl0sWydjJywtMC4wNiwtMC42MCwtMC4wNiwtMi4wMSwwLjAwLC0yLjYxXSxbJ2MnLDAuMjQsLTEuOTUsMC45MCwtMy40NSwyLjAxLC00LjU2XSxbJ2MnLDAuNjksLTAuNjYsMS40NCwtMS4xMSwyLjM3LC0xLjQ3XSxbJ2MnLDAuNjMsLTAuMjQsMS40NywtMC40MiwyLjIyLC0wLjQ4XSxbJ3onXV0sdzoxMy4wMzgsaDoxNS42ODl9LFxuXHRcdCd0aW1lc2lnLmN1dCc6e2Q6W1snTScsNi4yNCwtMTAuNDRdLFsnYycsMC4wOSwtMC4wNiwwLjA5LC0wLjA2LDAuNDgsLTAuMDZdLFsnYycsMC4zNiwwLjAwLDAuMzYsMC4wMCwwLjQ1LDAuMDZdLFsnbCcsMC4wNiwwLjA5XSxbJ2wnLDAuMDAsMS4yM10sWydsJywwLjAwLDEuMjZdLFsnbCcsMC4yNywwLjAwXSxbJ2MnLDEuMjYsMC4wMCwyLjQ5LDAuNDUsMy40OCwxLjI5XSxbJ2MnLDEuMDUsMC44NywxLjgwLDIuMjgsMS44OSwzLjQ4XSxbJ2MnLDAuMDYsMS4wMiwtMC41MSwxLjkyLC0xLjQ0LDIuMjJdLFsnYycsLTAuMjQsMC4wOSwtMC4zMCwwLjA5LC0wLjYzLDAuMDldLFsnYycsLTAuMzMsMC4wMCwtMC40MiwwLjAwLC0wLjYzLC0wLjA2XSxbJ2MnLC0wLjY2LC0wLjI0LC0xLjE0LC0wLjYzLC0xLjQxLC0xLjIwXSxbJ2MnLC0wLjE1LC0wLjMwLC0wLjIxLC0wLjUxLC0wLjI0LC0wLjkwXSxbJ2MnLC0wLjA2LC0xLjA4LDAuNTcsLTIuMDQsMS41NiwtMi4zN10sWydjJywwLjE4LC0wLjA2LDAuMjcsLTAuMDYsMC42MywtMC4wNl0sWydsJywwLjQ1LDAuMDBdLFsnYycsMC4wNiwwLjAzLDAuMDksMC4wMywwLjA5LDAuMDBdLFsnYycsMC4wMCwtMC4wMywtMC40NSwtMC41MSwtMC42NiwtMC42OV0sWydjJywtMC44NywtMC42OSwtMS44MywtMS4wNSwtMi45NCwtMS4xMV0sWydsJywtMC40MiwwLjAwXSxbJ2wnLDAuMDAsNy4xN10sWydsJywwLjAwLDcuMTRdLFsnbCcsMC40MiwwLjAwXSxbJ2MnLDAuNjksLTAuMDMsMS4yMywtMC4xOCwxLjg2LC0wLjUxXSxbJ2MnLDEuMDUsLTAuNTEsMS44OSwtMS40NywyLjQ2LC0yLjcwXSxbJ2MnLDAuMTUsLTAuMzMsMC4zMywtMC44NywwLjM5LC0xLjE3XSxbJ2MnLDAuMDksLTAuMjQsMC4xNSwtMC4zNiwwLjMwLC0wLjM5XSxbJ2MnLDAuMjEsLTAuMDMsMC40MiwwLjE1LDAuMzksMC4zNl0sWydjJywtMC4wMywwLjI0LC0wLjIxLDAuNzgsLTAuMzksMS4yMF0sWydjJywtMC45NiwyLjM3LC0yLjk0LDMuOTAsLTUuMTMsMy45MF0sWydsJywtMC4zMCwwLjAwXSxbJ2wnLDAuMDAsMS4yNl0sWydsJywwLjAwLDEuMjNdLFsnbCcsLTAuMDYsMC4wOV0sWydjJywtMC4wOSwwLjA2LC0wLjA5LDAuMDYsLTAuNDUsMC4wNl0sWydjJywtMC4zOSwwLjAwLC0wLjM5LDAuMDAsLTAuNDgsLTAuMDZdLFsnbCcsLTAuMDYsLTAuMDldLFsnbCcsMC4wMCwtMS4yOV0sWydsJywwLjAwLC0xLjI5XSxbJ2wnLC0wLjIxLC0wLjAzXSxbJ2MnLC0xLjIzLC0wLjIxLC0yLjMxLC0wLjYzLC0zLjIxLC0xLjI5XSxbJ2MnLC0wLjE1LC0wLjA5LC0wLjQ1LC0wLjM2LC0wLjY2LC0wLjU3XSxbJ2MnLC0xLjExLC0xLjExLC0xLjgwLC0yLjYxLC0yLjA0LC00LjU2XSxbJ2MnLC0wLjA2LC0wLjYwLC0wLjA2LC0yLjAxLDAuMDAsLTIuNjFdLFsnYycsMC4yNCwtMS45NSwwLjkzLC0zLjQ1LDIuMDQsLTQuNTldLFsnYycsMC40MiwtMC4zOSwwLjc4LC0wLjY2LDEuMjYsLTAuOTNdLFsnYycsMC43NSwtMC40NSwxLjY1LC0wLjc1LDIuNjEsLTAuOTBdLFsnbCcsMC4yMSwtMC4wM10sWydsJywwLjAwLC0xLjI5XSxbJ2wnLDAuMDAsLTEuMjldLFsneiddLFsnbScsLTAuMDYsMTAuNDRdLFsnYycsMC4wMCwtNS41OCwwLjAwLC02Ljk5LC0wLjAzLC02Ljk5XSxbJ2MnLC0wLjE1LDAuMDAsLTAuNjMsMC4yNywtMC44NywwLjQ1XSxbJ2MnLC0wLjQ1LDAuMzYsLTAuNzUsMC45MywtMC45MywxLjc3XSxbJ2MnLC0wLjE4LDAuODEsLTAuMjQsMS44MCwtMC4yNCw0Ljc0XSxbJ2MnLDAuMDAsMi45NywwLjA2LDMuOTYsMC4yNCw0Ljc3XSxbJ2MnLDAuMjQsMS4wOCwwLjY2LDEuNjgsMS40MSwyLjA3XSxbJ2MnLDAuMTIsMC4wNiwwLjMwLDAuMTIsMC4zMywwLjE1XSxbJ2wnLDAuMDksMC4wMF0sWydsJywwLjAwLC02Ljk2XSxbJ3onXV0sdzoxMy4wMzgsaDoyMC45N30sXG5cdFx0J3RpbWVzaWcuaW1wZXJmZWN0dW0nOntkOltbJ00nLDEzLC01XSxbJ2EnLDgsOCwwLDEsMCwwLDEwXV0sdzoxMy4wMzgsaDoyMC45N30sXG5cdFx0J3RpbWVzaWcuaW1wZXJmZWN0dW0yJzp7ZDpbWydNJywxMywtNV0sWydhJyw4LDgsMCwxLDAsMCwxMF1dLHc6MTMuMDM4LGg6MjAuOTd9LFxuXHRcdCd0aW1lc2lnLnBlcmZlY3R1bSc6e2Q6W1snTScsMTMsLTVdLFsnYScsOCw4LDAsMSwwLDAsMTBdXSx3OjEzLjAzOCxoOjIwLjk3fSxcblx0XHQndGltZXNpZy5wZXJmZWN0dW0yJzp7ZDpbWydNJywxMywtNV0sWydhJyw4LDgsMCwxLDAsMCwxMF1dLHc6MTMuMDM4LGg6MjAuOTd9LFxuXHRcdCdmJzp7ZDpbWydNJyw5LjkzLC0xNC4yOF0sWydjJywxLjUzLC0wLjE4LDIuODgsMC40NSwzLjEyLDEuNTBdLFsnYycsMC4xMiwwLjUxLDAuMDAsMS4zMiwtMC4yNywxLjg2XSxbJ2MnLC0wLjE1LDAuMzAsLTAuNDIsMC41NywtMC42MywwLjY5XSxbJ2MnLC0wLjY5LDAuMzYsLTEuNTYsMC4wMywtMS44MywtMC42OV0sWydjJywtMC4wOSwtMC4yNCwtMC4wOSwtMC42OSwwLjAwLC0wLjg3XSxbJ2MnLDAuMDYsLTAuMTIsMC4yMSwtMC4yNCwwLjQ1LC0wLjQyXSxbJ2MnLDAuNDIsLTAuMjQsMC41NywtMC40NSwwLjYwLC0wLjcyXSxbJ2MnLDAuMDMsLTAuMzMsLTAuMDksLTAuMzksLTAuNjMsLTAuNDJdLFsnYycsLTAuMzAsMC4wMCwtMC40NSwwLjAwLC0wLjYwLDAuMDNdLFsnYycsLTAuODEsMC4yMSwtMS4zNSwwLjkzLC0xLjc0LDIuNDZdLFsnYycsLTAuMDYsMC4yNywtMC40OCwyLjI1LC0wLjQ4LDIuMzFdLFsnYycsMC4wMCwwLjAzLDAuMzksMC4wMywwLjkwLDAuMDNdLFsnYycsMC43MiwwLjAwLDAuOTAsMC4wMCwwLjk5LDAuMDZdLFsnYycsMC40MiwwLjE1LDAuNDUsMC43MiwwLjAzLDAuOTBdLFsnYycsLTAuMTIsMC4wNiwtMC4yNCwwLjA2LC0xLjE3LDAuMDZdLFsnbCcsLTEuMDUsMC4wMF0sWydsJywtMC43OCwyLjU1XSxbJ2MnLC0wLjQ1LDEuNDEsLTAuODcsMi43OSwtMC45NiwzLjA2XSxbJ2MnLC0wLjg3LDIuMzcsLTIuMzcsNC43NCwtMy43OCw1LjkxXSxbJ2MnLC0xLjA1LDAuOTAsLTIuMDQsMS4yMywtMy4wOSwxLjA4XSxbJ2MnLC0xLjExLC0wLjE4LC0xLjg5LC0wLjc4LC0yLjA0LC0xLjU5XSxbJ2MnLC0wLjEyLC0wLjY2LDAuMTUsLTEuNzEsMC41NCwtMi4xOV0sWydjJywwLjY5LC0wLjc1LDEuODYsLTAuNTQsMi4yMiwwLjM5XSxbJ2MnLDAuMDYsMC4xNSwwLjA5LDAuMjcsMC4wOSwwLjQ4XSxbJ2MnLDAuMDAsMC4yNCwtMC4wMywwLjI3LC0wLjEyLDAuNDJdLFsnYycsLTAuMDMsMC4wOSwtMC4xNSwwLjE4LC0wLjI3LDAuMjddLFsnYycsLTAuMDksMC4wNiwtMC4yNywwLjIxLC0wLjM2LDAuMjddLFsnYycsLTAuMjQsMC4xOCwtMC4zNiwwLjM2LC0wLjM5LDAuNjBdLFsnYycsLTAuMDMsMC4zMywwLjA5LDAuMzksMC42MywwLjQyXSxbJ2MnLDAuNDIsMC4wMCwwLjYzLC0wLjAzLDAuOTAsLTAuMTVdLFsnYycsMC42MCwtMC4zMCwwLjk2LC0wLjk2LDEuMzgsLTIuNjRdLFsnYycsMC4wOSwtMC40MiwwLjYzLC0yLjU1LDEuMTcsLTQuNzddLFsnbCcsMS4wMiwtNC4wOF0sWydjJywwLjAwLC0wLjAzLC0wLjM2LC0wLjAzLC0wLjgxLC0wLjAzXSxbJ2MnLC0wLjcyLDAuMDAsLTAuODEsMC4wMCwtMC45MywtMC4wNl0sWydjJywtMC40MiwtMC4xOCwtMC4zOSwtMC43NSwwLjAzLC0wLjkwXSxbJ2MnLDAuMDksLTAuMDYsMC4yNywtMC4wNiwxLjA1LC0wLjA2XSxbJ2wnLDAuOTYsMC4wMF0sWydsJywwLjAwLC0wLjA5XSxbJ2MnLDAuMDYsLTAuMTgsMC4zMCwtMC43MiwwLjUxLC0xLjE3XSxbJ2MnLDEuMjAsLTIuNDYsMy4zMCwtNC4yMyw1LjM0LC00LjUwXSxbJ3onXV0sdzoxNi4xNTUsaDoxOS40NDV9LFxuXHRcdCdtJzp7ZDpbWydNJywyLjc5LC04LjkxXSxbJ2MnLDAuMDksMC4wMCwwLjMwLC0wLjAzLDAuNDUsLTAuMDNdLFsnYycsMC4yNCwwLjAzLDAuMzAsMC4wMywwLjQ1LDAuMTJdLFsnYycsMC4zNiwwLjE1LDAuNjMsMC41NCwwLjc1LDEuMDJdLFsnbCcsMC4wMywwLjIxXSxbJ2wnLDAuMzMsLTAuMzBdLFsnYycsMC42OSwtMC42OSwxLjM4LC0xLjAyLDIuMDcsLTEuMDJdLFsnYycsMC4yNywwLjAwLDAuMzMsMC4wMCwwLjQ4LDAuMDZdLFsnYycsMC4yMSwwLjA5LDAuNDgsMC4zNiwwLjYzLDAuNjBdLFsnYycsMC4wMywwLjA5LDAuMTIsMC4yNywwLjE4LDAuNDJdLFsnYycsMC4wMywwLjE1LDAuMDksMC4yNywwLjEyLDAuMjddLFsnYycsMC4wMCwwLjAwLDAuMDksLTAuMDksMC4xOCwtMC4yMV0sWydjJywwLjMzLC0wLjM5LDAuODcsLTAuODEsMS4yOSwtMC45OV0sWydjJywwLjc4LC0wLjMzLDEuNDcsLTAuMjEsMi4wMSwwLjMzXSxbJ2MnLDAuMzAsMC4zMywwLjQ4LDAuNjksMC42MCwxLjE0XSxbJ2MnLDAuMDksMC40MiwwLjA2LDAuNTQsLTAuNTQsMy4wNl0sWydjJywtMC4zMywxLjI5LC0wLjU3LDIuNDAsLTAuNTcsMi40M10sWydjJywwLjAwLDAuMTIsMC4wOSwwLjIxLDAuMjEsMC4yMV0sWydjJywwLjI0LDAuMDAsMC43NSwtMC4zMCwxLjIwLC0wLjcyXSxbJ2MnLDAuNDUsLTAuMzksMC42MCwtMC40NSwwLjc4LC0wLjI3XSxbJ2MnLDAuMTgsMC4xOCwwLjA5LDAuMzYsLTAuNDUsMC44N10sWydjJywtMS4wNSwwLjk2LC0xLjgzLDEuNDcsLTIuNTgsMS43MV0sWydjJywtMC45MywwLjMzLC0xLjUzLDAuMjEsLTEuODAsLTAuMzNdLFsnYycsLTAuMDYsLTAuMTUsLTAuMDYsLTAuMjEsLTAuMDYsLTAuNDVdLFsnYycsMC4wMCwtMC4yNCwwLjAzLC0wLjQ4LDAuNjAsLTIuODJdLFsnYycsMC40MiwtMS43MSwwLjYwLC0yLjY0LDAuNjMsLTIuNzldLFsnYycsMC4wMywtMC41NywtMC4zMCwtMC43NSwtMC44NCwtMC40OF0sWydjJywtMC4yNCwwLjEyLC0wLjU0LDAuMzksLTAuNjYsMC42M10sWydjJywtMC4wMywwLjA5LC0wLjQyLDEuMzgsLTAuOTAsMy4wMF0sWydjJywtMC45MCwzLjE1LC0wLjg0LDMuMDAsLTEuMTQsMy4xNV0sWydsJywtMC4xNSwwLjA5XSxbJ2wnLC0wLjc4LDAuMDBdLFsnYycsLTAuNjAsMC4wMCwtMC43OCwwLjAwLC0wLjg0LC0wLjA2XSxbJ2MnLC0wLjA5LC0wLjAzLC0wLjE4LC0wLjE4LC0wLjE4LC0wLjI3XSxbJ2MnLDAuMDAsLTAuMDMsMC4zNiwtMS4zOCwwLjg0LC0yLjk3XSxbJ2MnLDAuNTcsLTIuMDQsMC44MSwtMi45NywwLjg0LC0zLjEyXSxbJ2MnLDAuMDMsLTAuNTQsLTAuMzAsLTAuNzIsLTAuODQsLTAuNDVdLFsnYycsLTAuMjQsMC4xMiwtMC41NywwLjQyLC0wLjY2LDAuNjNdLFsnYycsLTAuMDYsMC4wOSwtMC41MSwxLjQ0LC0xLjA1LDIuOTddLFsnYycsLTAuNTEsMS41NiwtMC45OSwyLjg1LC0wLjk5LDIuOTFdLFsnYycsLTAuMDYsMC4xMiwtMC4yMSwwLjI0LC0wLjM2LDAuMzBdLFsnYycsLTAuMTIsMC4wNiwtMC4yMSwwLjA2LC0wLjkwLDAuMDZdLFsnYycsLTAuNjAsMC4wMCwtMC43OCwwLjAwLC0wLjg0LC0wLjA2XSxbJ2MnLC0wLjA5LC0wLjAzLC0wLjE4LC0wLjE4LC0wLjE4LC0wLjI3XSxbJ2MnLDAuMDAsLTAuMDMsMC40NSwtMS4zOCwwLjk5LC0yLjk3XSxbJ2MnLDEuMDUsLTMuMTgsMS4wNSwtMy4xOCwwLjkzLC0zLjQ1XSxbJ2MnLC0wLjEyLC0wLjI3LC0wLjM5LC0wLjMwLC0wLjcyLC0wLjE1XSxbJ2MnLC0wLjU0LDAuMjcsLTEuMTQsMS4xNywtMS41NiwyLjQwXSxbJ2MnLC0wLjA2LDAuMTUsLTAuMTUsMC4zMCwtMC4xOCwwLjM2XSxbJ2MnLC0wLjIxLDAuMjEsLTAuNTcsMC4yNywtMC43MiwwLjA5XSxbJ2MnLC0wLjA5LC0wLjA5LC0wLjA2LC0wLjIxLDAuMDYsLTAuNjNdLFsnYycsMC40OCwtMS4yNiwxLjI2LC0yLjQ2LDIuMDEsLTMuMjFdLFsnYycsMC41NywtMC41NCwxLjIwLC0wLjg3LDEuODMsLTEuMDJdLFsneiddXSx3OjE0LjY4NyxoOjkuMTI2fSxcblx0XHQncCc6e2Q6W1snTScsMS45MiwtOC43MF0sWydjJywwLjI3LC0wLjA5LDAuODEsLTAuMDYsMS4xMSwwLjAzXSxbJ2MnLDAuNTQsMC4xOCwwLjkzLDAuNTEsMS4xNywwLjk5XSxbJ2MnLDAuMDksMC4xNSwwLjE1LDAuMzMsMC4xOCwwLjM2XSxbJ2wnLDAuMDAsMC4xMl0sWydsJywwLjMwLC0wLjI3XSxbJ2MnLDAuNjYsLTAuNjAsMS4zNSwtMS4wMiwyLjEzLC0xLjIwXSxbJ2MnLDAuMjEsLTAuMDYsMC4zMywtMC4wNiwwLjc4LC0wLjA2XSxbJ2MnLDAuNDUsMC4wMCwwLjUxLDAuMDAsMC44NCwwLjA5XSxbJ2MnLDEuMjksMC4zMywyLjA3LDEuMzIsMi4yNSwyLjc5XSxbJ2MnLDAuMDksMC44MSwtMC4wOSwyLjAxLC0wLjQ1LDIuNzldLFsnYycsLTAuNTQsMS4yNiwtMS44NiwyLjU1LC0zLjE4LDMuMDNdLFsnYycsLTAuNDUsMC4xOCwtMC44MSwwLjI0LC0xLjI5LDAuMjRdLFsnYycsLTAuNjksLTAuMDMsLTEuMzUsLTAuMTgsLTEuODYsLTAuNDVdLFsnYycsLTAuMzAsLTAuMTUsLTAuNTEsLTAuMTgsLTAuNjksLTAuMDldLFsnYycsLTAuMDksMC4wMywtMC4xOCwwLjA5LC0wLjE4LDAuMTJdLFsnYycsLTAuMDksMC4xMiwtMS4wNSwyLjk0LC0xLjA1LDMuMDZdLFsnYycsMC4wMCwwLjI0LDAuMTgsMC40OCwwLjUxLDAuNjNdLFsnYycsMC4xOCwwLjA2LDAuNTQsMC4xNSwwLjc1LDAuMTVdLFsnYycsMC4yMSwwLjAwLDAuMzYsMC4wNiwwLjQyLDAuMThdLFsnYycsMC4xMiwwLjE4LDAuMDYsMC40MiwtMC4xMiwwLjU0XSxbJ2MnLC0wLjA5LDAuMDMsLTAuMTUsMC4wMywtMC43OCwwLjAwXSxbJ2MnLC0xLjk4LC0wLjE1LC0zLjgxLC0wLjE1LC01Ljc5LDAuMDBdLFsnYycsLTAuNjMsMC4wMywtMC42OSwwLjAzLC0wLjc4LDAuMDBdLFsnYycsLTAuMjQsLTAuMTUsLTAuMjQsLTAuNTcsMC4wMywtMC42Nl0sWydjJywwLjA2LC0wLjAzLDAuNDgsLTAuMDksMC45OSwtMC4xMl0sWydjJywwLjg3LC0wLjA2LDEuMTEsLTAuMDksMS4zNSwtMC4yMV0sWydjJywwLjE4LC0wLjA2LDAuMzMsLTAuMTgsMC4zOSwtMC4zMF0sWydjJywwLjA2LC0wLjEyLDMuMjQsLTkuNDIsMy4yNywtOS42MF0sWydjJywwLjA2LC0wLjMzLDAuMDMsLTAuNTcsLTAuMTUsLTAuNjldLFsnYycsLTAuMDksLTAuMDYsLTAuMTIsLTAuMDYsLTAuMzAsLTAuMDZdLFsnYycsLTAuNjksMC4wNiwtMS41MywxLjAyLC0yLjI4LDIuNjFdLFsnYycsLTAuMDksMC4yMSwtMC4yMSwwLjQ1LC0wLjI3LDAuNTFdLFsnYycsLTAuMDksMC4xMiwtMC4zMywwLjI0LC0wLjQ4LDAuMjRdLFsnYycsLTAuMTgsMC4wMCwtMC4zNiwtMC4xNSwtMC4zNiwtMC4zMF0sWydjJywwLjAwLC0wLjI0LDAuNzgsLTEuODMsMS4yNiwtMi41NV0sWydjJywwLjcyLC0xLjExLDEuNDcsLTEuNzQsMi4yOCwtMS45Ml0sWyd6J10sWydtJyw1LjM3LDEuNDddLFsnYycsLTAuMjcsLTAuMTIsLTAuNzUsLTAuMDMsLTEuMTQsMC4yMV0sWydjJywtMC43NSwwLjQ4LC0xLjQ3LDEuNjgsLTEuODksMy4xNV0sWydjJywtMC40NSwxLjQ3LC0wLjQyLDIuMzQsMC4wMCwyLjcwXSxbJ2MnLDAuNDUsMC4zOSwxLjI2LDAuMjEsMS44MywtMC4zNl0sWydjJywwLjUxLC0wLjUxLDAuOTksLTEuNjgsMS4zOCwtMy4yN10sWydjJywwLjMwLC0xLjE3LDAuMzMsLTEuNzQsMC4xNSwtMi4xM10sWydjJywtMC4wOSwtMC4xNSwtMC4xNSwtMC4yMSwtMC4zMywtMC4zMF0sWyd6J11dLHc6MTQuNjg5LGg6MTMuMTI3fSxcblx0XHQncic6e2Q6W1snTScsNi4zMywtOS4xMl0sWydjJywwLjI3LC0wLjAzLDAuOTMsMC4wMCwxLjIwLDAuMDZdLFsnYycsMC44NCwwLjIxLDEuMjMsMC44MSwxLjAyLDEuNTNdLFsnYycsLTAuMjQsMC43NSwtMC45MCwxLjE3LC0xLjU2LDAuOTZdLFsnYycsLTAuMzMsLTAuMDksLTAuNTEsLTAuMzAsLTAuNjYsLTAuNzVdLFsnYycsLTAuMDMsLTAuMTIsLTAuMDksLTAuMjQsLTAuMTIsLTAuMzBdLFsnYycsLTAuMDksLTAuMTUsLTAuMzAsLTAuMjQsLTAuNDgsLTAuMjRdLFsnYycsLTAuNTcsMC4wMCwtMS4zOCwwLjU0LC0xLjY1LDEuMDhdLFsnYycsLTAuMDYsMC4xNSwtMC4zMywxLjE3LC0wLjkwLDMuMjddLFsnYycsLTAuNTcsMi4zMSwtMC44MSwzLjEyLC0wLjg3LDMuMjFdLFsnYycsLTAuMDMsMC4wNiwtMC4xMiwwLjE1LC0wLjE4LDAuMjFdLFsnbCcsLTAuMTIsMC4wNl0sWydsJywtMC44MSwwLjAzXSxbJ2MnLC0wLjY5LDAuMDAsLTAuODEsMC4wMCwtMC45MCwtMC4wM10sWydjJywtMC4wOSwtMC4wNiwtMC4xOCwtMC4yMSwtMC4xOCwtMC4zMF0sWydjJywwLjAwLC0wLjA2LDAuMzksLTEuNjIsMC45MCwtMy41MV0sWydjJywwLjg0LC0zLjI0LDAuODcsLTMuNDUsMC44NywtMy43Ml0sWydjJywwLjAwLC0wLjIxLDAuMDAsLTAuMjcsLTAuMDMsLTAuMzZdLFsnYycsLTAuMTIsLTAuMTUsLTAuMjEsLTAuMjQsLTAuNDIsLTAuMjRdLFsnYycsLTAuMjQsMC4wMCwtMC40NSwwLjE1LC0wLjc4LDAuNDJdLFsnYycsLTAuMzMsMC4zNiwtMC40NSwwLjU0LC0wLjcyLDEuMTRdLFsnYycsLTAuMDMsMC4xMiwtMC4yMSwwLjI0LC0wLjM2LDAuMjddLFsnYycsLTAuMTIsMC4wMCwtMC4xNSwwLjAwLC0wLjI0LC0wLjA2XSxbJ2MnLC0wLjE4LC0wLjEyLC0wLjE4LC0wLjIxLC0wLjA2LC0wLjU0XSxbJ2MnLDAuMjEsLTAuNTcsMC40MiwtMC45MywwLjc4LC0xLjMyXSxbJ2MnLDAuNTQsLTAuNTEsMS4yMCwtMC44MSwxLjk1LC0wLjg3XSxbJ2MnLDAuODEsLTAuMDMsMS41MywwLjMwLDEuOTIsMC44N10sWydsJywwLjEyLDAuMThdLFsnbCcsMC4wOSwtMC4wOV0sWydjJywwLjU3LC0wLjQ1LDEuNDEsLTAuODQsMi4xOSwtMC45Nl0sWyd6J11dLHc6OS40MSxoOjkuMTMyfSxcblx0XHQncyc6e2Q6W1snTScsNC40NywtOC43M10sWydjJywwLjA5LDAuMDAsMC4zNiwtMC4wMywwLjU3LC0wLjAzXSxbJ2MnLDAuNzUsMC4wMywxLjI5LDAuMjQsMS43MSwwLjYzXSxbJ2MnLDAuNTEsMC41NCwwLjY2LDEuMjYsMC4zNiwxLjgzXSxbJ2MnLC0wLjI0LDAuNDIsLTAuNjMsMC41NywtMS4xMSwwLjQyXSxbJ2MnLC0wLjMzLC0wLjA5LC0wLjYwLC0wLjM2LC0wLjYwLC0wLjU3XSxbJ2MnLDAuMDAsLTAuMDMsMC4wNiwtMC4yMSwwLjE1LC0wLjM5XSxbJ2MnLDAuMTIsLTAuMjEsMC4xNSwtMC4zMywwLjE4LC0wLjQ4XSxbJ2MnLDAuMDAsLTAuMjQsLTAuMDYsLTAuNDgsLTAuMTUsLTAuNjBdLFsnYycsLTAuMTUsLTAuMjEsLTAuNDIsLTAuMjQsLTAuNzUsLTAuMTVdLFsnYycsLTAuMjcsMC4wNiwtMC40OCwwLjE4LC0wLjY5LDAuMzZdLFsnYycsLTAuMzksMC4zOSwtMC41MSwwLjk2LC0wLjMzLDEuMzhdLFsnYycsMC4wOSwwLjIxLDAuNDIsMC41MSwwLjc4LDAuNzJdLFsnYycsMS4xMSwwLjY5LDEuNTksMS4xMSwxLjg5LDEuNjhdLFsnYycsMC4yMSwwLjM5LDAuMjQsMC43OCwwLjE1LDEuMjldLFsnYycsLTAuMTgsMS4yMCwtMS4xNywyLjE2LC0yLjUyLDIuNTJdLFsnYycsLTEuMDIsMC4yNCwtMS45NSwwLjEyLC0yLjcwLC0wLjQyXSxbJ2MnLC0wLjcyLC0wLjUxLC0wLjk5LC0xLjQ3LC0wLjYwLC0yLjE5XSxbJ2MnLDAuMjQsLTAuNDgsMC43MiwtMC42MywxLjE3LC0wLjQyXSxbJ2MnLDAuMzMsMC4xOCwwLjU0LDAuNDUsMC41NywwLjgxXSxbJ2MnLDAuMDAsMC4yMSwtMC4wMywwLjMwLC0wLjMzLDAuNTFdLFsnYycsLTAuMzMsMC4yNCwtMC4zOSwwLjQyLC0wLjI3LDAuNjldLFsnYycsMC4wNiwwLjE1LDAuMjEsMC4yNywwLjQ1LDAuMzNdLFsnYycsMC4zMCwwLjA5LDAuODcsMC4wOSwxLjIwLDAuMDBdLFsnYycsMC43NSwtMC4yMSwxLjIzLC0wLjcyLDEuMjksLTEuMzVdLFsnYycsMC4wMywtMC40MiwtMC4xNSwtMC44MSwtMC41NCwtMS4yMF0sWydjJywtMC4yNCwtMC4yNCwtMC40OCwtMC40MiwtMS40MSwtMS4wMl0sWydjJywtMC42OSwtMC40MiwtMS4wNSwtMC45MywtMS4wNSwtMS40N10sWydjJywwLjAwLC0wLjM5LDAuMTIsLTAuODcsMC4zMCwtMS4yM10sWydjJywwLjI3LC0wLjU3LDAuNzgsLTEuMDUsMS4zOCwtMS4zNV0sWydjJywwLjI0LC0wLjEyLDAuNjMsLTAuMjcsMC45MCwtMC4zMF0sWyd6J11dLHc6Ni42MzIsaDo4Ljc1OH0sXG5cdFx0J3onOntkOltbJ00nLDIuNjQsLTcuOTVdLFsnYycsMC4zNiwtMC4wOSwwLjgxLC0wLjAzLDEuNzEsMC4yN10sWydjJywwLjc4LDAuMjEsMC45NiwwLjI3LDEuNzQsMC4zMF0sWydjJywwLjg3LDAuMDYsMS4wMiwwLjAzLDEuMzgsLTAuMjFdLFsnYycsMC4yMSwtMC4xNSwwLjMzLC0wLjE1LDAuNDgsLTAuMDZdLFsnYycsMC4xNSwwLjA5LDAuMjEsMC4zMCwwLjE1LDAuNDVdLFsnYycsLTAuMDMsMC4wNiwtMS4yNiwxLjI2LC0yLjc2LDIuNjddLFsnbCcsLTIuNzMsMi41NV0sWydsJywwLjU0LDAuMDNdLFsnYycsMC41NCwwLjAzLDAuNzIsMC4wMywyLjAxLDAuMTVdLFsnYycsMC4zNiwwLjAzLDAuOTAsMC4wNiwxLjIwLDAuMDldLFsnYycsMC42NiwwLjAwLDAuODEsLTAuMDMsMS4wMiwtMC4yNF0sWydjJywwLjMwLC0wLjMwLDAuMzksLTAuNzIsMC4yNywtMS4yM10sWydjJywtMC4wNiwtMC4yNywtMC4wNiwtMC4yNywtMC4wMywtMC4zOV0sWydjJywwLjE1LC0wLjMwLDAuNTQsLTAuMjcsMC42OSwwLjAzXSxbJ2MnLDAuMTUsMC4zMywwLjI3LDEuMDIsMC4yNywxLjUwXSxbJ2MnLDAuMDAsMS40NywtMS4xMSwyLjcwLC0yLjUyLDIuNzldLFsnYycsLTAuNTcsMC4wMywtMS4wMiwtMC4wOSwtMi4wMSwtMC41MV0sWydjJywtMS4wMiwtMC40MiwtMS4yMywtMC40OCwtMi4xMywtMC41NF0sWydjJywtMC44MSwtMC4wNiwtMC45NiwtMC4wMywtMS4yNiwwLjE4XSxbJ2MnLC0wLjEyLDAuMDYsLTAuMjQsMC4xMiwtMC4yNywwLjEyXSxbJ2MnLC0wLjI3LDAuMDAsLTAuNDUsLTAuMzAsLTAuMzYsLTAuNTFdLFsnYycsMC4wMywtMC4wNiwxLjMyLC0xLjMyLDIuOTEsLTIuNzldLFsnbCcsMi44OCwtMi43M10sWydjJywtMC4wMywwLjAwLC0wLjIxLDAuMDMsLTAuNDIsMC4wNl0sWydjJywtMC4yMSwwLjAzLC0wLjc4LDAuMDksLTEuMjMsMC4xMl0sWydjJywtMS4xMSwwLjEyLC0xLjIzLDAuMTUsLTEuOTUsMC4yN10sWydjJywtMC43MiwwLjE1LC0xLjE3LDAuMTgsLTEuMjksMC4wOV0sWydjJywtMC4yNywtMC4xOCwtMC4yMSwtMC43NSwwLjEyLC0xLjI2XSxbJ2MnLDAuMzksLTAuNjAsMC45MywtMS4wMiwxLjU5LC0xLjIwXSxbJ3onXV0sdzo4LjU3MyxoOjguNzQzfSxcblx0XHQnKyc6e2Q6W1snTScsMy40OCwtOS4zXSxbJ2MnLDAuMTgsLTAuMDksMC4zNiwtMC4wOSwwLjU0LDAuMDBdLFsnYycsMC4xOCwwLjA5LDAuMjQsMC4xNSwwLjMzLDAuMzBdLFsnbCcsMC4wNiwwLjE1XSxbJ2wnLDAuMDAsMS4yOV0sWydsJywwLjAwLDEuMjldLFsnbCcsMS4yOSwwLjAwXSxbJ2MnLDEuMjMsMC4wMCwxLjI5LDAuMDAsMS40MSwwLjA2XSxbJ2MnLDAuMDYsMC4wMywwLjE1LDAuMDksMC4xOCwwLjEyXSxbJ2MnLDAuMTIsMC4wOSwwLjIxLDAuMzMsMC4yMSwwLjQ4XSxbJ2MnLDAuMDAsMC4xNSwtMC4wOSwwLjM5LC0wLjIxLDAuNDhdLFsnYycsLTAuMDMsMC4wMywtMC4xMiwwLjA5LC0wLjE4LDAuMTJdLFsnYycsLTAuMTIsMC4wNiwtMC4xOCwwLjA2LC0xLjQxLDAuMDZdLFsnbCcsLTEuMjksMC4wMF0sWydsJywwLjAwLDEuMjldLFsnYycsMC4wMCwxLjIzLDAuMDAsMS4yOSwtMC4wNiwxLjQxXSxbJ2MnLC0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zMCwwLjMzXSxbJ2MnLC0wLjIxLDAuMDksLTAuMzksMC4wOSwtMC41NywwLjAwXSxbJ2MnLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbJ2MnLC0wLjA2LC0wLjEyLC0wLjA2LC0wLjE4LC0wLjA2LC0xLjQxXSxbJ2wnLDAuMDAsLTEuMjldLFsnbCcsLTEuMjksMC4wMF0sWydjJywtMS4yMywwLjAwLC0xLjI5LDAuMDAsLTEuNDEsLTAuMDZdLFsnYycsLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNdLFsnYycsLTAuMDksLTAuMTgsLTAuMDksLTAuMzYsMC4wMCwtMC41NF0sWydjJywwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sWydsJywwLjE1LC0wLjA2XSxbJ2wnLDEuMjYsMC4wMF0sWydsJywxLjI5LDAuMDBdLFsnbCcsMC4wMCwtMS4yOV0sWydjJywwLjAwLC0xLjIzLDAuMDAsLTEuMjksMC4wNiwtMS40MV0sWydjJywwLjA5LC0wLjE4LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sWyd6J11dLHc6Ny41MDcsaDo3LjUxNX0sXG5cdFx0JywnOntkOltbJ00nLDEuMzIsLTMuMzZdLFsnYycsMC41NywtMC4xNSwxLjE3LDAuMDMsMS41OSwwLjQ1XSxbJ2MnLDAuNDUsMC40NSwwLjYwLDAuOTYsMC41MSwxLjg5XSxbJ2MnLC0wLjA5LDEuMjMsLTAuNDIsMi40NiwtMC45OSwzLjkzXSxbJ2MnLC0wLjMwLDAuNzIsLTAuNzIsMS42MiwtMC43OCwxLjY4XSxbJ2MnLC0wLjE4LDAuMjEsLTAuNTEsMC4xOCwtMC42NiwtMC4wNl0sWydjJywtMC4wMywtMC4wNiwtMC4wNiwtMC4xNSwtMC4wNiwtMC4xOF0sWydjJywwLjAwLC0wLjA2LDAuMTIsLTAuMzMsMC4yNCwtMC42M10sWydjJywwLjg0LC0xLjgwLDEuMDIsLTIuNjEsMC42OSwtMy4yNF0sWydjJywtMC4xMiwtMC4yNCwtMC4yNywtMC4zNiwtMC43NSwtMC42MF0sWydjJywtMC4zNiwtMC4xNSwtMC40MiwtMC4yMSwtMC42MCwtMC4zOV0sWydjJywtMC42OSwtMC42OSwtMC42OSwtMS43MSwwLjAwLC0yLjQwXSxbJ2MnLDAuMjEsLTAuMjEsMC41MSwtMC4zOSwwLjgxLC0wLjQ1XSxbJ3onXV0sdzozLjQ1MixoOjguMTQzfSxcblx0XHQnLSc6e2Q6W1snTScsMC4xOCwtNS4zNF0sWydjJywwLjA5LC0wLjA2LDAuMTUsLTAuMDYsMi4zMSwtMC4wNl0sWydjJywyLjQ2LDAuMDAsMi4zNywwLjAwLDIuNDYsMC4yMV0sWydjJywwLjEyLDAuMjEsMC4wMywwLjQyLC0wLjE1LDAuNTRdLFsnYycsLTAuMDksMC4wNiwtMC4xNSwwLjA2LC0yLjI4LDAuMDZdLFsnYycsLTIuMTYsMC4wMCwtMi4yMiwwLjAwLC0yLjMxLC0wLjA2XSxbJ2MnLC0wLjI3LC0wLjE1LC0wLjI3LC0wLjU0LC0wLjAzLC0wLjY5XSxbJ3onXV0sdzo1LjAwMSxoOjAuODF9LFxuXHRcdCcuJzp7ZDpbWydNJywxLjMyLC0zLjM2XSxbJ2MnLDEuMDUsLTAuMjcsMi4xMCwwLjU3LDIuMTAsMS42NV0sWydjJywwLjAwLDEuMDgsLTEuMDUsMS45MiwtMi4xMCwxLjY1XSxbJ2MnLC0wLjkwLC0wLjIxLC0xLjUwLC0xLjE0LC0xLjI2LC0yLjA0XSxbJ2MnLDAuMTIsLTAuNjMsMC42MywtMS4xMSwxLjI2LC0xLjI2XSxbJ3onXV0sdzozLjQxMyxoOjMuNDAyfSxcblx0XHQnc2NyaXB0cy53ZWRnZSc6e2Q6W1snTScsLTMuNjYsLTcuNDRdLFsnYycsMC4wNiwtMC4wOSwwLjAwLC0wLjA5LDAuODEsMC4wM10sWydjJywxLjg2LDAuMzAsMy44NCwwLjMwLDUuNzMsMC4wMF0sWydjJywwLjc4LC0wLjEyLDAuNzIsLTAuMTIsMC43OCwtMC4wM10sWydjJywwLjE1LDAuMTUsMC4xMiwwLjI0LC0wLjI0LDAuNjBdLFsnYycsLTAuOTMsMC45MywtMS45OCwyLjc2LC0yLjY3LDQuNjJdLFsnYycsLTAuMzAsMC43OCwtMC41MSwxLjcxLC0wLjUxLDIuMTNdLFsnYycsMC4wMCwwLjE1LDAuMDAsMC4xOCwtMC4wNiwwLjI3XSxbJ2MnLC0wLjEyLDAuMDksLTAuMjQsMC4wOSwtMC4zNiwwLjAwXSxbJ2MnLC0wLjA2LC0wLjA5LC0wLjA2LC0wLjEyLC0wLjA2LC0wLjI3XSxbJ2MnLDAuMDAsLTAuNDIsLTAuMjEsLTEuMzUsLTAuNTEsLTIuMTNdLFsnYycsLTAuNjksLTEuODYsLTEuNzQsLTMuNjksLTIuNjcsLTQuNjJdLFsnYycsLTAuMzYsLTAuMzYsLTAuMzksLTAuNDUsLTAuMjQsLTAuNjBdLFsneiddXSx3OjcuNDksaDo3Ljc1Mn0sXG5cdFx0J3NjcmlwdHMudGh1bWInOntkOltbJ00nLC0wLjU0LC0zLjY5XSxbJ2MnLDAuMTUsLTAuMDMsMC4zNiwtMC4wNiwwLjUxLC0wLjA2XSxbJ2MnLDEuNDQsMC4wMCwyLjU4LDEuMTEsMi45NCwyLjg1XSxbJ2MnLDAuMDksMC40OCwwLjA5LDEuMzIsMC4wMCwxLjgwXSxbJ2MnLC0wLjI3LDEuNDEsLTEuMDgsMi40MywtMi4xNiwyLjczXSxbJ2wnLC0wLjE4LDAuMDZdLFsnbCcsMC4wMCwwLjEyXSxbJ2MnLDAuMDMsMC4wNiwwLjA2LDAuNDUsMC4wOSwwLjg3XSxbJ2MnLDAuMDMsMC41NywwLjAzLDAuNzgsMC4wMCwwLjg0XSxbJ2MnLC0wLjA5LDAuMjcsLTAuMzksMC40OCwtMC42NiwwLjQ4XSxbJ2MnLC0wLjI3LDAuMDAsLTAuNTcsLTAuMjEsLTAuNjYsLTAuNDhdLFsnYycsLTAuMDMsLTAuMDYsLTAuMDMsLTAuMjcsMC4wMCwtMC44NF0sWydjJywwLjAzLC0wLjQyLDAuMDYsLTAuODEsMC4wOSwtMC44N10sWydsJywwLjAwLC0wLjEyXSxbJ2wnLC0wLjE4LC0wLjA2XSxbJ2MnLC0xLjA4LC0wLjMwLC0xLjg5LC0xLjMyLC0yLjE2LC0yLjczXSxbJ2MnLC0wLjA5LC0wLjQ4LC0wLjA5LC0xLjMyLDAuMDAsLTEuODBdLFsnYycsMC4xNSwtMC44NCwwLjUxLC0xLjUzLDEuMDIsLTIuMDRdLFsnYycsMC4zOSwtMC4zOSwwLjg0LC0wLjYzLDEuMzUsLTAuNzVdLFsneiddLFsnbScsMS4wNSwwLjkwXSxbJ2MnLC0wLjE1LC0wLjA5LC0wLjIxLC0wLjA5LC0wLjQ1LC0wLjEyXSxbJ2MnLC0wLjE1LDAuMDAsLTAuMzAsMC4wMywtMC4zOSwwLjAzXSxbJ2MnLC0wLjU3LDAuMTgsLTAuOTAsMC43MiwtMS4wOCwxLjc0XSxbJ2MnLC0wLjA2LDAuNDgsLTAuMDYsMS44MCwwLjAwLDIuMjhdLFsnYycsMC4xNSwwLjkwLDAuNDIsMS40NCwwLjkwLDEuNjVdLFsnYycsMC4xOCwwLjA5LDAuMjEsMC4wOSwwLjUxLDAuMDldLFsnYycsMC4zMCwwLjAwLDAuMzMsMC4wMCwwLjUxLC0wLjA5XSxbJ2MnLDAuNDgsLTAuMjEsMC43NSwtMC43NSwwLjkwLC0xLjY1XSxbJ2MnLDAuMDMsLTAuMjcsMC4wMywtMC41NCwwLjAzLC0xLjE0XSxbJ2MnLDAuMDAsLTAuNjAsMC4wMCwtMC44NywtMC4wMywtMS4xNF0sWydjJywtMC4xNSwtMC45MCwtMC40NSwtMS40NCwtMC45MCwtMS42NV0sWyd6J11dLHc6NS45NTUsaDo5Ljc1fSxcblx0XHQnc2NyaXB0cy5vcGVuJzp7ZDpbWydNJywtMC41NCwtMy42OV0sWydjJywwLjE1LC0wLjAzLDAuMzYsLTAuMDYsMC41MSwtMC4wNl0sWydjJywxLjQ0LDAuMDAsMi41OCwxLjExLDIuOTQsMi44NV0sWydjJywwLjA5LDAuNDgsMC4wOSwxLjMyLDAuMDAsMS44MF0sWydjJywtMC4zMywxLjc0LC0xLjQ3LDIuODUsLTIuOTEsMi44NV0sWydjJywtMS40NCwwLjAwLC0yLjU4LC0xLjExLC0yLjkxLC0yLjg1XSxbJ2MnLC0wLjA5LC0wLjQ4LC0wLjA5LC0xLjMyLDAuMDAsLTEuODBdLFsnYycsMC4xNSwtMC44NCwwLjUxLC0xLjUzLDEuMDIsLTIuMDRdLFsnYycsMC4zOSwtMC4zOSwwLjg0LC0wLjYzLDEuMzUsLTAuNzVdLFsneiddLFsnbScsMS4xMSwwLjkwXSxbJ2MnLC0wLjIxLC0wLjA5LC0wLjI3LC0wLjA5LC0wLjUxLC0wLjEyXSxbJ2MnLC0wLjMwLDAuMDAsLTAuNDIsMC4wMywtMC42NiwwLjE1XSxbJ2MnLC0wLjI0LDAuMTIsLTAuNTEsMC4zOSwtMC42NiwwLjYzXSxbJ2MnLC0wLjU0LDAuOTMsLTAuNjMsMi42NCwtMC4yMSwzLjgxXSxbJ2MnLDAuMjEsMC41NCwwLjUxLDAuOTAsMC45MywxLjExXSxbJ2MnLDAuMjEsMC4wOSwwLjI0LDAuMDksMC41NCwwLjA5XSxbJ2MnLDAuMzAsMC4wMCwwLjMzLDAuMDAsMC41NCwtMC4wOV0sWydjJywwLjQyLC0wLjIxLDAuNzIsLTAuNTcsMC45MywtMS4xMV0sWydjJywwLjM2LC0wLjk5LDAuMzYsLTIuMzcsMC4wMCwtMy4zNl0sWydjJywtMC4yMSwtMC41NCwtMC41MSwtMC45MCwtMC45MCwtMS4xMV0sWyd6J11dLHc6NS45NTUsaDo3LjV9LFxuXHRcdCdzY3JpcHRzLmxvbmdwaHJhc2UnOntkOltbJ00nLDEuNDcsLTE1LjA5XSxbJ2MnLDAuMzYsLTAuMDksMC42NiwtMC4xOCwwLjY5LC0wLjE4XSxbJ2MnLDAuMDYsMC4wMCwwLjA2LDAuNTQsMC4wNiwxMS4yNV0sWydsJywwLjAwLDExLjI1XSxbJ2wnLC0wLjYzLDAuMTVdLFsnYycsLTAuNjYsMC4xOCwtMS40NCwwLjM5LC0xLjUwLDAuMzldLFsnYycsLTAuMDMsMC4wMCwtMC4wMywtMy4zOSwtMC4wMywtMTEuMjVdLFsnbCcsMC4wMCwtMTEuMjVdLFsnbCcsMC4zNiwtMC4wOV0sWydjJywwLjIxLC0wLjA2LDAuNjYsLTAuMTgsMS4wNSwtMC4yN10sWyd6J11dLHc6Mi4xNixoOjIzLjA0fSxcblx0XHQnc2NyaXB0cy5tZWRpdW1waHJhc2UnOntkOltbJ00nLDEuNDcsLTcuNTldLFsnYycsMC4zNiwtMC4wOSwwLjY2LC0wLjE4LDAuNjksLTAuMThdLFsnYycsMC4wNiwwLjAwLDAuMDYsMC4zOSwwLjA2LDcuNTBdLFsnbCcsMC4wMCw3LjUwXSxbJ2wnLC0wLjYzLDAuMTVdLFsnYycsLTAuNjYsMC4xOCwtMS40NCwwLjM5LC0xLjUwLDAuMzldLFsnYycsLTAuMDMsMC4wMCwtMC4wMywtMi4yOCwtMC4wMywtNy41MF0sWydsJywwLjAwLC03LjUwXSxbJ2wnLDAuMzYsLTAuMDldLFsnYycsMC4yMSwtMC4wNiwwLjY2LC0wLjE4LDEuMDUsLTAuMjddLFsneiddXSx3OjIuMTYsaDoxNS41NH0sXG5cdFx0J3NjcmlwdHMuc2hvcnRwaHJhc2UnOntkOltbJ00nLDEuNDcsLTcuNTldLFsnYycsMC4zNiwtMC4wOSwwLjY2LC0wLjE4LDAuNjksLTAuMThdLFsnYycsMC4wNiwwLjAwLDAuMDYsMC4yMSwwLjA2LDMuNzVdLFsnbCcsMC4wMCwzLjc1XSxbJ2wnLC0wLjQyLDAuMDldLFsnYycsLTAuNTcsMC4xOCwtMS42NSwwLjQ1LC0xLjcxLDAuNDVdLFsnYycsLTAuMDMsMC4wMCwtMC4wMywtMC43MiwtMC4wMywtMy43NV0sWydsJywwLjAwLC0zLjc1XSxbJ2wnLDAuMzYsLTAuMDldLFsnYycsMC4yMSwtMC4wNiwwLjY2LC0wLjE4LDEuMDUsLTAuMjddLFsneiddXSx3OjIuMTYsaDo4LjA0fSxcblx0XHQnc2NyaXB0cy5zbmFwJzp7ZDpbWydNJyw0LjUwLC0zLjM5XSxbJ2MnLDAuMzYsLTAuMDMsMC45NiwtMC4wMywxLjM1LDAuMDBdLFsnYycsMS41NiwwLjE1LDMuMTUsMC45MCw0LjIwLDIuMDFdLFsnYycsMC4yNCwwLjI3LDAuMzMsMC40MiwwLjMzLDAuNjBdLFsnYycsMC4wMCwwLjI3LDAuMDMsMC4yNCwtMi40NiwyLjIyXSxbJ2MnLC0xLjI5LDEuMDIsLTIuNDAsMS44NiwtMi40OSwxLjkyXSxbJ2MnLC0wLjE4LDAuMDksLTAuMzAsMC4wOSwtMC40OCwwLjAwXSxbJ2MnLC0wLjA5LC0wLjA2LC0xLjIwLC0wLjkwLC0yLjQ5LC0xLjkyXSxbJ2MnLC0yLjQ5LC0xLjk4LC0yLjQ2LC0xLjk1LC0yLjQ2LC0yLjIyXSxbJ2MnLDAuMDAsLTAuMTgsMC4wOSwtMC4zMywwLjMzLC0wLjYwXSxbJ2MnLDEuMDUsLTEuMDgsMi42NCwtMS44Niw0LjE3LC0yLjAxXSxbJ3onXSxbJ20nLDEuMjksMS4xN10sWydjJywtMS40NywtMC4xNSwtMi45NywwLjMwLC00LjE0LDEuMjBdLFsnbCcsLTAuMTgsMC4xNV0sWydsJywwLjA2LDAuMDldLFsnYycsMC4xNSwwLjEyLDMuNjMsMi44NSwzLjY2LDIuODVdLFsnYycsMC4wMywwLjAwLDMuNTEsLTIuNzMsMy42NiwtMi44NV0sWydsJywwLjA2LC0wLjA5XSxbJ2wnLC0wLjE4LC0wLjE1XSxbJ2MnLC0wLjg0LC0wLjY2LC0xLjg5LC0xLjA4LC0yLjk0LC0xLjIwXSxbJ3onXV0sdzoxMC4zOCxoOjYuODR9fTtcblxuXHQvLyBDdXN0b20gY2hhcmFjdGVycyB0aGF0IHdlcmVuJ3QgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbnQ6XG5cdGdseXBoc1snbm90ZWhlYWRzLnNsYXNoLndob2xlJ10gPSB7ZDpbWydNJyw1LC01XSxbJ2wnLDEsMV0sWydsJywtNSw1XSxbJ2wnLC0xLC0xXSxbJ3onXSxbJ20nLDQsNl0sWydsJywtNSwtNV0sWydsJywyLC0yXSxbJ2wnLDUsNV0sWyd6J10sWydtJywwLC0yXSxbJ2wnLDEsMV0sWydsJywtNSw1XSxbJ2wnLC0xLC0xXSxbJ3onXSxbJ20nLC00LDZdLFsnbCcsLTUsLTVdLFsnbCcsMiwtMl0sWydsJyw1LDVdLFsneiddXSx3OjEwLjgxLGg6MTUuNjN9O1xuXG5cdGdseXBoc1snbm90ZWhlYWRzLnNsYXNoLnF1YXJ0ZXInXSA9IHtkOltbJ00nLDksLTZdLFsnbCcsMCw0XSxbJ2wnLC05LDldLFsnbCcsMCwtNF0sWyd6J11dLHc6OSxoOjl9O1xuXG5cdGdseXBoc1snbm90ZWhlYWRzLmhhcm1vbmljLnF1YXJ0ZXInXSA9IHtkOltbJ00nLDMuNjMsLTQuMDJdLFsnYycsMC4wOSwtMC4wNiwwLjE4LC0wLjA5LDAuMjQsLTAuMDNdLFsnYycsMC4wMywwLjAzLDAuODcsMC45MywxLjgzLDIuMDFdLFsnYycsMS41MCwxLjY1LDEuODAsMS45OCwxLjgwLDIuMDRdLFsnYycsMC4wMCwwLjA2LC0wLjMwLDAuMzksLTEuODAsMi4wNF0sWydjJywtMC45NiwxLjA4LC0xLjgwLDEuOTgsLTEuODMsMi4wMV0sWydjJywtMC4wNiwwLjA2LC0wLjE1LDAuMDMsLTAuMjQsLTAuMDNdLFsnYycsLTAuMTIsLTAuMDksLTMuNTQsLTMuODQsLTMuNjAsLTMuOTNdLFsnYycsLTAuMDMsLTAuMDMsLTAuMDMsLTAuMDksLTAuMDMsLTAuMTVdLFsnYycsMC4wMywtMC4wNiwzLjQ1LC0zLjg0LDMuNjMsLTMuOTZdLFsneiddXSx3OjcuNSxoOjguMTY1fTtcblxudmFyIHBhdGhDbG9uZSA9IGZ1bmN0aW9uIChwYXRoQXJyYXkpIHtcblx0dmFyIHJlcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuXHRcdHJlc1tpXSA9IFtdO1xuXHRcdGZvciAodmFyIGogPSAwLCBqaiA9IHBhdGhBcnJheVtpXS5sZW5ndGg7IGogPCBqajsgaisrKSB7XG5cdFx0XHRyZXNbaV1bal0gPSBwYXRoQXJyYXlbaV1bal07XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXM7XG59O1xuXG52YXIgcGF0aFNjYWxlID0gZnVuY3Rpb24gKHBhdGhBcnJheSwga3gsIGt5KSB7XG5cdGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGhBcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdFx0dmFyIHAgPSBwYXRoQXJyYXlbaV07XG5cdFx0dmFyIGosIGpqO1xuXHRcdGZvciAoaiA9IDEsIGpqID0gcC5sZW5ndGg7IGogPCBqajsgaisrKSB7XG5cdFx0XHRwW2pdICo9IChqICUgMikgPyBreCA6IGt5O1xuXHRcdH1cblx0fVxufTtcblxudmFyIEdseXBocyA9IHtcblx0cHJpbnRTeW1ib2w6IGZ1bmN0aW9uICh4LHksc3ltYixwYXBlciwga2xhc3MpIHtcbiAgICBpZiAoIWdseXBoc1tzeW1iXSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHBhdGhBcnJheSA9IHBhdGhDbG9uZShnbHlwaHNbc3ltYl0uZCk7XG4gICAgcGF0aEFycmF5WzBdWzFdICs9eDtcbiAgICBwYXRoQXJyYXlbMF1bMl0gKz15O1xuICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKylcbiAgICBcdHBhdGggKz0gcGF0aEFycmF5W2ldLmpvaW4oXCIgXCIpO1xuICAgIHJldHVybiBwYXBlci5wYXRoKHtwYXRoOnBhdGgsIHN0cm9rZTpcIm5vbmVcIiwgZmlsbDpcIiMwMDAwMDBcIiwgJ2NsYXNzJzoga2xhc3MgfSk7XG4gICB9LFxuXG4gIGdldFBhdGhGb3JTeW1ib2w6IGZ1bmN0aW9uICh4LHksc3ltYixzY2FsZXgsIHNjYWxleSkge1xuICAgIHNjYWxleCA9IHNjYWxleCB8fCAxO1xuICAgIHNjYWxleSA9IHNjYWxleSB8fCAxO1xuICAgIGlmICghZ2x5cGhzW3N5bWJdKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcGF0aEFycmF5ID0gcGF0aENsb25lKGdseXBoc1tzeW1iXS5kKTtcbiAgICBpZiAoc2NhbGV4IT09MSB8fCBzY2FsZXkhPT0xKSBwYXRoU2NhbGUocGF0aEFycmF5LHNjYWxleCxzY2FsZXkpO1xuICAgIHBhdGhBcnJheVswXVsxXSArPXg7XG4gICAgcGF0aEFycmF5WzBdWzJdICs9eTtcblxuICAgIHJldHVybiBwYXRoQXJyYXk7XG4gIH0sXG5cbiAgZ2V0U3ltYm9sV2lkdGg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICBpZiAoZ2x5cGhzW3N5bWJvbF0pIHJldHVybiBnbHlwaHNbc3ltYm9sXS53O1xuICAgIHJldHVybiAwO1xuICB9LFxuXG5cdHN5bWJvbEhlaWdodEluUGl0Y2hlczogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0dmFyIGhlaWdodCA9IGdseXBoc1tzeW1ib2xdID8gZ2x5cGhzW3N5bWJvbF0uaCA6IDA7XG5cdFx0cmV0dXJuIGhlaWdodCAvIHNwYWNpbmcuU1RFUDtcblx0fSxcblxuICBnZXRTeW1ib2xBbGlnbjogZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgIGlmIChzeW1ib2wuc3Vic3RyaW5nKDAsNyk9PT1cInNjcmlwdHNcIiAmJlxuXHRzeW1ib2whPT1cInNjcmlwdHMucm9sbFwiKSB7XG4gICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwibGVmdFwiO1xuICB9LFxuXG4gIGdldFlDb3JyOiBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgc3dpdGNoKHN5bWJvbCkge1xuICAgIGNhc2UgXCIwXCI6XG4gICAgY2FzZSBcIjFcIjpcbiAgICBjYXNlIFwiMlwiOlxuICAgIGNhc2UgXCIzXCI6XG4gICAgY2FzZSBcIjRcIjpcbiAgICBjYXNlIFwiNVwiOlxuICAgIGNhc2UgXCI2XCI6XG4gICAgY2FzZSBcIjdcIjpcbiAgICBjYXNlIFwiOFwiOlxuICAgIGNhc2UgXCI5XCI6XG4gICAgY2FzZSBcIitcIjogcmV0dXJuIC0yO1xuICAgIGNhc2UgXCJ0aW1lc2lnLmNvbW1vblwiOlxuICAgIGNhc2UgXCJ0aW1lc2lnLmN1dFwiOiByZXR1cm4gMDtcbiAgICBjYXNlIFwiZmxhZ3MuZDMybmRcIjogcmV0dXJuIC0xO1xuICAgIGNhc2UgXCJmbGFncy5kNjR0aFwiOiByZXR1cm4gLTI7XG4gICAgY2FzZSBcImZsYWdzLnUzMm5kXCI6IHJldHVybiAxO1xuICAgIGNhc2UgXCJmbGFncy51NjR0aFwiOiByZXR1cm4gMztcbiAgICBjYXNlIFwicmVzdHMud2hvbGVcIjogcmV0dXJuIDE7XG4gICAgY2FzZSBcInJlc3RzLmhhbGZcIjogcmV0dXJuIC0xO1xuICAgIGNhc2UgXCJyZXN0cy44dGhcIjogcmV0dXJuIC0xO1xuICAgIGNhc2UgXCJyZXN0cy5xdWFydGVyXCI6IHJldHVybiAtMTtcbiAgICBjYXNlIFwicmVzdHMuMTZ0aFwiOiByZXR1cm4gLTE7XG4gICAgY2FzZSBcInJlc3RzLjMybmRcIjogcmV0dXJuIC0xO1xuICAgIGNhc2UgXCJyZXN0cy42NHRoXCI6IHJldHVybiAtMTtcblx0XHRjYXNlIFwiZlwiOlxuXHRcdGNhc2UgXCJtXCI6XG5cdFx0Y2FzZSBcInBcIjpcblx0XHRjYXNlIFwic1wiOlxuXHRcdGNhc2UgXCJ6XCI6XG5cdFx0XHRyZXR1cm4gLTQ7XG5cdFx0Y2FzZSBcInNjcmlwdHMudHJpbGxcIjpcblx0XHRjYXNlIFwic2NyaXB0cy51cGJvd1wiOlxuXHRcdGNhc2UgXCJzY3JpcHRzLmRvd25ib3dcIjpcblx0XHRcdHJldHVybiAtMjtcblx0XHRjYXNlIFwic2NyaXB0cy51ZmVybWF0YVwiOlxuXHRcdGNhc2UgXCJzY3JpcHRzLndlZGdlXCI6XG5cdFx0Y2FzZSBcInNjcmlwdHMucm9sbFwiOlxuXHRcdGNhc2UgXCJzY3JpcHRzLnNob3J0cGhyYXNlXCI6XG5cdFx0Y2FzZSBcInNjcmlwdHMubG9uZ3BocmFzZVwiOlxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdGNhc2UgXCJzY3JpcHRzLmRmZXJtYXRhXCI6XG5cdFx0XHRyZXR1cm4gMTtcbiAgICBkZWZhdWx0OiByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG5cdHNldFN5bWJvbDogZnVuY3Rpb24obmFtZSwgcGF0aCkge1xuXHRcdGdseXBoc1tuYW1lXSA9IHBhdGg7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhzOyAvLyB3ZSBuZWVkIHRoZSBnbHlwaHMgZm9yIGxheW91dCBpbmZvcm1hdGlvblxuIiwiLy8gICAgYWJjX3JlbGF0aXZlX2VsZW1lbnQuanM6IERlZmluaXRpb24gb2YgdGhlIFJlbGF0aXZlRWxlbWVudCBjbGFzcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIFJlbGF0aXZlRWxlbWVudCA9IGZ1bmN0aW9uIFJlbGF0aXZlRWxlbWVudChjLCBkeCwgdywgcGl0Y2gsIG9wdCkge1xuXHRvcHQgPSBvcHQgfHwge307XG5cdHRoaXMueCA9IDA7XG5cdHRoaXMuYyA9IGM7ICAgICAgLy8gY2hhcmFjdGVyIG9yIHBhdGggb3Igc3RyaW5nXG5cdHRoaXMuZHggPSBkeDsgICAgLy8gcmVsYXRpdmUgeCBwb3NpdGlvblxuXHR0aGlzLncgPSB3OyAgICAgIC8vIG1pbmltdW0gd2lkdGggdGFrZW4gdXAgYnkgdGhpcyBlbGVtZW50IChjYW4gaW5jbHVkZSBncmF0dWl0b3VzIHNwYWNlKVxuXHR0aGlzLnBpdGNoID0gcGl0Y2g7IC8vIHJlbGF0aXZlIHkgcG9zaXRpb24gYnkgcGl0Y2hcblx0dGhpcy5zY2FsZXggPSBvcHQuc2NhbGV4IHx8IDE7IC8vIHNob3VsZCB0aGUgY2hhcmFjdGVyL3BhdGggYmUgc2NhbGVkP1xuXHR0aGlzLnNjYWxleSA9IG9wdC5zY2FsZXkgfHwgMTsgLy8gc2hvdWxkIHRoZSBjaGFyYWN0ZXIvcGF0aCBiZSBzY2FsZWQ/XG5cdHRoaXMudHlwZSA9IG9wdC50eXBlIHx8IFwic3ltYm9sXCI7IC8vIGNoZWFwIHR5cGVzLlxuXHR0aGlzLnBpdGNoMiA9IG9wdC5waXRjaDI7XG5cdHRoaXMubGluZXdpZHRoID0gb3B0LmxpbmV3aWR0aDtcblx0dGhpcy5rbGFzcyA9IG9wdC5rbGFzcztcblx0dGhpcy50b3AgPSBwaXRjaDtcblx0aWYgKHRoaXMucGl0Y2gyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5waXRjaDIgPiB0aGlzLnRvcCkgdGhpcy50b3AgPSB0aGlzLnBpdGNoMjtcblx0dGhpcy5ib3R0b20gPSBwaXRjaDtcblx0aWYgKHRoaXMucGl0Y2gyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5waXRjaDIgPCB0aGlzLmJvdHRvbSkgdGhpcy5ib3R0b20gPSB0aGlzLnBpdGNoMjtcblx0aWYgKG9wdC50aGlja25lc3MpIHtcblx0XHR0aGlzLnRvcCArPSBvcHQudGhpY2tuZXNzLzI7XG5cdFx0dGhpcy5ib3R0b20gLT0gb3B0LnRoaWNrbmVzcy8yO1xuXHR9XG5cdGlmIChvcHQuc3RlbUhlaWdodCkge1xuXHRcdGlmIChvcHQuc3RlbUhlaWdodCA+IDApXG5cdFx0XHR0aGlzLnRvcCArPSBvcHQuc3RlbUhlaWdodDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmJvdHRvbSArPSBvcHQuc3RlbUhlaWdodDtcblx0fVxuXHQvL2lmICh0aGlzLnR5cGUgPT09IFwic3ltYm9sXCIpIHtcblx0Ly9cdHZhciBvZmZzZXQgPSBnbHlwaHMuZ2V0WUNvcnIodGhpcy5jKTtcblx0Ly9cdHRoaXMudG9wICs9IG9mZnNldDtcblx0Ly9cdHRoaXMuYm90dG9tICs9IG9mZnNldDtcblx0Ly99XG5cdHRoaXMuaGVpZ2h0ID0gb3B0LmhlaWdodCA/IG9wdC5oZWlnaHQgOiA0OyAvLyBUaGUgKzEgaXMgdG8gZ2l2ZSBhIGxpdHRsZSBiaXQgb2YgcGFkZGluZy5cblx0dGhpcy5jZW50ZXJWZXJ0aWNhbGx5ID0gZmFsc2U7XG5cdHN3aXRjaCAodGhpcy50eXBlKSB7XG5cdFx0Y2FzZSBcImRlYnVnXCI6XG5cdFx0XHR0aGlzLmNob3JkSGVpZ2h0QWJvdmUgPSB0aGlzLmhlaWdodDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJseXJpY1wiOlxuXHRcdFx0aWYgKG9wdC5wb3NpdGlvbiAmJiBvcHQucG9zaXRpb24gPT09ICdiZWxvdycpXG5cdFx0XHRcdHRoaXMubHlyaWNIZWlnaHRCZWxvdyA9IHRoaXMuaGVpZ2h0O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLmx5cmljSGVpZ2h0QWJvdmUgPSB0aGlzLmhlaWdodDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJjaG9yZFwiOlxuXHRcdFx0aWYgKG9wdC5wb3NpdGlvbiAmJiBvcHQucG9zaXRpb24gPT09ICdiZWxvdycpXG5cdFx0XHRcdHRoaXMuY2hvcmRIZWlnaHRCZWxvdyA9IHRoaXMuaGVpZ2h0O1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLmNob3JkSGVpZ2h0QWJvdmUgPSB0aGlzLmhlaWdodDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJ0ZXh0XCI6XG5cdFx0XHRpZiAodGhpcy5waXRjaCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChvcHQucG9zaXRpb24gJiYgb3B0LnBvc2l0aW9uID09PSAnYmVsb3cnKVxuXHRcdFx0XHRcdHRoaXMuY2hvcmRIZWlnaHRCZWxvdyA9IHRoaXMuaGVpZ2h0O1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dGhpcy5jaG9yZEhlaWdodEFib3ZlID0gdGhpcy5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0dGhpcy5jZW50ZXJWZXJ0aWNhbGx5ID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJwYXJ0XCI6IHRoaXMucGFydEhlaWdodEFib3ZlID0gdGhpcy5oZWlnaHQ7IGJyZWFrO1xuXHR9XG59O1xuXG5SZWxhdGl2ZUVsZW1lbnQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuXHR0aGlzLnggPSB4K3RoaXMuZHg7XG59O1xuXG5SZWxhdGl2ZUVsZW1lbnQucHJvdG90eXBlLnNldFVwcGVyQW5kTG93ZXJFbGVtZW50cyA9IGZ1bmN0aW9uKHBvc2l0aW9uWSkge1xuXHRzd2l0Y2godGhpcy50eXBlKSB7XG5cdFx0Y2FzZSBcInBhcnRcIjpcblx0XHRcdHRoaXMudG9wID0gcG9zaXRpb25ZLnBhcnRIZWlnaHRBYm92ZSArIHRoaXMuaGVpZ2h0O1xuXHRcdFx0dGhpcy5ib3R0b20gPSBwb3NpdGlvblkucGFydEhlaWdodEFib3ZlO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInRleHRcIjpcblx0XHRjYXNlIFwiY2hvcmRcIjpcblx0XHRcdGlmICh0aGlzLmNob3JkSGVpZ2h0QWJvdmUpIHtcblx0XHRcdFx0dGhpcy50b3AgPSBwb3NpdGlvblkuY2hvcmRIZWlnaHRBYm92ZTtcblx0XHRcdFx0dGhpcy5ib3R0b20gPSBwb3NpdGlvblkuY2hvcmRIZWlnaHRBYm92ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9wID0gcG9zaXRpb25ZLmNob3JkSGVpZ2h0QmVsb3c7XG5cdFx0XHRcdHRoaXMuYm90dG9tID0gcG9zaXRpb25ZLmNob3JkSGVpZ2h0QmVsb3c7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwibHlyaWNcIjpcblx0XHRcdGlmICh0aGlzLmx5cmljSGVpZ2h0QWJvdmUpIHtcblx0XHRcdFx0dGhpcy50b3AgPSBwb3NpdGlvblkubHlyaWNIZWlnaHRBYm92ZTtcblx0XHRcdFx0dGhpcy5ib3R0b20gPSBwb3NpdGlvblkubHlyaWNIZWlnaHRBYm92ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudG9wID0gcG9zaXRpb25ZLmx5cmljSGVpZ2h0QmVsb3c7XG5cdFx0XHRcdHRoaXMuYm90dG9tID0gcG9zaXRpb25ZLmx5cmljSGVpZ2h0QmVsb3c7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiZGVidWdcIjpcblx0XHRcdHRoaXMudG9wID0gcG9zaXRpb25ZLmNob3JkSGVpZ2h0QWJvdmU7XG5cdFx0XHR0aGlzLmJvdHRvbSA9IHBvc2l0aW9uWS5jaG9yZEhlaWdodEFib3ZlO1xuXHRcdFx0YnJlYWs7XG5cdH1cblx0aWYgKHRoaXMucGl0Y2ggPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRvcCA9PT0gdW5kZWZpbmVkKVxuXHRcdHdpbmRvdy5jb25zb2xlLmVycm9yKFwiUmVsYXRpdmVFbGVtZW50IHBvc2l0aW9uIG5vdCBzZXQuXCIsIHRoaXMudHlwZSwgdGhpcy5waXRjaCwgdGhpcy50b3AsIHBvc2l0aW9uWSk7XG59O1xuXG5SZWxhdGl2ZUVsZW1lbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGJhcnRvcCkge1xuXHRpZiAodGhpcy5waXRjaCA9PT0gdW5kZWZpbmVkKVxuXHRcdHdpbmRvdy5jb25zb2xlLmVycm9yKHRoaXMudHlwZSArIFwiIFJlbGF0aXZlIEVsZW1lbnQgeS1jb29yZGluYXRlIG5vdCBzZXQuXCIpO1xuXHR2YXIgeSA9IHJlbmRlcmVyLmNhbGNZKHRoaXMucGl0Y2gpO1xuXHRzd2l0Y2godGhpcy50eXBlKSB7XG5cdFx0Y2FzZSBcInN5bWJvbFwiOlxuXHRcdFx0aWYgKHRoaXMuYz09PW51bGwpIHJldHVybiBudWxsO1xuXHRcdFx0dmFyIGtsYXNzID0gXCJzeW1ib2xcIjtcblx0XHRcdGlmICh0aGlzLmtsYXNzKSBrbGFzcyArPSBcIiBcIiArIHRoaXMua2xhc3M7XG5cdFx0XHR0aGlzLmdyYXBoZWxlbSA9IHJlbmRlcmVyLnByaW50U3ltYm9sKHRoaXMueCwgdGhpcy5waXRjaCwgdGhpcy5jLCB0aGlzLnNjYWxleCwgdGhpcy5zY2FsZXksIHJlbmRlcmVyLmFkZENsYXNzZXMoa2xhc3MpKTsgYnJlYWs7XG5cdFx0Y2FzZSBcImRlYnVnXCI6XG5cdFx0XHR0aGlzLmdyYXBoZWxlbSA9IHJlbmRlcmVyLnJlbmRlclRleHQodGhpcy54LCByZW5kZXJlci5jYWxjWSgxNSksIFwiXCIrdGhpcy5jLCBcImRlYnVnZm9udFwiLCAnZGVidWctbXNnJywgJ3N0YXJ0Jyk7IGJyZWFrO1xuXHRcdGNhc2UgXCJiYXJOdW1iZXJcIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dCh0aGlzLngsIHksIFwiXCIrdGhpcy5jLCBcIm1lYXN1cmVmb250XCIsICdiYXItbnVtYmVyJywgXCJtaWRkbGVcIik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwibHlyaWNcIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dCh0aGlzLngsIHksIHRoaXMuYywgXCJ2b2NhbGZvbnRcIiwgJ2x5cmljJywgXCJtaWRkbGVcIik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiY2hvcmRcIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dCh0aGlzLngsIHksIHRoaXMuYywgJ2djaG9yZGZvbnQnLCBcImNob3JkXCIsIFwibWlkZGxlXCIpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcImRlY29yYXRpb25cIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dCh0aGlzLngsIHksIHRoaXMuYywgJ2Fubm90YXRpb25mb250JywgXCJhbm5vdGF0aW9uXCIsIFwibWlkZGxlXCIsIHRydWUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInRleHRcIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dCh0aGlzLngsIHksIHRoaXMuYywgJ2Fubm90YXRpb25mb250JywgXCJhbm5vdGF0aW9uXCIsIFwic3RhcnRcIiwgdGhpcy5jZW50ZXJWZXJ0aWNhbGx5KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJtdWx0aW1lYXN1cmUtdGV4dFwiOlxuXHRcdFx0dGhpcy5ncmFwaGVsZW0gPSByZW5kZXJlci5yZW5kZXJUZXh0KHRoaXMueCt0aGlzLncvMiwgeSwgdGhpcy5jLCAndGVtcG9mb250JywgXCJyZXN0XCIsIFwibWlkZGxlXCIsIGZhbHNlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJwYXJ0XCI6XG5cdFx0XHR0aGlzLmdyYXBoZWxlbSA9IHJlbmRlcmVyLnJlbmRlclRleHQodGhpcy54LCB5LCB0aGlzLmMsICdwYXJ0c2ZvbnQnLCBcInBhcnRcIiwgXCJzdGFydFwiKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJiYXJcIjpcblx0XHRcdHRoaXMuZ3JhcGhlbGVtID0gcmVuZGVyZXIucHJpbnRTdGVtKHRoaXMueCwgdGhpcy5saW5ld2lkdGgsIHksIChiYXJ0b3ApP2JhcnRvcDpyZW5kZXJlci5jYWxjWSh0aGlzLnBpdGNoMikpOyBicmVhazsgLy8gYmFydG9wIGNhbid0IGJlIDBcblx0XHRjYXNlIFwic3RlbVwiOlxuXHRcdFx0dGhpcy5ncmFwaGVsZW0gPSByZW5kZXJlci5wcmludFN0ZW0odGhpcy54LCB0aGlzLmxpbmV3aWR0aCwgeSwgcmVuZGVyZXIuY2FsY1kodGhpcy5waXRjaDIpKTsgYnJlYWs7XG5cdFx0Y2FzZSBcImxlZGdlclwiOlxuXHRcdFx0dGhpcy5ncmFwaGVsZW0gPSByZW5kZXJlci5wcmludFN0YXZlTGluZSh0aGlzLngsIHRoaXMueCt0aGlzLncsIHRoaXMucGl0Y2gpOyBicmVhaztcblx0fVxuXHRpZiAodGhpcy5zY2FsZXghPT0xICYmIHRoaXMuZ3JhcGhlbGVtKSB7XG5cdFx0cmVuZGVyZXIuc2NhbGVFeGlzdGluZ0VsZW0odGhpcy5ncmFwaGVsZW0sIHRoaXMuc2NhbGV4LCB0aGlzLnNjYWxleSwgdGhpcy54LCB5KTtcblx0fVxuXHRyZXR1cm4gdGhpcy5ncmFwaGVsZW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbGF0aXZlRWxlbWVudDtcbiIsIi8vICAgIGFiY19yZW5kZXJlci5qczogQVBJIHRvIHJlbmRlciB0byBTVkcvUmFwaGFlbC93aGF0ZXZlciByZW5kZXJpbmcgZW5naW5lXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBHcmVnb3J5IER5a2UgKGdyZWdkeWtlIGF0IGdtYWlsIGRvdCBjb20pXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLypnbG9iYWwgTWF0aCwgY29uc29sZSAqL1xuXG52YXIgZ2x5cGhzID0gcmVxdWlyZSgnLi9hYmNfZ2x5cGhzJyk7XG52YXIgc3BhY2luZyA9IHJlcXVpcmUoJy4vYWJjX3NwYWNpbmcnKTtcbnZhciBzcHJpbnRmID0gcmVxdWlyZSgnLi9zcHJpbnRmJyk7XG52YXIgU3ZnID0gcmVxdWlyZSgnLi9zdmcnKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBBUEkgZm9yIHJlbmRlcmluZyBBQkNKUyBBYnN0cmFjdCBSZW5kZXJpbmcgU3RydWN0dXJlIHRvIGEgY2FudmFzL3BhcGVyIChlLmcuIFNWRywgUmFwaGFlbCwgZXRjKVxuICogQHBhcmFtIHtPYmplY3R9IHBhcGVyXG4gKiBAcGFyYW0ge2Jvb2x9IGRvUmVncmVzc2lvblxuICovXG52YXIgUmVuZGVyZXIgPSBmdW5jdGlvbihwYXBlciwgZG9SZWdyZXNzaW9uLCBzaG91bGRBZGRDbGFzc2VzKSB7XG4gIHRoaXMucGFwZXIgPSBuZXcgU3ZnKHBhcGVyKTtcbiAgdGhpcy5jb250cm9sbGVyID0gbnVsbDsgLy9UT0RPLUdEIG9ubHkgdXNlZCB3aGVuIGRyYXdpbmcgdGhlIEFCQ0pTIEFSUyB0byBjb25uZWN0IHRoZSBjb250cm9sbGVyIHdpdGggdGhlIGVsZW1lbnRzIGZvciBoaWdobGlnaHRpbmdcblxuXHR0aGlzLnNwYWNlID0gMypzcGFjaW5nLlNQQUNFO1xuICB0aGlzLnBhZGRpbmcgPSB7fTsgLy8gcmVuZGVyZXIncyBwYWRkaW5nIGlzIG1hbmFnZWQgYnkgdGhlIGNvbnRyb2xsZXJcbiAgdGhpcy5kb1JlZ3Jlc3Npb24gPSBkb1JlZ3Jlc3Npb247XG4gIHRoaXMuc2hvdWxkQWRkQ2xhc3NlcyA9IHNob3VsZEFkZENsYXNzZXM7XG4gIGlmICh0aGlzLmRvUmVncmVzc2lvbilcbiAgICB0aGlzLnJlZ3Jlc3Npb25MaW5lcyA9IFtdO1xuXHR0aGlzLnJlc2V0KCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLnBhcGVyLmNsZWFyKCk7XG5cdHRoaXMueSA9IDA7XG5cdHRoaXMuYWJjdHVuZSA9IG51bGw7XG5cdHRoaXMubGFzdE0gPSBudWxsO1xuXHR0aGlzLmluZ3JvdXAgPSBmYWxzZTtcblx0dGhpcy5wYXRoID0gbnVsbDtcblx0dGhpcy5pc1ByaW50ID0gZmFsc2U7XG5cdHRoaXMuaW5pdFZlcnRpY2FsU3BhY2UoKTtcblx0aWYgKHRoaXMuZG9SZWdyZXNzaW9uKVxuXHRcdHRoaXMucmVncmVzc2lvbkxpbmVzID0gW107XG5cdC8vIEhBQ0stUEVSOiBUaGVyZSB3YXMgYSBwcm9ibGVtIGluIFJhcGhhZWwgd2hlcmUgZXZlcnkgcGF0aCBzdHJpbmcgdGhhdCB3YXMgc2VudCB0byBpdCB3YXMgY2FjaGVkLlxuXHQvLyBUaGF0IHdhcyBjYXVzaW5nIHRoZSBicm93c2VyJ3MgbWVtb3J5IHRvIHN0ZWFkaWx5IGdyb3cgdW50aWwgdGhlIGJyb3dzZXIgd2VudCBzbG93ZXIgYW5kIHNsb3dlciB1bnRpbFxuXHQvLyBpdCBjcmFzaGVkLiBUaGUgZml4IHRvIHRoYXQgd2FzIGEgcGF0Y2ggdG8gUmFwaGFlbCwgc28gaXQgaXMgb25seSBwYXRjaGVkIG9uIHRoZSB2ZXJzaW9ucyBvZiB0aGlzIGxpYnJhcnkgdGhhdFxuXHQvLyBidW5kbGUgUmFwaGFlbCB3aXRoIGl0LiBBbHNvLCBpZiBSYXBoYWVsIGdldHMgYW4gdXBkYXRlLCB0aGVuIHRoYXQgcGF0Y2ggd2lsbCBiZSBsb3N0LiBPbiB2ZXJzaW9uIDIuMS4yIG9mIFJhcGhhZWwsXG5cdC8vIHRoZSBwYXRjaCBpcyBvbiBsaW5lIDE1NDIgYW5kIDE1NDUgYW5kIGl0IGlzOlxuXHQvLyAgICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDE7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubmV3VHVuZSA9IGZ1bmN0aW9uKGFiY1R1bmUpIHtcblx0dGhpcy5hYmN0dW5lID0gYWJjVHVuZTsgLy8gVE9ETy1QRVI6IHRoaXMgaXMganVzdCB0byBnZXQgdGhlIGZvbnQgaW5mby5cblx0dGhpcy5zZXRWZXJ0aWNhbFNwYWNlKGFiY1R1bmUuZm9ybWF0dGluZyk7XG5cdHRoaXMubWVhc3VyZU51bWJlciA9IG51bGw7XG5cdHRoaXMubm90ZU51bWJlciA9IG51bGw7XG5cdHRoaXMuc2V0UHJpbnRNb2RlKGFiY1R1bmUubWVkaWEgPT09ICdwcmludCcpO1xuXHR0aGlzLnNldFBhZGRpbmcoYWJjVHVuZSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbVNldCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wYXBlci5vcGVuR3JvdXAoKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5jbG9zZUVsZW1TZXQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucGFwZXIuY2xvc2VHcm91cCgpO1xufTtcblxuLyoqXG4gKiBTZXQgd2hldGhlciB3ZSBhcmUgZm9ybWF0dGluZyB0aGlzIGZvciB0aGUgc2NyZWVuLCBvciBhcyBhIHByZXZpZXcgZm9yIGNyZWF0aW5nIGEgUERGIHZlcnNpb24uXG4gKiBAcGFyYW0ge2Jvb2x9IGlzUHJpbnRcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLnNldFByaW50TW9kZSA9IGZ1bmN0aW9uIChpc1ByaW50KSB7XG5cdHRoaXMuaXNQcmludCA9IGlzUHJpbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtvYmplY3R9IG1heHdpZHRoXG4gKiBAcGFyYW0ge29iamVjdH0gc2NhbGVcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLnNldFBhcGVyU2l6ZSA9IGZ1bmN0aW9uIChtYXh3aWR0aCwgc2NhbGUsIHJlc3BvbnNpdmUpIHtcblx0dmFyIHcgPSAobWF4d2lkdGgrdGhpcy5wYWRkaW5nLnJpZ2h0KSpzY2FsZTtcblx0dmFyIGggPSAodGhpcy55K3RoaXMucGFkZGluZy5ib3R0b20pKnNjYWxlO1xuXHRpZiAodGhpcy5pc1ByaW50KVxuXHRcdGggPSBNYXRoLm1heChoLCAxMDU2KTsgLy8gMTFpbiB4IDcycHQvaW4geCAxLjMzcHgvcHRcblx0Ly8gVE9ETy1QRVI6IFdlIGFyZSBsZXR0aW5nIHRoZSBwYWdlIGdldCBhcyBsb25nIGFzIGl0IG5lZWRzIG5vdywgYnV0IGV2ZW50dWFsbHkgdGhhdCBzaG91bGQgZ28gdG8gYSBzZWNvbmQgcGFnZS5cblx0aWYgKHRoaXMuZG9SZWdyZXNzaW9uKVxuXHRcdHRoaXMucmVncmVzc2lvbkxpbmVzLnB1c2goXCJQQVBFUiBTSVpFOiAoXCIrdytcIixcIitoK1wiKVwiKTtcblxuXHQvLyBmb3IgYWNjZXNzaWJpbGl0eVxuXHR2YXIgdGV4dCA9IFwiU2hlZXQgTXVzaWNcIjtcblx0aWYgKHRoaXMuYWJjdHVuZSAmJiB0aGlzLmFiY3R1bmUubWV0YVRleHQgJiYgdGhpcy5hYmN0dW5lLm1ldGFUZXh0LnRpdGxlKVxuXHRcdHRleHQgKz0gXCIgZm9yIFxcXCJcIiArIHRoaXMuYWJjdHVuZS5tZXRhVGV4dC50aXRsZSArICdcIic7XG5cdHRoaXMucGFwZXIuc2V0VGl0bGUodGV4dCk7XG5cblx0dmFyIHBhcmVudFN0eWxlcyA9IHsgb3ZlcmZsb3c6IFwiaGlkZGVuXCIgfTtcblx0aWYgKHJlc3BvbnNpdmUgPT09ICdyZXNpemUnKSB7XG5cdFx0dGhpcy5wYXBlci5zZXRSZXNwb25zaXZlV2lkdGgodywgaCk7XG5cdH0gZWxzZSB7XG5cdFx0cGFyZW50U3R5bGVzLndpZHRoID0gXCJcIjtcblx0XHRwYXJlbnRTdHlsZXMuaGVpZ2h0ID0gaCArIFwicHhcIjtcblx0XHRpZiAoc2NhbGUgPCAxKSB7XG5cdFx0XHRwYXJlbnRTdHlsZXMud2lkdGggPSB3ICsgXCJweFwiO1xuXHRcdFx0dGhpcy5wYXBlci5zZXRTaXplKHcgLyBzY2FsZSwgaCAvIHNjYWxlKTtcblx0XHR9IGVsc2Vcblx0XHRcdHRoaXMucGFwZXIuc2V0U2l6ZSh3LCBoKTtcblx0fVxuXHR0aGlzLnBhcGVyLnNldFNjYWxlKHNjYWxlKTtcblx0dGhpcy5wYXBlci5zZXRQYXJlbnRTdHlsZXMocGFyZW50U3R5bGVzKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBwYWRkaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5zZXRQYWRkaW5nT3ZlcnJpZGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0dGhpcy5wYWRkaW5nT3ZlcnJpZGUgPSB7IHRvcDogcGFyYW1zLnBhZGRpbmd0b3AsIGJvdHRvbTogcGFyYW1zLnBhZGRpbmdib3R0b20sXG5cdFx0cmlnaHQ6IHBhcmFtcy5wYWRkaW5ncmlnaHQsIGxlZnQ6IHBhcmFtcy5wYWRkaW5nbGVmdCB9O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhZGRpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbihhYmN0dW5lKSB7XG5cdC8vIElmIHRoZSBwYWRkaW5nIGlzIHNldCBpbiB0aGUgdHVuZSwgdGhlbiB1c2UgdGhhdC5cblx0Ly8gT3RoZXJ3aXNlLCBpZiB0aGUgcGFkZGluZyBpcyBzZXQgaW4gdGhlIG92ZXJyaWRlLCB1c2UgdGhhdC5cblx0Ly8gT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHRzICh0aGVyZSBhcmUgYSBkaWZmZXJlbnQgc2V0IG9mIGRlZmF1bHRzIGZvciBzY3JlZW4gYW5kIHByaW50Lilcblx0ZnVuY3Rpb24gc2V0UGFkZGluZ1ZhcmlhYmxlKHNlbGYsIHBhZGRpbmdLZXksIGZvcm1hdHRpbmdLZXksIHByaW50RGVmYXVsdCwgc2NyZWVuRGVmYXVsdCkge1xuXHRcdGlmIChhYmN0dW5lLmZvcm1hdHRpbmdbZm9ybWF0dGluZ0tleV0gIT09IHVuZGVmaW5lZClcblx0XHRcdHNlbGYucGFkZGluZ1twYWRkaW5nS2V5XSA9IGFiY3R1bmUuZm9ybWF0dGluZ1tmb3JtYXR0aW5nS2V5XTtcblx0XHRlbHNlIGlmIChzZWxmLnBhZGRpbmdPdmVycmlkZVtwYWRkaW5nS2V5XSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0c2VsZi5wYWRkaW5nW3BhZGRpbmdLZXldID0gc2VsZi5wYWRkaW5nT3ZlcnJpZGVbcGFkZGluZ0tleV07XG5cdFx0ZWxzZSBpZiAoc2VsZi5pc1ByaW50KVxuXHRcdFx0c2VsZi5wYWRkaW5nW3BhZGRpbmdLZXldID0gcHJpbnREZWZhdWx0O1xuXHRcdGVsc2Vcblx0XHRcdHNlbGYucGFkZGluZ1twYWRkaW5nS2V5XSA9IHNjcmVlbkRlZmF1bHQ7XG5cdH1cblx0Ly8gMWNtIHggMC4zOTM3MDFpbi9jbSB4IDcycHQvaW4geCAxLjMzcHgvcHQgPSAzOHB4XG5cdC8vIDEuOGNtIHggMC4zOTM3MDFpbi9jbSB4IDcycHQvaW4geCAxLjMzcHgvcHQgPSA2OHB4XG5cdHNldFBhZGRpbmdWYXJpYWJsZSh0aGlzLCAndG9wJywgJ3RvcG1hcmdpbicsIDM4LCAxNSk7XG5cdHNldFBhZGRpbmdWYXJpYWJsZSh0aGlzLCAnYm90dG9tJywgJ2JvdG1hcmdpbicsIDM4LCAxNSk7XG5cdHNldFBhZGRpbmdWYXJpYWJsZSh0aGlzLCAnbGVmdCcsICdsZWZ0bWFyZ2luJywgNjgsIDE1KTtcblx0c2V0UGFkZGluZ1ZhcmlhYmxlKHRoaXMsICdyaWdodCcsICdyaWdodG1hcmdpbicsIDY4LCAxNSk7XG59O1xuXG4vKipcbiAqIFNvbWUgb2YgdGhlIGl0ZW1zIG9uIHRoZSBwYWdlIGFyZSBub3Qgc2NhbGVkLCBzbyBhZGp1c3QgdGhlbSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIG9mIHNjYWxpbmcgdG8gY2FuY2VsIG91dCB0aGUgc2NhbGluZy5cbiAqIEBwYXJhbSB7ZmxvYXR9IHNjYWxlXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5hZGp1c3ROb25TY2FsZWRJdGVtcyA9IGZ1bmN0aW9uIChzY2FsZSkge1xuXHR0aGlzLnBhZGRpbmcudG9wIC89IHNjYWxlO1xuXHR0aGlzLnBhZGRpbmcuYm90dG9tIC89IHNjYWxlO1xuXHR0aGlzLnBhZGRpbmcubGVmdCAvPSBzY2FsZTtcblx0dGhpcy5wYWRkaW5nLnJpZ2h0IC89IHNjYWxlO1xuXHR0aGlzLmFiY3R1bmUuZm9ybWF0dGluZy5oZWFkZXJmb250LnNpemUgLz0gc2NhbGU7XG5cdHRoaXMuYWJjdHVuZS5mb3JtYXR0aW5nLmZvb3RlcmZvbnQuc2l6ZSAvPSBzY2FsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgdmFsdWVzIGZvciBhbGwgdGhlIGNvbmZpZ3VyYWJsZSB2ZXJ0aWNhbCBzcGFjZSBvcHRpb25zLlxuICovXG5SZW5kZXJlci5wcm90b3R5cGUuaW5pdFZlcnRpY2FsU3BhY2UgPSBmdW5jdGlvbigpIHtcblx0Ly8gY29udmVyc2lvbjogMzcuNzk1MyA9IGNvbnZlcnNpb24gZmFjdG9yIGZvciBjbSB0byBweC5cblx0Ly8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSBpbiBweC5cblx0dGhpcy5zcGFjaW5nID0ge1xuXHRcdGNvbXBvc2VyOiA3LjU2LCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSBjb21wb3Nlci5cblx0XHRncmFjZUJlZm9yZTogOC42NywgLy8gRGVmaW5lIHRoZSBzcGFjZSBiZWZvcmUsIGluc2lkZSBhbmQgYWZ0ZXIgdGhlIGdyYWNlIG5vdGVzLlxuXHRcdGdyYWNlSW5zaWRlOiAxMC42Nyxcblx0XHRncmFjZUFmdGVyOiAxNixcblx0XHRpbmZvOiAwLCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSBpbmZvbGluZS5cblx0XHRsaW5lU2tpcEZhY3RvcjogMS4xLCAvLyBTZXQgdGhlIGZhY3RvciBmb3Igc3BhY2luZyBiZXR3ZWVuIGxpbmVzIG9mIHRleHQuIChtdWx0aXBseSB0aGlzIGJ5IHRoZSBmb250IHNpemUpXG5cdFx0bXVzaWM6IDcuNTYsIC8vIFNldCB0aGUgdmVydGljYWwgc3BhY2UgYWJvdmUgdGhlIGZpcnN0IHN0YWZmLlxuXHRcdHBhcmFncmFwaFNraXBGYWN0b3I6IDAuNCwgLy8gU2V0IHRoZSBmYWN0b3IgZm9yIHNwYWNpbmcgYmV0d2VlbiB0ZXh0IHBhcmFncmFwaHMuIChtdWx0aXBseSB0aGlzIGJ5IHRoZSBmb250IHNpemUpXG5cdFx0cGFydHM6IDExLjMzLCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIGEgbmV3IHBhcnQuXG5cdFx0c2x1ckhlaWdodDogMS4wLCAvLyBTZXQgdGhlIHNsdXIgaGVpZ2h0IGZhY3Rvci5cblx0XHRzdGFmZlNlcGFyYXRpb246IDYxLjMzLCAvLyBEbyBub3QgcHV0IGEgc3RhZmYgc3lzdGVtIGNsb3NlciB0aGFuIDx1bml0PiBmcm9tIHRoZSBwcmV2aW91cyBzeXN0ZW0uXG5cdFx0c3RlbUhlaWdodDogMjYuNjcrMTAsIC8vIFNldCB0aGUgc3RlbSBoZWlnaHQuXG5cdFx0c3VidGl0bGU6IDMuNzgsIC8vIFNldCB0aGUgdmVydGljYWwgc3BhY2UgYWJvdmUgdGhlIHN1YnRpdGxlLlxuXHRcdHN5c3RlbVN0YWZmU2VwYXJhdGlvbjogNDgsIC8vIERvIG5vdCBwbGFjZSB0aGUgc3RhdmVzIGNsb3NlciB0aGFuIDx1bml0PiBpbnNpZGUgYSBzeXN0ZW0uICogVGhpcyB2YWx1ZXMgYXBwbGllcyB0byBhbGwgc3RhdmVzIHdoZW4gaW4gdGhlIHR1bmUgaGVhZGVyLiBPdGhlcndpc2UsIGl0IGFwcGxpZXMgdG8gdGhlIG5leHQgc3RhZmZcblx0XHR0ZXh0OiAxOC45LCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSBoaXN0b3J5LlxuXHRcdHRpdGxlOiA3LjU2LCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSB0aXRsZS5cblx0XHR0b3A6IDMwLjI0LCAvL1NldCB0aGUgdmVydGljYWwgc3BhY2UgYWJvdmUgdGhlIHR1bmVzIGFuZCBvbiB0aGUgdG9wIG9mIHRoZSBjb250aW51YXRpb24gcGFnZXMuXG5cdFx0dm9jYWw6IDMwLjY3LCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSBseXJpY3MgdW5kZXIgdGhlIHN0YXZlcy5cblx0XHR3b3JkczogMCAvLyBTZXQgdGhlIHZlcnRpY2FsIHNwYWNlIGFib3ZlIHRoZSBseXJpY3MgYXQgdGhlIGVuZCBvZiB0aGUgdHVuZS5cblx0fTtcblx0Lypcblx0VE9ETy1QRVI6IEhhbmRsZSB0aGUgeC1jb29yZGluYXRlIHNwYWNpbmcgaXRlbXMsIHRvby5cbm1heHNocmluayA8ZmxvYXQ+RGVmYXVsdDogMC42NVxuU2V0IGhvdyBtdWNoIHRvIGNvbXByZXNzIGhvcml6b250YWxseSB3aGVuIG11c2ljIGxpbmUgYnJlYWtzXG5hcmUgYXV0b21hdGljLlxuPGZsb2F0PiBtdXN0IGJlIGJldHdlZW4gMCAobmF0dXJhbCBzcGFjaW5nKVxuYW5kIDEgKG1heCBzaHJpbmtpbmcpLlxuXG4vLyBUaGlzIG5leHQgdmFsdWUgaXMgdXNlZCB0byBjb21wdXRlIHRoZSBuYXR1cmFsIHNwYWNpbmcgb2Zcbi8vIHRoZSBub3Rlcy4gVGhlIGJhc2Ugc3BhY2luZyBvZiB0aGUgY3JvdGNoZXQgaXMgYWx3YXlzXG4vLyA0MCBwdHMuIFdoZW4gdGhlIGR1cmF0aW9uIG9mIGEgbm90ZSB0eXBlIGlzIHR3aWNlIHRoZVxuLy8gZHVyYXRpb24gb2YgYW4gb3RoZXIgbm90ZSB0eXBlLCBpdHMgc3BhY2luZyBpcyBtdWx0aXBsaWVkXG4vLyBieSB0aGlzIGZhY3Rvci5cbi8vIFRoZSBkZWZhdWx0IHZhbHVlIGNhdXNlcyB0aGUgbm90ZSBzcGFjaW5nIHRvIGJlIG11bHRpcGxpZWRcbi8vIGJ5IDIgd2hlbiBpdHMgZHVyYXRpb24gaXMgbXVsdGlwbGllZCBieSA0LCBpLmUuIHRoZVxuLy8gc3BhY2Ugb2YgdGhlIHNlbWlicmV2ZSBpcyA4MCBwdHMgYW5kIHRoZSBzcGFjZSBvZiB0aGVcbi8vIHNlbWlxdWF2ZXIgaXMgMjAgcHRzLlxuLy8gU2V0dGluZyB0aGlzIHZhbHVlIHRvIDEgc2V0cyBhbGwgbm90ZSBzcGFjaW5nIHRvIDQwIHB0cy5cbm5vdGVTcGFjaW5nRmFjdG9yOiAxLjQxNCwgLy8gU2V0IHRoZSBub3RlIHNwYWNpbmcgZmFjdG9yIHRvIDxmbG9hdD4gKHJhbmdlIDEuLjIpLlxuXG5zY2FsZSA8ZmxvYXQ+IERlZmF1bHQ6IDAuNzUgU2V0IHRoZSBwYWdlIHNjYWxlIGZhY3Rvci4gTm90ZSB0aGF0IHRoZSBoZWFkZXIgYW5kIGZvb3RlciBhcmUgbm90IHNjYWxlZC5cblxuc3RyZXRjaGxhc3QgPGZsb2F0PkRlZmF1bHQ6IDAuOFxuU3RyZXRjaCB0aGUgbGFzdCBtdXNpYyBsaW5lIG9mIGEgdHVuZSB3aGVuIGl0IGV4Y2VlZHNcbnRoZSA8ZmxvYXQ+IGZyYWN0aW9uIG9mIHRoZSBwYWdlIHdpZHRoLlxuPGZsb2F0PiByYW5nZSBpcyAwLjAgdG8gMS4wLlxuXHQgKi9cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5zZXRWZXJ0aWNhbFNwYWNlID0gZnVuY3Rpb24oZm9ybWF0dGluZykge1xuXHQvLyBjb252ZXJzaW9uIGZyb20gcHRzIHRvIHB4IDQvM1xuXHRpZiAoZm9ybWF0dGluZy5zdGFmZnNlcCAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuc3BhY2luZy5zdGFmZlNlcGFyYXRpb24gPSBmb3JtYXR0aW5nLnN0YWZmc2VwICo0LzM7XG5cdGlmIChmb3JtYXR0aW5nLmNvbXBvc2Vyc3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcuY29tcG9zZXIgPSBmb3JtYXR0aW5nLmNvbXBvc2Vyc3BhY2UgKjQvMztcblx0aWYgKGZvcm1hdHRpbmcucGFydHNzcGFjZSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuc3BhY2luZy5wYXJ0cyA9IGZvcm1hdHRpbmcucGFydHNzcGFjZSAqNC8zO1xuXHRpZiAoZm9ybWF0dGluZy50ZXh0c3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcudGV4dCA9IGZvcm1hdHRpbmcudGV4dHNwYWNlICo0LzM7XG5cdGlmIChmb3JtYXR0aW5nLm11c2ljc3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcubXVzaWMgPSBmb3JtYXR0aW5nLm11c2ljc3BhY2UgKjQvMztcblx0aWYgKGZvcm1hdHRpbmcudGl0bGVzcGFjZSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuc3BhY2luZy50aXRsZSA9IGZvcm1hdHRpbmcudGl0bGVzcGFjZSAqNC8zO1xuXHRpZiAoZm9ybWF0dGluZy5zeXNzdGFmZnNlcCAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuc3BhY2luZy5zeXN0ZW1TdGFmZlNlcGFyYXRpb24gPSBmb3JtYXR0aW5nLnN5c3N0YWZmc2VwICo0LzM7XG5cdGlmIChmb3JtYXR0aW5nLnN1YnRpdGxlc3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcuc3VidGl0bGUgPSBmb3JtYXR0aW5nLnN1YnRpdGxlc3BhY2UgKjQvMztcblx0aWYgKGZvcm1hdHRpbmcudG9wc3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcudG9wID0gZm9ybWF0dGluZy50b3BzcGFjZSAqNC8zO1xuXHRpZiAoZm9ybWF0dGluZy52b2NhbHNwYWNlICE9PSB1bmRlZmluZWQpXG5cdFx0dGhpcy5zcGFjaW5nLnZvY2FsID0gZm9ybWF0dGluZy52b2NhbHNwYWNlICo0LzM7XG5cdGlmIChmb3JtYXR0aW5nLndvcmRzc3BhY2UgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnNwYWNpbmcud29yZHMgPSBmb3JtYXR0aW5nLndvcmRzc3BhY2UgKjQvMztcbn07XG5cbi8qKlxuICogTGVhdmUgc3BhY2UgYXQgdGhlIHRvcCBvZiB0aGUgcGFwZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBhYmN0dW5lXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS50b3BNYXJnaW4gPSBmdW5jdGlvbihhYmN0dW5lKSB7XG5cdFx0dGhpcy5tb3ZlWSh0aGlzLnBhZGRpbmcudG9wKTtcbn07XG5cbi8qKlxuICogTGVhdmUgc3BhY2UgYmVmb3JlIHByaW50aW5nIHRoZSBtdXNpY1xuICovXG5SZW5kZXJlci5wcm90b3R5cGUuYWRkTXVzaWNQYWRkaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tb3ZlWSh0aGlzLnNwYWNpbmcubXVzaWMpO1xufTtcblxuLyoqXG4gKiBMZWF2ZSBzcGFjZSBiZWZvcmUgcHJpbnRpbmcgYSBzdGFmZiBzeXN0ZW1cbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLmFkZFN0YWZmUGFkZGluZyA9IGZ1bmN0aW9uKGxhc3RTdGFmZkdyb3VwLCB0aGlzU3RhZmZHcm91cCkge1xuXHR2YXIgbGFzdFN0YWZmID0gbGFzdFN0YWZmR3JvdXAuc3RhZmZzW2xhc3RTdGFmZkdyb3VwLnN0YWZmcy5sZW5ndGgtMV07XG5cdHZhciBsYXN0Qm90dG9tTGluZSA9IC0obGFzdFN0YWZmLmJvdHRvbSAtIDIpOyAvLyBUaGUgMiBpcyBiZWNhdXNlIHRoZSBzY2FsZSBnb2VzIHRvIDIgYmVsb3cgdGhlIGxhc3QgbGluZS5cblx0dmFyIG5leHRUb3BMaW5lID0gdGhpc1N0YWZmR3JvdXAuc3RhZmZzWzBdLnRvcCAtIDEwOyAvLyBCZWNhdXNlIDEwIHJlcHJlc2VudHMgdGhlIHRvcCBsaW5lLlxuXHR2YXIgbmF0dXJhbFNlcGFyYXRpb24gPSBuZXh0VG9wTGluZSArIGxhc3RCb3R0b21MaW5lOyAvLyBUaGlzIGlzIGhvdyBmYXIgYXBhcnQgdGhleSdkIGJlIHdpdGhvdXQgZXh0cmEgc3BhY2luZ1xuXHR2YXIgc2VwYXJhdGlvbkluUGl4ZWxzID0gbmF0dXJhbFNlcGFyYXRpb24gKiBzcGFjaW5nLlNURVA7XG5cdGlmIChzZXBhcmF0aW9uSW5QaXhlbHMgPCB0aGlzLnNwYWNpbmcuc3RhZmZTZXBhcmF0aW9uKVxuXHRcdHRoaXMubW92ZVkodGhpcy5zcGFjaW5nLnN0YWZmU2VwYXJhdGlvbi1zZXBhcmF0aW9uSW5QaXhlbHMpO1xufTtcblxuLyoqXG4gKiBUZXh0IHRoYXQgZ29lcyBhYm92ZSB0aGUgc2NvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtvYmplY3R9IGFiY3R1bmVcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLmVuZ3JhdmVUb3BUZXh0ID0gZnVuY3Rpb24od2lkdGgsIGFiY3R1bmUpIHtcblx0aWYgKGFiY3R1bmUubWV0YVRleHQuaGVhZGVyICYmIHRoaXMuaXNQcmludCkge1xuXHRcdC8vIE5vdGU6IHdoZXRoZXIgdGhlcmUgaXMgYSBoZWFkZXIgb3Igbm90IGRvZXNuJ3QgY2hhbmdlIGFueSBvdGhlciBwb3NpdGlvbmluZywgc28gdGhpcyBkb2Vzbid0IGNoYW5nZSB0aGUgWS1jb29yZGluYXRlLlxuXHRcdC8vIFRoaXMgdGV4dCBnb2VzIGFib3ZlIHRoZSBtYXJnaW4sIHNvIHdlJ2xsIHRlbXBvcmFyaWx5IG1vdmUgdXAuXG5cdFx0dmFyIGhlYWRlclRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRTaXplKFwiWFhYWFwiLCBcImhlYWRlcmZvbnRcIiwgJ2FiY2pzLWhlYWRlciBhYmNqcy1tZXRhLXRvcCcpLmhlaWdodDtcblx0XHR0aGlzLnkgLT1oZWFkZXJUZXh0SGVpZ2h0O1xuXHRcdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0LCBhYmN0dW5lLm1ldGFUZXh0LmhlYWRlci5sZWZ0LCAnaGVhZGVyZm9udCcsICdoZWFkZXIgbWV0YS10b3AnLCAwLCBudWxsLCAnc3RhcnQnKTtcblx0XHR0aGlzLm91dHB1dFRleHRJZih0aGlzLnBhZGRpbmcubGVmdCArIHdpZHRoIC8gMiwgYWJjdHVuZS5tZXRhVGV4dC5oZWFkZXIuY2VudGVyLCAnaGVhZGVyZm9udCcsICdoZWFkZXIgbWV0YS10b3AnLCAwLCBudWxsLCAnbWlkZGxlJyk7XG5cdFx0dGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQgKyB3aWR0aCwgYWJjdHVuZS5tZXRhVGV4dC5oZWFkZXIucmlnaHQsICdoZWFkZXJmb250JywgJ2hlYWRlciBtZXRhLXRvcCcsIDAsIG51bGwsICdlbmQnKTtcblx0XHR0aGlzLnkgKz0gaGVhZGVyVGV4dEhlaWdodDtcblx0fVxuXHRpZiAodGhpcy5pc1ByaW50KVxuXHRcdHRoaXMubW92ZVkodGhpcy5zcGFjaW5nLnRvcCk7XG5cdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0ICsgd2lkdGggLyAyLCBhYmN0dW5lLm1ldGFUZXh0LnRpdGxlLCAndGl0bGVmb250JywgJ3RpdGxlIG1ldGEtdG9wJywgdGhpcy5zcGFjaW5nLnRpdGxlLCAwLCAnbWlkZGxlJyk7XG5cdGlmIChhYmN0dW5lLmxpbmVzWzBdKVxuXHRcdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0ICsgd2lkdGggLyAyLCBhYmN0dW5lLmxpbmVzWzBdLnN1YnRpdGxlLCAnc3VidGl0bGVmb250JywgJ3RleHQgbWV0YS10b3AnLCB0aGlzLnNwYWNpbmcuc3VidGl0bGUsIDAsICdtaWRkbGUnKTtcblxuXHRpZiAoYWJjdHVuZS5tZXRhVGV4dC5yaHl0aG0gfHwgYWJjdHVuZS5tZXRhVGV4dC5vcmlnaW4gfHwgYWJjdHVuZS5tZXRhVGV4dC5jb21wb3Nlcikge1xuXHRcdHRoaXMubW92ZVkodGhpcy5zcGFjaW5nLmNvbXBvc2VyKTtcblx0XHR2YXIgclNwYWNlID0gdGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQsIGFiY3R1bmUubWV0YVRleHQucmh5dGhtLCAnaW5mb2ZvbnQnLCAnbWV0YS10b3AnLCAwLCBudWxsLCBcInN0YXJ0XCIpO1xuXG5cdFx0dmFyIGNvbXBvc2VyTGluZSA9IFwiXCI7XG5cdFx0aWYgKGFiY3R1bmUubWV0YVRleHQuY29tcG9zZXIpIGNvbXBvc2VyTGluZSArPSBhYmN0dW5lLm1ldGFUZXh0LmNvbXBvc2VyO1xuXHRcdGlmIChhYmN0dW5lLm1ldGFUZXh0Lm9yaWdpbikgY29tcG9zZXJMaW5lICs9ICcgKCcgKyBhYmN0dW5lLm1ldGFUZXh0Lm9yaWdpbiArICcpJztcblx0XHRpZiAoY29tcG9zZXJMaW5lLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBzcGFjZSA9IHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0ICsgd2lkdGgsIGNvbXBvc2VyTGluZSwgJ2NvbXBvc2VyZm9udCcsICdtZXRhLXRvcCcsIDAsIG51bGwsIFwiZW5kXCIpO1xuXHRcdFx0dGhpcy5tb3ZlWShzcGFjZVsxXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW92ZVkoclNwYWNlWzFdKTtcblx0XHR9XG5cdFx0Ly8gVE9ETy1QRVI6IFRoZSBmb2xsb3dpbmcgaXMgYSBoYWNrIHRvIG1ha2UgdGhlIGVsZW1lbnRzIGxpbmUgdXAgd2l0aCBhYmNtMnBzLiBEb24ndCBrbm93IHdoZXJlIHRoZSBleHRyYSBzcGFjZSBpcyBjb21pbmcgZnJvbS5cblx0XHR0aGlzLm1vdmVZKC02KTtcblx0Ly99IGVsc2UgaWYgKHRoaXMuaXNQcmludCkge1xuXHQvL1x0Ly8gYWJjbTJwcyBhZGRzIHRoaXMgc3BhY2Ugd2hldGhlciB0aGVyZSBpcyBhbnl0aGluZyB0byB3cml0ZSBvciBub3QuXG5cdC8vXHR0aGlzLm1vdmVZKHRoaXMuc3BhY2luZy5jb21wb3Nlcik7XG5cdC8vXHR2YXIgc3BhY2UyID0gdGhpcy5nZXRUZXh0U2l6ZShcIk1cIiwgJ2NvbXBvc2VyZm9udCcsICdtZXRhLXRvcCcpO1xuXHQvL1x0dGhpcy5tb3ZlWShzcGFjZTIuaGVpZ2h0KTtcblx0fVxuXG5cdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0ICsgd2lkdGgsIGFiY3R1bmUubWV0YVRleHQuYXV0aG9yLCAnY29tcG9zZXJmb250JywgJ21ldGEtdG9wJywgMCwgMCwgXCJlbmRcIik7XG5cdC8vdGhpcy5za2lwU3BhY2VZKCk7XG5cblx0dGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQsIGFiY3R1bmUubWV0YVRleHQucGFydE9yZGVyLCAncGFydHNmb250JywgJ21ldGEtYm90dG9tJywgMCwgMCwgXCJzdGFydFwiKTtcbn07XG5cbi8qKlxuICogVGV4dCB0aGF0IGdvZXMgYmVsb3cgdGhlIHNjb3JlXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBhYmN0dW5lXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5lbmdyYXZlRXh0cmFUZXh0ID0gZnVuY3Rpb24od2lkdGgsIGFiY3R1bmUpIHtcblx0dGhpcy5saW5lTnVtYmVyID0gbnVsbDtcblx0dGhpcy5tZWFzdXJlTnVtYmVyID0gbnVsbDtcblx0dGhpcy5ub3RlTnVtYmVyID0gbnVsbDtcblx0dGhpcy52b2ljZU51bWJlciA9IG51bGw7XG5cblx0aWYgKGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHMpIHtcblx0XHR2YXIgaGFzaCA9IHRoaXMuZ2V0Rm9udEFuZEF0dHIoXCJ3b3Jkc2ZvbnRcIiwgJ21ldGEtYm90dG9tJyk7XG5cdFx0dmFyIHNwYWNlID0gdGhpcy5nZXRUZXh0U2l6ZShcImlcIiwgJ3dvcmRzZm9udCcsICdtZXRhLWJvdHRvbScpO1xuXG5cdFx0aWYgKGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHMubGVuZ3RoID4gMClcblx0XHRcdHRoaXMubW92ZVkodGhpcy5zcGFjaW5nLndvcmRzLCAxKTtcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmIChhYmN0dW5lLm1ldGFUZXh0LnVuYWxpZ25lZFdvcmRzW2pdID09PSAnJylcblx0XHRcdFx0dGhpcy5tb3ZlWShoYXNoLmZvbnQuc2l6ZSwgMSk7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYWJjdHVuZS5tZXRhVGV4dC51bmFsaWduZWRXb3Jkc1tqXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQgKyBzcGFjaW5nLklOREVOVCwgYWJjdHVuZS5tZXRhVGV4dC51bmFsaWduZWRXb3Jkc1tqXSwgJ3dvcmRzZm9udCcsICdtZXRhLWJvdHRvbScsIDAsIDAsIFwic3RhcnRcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbGFyZ2VzdFkgPSAwO1xuXHRcdFx0XHR2YXIgb2Zmc2V0WCA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgYWJjdHVuZS5tZXRhVGV4dC51bmFsaWduZWRXb3Jkc1tqXS5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdHZhciB0aGlzV29yZCA9IGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHNbal1ba107XG5cdFx0XHRcdFx0dmFyIHR5cGUgPSAodGhpc1dvcmQuZm9udCkgPyB0aGlzV29yZC5mb250IDogXCJ3b3Jkc2ZvbnRcIjtcblx0XHRcdFx0XHR2YXIgZWwgPSB0aGlzLnJlbmRlclRleHQodGhpcy5wYWRkaW5nLmxlZnQgKyBzcGFjaW5nLklOREVOVCArIG9mZnNldFgsIHRoaXMueSwgdGhpc1dvcmQudGV4dCwgdHlwZSwgJ21ldGEtYm90dG9tJywgZmFsc2UpO1xuXHRcdFx0XHRcdHZhciBzaXplID0gdGhpcy5nZXRUZXh0U2l6ZSh0aGlzV29yZC50ZXh0LCB0eXBlLCAnbWV0YS1ib3R0b20nKTtcblx0XHRcdFx0XHRsYXJnZXN0WSA9IE1hdGgubWF4KGxhcmdlc3RZLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdFx0b2Zmc2V0WCArPSBzaXplLndpZHRoO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwaHJhc2UgZW5kcyBpbiBhIHNwYWNlLCB0aGVuIHRoYXQgaXMgbm90IGNvdW50ZWQgaW4gdGhlIHdpZHRoLCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGF0IGluIG91cnNlbHZlcy5cblx0XHRcdFx0XHRpZiAodGhpc1dvcmQudGV4dFt0aGlzV29yZC50ZXh0Lmxlbmd0aC0xXSA9PT0gJyAnKSB7XG5cdFx0XHRcdFx0XHRvZmZzZXRYICs9IHNwYWNlLndpZHRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm1vdmVZKGxhcmdlc3RZLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHMubGVuZ3RoID4gMClcblx0XHRcdHRoaXMubW92ZVkoaGFzaC5mb250LnNpemUsIDIpO1xuXHR9XG5cblx0dmFyIGV4dHJhVGV4dCA9IFwiXCI7XG5cdGlmIChhYmN0dW5lLm1ldGFUZXh0LmJvb2spIGV4dHJhVGV4dCArPSBcIkJvb2s6IFwiICsgYWJjdHVuZS5tZXRhVGV4dC5ib29rICsgXCJcXG5cIjtcblx0aWYgKGFiY3R1bmUubWV0YVRleHQuc291cmNlKSBleHRyYVRleHQgKz0gXCJTb3VyY2U6IFwiICsgYWJjdHVuZS5tZXRhVGV4dC5zb3VyY2UgKyBcIlxcblwiO1xuXHRpZiAoYWJjdHVuZS5tZXRhVGV4dC5kaXNjb2dyYXBoeSkgZXh0cmFUZXh0ICs9IFwiRGlzY29ncmFwaHk6IFwiICsgYWJjdHVuZS5tZXRhVGV4dC5kaXNjb2dyYXBoeSArIFwiXFxuXCI7XG5cdGlmIChhYmN0dW5lLm1ldGFUZXh0Lm5vdGVzKSBleHRyYVRleHQgKz0gXCJOb3RlczogXCIgKyBhYmN0dW5lLm1ldGFUZXh0Lm5vdGVzICsgXCJcXG5cIjtcblx0aWYgKGFiY3R1bmUubWV0YVRleHQudHJhbnNjcmlwdGlvbikgZXh0cmFUZXh0ICs9IFwiVHJhbnNjcmlwdGlvbjogXCIgKyBhYmN0dW5lLm1ldGFUZXh0LnRyYW5zY3JpcHRpb24gKyBcIlxcblwiO1xuXHRpZiAoYWJjdHVuZS5tZXRhVGV4dC5oaXN0b3J5KSBleHRyYVRleHQgKz0gXCJIaXN0b3J5OiBcIiArIGFiY3R1bmUubWV0YVRleHQuaGlzdG9yeSArIFwiXFxuXCI7XG5cdGlmIChhYmN0dW5lLm1ldGFUZXh0WydhYmMtY29weXJpZ2h0J10pIGV4dHJhVGV4dCArPSBcIkNvcHlyaWdodDogXCIgKyBhYmN0dW5lLm1ldGFUZXh0WydhYmMtY29weXJpZ2h0J10gKyBcIlxcblwiO1xuXHRpZiAoYWJjdHVuZS5tZXRhVGV4dFsnYWJjLWNyZWF0b3InXSkgZXh0cmFUZXh0ICs9IFwiQ3JlYXRvcjogXCIgKyBhYmN0dW5lLm1ldGFUZXh0WydhYmMtY3JlYXRvciddICsgXCJcXG5cIjtcblx0aWYgKGFiY3R1bmUubWV0YVRleHRbJ2FiYy1lZGl0ZWQtYnknXSkgZXh0cmFUZXh0ICs9IFwiRWRpdGVkIEJ5OiBcIiArIGFiY3R1bmUubWV0YVRleHRbJ2FiYy1lZGl0ZWQtYnknXSArIFwiXFxuXCI7XG5cdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0LCBleHRyYVRleHQsICdoaXN0b3J5Zm9udCcsICdtZXRhLWJvdHRvbScsIHRoaXMuc3BhY2luZy5pbmZvLCAwLCBcInN0YXJ0XCIpO1xuXG5cdGlmIChhYmN0dW5lLm1ldGFUZXh0LmZvb3RlciAmJiB0aGlzLmlzUHJpbnQpIHtcblx0XHQvLyBOb3RlOiB3aGV0aGVyIHRoZXJlIGlzIGEgZm9vdGVyIG9yIG5vdCBkb2Vzbid0IGNoYW5nZSBhbnkgb3RoZXIgcG9zaXRpb25pbmcsIHNvIHRoaXMgZG9lc24ndCBjaGFuZ2UgdGhlIFktY29vcmRpbmF0ZS5cblx0XHR0aGlzLm91dHB1dFRleHRJZih0aGlzLnBhZGRpbmcubGVmdCwgYWJjdHVuZS5tZXRhVGV4dC5mb290ZXIubGVmdCwgJ2Zvb3RlcmZvbnQnLCAnaGVhZGVyIG1ldGEtYm90dG9tJywgMCwgbnVsbCwgJ3N0YXJ0Jyk7XG5cdFx0dGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQgKyB3aWR0aCAvIDIsIGFiY3R1bmUubWV0YVRleHQuZm9vdGVyLmNlbnRlciwgJ2Zvb3RlcmZvbnQnLCAnaGVhZGVyIG1ldGEtYm90dG9tJywgMCwgbnVsbCwgJ21pZGRsZScpO1xuXHRcdHRoaXMub3V0cHV0VGV4dElmKHRoaXMucGFkZGluZy5sZWZ0ICsgd2lkdGgsIGFiY3R1bmUubWV0YVRleHQuZm9vdGVyLnJpZ2h0LCAnZm9vdGVyZm9udCcsICdoZWFkZXIgbWV0YS1ib3R0b20nLCAwLCBudWxsLCAnZW5kJyk7XG5cdH1cbn07XG5cbi8qKlxuICogT3V0cHV0IHRleHQgZGVmaW5lZCB3aXRoICUldGV4dC5cbiAqIEBwYXJhbSB7YXJyYXkgb3Igc3RyaW5nfSB0ZXh0XG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5vdXRwdXRGcmVlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB2c2tpcCkge1xuXHRpZiAodnNraXApXG5cdFx0dGhpcy5tb3ZlWSh2c2tpcCk7XG5cdHZhciBoYXNoID0gdGhpcy5nZXRGb250QW5kQXR0cigndGV4dGZvbnQnLCAnZGVmaW5lZC10ZXh0Jyk7XG5cdGlmICh0ZXh0ID09PSBcIlwiKSB7XHQvLyB3ZSBkbyB3YW50IHRvIHByaW50IG91dCBibGFuayBsaW5lcyBpZiB0aGV5IGhhdmUgYmVlbiBzcGVjaWZpZWQuXG5cdFx0dGhpcy5tb3ZlWShoYXNoLmF0dHJbJ2ZvbnQtc2l6ZSddICogMik7IC8vIG1vdmUgdGhlIGRpc3RhbmNlIG9mIHRoZSBsaW5lLCBwbHVzIHRoZSBkaXN0YW5jZSBvZiB0aGUgbWFyZ2luLCB3aGljaCBpcyBhbHNvIG9uZSBsaW5lLlxuXHR9IGVsc2UgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuXHRcdHRoaXMubW92ZVkoaGFzaC5hdHRyWydmb250LXNpemUnXS8yKTsgLy8gVE9ETy1QRVI6IG1vdmUgZG93biBzb21lIC0gdGhlIHkgbG9jYXRpb24gc2hvdWxkIGJlIHRoZSB0b3Agb2YgdGhlIHRleHQsIGJ1dCB3ZSBvdXRwdXQgdGV4dCBzcGVjaWZ5aW5nIHRoZSBjZW50ZXIgbGluZS5cblx0XHR0aGlzLm91dHB1dFRleHRJZih0aGlzLnBhZGRpbmcubGVmdCwgdGV4dCwgJ3RleHRmb250JywgJ2RlZmluZWQtdGV4dCcsIDAsIDAsIFwic3RhcnRcIik7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHN0ciA9IFwiXCI7XG5cdFx0dmFyIGlzQ2VudGVyZWQgPSBmYWxzZTsgLy8gVGhlIHN0cnVjdHVyZSBpcyB3cm9uZyBoZXJlOiBpdCByZXF1aXJlcyBhbiBhcnJheSB0byBkbyBjZW50ZXJpbmcsIGJ1dCBpdCBzaG91bGRuJ3QgaGF2ZS5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0ZXh0W2ldLmZvbnQpXG5cdFx0XHRcdHN0ciArPSBcIkZPTlQoXCIgKyB0ZXh0W2ldLmZvbnQgKyBcIilcIjtcblx0XHRcdHN0ciArPSB0ZXh0W2ldLnRleHQ7XG5cdFx0XHRpZiAodGV4dFtpXS5jZW50ZXIpXG5cdFx0XHRcdGlzQ2VudGVyZWQgPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYWxpZ25tZW50ID0gaXNDZW50ZXJlZCA/ICdtaWRkbGUnIDogJ3N0YXJ0Jztcblx0XHR2YXIgeCA9IGlzQ2VudGVyZWQgPyB0aGlzLmNvbnRyb2xsZXIud2lkdGggLyAyIDogdGhpcy5wYWRkaW5nLmxlZnQ7XG5cdFx0dGhpcy5vdXRwdXRUZXh0SWYoeCwgc3RyLCAndGV4dGZvbnQnLCAnZGVmaW5lZC10ZXh0JywgMCwgMSwgYWxpZ25tZW50KTtcblx0fVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLm91dHB1dFNlcGFyYXRvciA9IGZ1bmN0aW9uIChzZXBhcmF0b3IpIHtcblx0aWYgKCFzZXBhcmF0b3IubGluZUxlbmd0aClcblx0XHRyZXR1cm47XG5cdHRoaXMubW92ZVkoc2VwYXJhdG9yLnNwYWNlQWJvdmUpO1xuXHR0aGlzLnByaW50U2VwYXJhdG9yKHNlcGFyYXRvci5saW5lTGVuZ3RoKTtcblx0dGhpcy5tb3ZlWShzZXBhcmF0b3Iuc3BhY2VCZWxvdyk7XG59O1xuXG4vKipcbiAqIE91dHB1dCBhbiBleHRyYSBzdWJ0aXRsZSB0aGF0IGlzIGRlZmluZWQgbGF0ZXIgaW4gdGhlIHR1bmUuXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5vdXRwdXRTdWJ0aXRsZSA9IGZ1bmN0aW9uICh3aWR0aCwgc3VidGl0bGUpIHtcblx0dGhpcy5vdXRwdXRUZXh0SWYodGhpcy5wYWRkaW5nLmxlZnQgKyB3aWR0aCAvIDIsIHN1YnRpdGxlLCAnc3VidGl0bGVmb250JywgJ3RleHQgbWV0YS10b3AnLCB0aGlzLnNwYWNpbmcuc3VidGl0bGUsIDAsICdtaWRkbGUnKTtcbn07XG5cbi8qKlxuICogQmVnaW4gYSBncm91cCBvZiBnbHlwaHMgdGhhdCB3aWxsIGFsd2F5cyBiZSBtb3ZlZCwgc2NhbGVkIGFuZCBoaWdobGlnaHRlZCB0b2dldGhlclxuICovXG5SZW5kZXJlci5wcm90b3R5cGUuYmVnaW5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYXRoID0gW107XG4gIHRoaXMubGFzdE0gPSBbMCwwXTtcbiAgdGhpcy5pbmdyb3VwID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgcGF0aCB0byB0aGUgY3VycmVudCBncm91cFxuICogQHBhcmFtIHtBcnJheX0gcGF0aFxuICogQHByaXZhdGVcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLmFkZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICBwYXRoID0gcGF0aCB8fCBbXTtcbiAgaWYgKHBhdGgubGVuZ3RoPT09MCkgcmV0dXJuO1xuICBwYXRoWzBdWzBdPVwibVwiO1xuICBwYXRoWzBdWzFdLT10aGlzLmxhc3RNWzBdO1xuICBwYXRoWzBdWzJdLT10aGlzLmxhc3RNWzFdO1xuICB0aGlzLmxhc3RNWzBdKz1wYXRoWzBdWzFdO1xuICB0aGlzLmxhc3RNWzFdKz1wYXRoWzBdWzJdO1xuICB0aGlzLnBhdGgucHVzaChwYXRoWzBdKTtcbiAgZm9yICh2YXIgaT0xLGlpPXBhdGgubGVuZ3RoO2k8aWk7aSsrKSB7XG4gICAgaWYgKHBhdGhbaV1bMF09PT1cIm1cIikge1xuICAgICAgdGhpcy5sYXN0TVswXSs9cGF0aFtpXVsxXTtcbiAgICAgIHRoaXMubGFzdE1bMV0rPXBhdGhbaV1bMl07XG4gICAgfVxuICAgIHRoaXMucGF0aC5wdXNoKHBhdGhbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuZCBhIGdyb3VwIG9mIGdseXBocyB0aGF0IHdpbGwgYWx3YXlzIGJlIG1vdmVkLCBzY2FsZWQgYW5kIGhpZ2hsaWdodGVkIHRvZ2V0aGVyXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5lbmRHcm91cCA9IGZ1bmN0aW9uIChrbGFzcykge1xuICB0aGlzLmluZ3JvdXAgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGF0aC5sZW5ndGg9PT0wKSByZXR1cm4gbnVsbDtcbiAgdmFyIHBhdGggPSBcIlwiO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKylcblx0XHRwYXRoICs9IHRoaXMucGF0aFtpXS5qb2luKFwiIFwiKTtcblx0dmFyIHJldCA9IHRoaXMucGFwZXIucGF0aCh7cGF0aDogcGF0aCwgc3Ryb2tlOlwibm9uZVwiLCBmaWxsOlwiIzAwMDAwMFwiLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoa2xhc3MpfSk7XG5cdHRoaXMucGF0aCA9IFtdO1xuICBpZiAodGhpcy5kb1JlZ3Jlc3Npb24pIHRoaXMuYWRkVG9SZWdyZXNzaW9uKHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogZ2V0cyBzY2FsZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBzdGFydCB4XG4gKiBAcGFyYW0ge251bWJlcn0geDIgZW5kIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXRjaCBwaXRjaCB0aGUgc3RhdmUgbGluZSBpcyBkcmF3biBhdFxuICovXG5SZW5kZXJlci5wcm90b3R5cGUucHJpbnRTdGF2ZUxpbmUgPSBmdW5jdGlvbiAoeDEseDIsIHBpdGNoLCBrbGFzcykge1xuXHR2YXIgZXh0cmFDbGFzcyA9IFwic3RhZmZcIjtcblx0aWYgKGtsYXNzICE9PSB1bmRlZmluZWQpXG5cdFx0ZXh0cmFDbGFzcyArPSBcIiBcIiArIGtsYXNzO1xuICB2YXIgaXNJRT0vKkBjY19vbiFAKi9mYWxzZTsvL0lFIGRldGVjdG9yXG4gIHZhciBkeSA9IDAuMzU7XG4gIHZhciBmaWxsID0gXCIjMDAwMDAwXCI7XG4gIGlmIChpc0lFKSB7XG4gICAgZHkgPSAxO1xuICAgIGZpbGwgPSBcIiM2NjY2NjZcIjtcbiAgfVxuICB2YXIgeSA9IHRoaXMuY2FsY1kocGl0Y2gpO1xuICB2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWYgTCAlZiAlZiBMICVmICVmIHpcIiwgeDEsIHktZHksIHgyLCB5LWR5LFxuICAgICB4MiwgeStkeSwgeDEsIHkrZHkpO1xuICB2YXIgcmV0ID0gdGhpcy5wYXBlci5wYXRoVG9CYWNrKHtwYXRoOnBhdGhTdHJpbmcsIHN0cm9rZTpcIm5vbmVcIiwgZmlsbDpmaWxsLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoZXh0cmFDbGFzcyl9KTtcbiAgaWYgKHRoaXMuZG9SZWdyZXNzaW9uKSB0aGlzLmFkZFRvUmVncmVzc2lvbihyZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIGdldHMgc2NhbGVkIGlmIG5vdCBpbiBhIGdyb3VwXG4gKiBAcGFyYW0ge251bWJlcn0geCB4IGNvb3JkaW5hdGUgb2YgdGhlIHN0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCBzdGVtIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0geTEgeSBjb29yZGluYXRlIG9mIHRoZSBzdGVtIGJvdHRvbVxuICogQHBhcmFtIHtudW1iZXJ9IHkyIHkgY29vcmRpbmF0ZSBvZiB0aGUgc3RlbSB0b3BcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLnByaW50U3RlbSA9IGZ1bmN0aW9uICh4LCBkeCwgeTEsIHkyKSB7XG4gIGlmIChkeDwwKSB7IC8vIGNvcnJlY3QgcGF0aCBcImhhbmRlZG5lc3NcIiBmb3IgaW50ZXJzZWN0aW9uIHdpdGggb3RoZXIgZWxlbWVudHNcbiAgICB2YXIgdG1wID0geTI7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHRtcDtcbiAgfVxuICB2YXIgaXNJRT0vKkBjY19vbiFAKi9mYWxzZTsvL0lFIGRldGVjdG9yXG4gIHZhciBmaWxsID0gXCIjMDAwMDAwXCI7XG4gIGlmIChpc0lFICYmIGR4PDEpIHtcbiAgICBkeCA9IDE7XG4gICAgZmlsbCA9IFwiIzY2NjY2NlwiO1xuICB9XG4gIGlmICh+fnggPT09IHgpIHgrPTAuMDU7IC8vIHJhcGhhZWwgZG9lcyB3ZWlyZCByb3VuZGluZyAoZm9yIFZNTClcbiAgdmFyIHBhdGhBcnJheSA9IFtbXCJNXCIseCx5MV0sW1wiTFwiLCB4LCB5Ml0sW1wiTFwiLCB4K2R4LCB5Ml0sW1wiTFwiLHgrZHgseTFdLFtcInpcIl1dO1xuICBpZiAoIWlzSUUgJiYgdGhpcy5pbmdyb3VwKSB7XG4gICAgdGhpcy5hZGRQYXRoKHBhdGhBcnJheSk7XG4gIH0gZWxzZSB7XG4gIFx0dmFyIHBhdGggPSBcIlwiO1xuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKVxuICBcdFx0cGF0aCArPSBwYXRoQXJyYXlbaV0uam9pbihcIiBcIik7XG4gICAgdmFyIHJldCA9IHRoaXMucGFwZXIucGF0aFRvQmFjayh7cGF0aDpwYXRoLCBzdHJva2U6XCJub25lXCIsIGZpbGw6ZmlsbCwgJ2NsYXNzJzogdGhpcy5hZGRDbGFzc2VzKCdzdGVtJyl9KTtcbiAgICBpZiAodGhpcy5kb1JlZ3Jlc3Npb24pIHRoaXMuYWRkVG9SZWdyZXNzaW9uKHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuXG5mdW5jdGlvbiBrZXJuU3ltYm9scyhsYXN0U3ltYm9sLCB0aGlzU3ltYm9sLCBsYXN0U3ltYm9sV2lkdGgpIHtcblx0Ly8gVGhpcyBpcyBqdXN0IHNvbWUgYWRqdXN0bWVudHMgdG8gbWFrZSBpdCBsb29rIGJldHRlci5cblx0dmFyIHdpZHRoID0gbGFzdFN5bWJvbFdpZHRoO1xuXHRpZiAobGFzdFN5bWJvbCA9PT0gJ2YnICYmIHRoaXNTeW1ib2wgPT09ICdmJylcblx0XHR3aWR0aCA9IHdpZHRoKjIvMztcblx0aWYgKGxhc3RTeW1ib2wgPT09ICdwJyAmJiB0aGlzU3ltYm9sID09PSAncCcpXG5cdFx0d2lkdGggPSB3aWR0aCo1LzY7XG5cdGlmIChsYXN0U3ltYm9sID09PSAnZicgJiYgdGhpc1N5bWJvbCA9PT0gJ3onKVxuXHRcdHdpZHRoID0gd2lkdGgqNS84O1xuXHRyZXR1cm4gd2lkdGg7XG59XG5cbi8qKlxuICogYXNzdW1lcyB0aGlzLnkgaXMgc2V0IGFwcHJvcHJpYXRlbHlcbiAqIGlmIHN5bWJvbCBpcyBhIG11bHRpY2hhciBzdHJpbmcgd2l0aG91dCBhIC4gKGFzIGluIHNjcmlwdHMuc3RhY2NhdG8pIDEgc3ltYm9sIHBlciBjaGFyIGlzIGFzc3VtZWRcbiAqIG5vdCBzY2FsZWQgaWYgbm90IGluIHByaW50Z3JvdXBcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLnByaW50U3ltYm9sID0gZnVuY3Rpb24gKHgsIG9mZnNldCwgc3ltYm9sLCBzY2FsZXgsIHNjYWxleSwga2xhc3MpIHtcblx0dmFyIGVsO1xuXHR2YXIgeWNvcnI7XG5cdGlmICghc3ltYm9sKSByZXR1cm4gbnVsbDtcblx0aWYgKHN5bWJvbC5sZW5ndGggPiAxICYmIHN5bWJvbC5pbmRleE9mKFwiLlwiKSA8IDApIHtcblx0XHR0aGlzLnBhcGVyLm9wZW5Hcm91cCgpO1xuXHRcdHZhciBkeCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2wubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzID0gc3ltYm9sLmNoYXJBdChpKTtcblx0XHRcdHljb3JyID0gZ2x5cGhzLmdldFlDb3JyKHMpO1xuXHRcdFx0ZWwgPSBnbHlwaHMucHJpbnRTeW1ib2woeCArIGR4LCB0aGlzLmNhbGNZKG9mZnNldCArIHljb3JyKSwgcywgdGhpcy5wYXBlciwga2xhc3MpO1xuXHRcdFx0aWYgKGVsKSB7XG5cdFx0XHRcdGlmICh0aGlzLmRvUmVncmVzc2lvbikgdGhpcy5hZGRUb1JlZ3Jlc3Npb24oZWwpO1xuXHRcdFx0XHQvL2VsZW1zZXQucHVzaChlbCk7XG5cdFx0XHRcdGlmIChpIDwgc3ltYm9sLmxlbmd0aCAtIDEpXG5cdFx0XHRcdFx0ZHggKz0ga2VyblN5bWJvbHMocywgc3ltYm9sLmNoYXJBdChpICsgMSksIGdseXBocy5nZXRTeW1ib2xXaWR0aChzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlbmRlclRleHQoeCwgdGhpcy55LCBcIm5vIHN5bWJvbDpcIiArIHN5bWJvbCwgXCJkZWJ1Z2ZvbnRcIiwgJ2RlYnVnLW1zZycsICdzdGFydCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXBlci5jbG9zZUdyb3VwKCk7XG5cdH0gZWxzZSB7XG5cdFx0eWNvcnIgPSBnbHlwaHMuZ2V0WUNvcnIoc3ltYm9sKTtcblx0XHRpZiAodGhpcy5pbmdyb3VwKSB7XG5cdFx0XHR0aGlzLmFkZFBhdGgoZ2x5cGhzLmdldFBhdGhGb3JTeW1ib2woeCwgdGhpcy5jYWxjWShvZmZzZXQgKyB5Y29yciksIHN5bWJvbCwgc2NhbGV4LCBzY2FsZXkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWwgPSBnbHlwaHMucHJpbnRTeW1ib2woeCwgdGhpcy5jYWxjWShvZmZzZXQgKyB5Y29yciksIHN5bWJvbCwgdGhpcy5wYXBlciwga2xhc3MpO1xuXHRcdFx0aWYgKGVsKSB7XG5cdFx0XHRcdGlmICh0aGlzLmRvUmVncmVzc2lvbikgdGhpcy5hZGRUb1JlZ3Jlc3Npb24oZWwpO1xuXHRcdFx0XHRyZXR1cm4gZWw7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0dGhpcy5yZW5kZXJUZXh0KHgsIHRoaXMueSwgXCJubyBzeW1ib2w6XCIgKyBzeW1ib2wsIFwiZGVidWdmb250XCIsICdkZWJ1Zy1tc2cnLCAnc3RhcnQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5zY2FsZUV4aXN0aW5nRWxlbSA9IGZ1bmN0aW9uIChlbGVtLCBzY2FsZVgsIHNjYWxlWSwgeCwgeSkge1xuXHR0aGlzLnBhcGVyLnNldEF0dHJpYnV0ZU9uRWxlbWVudChlbGVtLCB7IHN0eWxlOiBcInRyYW5zZm9ybTpzY2FsZShcIitzY2FsZVgrXCIsXCIrc2NhbGVZICsgXCIpO3RyYW5zZm9ybS1vcmlnaW46XCIgKyB4ICsgXCJweCBcIiArIHkgKyBcInB4O1wifSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucHJpbnRQYXRoID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gIHZhciByZXQgPSB0aGlzLnBhcGVyLnBhdGgoYXR0cnMpO1xuICBpZiAodGhpcy5kb1JlZ3Jlc3Npb24pIHRoaXMuYWRkVG9SZWdyZXNzaW9uKHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZHJhd0JyYWNlID0gZnVuY3Rpb24oeExlZnQsIHlUb3AsIHlCb3R0b20pIHsvL1Rvbnlcblx0dmFyIHlIZWlnaHQgPSB5Qm90dG9tIC0geVRvcDtcblxuXHR2YXIgeEN1cnZlID0gWzcuNSwgLTgsIDIxLCAwLCAxOC41LCAtMTAuNSwgNy41XTtcblx0dmFyIHlDdXJ2ZSA9IFswLCB5SGVpZ2h0LzUuNSwgeUhlaWdodC8zLjE0LCB5SGVpZ2h0LzIsIHlIZWlnaHQvMi45MywgeUhlaWdodC80Ljg4LCAwXTtcblxuXHR2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEMgJWYgJWYgJWYgJWYgJWYgJWYgQyAlZiAlZiAlZiAlZiAlZiAlZiB6XCIsXG5cdFx0eExlZnQreEN1cnZlWzBdLCB5VG9wK3lDdXJ2ZVswXSxcblx0XHR4TGVmdCt4Q3VydmVbMV0sIHlUb3AreUN1cnZlWzFdLFxuXHRcdHhMZWZ0K3hDdXJ2ZVsyXSwgeVRvcCt5Q3VydmVbMl0sXG5cdFx0eExlZnQreEN1cnZlWzNdLCB5VG9wK3lDdXJ2ZVszXSxcblx0XHR4TGVmdCt4Q3VydmVbNF0sIHlUb3AreUN1cnZlWzRdLFxuXHRcdHhMZWZ0K3hDdXJ2ZVs1XSwgeVRvcCt5Q3VydmVbNV0sXG5cdFx0eExlZnQreEN1cnZlWzZdLCB5VG9wK3lDdXJ2ZVs2XSk7XG5cdHZhciByZXQxID0gdGhpcy5wYXBlci5wYXRoKHtwYXRoOnBhdGhTdHJpbmcsIHN0cm9rZTpcIiMwMDAwMDBcIiwgZmlsbDpcIiMwMDAwMDBcIiwgJ2NsYXNzJzogdGhpcy5hZGRDbGFzc2VzKCdicmFjZScpfSk7XG5cblx0eEN1cnZlID0gWzAsIDE3LjUsIC03LjUsIDYuNiwgLTUsIDIwLCAwXTtcblx0eUN1cnZlID0gW3lIZWlnaHQvMiwgeUhlaWdodC8xLjQ2LCB5SGVpZ2h0LzEuMjIsIHlIZWlnaHQsIHlIZWlnaHQvMS4xOSwgeUhlaWdodC8xLjQyLCB5SGVpZ2h0LzJdO1xuXG5cdHBhdGhTdHJpbmcgPSBzcHJpbnRmKFwiTSAlZiAlZiBDICVmICVmICVmICVmICVmICVmIEMgJWYgJWYgJWYgJWYgJWYgJWYgelwiLFxuXHRcdHhMZWZ0K3hDdXJ2ZVsgMF0sIHlUb3AreUN1cnZlWzBdLFxuXHRcdHhMZWZ0K3hDdXJ2ZVsxXSwgeVRvcCt5Q3VydmVbMV0sXG5cdFx0eExlZnQreEN1cnZlWzJdLCB5VG9wK3lDdXJ2ZVsyXSxcblx0XHR4TGVmdCt4Q3VydmVbM10sIHlUb3AreUN1cnZlWzNdLFxuXHRcdHhMZWZ0K3hDdXJ2ZVs0XSwgeVRvcCt5Q3VydmVbNF0sXG5cdFx0eExlZnQreEN1cnZlWzVdLCB5VG9wK3lDdXJ2ZVs1XSxcblx0XHR4TGVmdCt4Q3VydmVbNl0sIHlUb3AreUN1cnZlWzZdKTtcblx0dmFyIHJldDIgPSB0aGlzLnBhcGVyLnBhdGgoe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOlwiIzAwMDAwMFwiLCBmaWxsOlwiIzAwMDAwMFwiLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoJ2JyYWNlJyl9KTtcblxuXHRpZiAodGhpcy5kb1JlZ3Jlc3Npb24pe1xuXHRcdHRoaXMuYWRkVG9SZWdyZXNzaW9uKHJldDEpO1xuXHRcdHRoaXMuYWRkVG9SZWdyZXNzaW9uKHJldDIpO1xuXHR9XG5cdHJldHVybiByZXQxICsgcmV0Mjtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kcmF3QXJjID0gZnVuY3Rpb24oeDEsIHgyLCBwaXRjaDEsIHBpdGNoMiwgYWJvdmUsIGtsYXNzLCBpc1RpZSkge1xuXHQvLyBJZiBpdCBpcyBhIHRpZSB2cy4gYSBzbHVyLCBkcmF3IGl0IHNoYWxsb3dlci5cblx0dmFyIHNwYWNpbmcgPSBpc1RpZSA/IDEuMiA6IDEuNTtcblxuICB4MSA9IHgxICsgNjtcbiAgeDIgPSB4MiArIDQ7XG4gIHBpdGNoMSA9IHBpdGNoMSArICgoYWJvdmUpP3NwYWNpbmc6LXNwYWNpbmcpO1xuICBwaXRjaDIgPSBwaXRjaDIgKyAoKGFib3ZlKT9zcGFjaW5nOi1zcGFjaW5nKTtcbiAgdmFyIHkxID0gdGhpcy5jYWxjWShwaXRjaDEpO1xuICB2YXIgeTIgPSB0aGlzLmNhbGNZKHBpdGNoMik7XG5cbiAgLy91bml0IGRpcmVjdGlvbiB2ZWN0b3JcbiAgdmFyIGR4ID0geDIteDE7XG4gIHZhciBkeSA9IHkyLXkxO1xuICB2YXIgbm9ybT0gTWF0aC5zcXJ0KGR4KmR4K2R5KmR5KTtcbiAgdmFyIHV4ID0gZHgvbm9ybTtcbiAgdmFyIHV5ID0gZHkvbm9ybTtcblxuICB2YXIgZmxhdHRlbiA9IG5vcm0vMy41O1xuICB2YXIgbWF4RmxhdHRlbiA9IGlzVGllID8gMTAgOiAyNTsgIC8vIElmIGl0IGlzIGEgdGllIHZzLiBhIHNsdXIsIGRyYXcgaXQgc2hhbGxvd2VyLlxuICB2YXIgY3VydmUgPSAoKGFib3ZlKT8tMToxKSpNYXRoLm1pbihtYXhGbGF0dGVuLCBNYXRoLm1heCg0LCBmbGF0dGVuKSk7XG5cbiAgdmFyIGNvbnRyb2x4MSA9IHgxK2ZsYXR0ZW4qdXgtY3VydmUqdXk7XG4gIHZhciBjb250cm9seTEgPSB5MStmbGF0dGVuKnV5K2N1cnZlKnV4O1xuICB2YXIgY29udHJvbHgyID0geDItZmxhdHRlbip1eC1jdXJ2ZSp1eTtcbiAgdmFyIGNvbnRyb2x5MiA9IHkyLWZsYXR0ZW4qdXkrY3VydmUqdXg7XG4gIHZhciB0aGlja25lc3MgPSAyO1xuICB2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEMgJWYgJWYgJWYgJWYgJWYgJWYgQyAlZiAlZiAlZiAlZiAlZiAlZiB6XCIsIHgxLCB5MSxcbiAgICAgY29udHJvbHgxLCBjb250cm9seTEsIGNvbnRyb2x4MiwgY29udHJvbHkyLCB4MiwgeTIsXG4gICAgIGNvbnRyb2x4Mi10aGlja25lc3MqdXksIGNvbnRyb2x5Mit0aGlja25lc3MqdXgsIGNvbnRyb2x4MS10aGlja25lc3MqdXksIGNvbnRyb2x5MSt0aGlja25lc3MqdXgsIHgxLCB5MSk7XG5cdGlmIChrbGFzcylcblx0XHRrbGFzcyArPSAnIHNsdXInO1xuXHRlbHNlXG5cdFx0a2xhc3MgPSAnc2x1cic7XG4gIHZhciByZXQgPSB0aGlzLnBhcGVyLnBhdGgoe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOlwibm9uZVwiLCBmaWxsOlwiIzAwMDAwMFwiLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoa2xhc3MpfSk7XG4gIGlmICh0aGlzLmRvUmVncmVzc2lvbikgdGhpcy5hZGRUb1JlZ3Jlc3Npb24ocmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgeSBmb3IgYSBnaXZlbiBwaXRjaCB2YWx1ZSAocmVsYXRpdmUgdG8gdGhlIHN0YXZlIHRoZSByZW5kZXJlciBpcyBjdXJyZW50bHkgcHJpbnRpbmcpXG4gKiBAcGFyYW0ge251bWJlcn0gb2ZzIHBpdGNoIHZhbHVlIChib3R0b20gQyBvbiBhIEcgY2xlZiA9IDAsIEQ9MSwgZXRjLilcbiAqL1xuUmVuZGVyZXIucHJvdG90eXBlLmNhbGNZID0gZnVuY3Rpb24ob2ZzKSB7XG4gIHJldHVybiB0aGlzLnkgLSBvZnMqc3BhY2luZy5TVEVQO1xufTtcblxuLyoqXG4gKiBQcmludCBAcGFyYW0ge251bWJlcn0gbnVtTGluZXMuIElmIHRoZXJlIGlzIDEgbGluZSBpdCBpcyB0aGUgQiBsaW5lLiBPdGhlcndpc2UgdGhlIGJvdHRvbSBsaW5lIGlzIHRoZSBFIGxpbmUuXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5wcmludFN0YXZlID0gZnVuY3Rpb24gKHN0YXJ0eCwgZW5keCwgbnVtTGluZXMpIHtcblx0dmFyIGtsYXNzID0gXCJ0b3AtbGluZVwiO1xuXHR0aGlzLnBhcGVyLm9wZW5Hcm91cCh7IHByZXBlbmQ6IHRydWUgfSk7XG5cdC8vIElmIHRoZXJlIGlzIG9uZSBsaW5lLCBpdCBpcyB0aGUgQiBsaW5lLiBPdGhlcndpc2UsIHRoZSBib3R0b20gbGluZSBpcyB0aGUgRSBsaW5lLlxuXHRpZiAobnVtTGluZXMgPT09IDEpIHtcblx0XHR0aGlzLnByaW50U3RhdmVMaW5lKHN0YXJ0eCxlbmR4LDYsIGtsYXNzKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Zm9yICh2YXIgaSA9IG51bUxpbmVzLTE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dGhpcy5wcmludFN0YXZlTGluZShzdGFydHgsZW5keCwoaSsxKSoyLCBrbGFzcyk7XG5cdFx0a2xhc3MgPSB1bmRlZmluZWQ7XG5cdH1cblx0dGhpcy5wYXBlci5jbG9zZUdyb3VwKCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5SZW5kZXJlci5wcm90b3R5cGUuYWRkQ2xhc3NlcyA9IGZ1bmN0aW9uIChjLCBpc05vdGUpIHtcblx0aWYgKCF0aGlzLnNob3VsZEFkZENsYXNzZXMpXG5cdFx0cmV0dXJuIFwiXCI7XG5cdHZhciByZXQgPSBbXTtcblx0aWYgKGMubGVuZ3RoID4gMCkgcmV0LnB1c2goYyk7XG5cdGlmICh0aGlzLmxpbmVOdW1iZXIgIT09IG51bGwgJiYgdGhpcy5saW5lTnVtYmVyICE9PSB1bmRlZmluZWQpIHJldC5wdXNoKFwibFwiK3RoaXMubGluZU51bWJlcik7XG5cdGlmICh0aGlzLm1lYXN1cmVOdW1iZXIgIT09IG51bGwgJiYgdGhpcy5tZWFzdXJlTnVtYmVyICE9PSB1bmRlZmluZWQpIHJldC5wdXNoKFwibVwiK3RoaXMubWVhc3VyZU51bWJlcik7XG5cdGlmICh0aGlzLnZvaWNlTnVtYmVyICE9PSBudWxsICYmIHRoaXMudm9pY2VOdW1iZXIgIT09IHVuZGVmaW5lZCkgcmV0LnB1c2goXCJ2XCIrdGhpcy52b2ljZU51bWJlcik7XG5cdGlmICgoYy5pbmRleE9mKCdub3RlJykgPj0gMCB8fCBjLmluZGV4T2YoJ3Jlc3QnKSA+PSAwIHx8IGMuaW5kZXhPZignbHlyaWMnKSA+PSAwICkgJiYgdGhpcy5ub3RlTnVtYmVyICE9PSBudWxsICYmIHRoaXMubm90ZU51bWJlciAhPT0gdW5kZWZpbmVkKSByZXQucHVzaChcIm5cIit0aGlzLm5vdGVOdW1iZXIpO1xuXHQvLyBhZGQgYSBwcmVmaXggdG8gYWxsIGNsYXNzZXMgdGhhdCBhYmNqcyBhZGRzLlxuXHRpZiAocmV0Lmxlbmd0aCA+IDApIHtcblx0XHRyZXQgPSByZXQuam9pbignICcpOyAvLyBTb21lIHN0cmluZ3MgYXJlIGNvbXBvdW5kIGNsYXNzZXMgLSB0aGF0IGlzLCBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgY2xhc3MgaW4gYSBzdHJpbmcuXG5cdFx0cmV0ID0gcmV0LnNwbGl0KCcgJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyZXRbaV0uaW5kZXhPZignYWJjanMtJykgIT09IDAgJiYgcmV0W2ldLmxlbmd0aCA+IDApIC8vIGlmIHRoZSBwcmVmaXggZG9lc24ndCBhbHJlYWR5IGV4aXN0IGFuZCB0aGUgY2xhc3MgaXMgbm90IGJsYW5rLlxuXHRcdFx0XHRyZXRbaV0gPSAnYWJjanMtJyArIHJldFtpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJldC5qb2luKCcgJyk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZ2V0Rm9udEFuZEF0dHIgPSBmdW5jdGlvbih0eXBlLCBrbGFzcykge1xuXHR2YXIgZm9udDtcblx0aWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdGZvbnQgPSB0aGlzLmFiY3R1bmUuZm9ybWF0dGluZ1t0eXBlXTtcblx0XHQvLyBSYXBoYWVsIGRlbGliZXJhdGVseSBjaGFuZ2VzIHRoZSBmb250IHVuaXRzIHRvIHBpeGVscyBmb3Igc29tZSByZWFzb24sIHNvIHdlIG5lZWQgdG8gY2hhbmdlIHBvaW50cyB0byBwaXhlbHMgaGVyZS5cblx0XHRpZiAoZm9udClcblx0XHRcdGZvbnQgPSB7ZmFjZTogZm9udC5mYWNlLCBzaXplOiBmb250LnNpemUgKiA0IC8gMywgZGVjb3JhdGlvbjogZm9udC5kZWNvcmF0aW9uLCBzdHlsZTogZm9udC5zdHlsZSwgd2VpZ2h0OiBmb250LndlaWdodCwgYm94OiBmb250LmJveH07XG5cdFx0ZWxzZVxuXHRcdFx0Zm9udCA9IHtmYWNlOiBcIkFyaWFsXCIsIHNpemU6IDEyICogNCAvIDMsIGRlY29yYXRpb246IFwidW5kZXJsaW5lXCIsIHN0eWxlOiBcIm5vcm1hbFwiLCB3ZWlnaHQ6IFwibm9ybWFsXCJ9O1xuXHR9IGVsc2Vcblx0XHRmb250ID0ge2ZhY2U6IHR5cGUuZmFjZSwgc2l6ZTogdHlwZS5zaXplICogNCAvIDMsIGRlY29yYXRpb246IHR5cGUuZGVjb3JhdGlvbiwgc3R5bGU6IHR5cGUuc3R5bGUsIHdlaWdodDogdHlwZS53ZWlnaHQsIGJveDogdHlwZS5ib3h9O1xuXG5cdHZhciBhdHRyID0ge1wiZm9udC1zaXplXCI6IGZvbnQuc2l6ZSwgJ2ZvbnQtc3R5bGUnOiBmb250LnN0eWxlLFxuXHRcdFwiZm9udC1mYW1pbHlcIjogZm9udC5mYWNlLCAnZm9udC13ZWlnaHQnOiBmb250LndlaWdodCwgJ3RleHQtZGVjb3JhdGlvbic6IGZvbnQuZGVjb3JhdGlvbixcblx0XHQnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoa2xhc3MpIH07XG5cdGF0dHIuZm9udCA9IFwiXCI7XHQvLyBUaGVyZSBpcyBhIHNwdXJpb3VzIGZvbnQgZGVmaW5pdGlvbiB0aGF0IGlzIHB1dCBvbiBhbGwgdGV4dCBlbGVtZW50cy4gVGhpcyBvdmVyd3JpdGVzIGl0LlxuXHRyZXR1cm4geyBmb250OiBmb250LCBhdHRyOiBhdHRyIH07XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dFNpemUgPSBmdW5jdGlvbih0ZXh0LCB0eXBlLCBrbGFzcywgZWwpIHtcblx0dmFyIGhhc2ggPSB0aGlzLmdldEZvbnRBbmRBdHRyKHR5cGUsIGtsYXNzKTtcblx0dmFyIHNpemUgPSB0aGlzLnBhcGVyLmdldFRleHRTaXplKHRleHQsIGhhc2guYXR0ciwgZWwpO1xuXHRpZiAoaGFzaC5mb250LmJveCkge1xuXHRcdHNpemUuaGVpZ2h0ICs9IDg7XG5cdFx0c2l6ZS53aWR0aCArPSA4O1xuXHR9XG5cdHJldHVybiBzaXplO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRleHQgPSBmdW5jdGlvbih4LCB5LCB0ZXh0LCB0eXBlLCBrbGFzcywgYW5jaG9yLCBjZW50ZXJWZXJ0aWNhbGx5KSB7XG5cdHZhciBoYXNoID0gdGhpcy5nZXRGb250QW5kQXR0cih0eXBlLCBrbGFzcyk7XG5cdGlmIChhbmNob3IpXG5cdFx0aGFzaC5hdHRyW1widGV4dC1hbmNob3JcIl0gPSBhbmNob3I7XG5cdGhhc2guYXR0ci54ID0geDtcblx0aGFzaC5hdHRyLnkgPSB5ICsgNzsgLy8gVE9ETy1QRVI6IE5vdCBzdXJlIHdoeSB0aGUgdGV4dCBhcHBlYXJzIHRvIGJlIDcgcGl4ZWxzIG9mZi5cblx0aWYgKCFjZW50ZXJWZXJ0aWNhbGx5KVxuXHRcdGhhc2guYXR0ci5keSA9IFwiMC41ZW1cIjtcblx0aWYgKHR5cGUgPT09ICdkZWJ1Z2ZvbnQnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJEZWJ1ZyBtc2c6IFwiICsgdGV4dCk7XG5cdFx0aGFzaC5hdHRyLnN0cm9rZSA9IFwiI2ZmMDAwMFwiO1xuXHR9XG5cblx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuXFxuL2csIFwiXFxuIFxcblwiKTtcblx0dGV4dCA9IHRleHQucmVwbGFjZSgvXlxcbi8sIFwiXFx4QTBcXG5cIik7XG5cblx0aWYgKGhhc2guZm9udC5ib3gpIHtcblx0XHRoYXNoLmF0dHIueCArPSAyO1xuXHRcdGhhc2guYXR0ci55ICs9IDQ7XG5cdH1cblx0dmFyIGVsID0gdGhpcy5wYXBlci50ZXh0KHRleHQsIGhhc2guYXR0cik7XG5cblx0aWYgKGhhc2guZm9udC5ib3gpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuZ2V0VGV4dFNpemUodGV4dCwgdHlwZSwga2xhc3MpO1xuXHRcdHZhciBwYWRkaW5nID0gMjtcblx0XHR2YXIgbWFyZ2luID0gMjtcblx0XHR0aGlzLnBhcGVyLnJlY3QoeyB4OiB4IC0gcGFkZGluZywgeTogeSwgd2lkdGg6IHNpemUud2lkdGggKyBwYWRkaW5nKjIsIGhlaWdodDogc2l6ZS5oZWlnaHQgKyBwYWRkaW5nKjIgLSBtYXJnaW4sICBzdHJva2U6IFwiIzg4ODg4OFwiLCBmaWxsOiBcInRyYW5zcGFyZW50XCJ9KTtcblx0XHQvL3NpemUuaGVpZ2h0ICs9IDg7XG5cdH1cblx0aWYgKHRoaXMuZG9SZWdyZXNzaW9uKSB0aGlzLmFkZFRvUmVncmVzc2lvbihlbCk7XG5cdHJldHVybiBlbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5tb3ZlWSA9IGZ1bmN0aW9uIChlbSwgbnVtTGluZXMpIHtcblx0aWYgKG51bUxpbmVzID09PSB1bmRlZmluZWQpIG51bUxpbmVzID0gMTtcblx0dGhpcy55ICs9IGVtKm51bUxpbmVzO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnNraXBTcGFjZVkgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMueSArPSB0aGlzLnNwYWNlO1xufTtcblxuLy8gQ2FsbCB3aXRoICdraW5kJyBiZWluZyB0aGUgZm9udCB0eXBlIHRvIHVzZSxcbi8vIGlmIG1hcmdpbkJvdHRvbSA9PT0gbnVsbCB0aGVuIGRvbid0IGluY3JlbWVudCB0aGUgWSBhZnRlciBwcmludGluZywgb3RoZXJ3aXNlIHRoYXQgaXMgdGhlIGV4dHJhIG51bWJlciBvZiBlbSdzIHRvIGxlYXZlIGJlbG93IHRoZSBsaW5lLlxuLy8gYW5kIGFsaWdubWVudCBiZWluZyBcInN0YXJ0XCIsIFwibWlkZGxlXCIsIG9yIFwiZW5kXCIuXG5SZW5kZXJlci5wcm90b3R5cGUub3V0cHV0VGV4dElmID0gZnVuY3Rpb24oeCwgc3RyLCBraW5kLCBrbGFzcywgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIGFsaWdubWVudCkge1xuXHRpZiAoc3RyKSB7XG5cdFx0aWYgKG1hcmdpblRvcClcblx0XHRcdHRoaXMubW92ZVkobWFyZ2luVG9wKTtcblx0XHR2YXIgZWwgPSB0aGlzLnJlbmRlclRleHQoeCwgdGhpcy55LCBzdHIsIGtpbmQsIGtsYXNzLCBhbGlnbm1lbnQpO1xuXHRcdHZhciBiYiA9IHRoaXMuZ2V0VGV4dFNpemUoc3RyLCBraW5kLCBrbGFzcyk7XG5cdFx0dmFyIHdpZHRoID0gaXNOYU4oYmIud2lkdGgpID8gMCA6IGJiLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBpc05hTihiYi5oZWlnaHQpID8gMCA6IGJiLmhlaWdodDtcblx0XHR2YXIgaGFzaCA9IHRoaXMuZ2V0Rm9udEFuZEF0dHIoa2luZCwga2xhc3MpO1xuXHRcdGlmIChoYXNoLmZvbnQuYm94KSB7XG5cdFx0XHR3aWR0aCArPSA4O1xuXHRcdFx0aGVpZ2h0ICs9IDg7XG5cdFx0fVxuXHRcdGlmIChtYXJnaW5Cb3R0b20gIT09IG51bGwpIHtcblx0XHRcdHZhciBudW1MaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKS5sZW5ndGg7XG5cdFx0XHRpZiAoIWlzTmFOKGJiLmhlaWdodCkpXG5cdFx0XHRcdHRoaXMubW92ZVkoaGVpZ2h0L251bUxpbmVzLCAobnVtTGluZXMgKyBtYXJnaW5Cb3R0b20pKTtcblx0XHR9XG5cdFx0cmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcblx0fVxuXHRyZXR1cm4gWzAsMF07XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYWRkSW52aXNpYmxlTWFya2VyID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHR2YXIgZHkgPSAwLjM1O1xuXHR2YXIgZmlsbCA9IFwicmdiYSgwLDAsMCwwKVwiO1xuXHR2YXIgeSA9IHRoaXMueTtcblx0eSA9IE1hdGgucm91bmQoeSk7XG5cdHZhciB4MSA9IDA7XG5cdHZhciB4MiA9IDEwMDtcblx0dmFyIHBhdGhTdHJpbmcgPSBzcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmIEwgJWYgJWYgTCAlZiAlZiB6XCIsIHgxLCB5LWR5LCB4MSt4MiwgeS1keSxcblx0XHR4MiwgeStkeSwgeDEsIHkrZHkpO1xuXHR0aGlzLnBhcGVyLnBhdGhUb0JhY2soe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOlwibm9uZVwiLCBmaWxsOmZpbGwsIFwiZmlsbC1vcGFjaXR5XCI6IDAsICdjbGFzcyc6IHRoaXMuYWRkQ2xhc3NlcyhjbGFzc05hbWUpLCAnZGF0YS12ZXJ0aWNhbCc6IHkgfSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucHJpbnRTZXBhcmF0b3IgPSBmdW5jdGlvbih3aWR0aCkge1xuXHR2YXIgZmlsbCA9IFwicmdiYSgwLDAsMCwyNTUpXCI7XG5cdHZhciBzdHJva2UgPSBcInJnYmEoMCwwLDAsMClcIjtcblx0dmFyIHkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG5cdHZhciBzdGFmZldpZHRoID0gdGhpcy5jb250cm9sbGVyLndpZHRoO1xuXHR2YXIgeDEgPSAoc3RhZmZXaWR0aCAtIHdpZHRoKS8yO1xuXHR2YXIgeDIgPSB4MSArIHdpZHRoO1xuXHR2YXIgcGF0aFN0cmluZyA9ICdNICcgKyB4MSArICcgJyArIHkgK1xuXHRcdCcgTCAnICsgeDIgKyAnICcgKyB5ICtcblx0XHQnIEwgJyArIHgyICsgJyAnICsgKHkrMSkgK1xuXHRcdCcgTCAnICsgeDEgKyAnICcgKyAoeSsxKSArXG5cdFx0JyBMICcgKyB4MSArICcgJyArIHkgKyAnIHonO1xuXHR0aGlzLnBhcGVyLnBhdGhUb0JhY2soe3BhdGg6cGF0aFN0cmluZywgc3Ryb2tlOnN0cm9rZSwgZmlsbDpmaWxsLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoJ2RlZmluZWQtdGV4dCcpfSk7XG59O1xuXG4vLyBGb3IgZGVidWdnaW5nLCBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGtub3cgd2hlcmUgeW91IGFyZSB2ZXJ0aWNhbGx5LlxuUmVuZGVyZXIucHJvdG90eXBlLnByaW50SG9yaXpvbnRhbExpbmUgPSBmdW5jdGlvbiAod2lkdGgsIHZlcnRpY2FsLCBjb21tZW50KSB7XG5cdHZhciBkeSA9IDAuMzU7XG5cdHZhciBmaWxsID0gXCJyZ2JhKDAsMCwyNTUsLjQpXCI7XG5cdHZhciB5ID0gdGhpcy55O1xuXHRpZiAodmVydGljYWwpIHkgPSB2ZXJ0aWNhbDtcblx0eSA9IE1hdGgucm91bmQoeSk7XG5cdHRoaXMucGFwZXIudGV4dChcIlwiK01hdGgucm91bmQoeSksIHt4OiAxMCwgeTogeSwgXCJ0ZXh0LWFuY2hvclwiOiBcInN0YXJ0XCIsIFwiZm9udC1zaXplXCI6XCIxOHB4XCIsIGZpbGw6IGZpbGwsIHN0cm9rZTogZmlsbCB9KTtcblx0dmFyIHgxID0gNTA7XG5cdHZhciB4MiA9IHdpZHRoO1xuXHR2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWYgTCAlZiAlZiBMICVmICVmIHpcIiwgeDEsIHktZHksIHgxK3gyLCB5LWR5LFxuXHRcdHgyLCB5K2R5LCB4MSwgeStkeSk7XG5cdHRoaXMucGFwZXIucGF0aFRvQmFjayh7cGF0aDpwYXRoU3RyaW5nLCBzdHJva2U6XCJub25lXCIsIGZpbGw6ZmlsbCwgJ2NsYXNzJzogdGhpcy5hZGRDbGFzc2VzKCdzdGFmZicpfSk7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgd2lkdGgvMTAwOyBpKyspIHtcblx0XHRwYXRoU3RyaW5nID0gc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZiBMICVmICVmIEwgJWYgJWYgelwiLCBpKjEwMC1keSwgeS01LCBpKjEwMC1keSwgeSs1LFxuXHRcdFx0aSoxMDArZHksIHktNSwgaSoxMDArZHksIHkrNSk7XG5cdFx0dGhpcy5wYXBlci5wYXRoVG9CYWNrKHtwYXRoOnBhdGhTdHJpbmcsIHN0cm9rZTpcIm5vbmVcIiwgZmlsbDpmaWxsLCAnY2xhc3MnOiB0aGlzLmFkZENsYXNzZXMoJ3N0YWZmJyl9KTtcblx0fVxuXHRpZiAoY29tbWVudClcblx0XHR0aGlzLnBhcGVyLnRleHQoY29tbWVudCwge3g6IHdpZHRoKzcwLCB5OiB5LCBcInRleHQtYW5jaG9yXCI6IFwic3RhcnRcIiwgXCJmb250LXNpemVcIjpcIjE4cHhcIiwgZmlsbDogZmlsbCwgc3Ryb2tlOiBmaWxsIH0pO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnByaW50U2hhZGVkQm94ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yLCBvcGFjaXR5LCBjb21tZW50KSB7XG5cdHZhciBib3ggPSB0aGlzLnBhcGVyLnJlY3QoeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBmaWxsOiBjb2xvciwgc3Ryb2tlOiBjb2xvciwgXCJmaWxsLW9wYWNpdHlcIjogb3BhY2l0eSwgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5IH0pO1xuXHRpZiAoY29tbWVudClcblx0XHR0aGlzLnBhcGVyLnRleHQoY29tbWVudCwge3g6IDAsIHk6IHkrNywgXCJ0ZXh0LWFuY2hvclwiOiBcInN0YXJ0XCIsIFwiZm9udC1zaXplXCI6XCIxNHB4XCIsIGZpbGw6IFwicmdiYSgwLDAsMjU1LC40KVwiLCBzdHJva2U6IFwicmdiYSgwLDAsMjU1LC40KVwiIH0pO1xuXHRyZXR1cm4gYm94O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnByaW50VmVydGljYWxMaW5lID0gZnVuY3Rpb24gKHgsIHkxLCB5Mikge1xuXHR2YXIgZHkgPSAwLjM1O1xuXHR2YXIgZmlsbCA9IFwiIzAwYWFhYVwiO1xuXHR2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWYgTCAlZiAlZiBMICVmICVmIHpcIiwgeCAtIGR5LCB5MSwgeCAtIGR5LCB5Mixcblx0XHRcdHggKyBkeSwgeTEsIHggKyBkeSwgeTIpO1xuXHR0aGlzLnBhcGVyLnBhdGhUb0JhY2soe3BhdGg6IHBhdGhTdHJpbmcsIHN0cm9rZTogXCJub25lXCIsIGZpbGw6IGZpbGwsICdjbGFzcyc6IHRoaXMuYWRkQ2xhc3Nlcygnc3RhZmYnKX0pO1xuXHRwYXRoU3RyaW5nID0gc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZiBMICVmICVmIEwgJWYgJWYgelwiLCB4IC0gMjAsIHkxLCB4IC0gMjAsIHkxKzMsXG5cdFx0eCwgeTEsIHgsIHkxKzMpO1xuXHR0aGlzLnBhcGVyLnBhdGhUb0JhY2soe3BhdGg6IHBhdGhTdHJpbmcsIHN0cm9rZTogXCJub25lXCIsIGZpbGw6IGZpbGwsICdjbGFzcyc6IHRoaXMuYWRkQ2xhc3Nlcygnc3RhZmYnKX0pO1xuXHRwYXRoU3RyaW5nID0gc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZiBMICVmICVmIEwgJWYgJWYgelwiLCB4ICsgMjAsIHkyLCB4ICsgMjAsIHkyKzMsXG5cdFx0eCwgeTIsIHgsIHkyKzMpO1xuXHR0aGlzLnBhcGVyLnBhdGhUb0JhY2soe3BhdGg6IHBhdGhTdHJpbmcsIHN0cm9rZTogXCJub25lXCIsIGZpbGw6IGZpbGwsICdjbGFzcyc6IHRoaXMuYWRkQ2xhc3Nlcygnc3RhZmYnKX0pO1xuXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblJlbmRlcmVyLnByb3RvdHlwZS5hZGRUb1JlZ3Jlc3Npb24gPSBmdW5jdGlvbiAoZWwpIHtcblx0dmFyIGJveDtcblx0dHJ5IHtcblx0XHRib3ggPSBlbC5nZXRCQm94KCk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdGJveCA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHR9XG5cdC8vdmFyIHN0ciA9IFwiKFwiK2JveC54K1wiLFwiK2JveC55K1wiKVtcIitib3gud2lkdGgrXCIsXCIrYm94LmhlaWdodCtcIl0gXCJcblx0dmFyIHN0ciA9IGVsLnR5cGUgKyAnICcgKyBib3gudG9TdHJpbmcoKSArICcgJztcblx0dmFyIGF0dHJzID0gW107XG5cdGZvciAodmFyIGtleSBpbiBlbC5hdHRycykge1xuXHRcdGlmIChlbC5hdHRycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAnY2xhc3MnKVxuXHRcdFx0XHRzdHIgPSBlbC5hdHRyc1trZXldICsgXCIgXCIgKyBzdHI7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGF0dHJzLnB1c2goa2V5K1wiOiBcIitlbC5hdHRyc1trZXldKTtcblx0XHR9XG5cdH1cblx0YXR0cnMuc29ydCgpO1xuXHRzdHIgKz0gXCJ7IFwiICthdHRycy5qb2luKFwiIFwiKSArIFwiIH1cIjtcblx0dGhpcy5yZWdyZXNzaW9uTGluZXMucHVzaChzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiIsIi8vICAgIENvcHlyaWdodCAoQykgMjAxNC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSlcbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHNwYWNpbmcgPSB7fTtcblxuc3BhY2luZy5GT05URU0gPSAzNjA7XG5zcGFjaW5nLkZPTlRTSVpFID0gMzA7XG5zcGFjaW5nLlNURVAgPSBzcGFjaW5nLkZPTlRTSVpFKjkzLzcyMDtcbnNwYWNpbmcuU1BBQ0UgPSAxMDtcbnNwYWNpbmcuVE9QTk9URSA9IDE1O1xuc3BhY2luZy5TVEFWRUhFSUdIVCA9IDEwMDtcbnNwYWNpbmcuSU5ERU5UID0gNTA7XG5cbm1vZHVsZS5leHBvcnRzID0gc3BhY2luZztcbiIsIi8vICAgIGFiY19zdGFmZl9ncm91cF9lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBTdGFmZkdyb3VwRWxlbWVudCBjbGFzcy5cbi8vICAgIENvcHlyaWdodCAoQykgMjAxMC0yMDE4IEdyZWdvcnkgRHlrZSAoZ3JlZ2R5a2UgYXQgZ21haWwgZG90IGNvbSkgYW5kIFBhdWwgUm9zZW5cbi8vXG4vLyAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWRcbi8vICAgIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4vLyAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kXG4vLyAgICB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4vLyAgICBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbi8vICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLypnbG9iYWxzIGNvbnNvbGUgKi9cblxudmFyIHNwYWNpbmcgPSByZXF1aXJlKCcuL2FiY19zcGFjaW5nJyk7XG5cbi8vIFN0YWZmR3JvdXBFbGVtZW50IGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBnbyB0b2dldGhlciB0byBtYWtlIG9uZSBsaW5lIG9mIG11c2ljLlxuLy8gVGhhdCBtaWdodCBiZSBtdWx0aXBsZSBzdGF2ZXMgdGhhdCBhcmUgdGllZCB0b2dldGhlciwgYW5kIGl0IG1pZ2h0IGJlIG11bHRpcGxlIHZvaWNlcyBvbiBvbmUgc3RhZmYuXG4vL1xuLy8gTWV0aG9kczpcbi8vIGNvbnN0cnVjdG9yOiBzb21lIGJhc2ljIGluaXRpYWxpemF0aW9uXG4vLyBhZGRWb2ljZSgpOiBDYWxsZWQgb25jZSBmb3IgZWFjaCB2b2ljZS4gTWF5IGFkZCBhIG5ldyBzdGFmZiBpZiBuZWVkZWQuXG4vLyBmaW5pc2hlZCgpOiBDYWxsZWQgb25seSBpbnRlcm5hbGx5IGJ5IGxheW91dCgpXG4vLyBsYXlvdXQoKTogVGhpcyBkb2VzIGFsbCB0aGUgbGF5b3V0LiBJdCBzZXRzIHRoZSBmb2xsb3dpbmc6IHNwYWNpbmd1bml0cywgc3RhcnR4LCBtaW5zcGFjZSwgdywgYW5kIHRoZSB4LWNvb3JkaW5hdGUgb2YgZWFjaCBlbGVtZW50IGluIGVhY2ggdm9pY2UuXG4vLyBkcmF3KCk6IENhbGxzIHRoZSB1bmRlcmx5aW5nIG1ldGhvZHMgb24gdGhlIHZvaWNlIG9iamVjdHMgdG8gZG8gdGhlIGRyYXdpbmcuIFNldHMgeSBhbmQgaGVpZ2h0LlxuLy9cbi8vIE1lbWJlcnM6XG4vLyBzdGFmZnM6IGFuIGFycmF5IG9mIGFsbCB0aGUgc3RhdmVzIGluIHRoaXMgZ3JvdXAuIEVhY2ggc3RhZmYgY29udGFpbnMgdGhlIGZvbGxvd2luZyBlbGVtZW50czpcbi8vICAgIHsgdG9wLCBib3R0b20sIGhpZ2hlc3QsIGxvd2VzdCwgeSB9XG4vLyB2b2ljZXM6IGFycmF5IG9mIFZvaWNlRWxlbWVudCBvYmplY3RzLiBUaGlzIGlzIG1vc3RseSBwYXNzZWQgaW4sIGJ1dCB0aGUgVm9pY2VFbGVtZW50IG9iamVjdHMgYXJlIG1vZGlmaWVkIGhlcmUuXG4vL1xuLy8gc3BhY2luZ3VuaXRzOiBudW1iZXIgb2YgcmVsYXRpdmUgeC11bml0cyBpbiB0aGUgbGluZS4gVXNlZCBieSB0aGUgY2FsbGluZyBmdW5jdGlvbiB0byBwYXNzIGJhY2sgaW4gYXMgdGhlIFwic3BhY2luZ1wiIGlucHV0IHBhcmFtZXRlci5cbi8vIFRPRE8tUEVSOiBUaGlzIHNob3VsZCBhY3R1YWxseSBiZSBwYXNzZWQgYmFjayBhcyBhIHJldHVybiB2YWx1ZS5cbi8vIG1pbnNwYWNlOiBzbWFsbGVzdCBzcGFjZSBiZXR3ZWVuIHR3byBub3Rlcy4gVXNlZCBieSB0aGUgY2FsbGluZyBmdW5jdGlvbiB0byBwYXNzIGJhY2sgaW4gYXMgdGhlIFwic3BhY2luZ1wiIGlucHV0IHBhcmFtZXRlci5cbi8vIFRPRE8tUEVSOiBUaGlzIHNob3VsZCBhY3R1YWxseSBiZSBwYXNzZWQgYmFjayBhcyBhIHJldHVybiB2YWx1ZS5cbi8vIHN0YXJ0eDogVGhlIGxlZnQgZWRnZSwgdGFraW5nIHRoZSBtYXJnaW4gYW5kIHRoZSBvcHRpb25hbCB2b2ljZSBuYW1lLiBVc2VkIGJ5IHRoZSBkcmF3KCkgbWV0aG9kLlxuLy8gdzogVGhlIHdpZHRoIG9mIHRoZSBsaW5lLiBVc2VkIGJ5IGNhbGxpbmcgZnVuY3Rpb24gdG8gcGFzcyBiYWNrIGluIGFzIHRoZSBcInNwYWNpbmdcIiBpbnB1dCBwYXJhbWV0ZXIsIGFuZCB0aGUgZHJhdygpIG1ldGhvZC5cbi8vIFRPRE8tUEVSOiBUaGlzIHNob3VsZCBhY3R1YWxseSBiZSBwYXNzZWQgYmFjayBhcyBhIHJldHVybiB2YWx1ZS4gIChUT0RPLVBFUjogaW4gcGl4ZWxzIG9yIHNwYWNpbmcgdW5pdHM/KVxuLy8geTogVGhlIHRvcCBvZiB0aGUgc3RhZmYgZ3JvdXAsIGluIHBpeGVscy4gVGhpcyBpcyBzZXQgaW4gdGhlIGRyYXcgbWV0aG9kLlxuLy8gVE9ETy1QRVI6IFdoZXJlIGlzIHRoYXQgdXNlZD8gSXQgbG9va3MgbGlrZSBpdCBtaWdodCBub3QgYmUgbmVlZGVkLlxuLy8gaGVpZ2h0OiBTZXQgaW4gdGhlIGRyYXcoKSBtZXRob2QgdG8gdGhlIGhlaWdodCBhY3R1YWxseSB1c2VkLiBVc2VkIGJ5IHRoZSBjYWxsaW5nIGZ1bmN0aW9uIHRvIGtub3cgd2hlcmUgdG8gc3RhcnQgdGhlIG5leHQgc3RhZmYgZ3JvdXAuXG4vLyBUT0RPLVBFUjogVGhpcyBzaG91bGQgYWN0dWFsbHkgYmUgc2V0IGluIHRoZSBsYXlvdXQgbWV0aG9kIGFuZCBwYXNzZWQgYmFjayBhcyBhIHJldHVybiB2YWx1ZS5cblxudmFyIFN0YWZmR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMudm9pY2VzID0gW107XG5cdHRoaXMuc3RhZmZzID0gW107XG5cdHRoaXMuYnJhY2UgPSB1bmRlZmluZWQ7IC8vdG9ueVxufTtcblxuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLnNldExpbWl0ID0gZnVuY3Rpb24obWVtYmVyLCB2b2ljZSkge1xuXHRpZiAoIXZvaWNlLnNwZWNpYWxZW21lbWJlcl0pIHJldHVybjtcblx0aWYgKCF2b2ljZS5zdGFmZi5zcGVjaWFsWVttZW1iZXJdKVxuXHRcdHZvaWNlLnN0YWZmLnNwZWNpYWxZW21lbWJlcl0gPSB2b2ljZS5zcGVjaWFsWVttZW1iZXJdO1xuXHRlbHNlXG5cdFx0dm9pY2Uuc3RhZmYuc3BlY2lhbFlbbWVtYmVyXSA9IE1hdGgubWF4KHZvaWNlLnN0YWZmLnNwZWNpYWxZW21lbWJlcl0sIHZvaWNlLnNwZWNpYWxZW21lbWJlcl0pO1xufTtcblxuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLmFkZFZvaWNlID0gZnVuY3Rpb24gKHZvaWNlLCBzdGFmZm51bWJlciwgc3RhZmZsaW5lcykge1xuXHR2YXIgdm9pY2VOdW0gPSB0aGlzLnZvaWNlcy5sZW5ndGg7XG5cdHRoaXMudm9pY2VzW3ZvaWNlTnVtXSA9IHZvaWNlO1xuXHRpZiAodGhpcy5zdGFmZnNbc3RhZmZudW1iZXJdKVxuXHRcdHRoaXMuc3RhZmZzW3N0YWZmbnVtYmVyXS52b2ljZXMucHVzaCh2b2ljZU51bSk7XG5cdGVsc2Uge1xuXHRcdC8vIFRPRE8tUEVSOiBob3cgZG9lcyB0aGUgbWluL21heCBjaGFuZ2Ugd2hlbiBzdGFmZmxpbmVzIGlzIG5vdCA1P1xuXHRcdHRoaXMuc3RhZmZzW3RoaXMuc3RhZmZzLmxlbmd0aF0gPSB7XG5cdFx0XHR0b3A6IDEwLFxuXHRcdFx0Ym90dG9tOiAyLFxuXHRcdFx0bGluZXM6IHN0YWZmbGluZXMsXG5cdFx0XHR2b2ljZXM6IFt2b2ljZU51bV0sXG5cdFx0XHRzcGVjaWFsWToge1xuXHRcdFx0XHR0ZW1wb0hlaWdodEFib3ZlOiAwLFxuXHRcdFx0XHRwYXJ0SGVpZ2h0QWJvdmU6IDAsXG5cdFx0XHRcdHZvbHVtZUhlaWdodEFib3ZlOiAwLFxuXHRcdFx0XHRkeW5hbWljSGVpZ2h0QWJvdmU6IDAsXG5cdFx0XHRcdGVuZGluZ0hlaWdodEFib3ZlOiAwLFxuXHRcdFx0XHRjaG9yZEhlaWdodEFib3ZlOiAwLFxuXHRcdFx0XHRseXJpY0hlaWdodEFib3ZlOiAwLFxuXG5cdFx0XHRcdGx5cmljSGVpZ2h0QmVsb3c6IDAsXG5cdFx0XHRcdGNob3JkSGVpZ2h0QmVsb3c6IDAsXG5cdFx0XHRcdHZvbHVtZUhlaWdodEJlbG93OiAwLFxuXHRcdFx0XHRkeW5hbWljSGVpZ2h0QmVsb3c6IDBcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdHZvaWNlLnN0YWZmID0gdGhpcy5zdGFmZnNbc3RhZmZudW1iZXJdO1xufTtcblxuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLnNldFN0YWZmTGltaXRzID0gZnVuY3Rpb24gKHZvaWNlKSB7XG5cdHZvaWNlLnN0YWZmLnRvcCA9IE1hdGgubWF4KHZvaWNlLnN0YWZmLnRvcCwgdm9pY2UudG9wKTtcblx0dm9pY2Uuc3RhZmYuYm90dG9tID0gTWF0aC5taW4odm9pY2Uuc3RhZmYuYm90dG9tLCB2b2ljZS5ib3R0b20pO1xuXHR0aGlzLnNldExpbWl0KCd0ZW1wb0hlaWdodEFib3ZlJywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdwYXJ0SGVpZ2h0QWJvdmUnLCB2b2ljZSk7XG5cdHRoaXMuc2V0TGltaXQoJ3ZvbHVtZUhlaWdodEFib3ZlJywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdkeW5hbWljSGVpZ2h0QWJvdmUnLCB2b2ljZSk7XG5cdHRoaXMuc2V0TGltaXQoJ2VuZGluZ0hlaWdodEFib3ZlJywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdjaG9yZEhlaWdodEFib3ZlJywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdseXJpY0hlaWdodEFib3ZlJywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdseXJpY0hlaWdodEJlbG93Jywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCdjaG9yZEhlaWdodEJlbG93Jywgdm9pY2UpO1xuXHR0aGlzLnNldExpbWl0KCd2b2x1bWVIZWlnaHRCZWxvdycsIHZvaWNlKTtcblx0dGhpcy5zZXRMaW1pdCgnZHluYW1pY0hlaWdodEJlbG93Jywgdm9pY2UpO1xufTtcblxuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLnNldFVwcGVyQW5kTG93ZXJFbGVtZW50cyA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG5cdC8vIEVhY2ggc3RhZmYgYWxyZWFkeSBoYXMgdGhlIHRvcCBhbmQgYm90dG9tIHNldCwgbm93IHdlIHNlZSBpZiB0aGVyZSBhcmUgZWxlbWVudHMgdGhhdCBhcmUgYWx3YXlzIG9uIHRvcCBhbmQgYm90dG9tLCBhbmQgcmVzb2x2ZSB0aGVpciBwaXRjaC5cblx0Ly8gQWxzbywgZ2V0IHRoZSBvdmVyYWxsIGhlaWdodCBvZiBhbGwgdGhlIHN0YXZlcyBpbiB0aGlzIGdyb3VwLlxuXHR2YXIgbGFzdFN0YWZmQm90dG9tO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhZmZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHN0YWZmID0gdGhpcy5zdGFmZnNbaV07XG5cdFx0Ly8gdGhlIHZlcnRpY2FsIG9yZGVyIG9mIGVsZW1lbnRzIHRoYXQgYXJlIGFib3ZlIGlzOiB0ZW1wbywgcGFydCwgdm9sdW1lL2R5bmFtaWMsIGVuZGluZy9jaG9yZCwgbHlyaWNcblx0XHQvLyB0aGUgdmVydGljYWwgb3JkZXIgb2YgZWxlbWVudHMgdGhhdCBhcmUgYmVsb3cgaXM6IGx5cmljLCBjaG9yZCwgdm9sdW1lL2R5bmFtaWNcblx0XHR2YXIgcG9zaXRpb25ZID0ge1xuXHRcdFx0dGVtcG9IZWlnaHRBYm92ZTogMCxcblx0XHRcdHBhcnRIZWlnaHRBYm92ZTogMCxcblx0XHRcdHZvbHVtZUhlaWdodEFib3ZlOiAwLFxuXHRcdFx0ZHluYW1pY0hlaWdodEFib3ZlOiAwLFxuXHRcdFx0ZW5kaW5nSGVpZ2h0QWJvdmU6IDAsXG5cdFx0XHRjaG9yZEhlaWdodEFib3ZlOiAwLFxuXHRcdFx0bHlyaWNIZWlnaHRBYm92ZTogMCxcblxuXHRcdFx0bHlyaWNIZWlnaHRCZWxvdzogMCxcblx0XHRcdGNob3JkSGVpZ2h0QmVsb3c6IDAsXG5cdFx0XHR2b2x1bWVIZWlnaHRCZWxvdzogMCxcblx0XHRcdGR5bmFtaWNIZWlnaHRCZWxvdzogMFxuXHRcdH07XG5cblx0XHRpZiAoLypBQkNKUy53cml0ZS5kZWJ1Z1BsYWNlbWVudCovZmFsc2UpIHtcblx0XHRcdHN0YWZmLm9yaWdpbmFsVG9wID0gc3RhZmYudG9wOyAvLyBUaGlzIGlzIGp1c3QgYmVpbmcgc3RvcmVkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG5cdFx0XHRzdGFmZi5vcmlnaW5hbEJvdHRvbSA9IHN0YWZmLmJvdHRvbTsgLy8gVGhpcyBpcyBqdXN0IGJlaW5nIHN0b3JlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuXHRcdH1cblxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS5seXJpY0hlaWdodEFib3ZlKSB7IHN0YWZmLnRvcCArPSBzdGFmZi5zcGVjaWFsWS5seXJpY0hlaWdodEFib3ZlOyBwb3NpdGlvblkubHlyaWNIZWlnaHRBYm92ZSA9IHN0YWZmLnRvcDsgfVxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS5jaG9yZEhlaWdodEFib3ZlKSB7IHN0YWZmLnRvcCArPSBzdGFmZi5zcGVjaWFsWS5jaG9yZEhlaWdodEFib3ZlOyBwb3NpdGlvblkuY2hvcmRIZWlnaHRBYm92ZSA9IHN0YWZmLnRvcDsgfVxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS5lbmRpbmdIZWlnaHRBYm92ZSkge1xuXHRcdFx0aWYgKHN0YWZmLnNwZWNpYWxZLmNob3JkSGVpZ2h0QWJvdmUpXG5cdFx0XHRcdHN0YWZmLnRvcCArPSAyO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzdGFmZi50b3AgKz0gc3RhZmYuc3BlY2lhbFkuZW5kaW5nSGVpZ2h0QWJvdmU7XG5cdFx0XHRwb3NpdGlvblkuZW5kaW5nSGVpZ2h0QWJvdmUgPSBzdGFmZi50b3A7XG5cdFx0fVxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS5keW5hbWljSGVpZ2h0QWJvdmUgJiYgc3RhZmYuc3BlY2lhbFkudm9sdW1lSGVpZ2h0QWJvdmUpIHtcblx0XHRcdHN0YWZmLnRvcCArPSBNYXRoLm1heChzdGFmZi5zcGVjaWFsWS5keW5hbWljSGVpZ2h0QWJvdmUsIHN0YWZmLnNwZWNpYWxZLnZvbHVtZUhlaWdodEFib3ZlKTtcblx0XHRcdHBvc2l0aW9uWS5keW5hbWljSGVpZ2h0QWJvdmUgPSBzdGFmZi50b3A7XG5cdFx0XHRwb3NpdGlvblkudm9sdW1lSGVpZ2h0QWJvdmUgPSBzdGFmZi50b3A7XG5cdFx0fSBlbHNlIGlmIChzdGFmZi5zcGVjaWFsWS5keW5hbWljSGVpZ2h0QWJvdmUpIHtcblx0XHRcdHN0YWZmLnRvcCArPSBzdGFmZi5zcGVjaWFsWS5keW5hbWljSGVpZ2h0QWJvdmU7IHBvc2l0aW9uWS5keW5hbWljSGVpZ2h0QWJvdmUgPSBzdGFmZi50b3A7XG5cdFx0fSBlbHNlIGlmIChzdGFmZi5zcGVjaWFsWS52b2x1bWVIZWlnaHRBYm92ZSkgeyBzdGFmZi50b3AgKz0gc3RhZmYuc3BlY2lhbFkudm9sdW1lSGVpZ2h0QWJvdmU7IHBvc2l0aW9uWS52b2x1bWVIZWlnaHRBYm92ZSA9IHN0YWZmLnRvcDsgfVxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS5wYXJ0SGVpZ2h0QWJvdmUpIHsgc3RhZmYudG9wICs9IHN0YWZmLnNwZWNpYWxZLnBhcnRIZWlnaHRBYm92ZTsgcG9zaXRpb25ZLnBhcnRIZWlnaHRBYm92ZSA9IHN0YWZmLnRvcDsgfVxuXHRcdGlmIChzdGFmZi5zcGVjaWFsWS50ZW1wb0hlaWdodEFib3ZlKSB7IHN0YWZmLnRvcCArPSBzdGFmZi5zcGVjaWFsWS50ZW1wb0hlaWdodEFib3ZlOyBwb3NpdGlvblkudGVtcG9IZWlnaHRBYm92ZSA9IHN0YWZmLnRvcDsgfVxuXG5cdFx0aWYgKHN0YWZmLnNwZWNpYWxZLmx5cmljSGVpZ2h0QmVsb3cpIHsgcG9zaXRpb25ZLmx5cmljSGVpZ2h0QmVsb3cgPSBzdGFmZi5ib3R0b207IHN0YWZmLmJvdHRvbSAtPSBzdGFmZi5zcGVjaWFsWS5seXJpY0hlaWdodEJlbG93OyB9XG5cdFx0aWYgKHN0YWZmLnNwZWNpYWxZLmNob3JkSGVpZ2h0QmVsb3cpIHsgcG9zaXRpb25ZLmNob3JkSGVpZ2h0QmVsb3cgPSBzdGFmZi5ib3R0b207IHN0YWZmLmJvdHRvbSAtPSBzdGFmZi5zcGVjaWFsWS5jaG9yZEhlaWdodEJlbG93OyB9XG5cdFx0aWYgKHN0YWZmLnNwZWNpYWxZLnZvbHVtZUhlaWdodEJlbG93ICYmIHN0YWZmLnNwZWNpYWxZLmR5bmFtaWNIZWlnaHRCZWxvdykge1xuXHRcdFx0cG9zaXRpb25ZLnZvbHVtZUhlaWdodEJlbG93ID0gc3RhZmYuYm90dG9tO1xuXHRcdFx0cG9zaXRpb25ZLmR5bmFtaWNIZWlnaHRCZWxvdyA9IHN0YWZmLmJvdHRvbTtcblx0XHRcdHN0YWZmLmJvdHRvbSAtPSBNYXRoLm1heChzdGFmZi5zcGVjaWFsWS52b2x1bWVIZWlnaHRCZWxvdywgc3RhZmYuc3BlY2lhbFkuZHluYW1pY0hlaWdodEJlbG93KTtcblx0XHR9IGVsc2UgaWYgKHN0YWZmLnNwZWNpYWxZLnZvbHVtZUhlaWdodEJlbG93KSB7XG5cdFx0XHRwb3NpdGlvblkudm9sdW1lSGVpZ2h0QmVsb3cgPSBzdGFmZi5ib3R0b207IHN0YWZmLmJvdHRvbSAtPSBzdGFmZi5zcGVjaWFsWS52b2x1bWVIZWlnaHRCZWxvdztcblx0XHR9IGVsc2UgaWYgKHN0YWZmLnNwZWNpYWxZLmR5bmFtaWNIZWlnaHRCZWxvdykge1xuXHRcdFx0cG9zaXRpb25ZLmR5bmFtaWNIZWlnaHRCZWxvdyA9IHN0YWZmLmJvdHRvbTsgc3RhZmYuYm90dG9tIC09IHN0YWZmLnNwZWNpYWxZLmR5bmFtaWNIZWlnaHRCZWxvdztcblx0XHR9XG5cblx0XHRpZiAoLypBQkNKUy53cml0ZS5kZWJ1Z1BsYWNlbWVudCovZmFsc2UpXG5cdFx0XHRzdGFmZi5wb3NpdGlvblkgPSBwb3NpdGlvblk7IC8vIFRoaXMgaXMganVzdCBiZWluZyBzdG9yZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cblxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgc3RhZmYudm9pY2VzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgdm9pY2UgPSB0aGlzLnZvaWNlc1tzdGFmZi52b2ljZXNbal1dO1xuXHRcdFx0dm9pY2Uuc2V0VXBwZXJBbmRMb3dlckVsZW1lbnRzKHBvc2l0aW9uWSk7XG5cdFx0fVxuXHRcdC8vIFdlIG1pZ2h0IG5lZWQgYSBsaXR0bGUgc3BhY2UgaW4gYmV0d2VlbiBzdGF2ZXMgaWYgdGhlIHN0YXZlcyBoYXZlbid0IGJlZW4gcHVzaGVkIGZhciBlbm91Z2ggYXBhcnQgYnkgbm90ZXMgb3IgZXh0cmEgdmVydGljYWwgc3R1ZmYuXG5cdFx0Ly8gT25seSB0cnkgdG8gcHV0IGluIGV4dHJhIHNwYWNlIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBzdGFmZi5cblx0XHRpZiAobGFzdFN0YWZmQm90dG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciB0aGlzU3RhZmZUb3AgPSBzdGFmZi50b3AgLSAxMDtcblx0XHRcdHZhciBmb3JjZWRTcGFjaW5nQmV0d2VlbiA9IGxhc3RTdGFmZkJvdHRvbSArIHRoaXNTdGFmZlRvcDtcblx0XHRcdHZhciBtaW5TcGFjaW5nSW5QaXRjaGVzID0gcmVuZGVyZXIuc3BhY2luZy5zeXN0ZW1TdGFmZlNlcGFyYXRpb24vc3BhY2luZy5TVEVQO1xuXHRcdFx0dmFyIGFkZGVkU3BhY2UgPSBtaW5TcGFjaW5nSW5QaXRjaGVzIC0gZm9yY2VkU3BhY2luZ0JldHdlZW47XG5cdFx0XHRpZiAoYWRkZWRTcGFjZSA+IDApXG5cdFx0XHRcdHN0YWZmLnRvcCArPSBhZGRlZFNwYWNlO1xuXHRcdH1cblx0XHRsYXN0U3RhZmZCb3R0b20gPSAyIC0gc3RhZmYuYm90dG9tOyAvLyB0aGUgc3RhZmYgc3RhcnRzIGF0IHBvc2l0aW9uIDIgYW5kIHRoZSBib3R0b20gdmFyaWFibGUgaXMgbmVnYXRpdmUuIFRoZXJlZm9yZSB0byBmaW5kIG91dCBob3cgbGFyZ2UgdGhlIGJvdHRvbSBpcywgd2UgcmV2ZXJzZSB0aGUgc2lnbiBvZiB0aGUgYm90dG9tLCBhbmQgYWRkIHRoZSAyIGluLlxuXG5cdFx0Ly8gTm93IHdlIG5lZWQgYSBsaXR0bGUgbWFyZ2luIG9uIHRoZSB0b3AsIHNvIHdlJ2xsIGp1c3QgdGhyb3cgdGhhdCBpbi5cblx0XHQvL3N0YWZmLnRvcCArPSA0O1xuXHRcdC8vY29uc29sZS5sb2coXCJTdGFmZiBZOiBcIixpLGhlaWdodEluUGl0Y2hlcyxzdGFmZi50b3Asc3RhZmYuYm90dG9tKTtcblx0fVxuXHQvL2NvbnNvbGUubG9nKFwiU3RhZmYgSGVpZ2h0OiBcIixoZWlnaHRJblBpdGNoZXMsdGhpcy5oZWlnaHQpO1xufTtcblxuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdGZvciAodmFyIGk9MDtpPHRoaXMudm9pY2VzLmxlbmd0aDtpKyspIHtcblx0XHRpZiAoIXRoaXMudm9pY2VzW2ldLmxheW91dEVuZGVkKCkpIHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldExlZnRFZGdlT2ZTdGFmZihyZW5kZXJlciwgdm9pY2VzLCBicmFjZSkge1xuXHR2YXIgeCA9IHJlbmRlcmVyLnBhZGRpbmcubGVmdDtcblxuXHQvLyBmaW5kIG91dCBob3cgbXVjaCBzcGFjZSB3aWxsIGJlIHRha2VuIHVwIGJ5IHZvaWNlIGhlYWRlcnNcblx0dmFyIHZvaWNlaGVhZGVydyA9IDA7XG5cdGZvciAodmFyIGk9MDtpPHZvaWNlcy5sZW5ndGg7aSsrKSB7XG5cdFx0aWYodm9pY2VzW2ldLmhlYWRlcikge1xuXHRcdFx0dmFyIHNpemUgPSByZW5kZXJlci5nZXRUZXh0U2l6ZSh2b2ljZXNbaV0uaGVhZGVyLCAndm9pY2Vmb250JywgJycpO1xuXHRcdFx0dm9pY2VoZWFkZXJ3ID0gTWF0aC5tYXgodm9pY2VoZWFkZXJ3LHNpemUud2lkdGgpO1xuXHRcdH1cblx0fVxuXHRpZiAodm9pY2VoZWFkZXJ3KSB7XG5cdFx0Ly8gR2l2ZSBlbm91Z2ggc3BhY2luZyB0byB0aGUgcmlnaHQgLSB3ZSB1c2UgdGhlIHdpZHRoIG9mIGFuIEEgZm9yIHRoZSBhbW91bnQgb2Ygc3BhY2luZy5cblx0XHR2YXIgc2l6ZVcgPSByZW5kZXJlci5nZXRUZXh0U2l6ZShcIkFcIiwgJ3ZvaWNlZm9udCcsICcnKTtcblx0XHR2b2ljZWhlYWRlcncgKz0gc2l6ZVcud2lkdGg7XG5cdH1cblx0eCArPSB2b2ljZWhlYWRlcnc7XG5cblx0aWYgKGJyYWNlKSB7XG5cdFx0YnJhY2Uuc2V0TG9jYXRpb24oeCk7XG5cdFx0eCArPSBicmFjZS5nZXRXaWR0aCgpO1xuXHR9XG5cdHJldHVybiB4O1xufVxuXG5TdGFmZkdyb3VwRWxlbWVudC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oc3BhY2luZywgcmVuZGVyZXIsIGRlYnVnKSB7XG5cdHZhciBlcHNpbG9uID0gMC4wMDAwMDAxOyAvLyBGdWRnaW5nIGZvciBpbmV4YWN0bmVzcyBvZiBmbG9hdGluZyBwb2ludCBtYXRoLlxuXHR2YXIgc3BhY2luZ3VuaXRzID0gMDsgLy8gbnVtYmVyIG9mIHRpbWVzIHdlIHdpbGwgaGF2ZSBlbmRlZCB1cCB1c2luZyB0aGUgc3BhY2luZyBkaXN0YW5jZSAoYXMgb3Bwb3NlZCB0byBmaXhlZCB3aWR0aCBkaXN0YW5jZXMpXG5cdHZhciBtaW5zcGFjZSA9IDEwMDA7IC8vIGEgYmlnIG51bWJlciB0byBzdGFydCBvZmYgd2l0aCAtIHVzZWQgdG8gZmluZCBvdXQgd2hhdCB0aGUgc21hbGxlc3Qgc3BhY2UgYmV0d2VlbiB0d28gbm90ZXMgaXMgLS0gR0QgMjAxNC4xLjdcblxuXHR2YXIgeCA9IGdldExlZnRFZGdlT2ZTdGFmZihyZW5kZXJlciwgdGhpcy52b2ljZXMsIHRoaXMuYnJhY2UpO1xuXHR0aGlzLnN0YXJ0eD14O1xuXHR2YXIgaTtcblxuXHR2YXIgY3VycmVudGR1cmF0aW9uID0gMDtcblx0aWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImluaXQgbGF5b3V0XCIsIHNwYWNpbmcpO1xuXHRmb3IgKGk9MDtpPHRoaXMudm9pY2VzLmxlbmd0aDtpKyspIHtcblx0XHR0aGlzLnZvaWNlc1tpXS5iZWdpbkxheW91dCh4KTtcblx0fVxuXG5cdHZhciBzcGFjaW5ndW5pdCA9IDA7IC8vIG51bWJlciBvZiBzcGFjaW5ndW5pdHMgY29taW5nIGZyb20gdGhlIHByZXZpb3VzbHkgbGFpZCBvdXQgZWxlbWVudCB0byB0aGlzIG9uZVxuXHR3aGlsZSAoIXRoaXMuZmluaXNoZWQoKSkge1xuXHRcdC8vIGZpbmQgZmlyc3QgZHVyYXRpb24gbGV2ZWwgdG8gYmUgbGFpZCBvdXQgYW1vbmcgY2FuZGlkYXRlcyBhY3Jvc3Mgdm9pY2VzXG5cdFx0Y3VycmVudGR1cmF0aW9uPSBudWxsOyAvLyBjYW5kaWRhdGUgc21hbGxlc3QgZHVyYXRpb24gbGV2ZWxcblx0XHRmb3IgKGk9MDtpPHRoaXMudm9pY2VzLmxlbmd0aDtpKyspIHtcblx0XHRcdGlmICghdGhpcy52b2ljZXNbaV0ubGF5b3V0RW5kZWQoKSAmJiAoIWN1cnJlbnRkdXJhdGlvbiB8fCB0aGlzLnZvaWNlc1tpXS5nZXREdXJhdGlvbkluZGV4KCk8Y3VycmVudGR1cmF0aW9uKSlcblx0XHRcdFx0Y3VycmVudGR1cmF0aW9uPXRoaXMudm9pY2VzW2ldLmdldER1cmF0aW9uSW5kZXgoKTtcblx0XHR9XG5cblxuXHRcdC8vIGlzb2xhdGUgdm9pY2VzIGF0IGN1cnJlbnQgZHVyYXRpb24gbGV2ZWxcblx0XHR2YXIgY3VycmVudHZvaWNlcyA9IFtdO1xuXHRcdHZhciBvdGhlcnZvaWNlcyA9IFtdO1xuXHRcdGZvciAoaT0wO2k8dGhpcy52b2ljZXMubGVuZ3RoO2krKykge1xuXHRcdFx0dmFyIGR1cmF0aW9uSW5kZXggPSB0aGlzLnZvaWNlc1tpXS5nZXREdXJhdGlvbkluZGV4KCk7XG5cdFx0XHQvLyBQRVI6IEJlY2F1c2Ugb2YgdGhlIGluZXhhY3RuZXNzIG9mIEpTIGZsb2F0aW5nIHBvaW50IG1hdGgsIHdlIGp1c3QgZ2V0IGNsb3NlLlxuXHRcdFx0aWYgKGR1cmF0aW9uSW5kZXggLSBjdXJyZW50ZHVyYXRpb24gPiBlcHNpbG9uKSB7XG5cdFx0XHRcdG90aGVydm9pY2VzLnB1c2godGhpcy52b2ljZXNbaV0pO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwib3V0OiB2b2ljZSBcIixpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnR2b2ljZXMucHVzaCh0aGlzLnZvaWNlc1tpXSk7XG5cdFx0XHRcdC8vaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcImluOiB2b2ljZSBcIixpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbW9uZyB0aGUgY3VycmVudCBkdXJhdGlvbiBsZXZlbCBmaW5kIHRoZSBvbmUgd2hpY2ggbmVlZHMgc3RhcnRpbmcgZnVydGhlc3QgcmlnaHRcblx0XHRzcGFjaW5ndW5pdCA9IDA7IC8vIG51bWJlciBvZiBzcGFjaW5ndW5pdHMgY29taW5nIGZyb20gdGhlIHByZXZpb3VzbHkgbGFpZCBvdXQgZWxlbWVudCB0byB0aGlzIG9uZVxuXHRcdHZhciBzcGFjaW5nZHVyYXRpb24gPSAwO1xuXHRcdGZvciAoaT0wO2k8Y3VycmVudHZvaWNlcy5sZW5ndGg7aSsrKSB7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiZ3JlYXRlc3Qgc3BhY2luZyB1bml0XCIsIHgsIGN1cnJlbnR2b2ljZXNbaV0uZ2V0TmV4dFgoKSwgY3VycmVudHZvaWNlc1tpXS5nZXRTcGFjaW5nVW5pdHMoKSwgY3VycmVudHZvaWNlc1tpXS5zcGFjaW5nZHVyYXRpb24pO1xuXHRcdFx0aWYgKGN1cnJlbnR2b2ljZXNbaV0uZ2V0TmV4dFgoKT54KSB7XG5cdFx0XHRcdHg9Y3VycmVudHZvaWNlc1tpXS5nZXROZXh0WCgpO1xuXHRcdFx0XHRzcGFjaW5ndW5pdD1jdXJyZW50dm9pY2VzW2ldLmdldFNwYWNpbmdVbml0cygpO1xuXHRcdFx0XHRzcGFjaW5nZHVyYXRpb24gPSBjdXJyZW50dm9pY2VzW2ldLnNwYWNpbmdkdXJhdGlvbjtcblx0XHRcdH1cblx0XHR9XG5cdFx0c3BhY2luZ3VuaXRzKz1zcGFjaW5ndW5pdDtcblx0XHRtaW5zcGFjZSA9IE1hdGgubWluKG1pbnNwYWNlLHNwYWNpbmd1bml0KTtcblx0XHRpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiY3VycmVudGR1cmF0aW9uOiBcIixjdXJyZW50ZHVyYXRpb24sIHNwYWNpbmd1bml0cywgbWluc3BhY2UpO1xuXG5cdFx0Zm9yIChpPTA7aTxjdXJyZW50dm9pY2VzLmxlbmd0aDtpKyspIHtcblx0XHRcdHZhciB2b2ljZWNoaWxkeCA9IGN1cnJlbnR2b2ljZXNbaV0ubGF5b3V0T25lSXRlbSh4LHNwYWNpbmcpO1xuXHRcdFx0dmFyIGR4ID0gdm9pY2VjaGlsZHgteDtcblx0XHRcdGlmIChkeD4wKSB7XG5cdFx0XHRcdHggPSB2b2ljZWNoaWxkeDsgLy91cGRhdGUgeFxuXHRcdFx0XHRmb3IgKHZhciBqPTA7ajxpO2orKykgeyAvLyBzaGlmdCBvdmVyIGFsbCBwcmV2aW91c2x5IGxhaWQgb3V0IGVsZW1lbnRzXG5cdFx0XHRcdFx0Y3VycmVudHZvaWNlc1tqXS5zaGlmdFJpZ2h0KGR4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSB0aGUgdmFsdWUgb2YgYWxyZWFkeSBjb3VudGVkIHNwYWNpbmcgdW5pdHMgaW4gb3RoZXIgdm9pY2VzIChlLmcuIGlmIGEgdm9pY2UgaGFkIHBsYW5uZWQgdG8gdXNlIHVwIDUgc3BhY2luZyB1bml0cyBidXQgaXMgbm90IGluIGxpbmUgdG8gYmUgbGFpZCBvdXQgYXQgdGhpcyBkdXJhdGlvbiBsZXZlbCAtIHdoZXJlIHdlJ3ZlIHVzZWQgMiBzcGFjaW5nIHVuaXRzIC0gdGhlbiB3ZSBtdXN0IHVzZSB1cCAzIHNwYWNpbmcgdW5pdHMsIG5vdCA1KVxuXHRcdGZvciAoaT0wO2k8b3RoZXJ2b2ljZXMubGVuZ3RoO2krKykge1xuXHRcdFx0b3RoZXJ2b2ljZXNbaV0uc3BhY2luZ2R1cmF0aW9uLT1zcGFjaW5nZHVyYXRpb247XG5cdFx0XHRvdGhlcnZvaWNlc1tpXS51cGRhdGVOZXh0WCh4LHNwYWNpbmcpOyAvLyBhZGp1c3Qgb3RoZXIgdm9pY2VzIGV4cGVjdGF0aW9uc1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBpbmRleGVzIG9mIGN1cnJlbnRseSBsYWlkIG91dCBlbGVtc1xuXHRcdGZvciAoaT0wO2k8Y3VycmVudHZvaWNlcy5sZW5ndGg7aSsrKSB7XG5cdFx0XHR2YXIgdm9pY2UgPSBjdXJyZW50dm9pY2VzW2ldO1xuXHRcdFx0dm9pY2UudXBkYXRlSW5kaWNlcygpO1xuXHRcdH1cblx0fSAvLyBmaW5pc2hlZCBsYXlpbmcgb3V0XG5cblxuXHQvLyBmaW5kIHRoZSBncmVhdGVzdCByZW1haW5pbmcgeCBhcyBhIGJhc2UgZm9yIHRoZSB3aWR0aFxuXHRmb3IgKGk9MDtpPHRoaXMudm9pY2VzLmxlbmd0aDtpKyspIHtcblx0XHRpZiAodGhpcy52b2ljZXNbaV0uZ2V0TmV4dFgoKT54KSB7XG5cdFx0XHR4PXRoaXMudm9pY2VzW2ldLmdldE5leHRYKCk7XG5cdFx0XHRzcGFjaW5ndW5pdD10aGlzLnZvaWNlc1tpXS5nZXRTcGFjaW5nVW5pdHMoKTtcblx0XHR9XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhcImdyZWF0ZXN0IHJlbWFpbmluZ1wiLHNwYWNpbmd1bml0LHgpO1xuXHRzcGFjaW5ndW5pdHMrPXNwYWNpbmd1bml0O1xuXHR0aGlzLncgPSB4O1xuXG5cdGZvciAoaT0wO2k8dGhpcy52b2ljZXMubGVuZ3RoO2krKykge1xuXHRcdHRoaXMudm9pY2VzW2ldLnc9dGhpcy53O1xuXHR9XG5cdHJldHVybiB7IHNwYWNpbmdVbml0czogc3BhY2luZ3VuaXRzLCBtaW5TcGFjZTogbWluc3BhY2UgfTtcbn07XG5cblN0YWZmR3JvdXBFbGVtZW50LnByb3RvdHlwZS5jYWxjSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHQvLyB0aGUgaGVpZ2h0IGlzIGNhbGN1bGF0ZWQgaGVyZSBpbiBhIHBhcmFsbGVsIHdheSB0byB0aGUgZHJhd2luZyBiZWxvdyBpbiBob3BlcyB0aGF0IGJvdGggb2YgdGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgbW9kaWZpZWQgdG9nZXRoZXIuXG5cdC8vIFRPRE8tUEVSOiBhbHNvIGFkZCB0aGUgc3BhY2UgYmV0d2VlbiBzdGF2ZXMuIChUaGF0J3Mgc3lzdGVtU3RhZmZTZXBhcmF0aW9uLCB3aGljaCBpcyB0aGUgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBzdGFmZiBMSU5FUy4pXG5cdHZhciBoZWlnaHQgPSAwO1xuXHRmb3IgKHZhciBpPTA7aTx0aGlzLnZvaWNlcy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIHN0YWZmID0gdGhpcy52b2ljZXNbaV0uc3RhZmY7XG5cdFx0aWYgKCF0aGlzLnZvaWNlc1tpXS5kdXBsaWNhdGUpIHtcblx0XHRcdGhlaWdodCArPSBzdGFmZi50b3A7XG5cdFx0XHRpZiAoc3RhZmYuYm90dG9tIDwgMClcblx0XHRcdFx0aGVpZ2h0ICs9IC1zdGFmZi5ib3R0b207XG5cdFx0fVxuXHR9XG5cdHJldHVybiBoZWlnaHQ7XG59O1xuXG5TdGFmZkdyb3VwRWxlbWVudC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuXHQvLyBXZSBlbnRlciB0aGlzIG1ldGhvZCB3aXRoIHJlbmRlcmVyLnkgcG9pbnRpbmcgdG8gdGhlIHRvcG1vc3QgY29vcmRpbmF0ZSB0aGF0IHdlJ3JlIGFsbG93ZWQgdG8gZHJhdy5cblx0Ly8gQWxsIG9mIHRoZSBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgZHJhd24gaGF2ZSBhIHJlbGF0aXZlIFwicGl0Y2hcIiBzZXQsIHdoZXJlIHplcm8gaXMgdGhlIGZpcnN0IGxlZGdlciBsaW5lIGJlbG93IHRoZSBzdGFmZi5cblx0Ly8gcmVuZGVyZXIueSB3aWxsIGJlIG9mZnNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggc3RhZmYgYnkgdGhlIGFtb3VudCByZXF1aXJlZCB0byBtYWtlIHRoZSByZWxhdGl2ZSBwaXRjaCB3b3JrLlxuXHQvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgc3RhdmVzLCB0aGVuIHJlbmRlcmVyLnkgd2lsbCBiZSBpbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgc3RhZmYuXG5cblx0dmFyIGRlYnVnUHJpbnQ7XG5cdHZhciBjb2xvckluZGV4O1xuXHRpZiAoLypBQkNKUy53cml0ZS5kZWJ1Z1BsYWNlbWVudCovZmFsc2UpIHtcblx0XHR2YXIgY29sb3JzID0gWyBcInJnYigyMDcsMjcsMzYpXCIsIFwicmdiKDE2OCwyMTQsODApXCIsIFwicmdiKDExMCwxNjEsMjI0KVwiLCBcInJnYigxOTEsMTE5LDIxOClcIiwgXCJyZ2IoMTk1LDMwLDE1MSlcIixcblx0XHRcdFwicmdiKDMxLDE3MCwxNzcpXCIsIFwicmdiKDIyMCwxNjYsMTQyKVwiIF07XG5cdFx0ZGVidWdQcmludCA9IGZ1bmN0aW9uKHN0YWZmLCBrZXkpIHtcblx0XHRcdGlmIChzdGFmZi5wb3NpdGlvbllba2V5XSkge1xuXHRcdFx0XHQvL3JlbmRlcmVyLnByaW50SG9yaXpvbnRhbExpbmUoNTAsIHJlbmRlcmVyLmNhbGNZKHN0YWZmLnBvc2l0aW9uWVtrZXldKSwga2V5LnN1YnN0cigwLCA0KSArIFwiIFwiICsgTWF0aC5yb3VuZChzdGFmZi5wb3NpdGlvbllba2V5XSkpO1xuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gc3RhZmYuc3BlY2lhbFlba2V5XSAqIHNwYWNpbmcuU1RFUDtcblx0XHRcdFx0cmVuZGVyZXIucHJpbnRTaGFkZWRCb3gocmVuZGVyZXIucGFkZGluZy5sZWZ0LCByZW5kZXJlci5jYWxjWShzdGFmZi5wb3NpdGlvbllba2V5XSksIHJlbmRlcmVyLmNvbnRyb2xsZXIud2lkdGgsIGhlaWdodCxjb2xvcnNbY29sb3JJbmRleF0sIDAuNCwga2V5LnN1YnN0cigwLCA0KSk7XG5cdFx0XHRcdGNvbG9ySW5kZXggKz0gMTsgaWYgKGNvbG9ySW5kZXggPiA2KSBjb2xvckluZGV4ID0gMDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gQW4gaW52aXNpYmxlIG1hcmtlciBpcyB1c2VmdWwgdG8gYmUgYWJsZSB0byBmaW5kIHdoZXJlIGVhY2ggc3lzdGVtIHN0YXJ0cy5cblx0cmVuZGVyZXIuYWRkSW52aXNpYmxlTWFya2VyKFwiYWJjanMtdG9wLW9mLXN5c3RlbVwiKTtcblxuXHR2YXIgc3RhcnRZID0gcmVuZGVyZXIueTsgLy8gU28gdGhhdCBpdCBjYW4gYmUgcmVzdG9yZWQgYWZ0ZXIgd2UncmUgZG9uZS5cblx0Ly8gU2V0IHRoZSBhYnNvbHV0ZSBZIHBvc2l0aW9uIGZvciBlYWNoIHN0YWZmIGhlcmUsIHNvIHRoZSB2b2ljZSBkcmF3aW5nIGJlbG93IGNhbiBqdXN0IHVzZSBpZi5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnN0YWZmcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBzdGFmZjEgPSB0aGlzLnN0YWZmc1tqXTtcblx0XHQvL3JlbmRlcmVyLnByaW50SG9yaXpvbnRhbExpbmUoNTAsIHJlbmRlcmVyLnksIFwic3RhcnRcIik7XG5cdFx0cmVuZGVyZXIubW92ZVkoc3BhY2luZy5TVEVQLCBzdGFmZjEudG9wKTtcblx0XHRzdGFmZjEuYWJzb2x1dGVZID0gcmVuZGVyZXIueTtcblx0XHRpZiAoLypBQkNKUy53cml0ZS5kZWJ1Z1BsYWNlbWVudCovZmFsc2UpIHtcblx0XHRcdGNvbG9ySW5kZXggPSAwO1xuXHRcdFx0cmVuZGVyZXIucHJpbnRTaGFkZWRCb3gocmVuZGVyZXIucGFkZGluZy5sZWZ0LCByZW5kZXJlci5jYWxjWShzdGFmZjEub3JpZ2luYWxUb3ApLCByZW5kZXJlci5jb250cm9sbGVyLndpZHRoLCByZW5kZXJlci5jYWxjWShzdGFmZjEub3JpZ2luYWxCb3R0b20pLXJlbmRlcmVyLmNhbGNZKHN0YWZmMS5vcmlnaW5hbFRvcCksIFwiIzAwMDAwMFwiLCAwLjEpO1xuXHRcdFx0ZGVidWdQcmludChzdGFmZjEsICdjaG9yZEhlaWdodEFib3ZlJyk7XG5cdFx0XHRkZWJ1Z1ByaW50KHN0YWZmMSwgJ2Nob3JkSGVpZ2h0QmVsb3cnKTtcblx0XHRcdGRlYnVnUHJpbnQoc3RhZmYxLCAnZHluYW1pY0hlaWdodEFib3ZlJyk7XG5cdFx0XHRkZWJ1Z1ByaW50KHN0YWZmMSwgJ2R5bmFtaWNIZWlnaHRCZWxvdycpO1xuXHRcdFx0ZGVidWdQcmludChzdGFmZjEsICdlbmRpbmdIZWlnaHRBYm92ZScpO1xuXHRcdFx0ZGVidWdQcmludChzdGFmZjEsICdseXJpY0hlaWdodEFib3ZlJyk7XG5cdFx0XHRkZWJ1Z1ByaW50KHN0YWZmMSwgJ2x5cmljSGVpZ2h0QmVsb3cnKTtcblx0XHRcdGRlYnVnUHJpbnQoc3RhZmYxLCAncGFydEhlaWdodEFib3ZlJyk7XG5cdFx0XHRkZWJ1Z1ByaW50KHN0YWZmMSwgJ3RlbXBvSGVpZ2h0QWJvdmUnKTtcblx0XHRcdGRlYnVnUHJpbnQoc3RhZmYxLCAndm9sdW1lSGVpZ2h0QWJvdmUnKTtcblx0XHRcdGRlYnVnUHJpbnQoc3RhZmYxLCAndm9sdW1lSGVpZ2h0QmVsb3cnKTtcblx0XHR9XG5cdFx0aWYgKHN0YWZmMS5ib3R0b20gPCAwKVxuXHRcdFx0cmVuZGVyZXIubW92ZVkoc3BhY2luZy5TVEVQLCAtc3RhZmYxLmJvdHRvbSk7XG5cdH1cblx0dmFyIHRvcExpbmU7IC8vIHRoZXNlIGFyZSB0byBjb25uZWN0IG11bHRpcGxlIHN0YXZlcy4gV2UgbmVlZCB0byByZW1lbWJlciB3aGVyZSB0aGV5IGFyZS5cblx0dmFyIGJvdHRvbUxpbmU7XG5cblx0dmFyIGJhcnRvcCA9IDA7XG5cdHJlbmRlcmVyLm1lYXN1cmVOdW1iZXIgPSBudWxsO1xuXHRyZW5kZXJlci5ub3RlTnVtYmVyID0gbnVsbDtcblx0Zm9yICh2YXIgaT0wO2k8dGhpcy52b2ljZXMubGVuZ3RoO2krKykge1xuXHRcdHZhciBzdGFmZiA9IHRoaXMudm9pY2VzW2ldLnN0YWZmO1xuXHRcdHJlbmRlcmVyLnkgPSBzdGFmZi5hYnNvbHV0ZVk7XG5cdFx0cmVuZGVyZXIudm9pY2VOdW1iZXIgPSBpO1xuXHRcdC8vcmVuZGVyZXIueSA9IHN0YWZmLnk7XG5cdFx0Ly8gb2Zmc2V0IGZvciBzdGFydGluZyB0aGUgY291bnRpbmcgYXQgbWlkZGxlIENcblx0XHRpZiAoIXRoaXMudm9pY2VzW2ldLmR1cGxpY2F0ZSkge1xuLy9cdFx0XHRyZW5kZXJlci5tb3ZlWShzcGFjaW5nLlNURVAsIHN0YWZmLnRvcCk7XG5cdFx0XHRpZiAoIXRvcExpbmUpIHRvcExpbmUgID0gcmVuZGVyZXIuY2FsY1koMTApO1xuXHRcdFx0Ym90dG9tTGluZSAgPSByZW5kZXJlci5jYWxjWSgyKTtcblx0XHRcdGlmIChzdGFmZi5saW5lcyAhPT0gMCkge1xuXHRcdFx0XHRyZW5kZXJlci5tZWFzdXJlTnVtYmVyID0gbnVsbDtcblx0XHRcdFx0cmVuZGVyZXIubm90ZU51bWJlciA9IG51bGw7XG5cdFx0XHRcdHJlbmRlcmVyLnByaW50U3RhdmUodGhpcy5zdGFydHgsIHRoaXMudywgc3RhZmYubGluZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnZvaWNlc1tpXS5kcmF3KHJlbmRlcmVyLCBiYXJ0b3ApO1xuXHRcdHJlbmRlcmVyLm1lYXN1cmVOdW1iZXIgPSBudWxsO1xuXHRcdHJlbmRlcmVyLm5vdGVOdW1iZXIgPSBudWxsO1xuXHRcdGlmICghdGhpcy52b2ljZXNbaV0uZHVwbGljYXRlKSB7XG5cdFx0XHRiYXJ0b3AgPSByZW5kZXJlci5jYWxjWSgyKTsgLy8gVGhpcyBjb25uZWN0cyB0aGUgYmFyIGxpbmVzIGJldHdlZW4gdHdvIGRpZmZlcmVudCBzdGF2ZXMuXG4vL1x0XHRcdGlmIChzdGFmZi5ib3R0b20gPCAwKVxuLy9cdFx0XHRcdHJlbmRlcmVyLm1vdmVZKHNwYWNpbmcuU1RFUCwgLXN0YWZmLmJvdHRvbSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuYnJhY2UpIHsvL1Rvbnlcblx0XHRcdGlmIChpID09PSB0aGlzLmJyYWNlLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0aWYgKHRoaXMuYnJhY2UpIHtcblx0XHRcdFx0XHR0aGlzLmJyYWNlLmRyYXcocmVuZGVyZXIsIHRvcExpbmUsIGJvdHRvbUxpbmUpOyAvL3Rvbnlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZW5kZXJlci5tZWFzdXJlTnVtYmVyID0gbnVsbDtcblx0cmVuZGVyZXIubm90ZU51bWJlciA9IG51bGw7XG5cblx0Ly8gY29ubmVjdCBhbGwgdGhlIHN0YXZlcyB0b2dldGhlciB3aXRoIGEgdmVydGljYWwgbGluZVxuXHRpZiAodGhpcy5zdGFmZnMubGVuZ3RoPjEpIHtcblx0XHRyZW5kZXJlci5wcmludFN0ZW0odGhpcy5zdGFydHgsIDAuNiwgdG9wTGluZSwgYm90dG9tTGluZSk7XG5cdH1cblx0cmVuZGVyZXIueSA9IHN0YXJ0WTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhZmZHcm91cEVsZW1lbnQ7XG4iLCIvLyAgICBhYmNfdGVtcG9fZWxlbWVudC5qczogRGVmaW5pdGlvbiBvZiB0aGUgVGVtcG9FbGVtZW50IGNsYXNzLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDE0LTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSBhbmQgUGF1bCBSb3NlblxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQWJzb2x1dGVFbGVtZW50ID0gcmVxdWlyZSgnLi9hYmNfYWJzb2x1dGVfZWxlbWVudCcpO1xudmFyIFJlbGF0aXZlRWxlbWVudCA9IHJlcXVpcmUoJy4vYWJjX3JlbGF0aXZlX2VsZW1lbnQnKTtcblxudmFyIFRlbXBvRWxlbWVudDtcbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciB0b3RhbEhlaWdodEluUGl0Y2hlcyA9IDU7XG5cblx0VGVtcG9FbGVtZW50ID0gZnVuY3Rpb24gVGVtcG9FbGVtZW50KHRlbXBvLCB0dW5lTnVtYmVyLCBjcmVhdGVOb3RlSGVhZCkge1xuXHRcdHRoaXMudGVtcG8gPSB0ZW1wbztcblx0XHR0aGlzLnR1bmVOdW1iZXIgPSB0dW5lTnVtYmVyO1xuXHRcdHRoaXMudGVtcG9IZWlnaHRBYm92ZSA9IHRvdGFsSGVpZ2h0SW5QaXRjaGVzO1xuXHRcdHRoaXMucGl0Y2ggPSB1bmRlZmluZWQ7IC8vIFRoaXMgd2lsbCBiZSBzZXQgbGF0ZXJcblx0XHRpZiAodGhpcy50ZW1wby5kdXJhdGlvbiAmJiAhdGhpcy50ZW1wby5zdXBwcmVzc0JwbSkge1xuXHRcdFx0dGhpcy5ub3RlID0gdGhpcy5jcmVhdGVOb3RlKGNyZWF0ZU5vdGVIZWFkLCB0ZW1wbywgdHVuZU51bWJlcik7XG5cdFx0fVxuXHR9O1xuXG5cdFRlbXBvRWxlbWVudC5wcm90b3R5cGUuc2V0VXBwZXJBbmRMb3dlckVsZW1lbnRzID0gZnVuY3Rpb24ocG9zaXRpb25ZKSB7IC8vIFRPRE8tUEVSOiBUaGlzIG1pZ2h0IG5vdCBiZSBjYWxsZWQuXG5cdFx0dGhpcy5waXRjaCA9IHBvc2l0aW9uWS50ZW1wb0hlaWdodEFib3ZlO1xuXHRcdHRoaXMudG9wID0gcG9zaXRpb25ZLnRlbXBvSGVpZ2h0QWJvdmU7XG5cdFx0dGhpcy5ib3R0b20gPSBwb3NpdGlvblkudGVtcG9IZWlnaHRBYm92ZTtcblx0XHRpZiAodGhpcy5ub3RlKSB7XG5cdFx0XHR2YXIgdGVtcG9QaXRjaCA9IHRoaXMucGl0Y2ggLSB0b3RhbEhlaWdodEluUGl0Y2hlcyArIDE7IC8vIFRoZSBwaXRjaCB3ZSByZWNlaXZlIGlzIHRoZSB0b3Agb2YgdGhlIGFsbG90dGVkIGFyZWE6IGNoYW5nZSB0aGF0IHRvIHByYWN0aWNhbGx5IHRoZSBib3R0b20uXG5cdFx0XHR0aGlzLm5vdGUudG9wID0gdGVtcG9QaXRjaDtcblx0XHRcdHRoaXMubm90ZS5ib3R0b20gPSB0ZW1wb1BpdGNoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vdGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5ub3RlLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRjaGlsZC50b3AgKz0gdGVtcG9QaXRjaDtcblx0XHRcdFx0Y2hpbGQuYm90dG9tICs9IHRlbXBvUGl0Y2g7XG5cdFx0XHRcdGNoaWxkLnBpdGNoICs9IHRlbXBvUGl0Y2g7XG5cdFx0XHRcdGlmIChjaGlsZC5waXRjaDIgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRjaGlsZC5waXRjaDIgKz0gdGVtcG9QaXRjaDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0VGVtcG9FbGVtZW50LnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcblx0XHR0aGlzLnggPSB4O1xuXHR9O1xuXG5cdFRlbXBvRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlTm90ZSA9IGZ1bmN0aW9uKGNyZWF0ZU5vdGVIZWFkLCB0ZW1wbywgdHVuZU51bWJlcikge1xuXHRcdHZhciB0ZW1wb3NjYWxlID0gMC43NTtcblx0XHR2YXIgZHVyYXRpb24gPSB0ZW1wby5kdXJhdGlvblswXTsgLy8gVE9ETyB3aGVuIG11bHRpcGxlIGR1cmF0aW9uc1xuXHRcdHZhciBhYnNFbGVtID0gbmV3IEFic29sdXRlRWxlbWVudCh0ZW1wbywgZHVyYXRpb24sIDEsICd0ZW1wbycsIHR1bmVOdW1iZXIpO1xuXHRcdC8vIFRoZXJlIGFyZW4ndCBhbiBpbmZpbml0ZSBudW1iZXIgb2Ygbm90ZSB2YWx1ZXMsIGJ1dCB3ZSBhcmUgcGFzc2VkIGEgZmxvYXQsIHNvIGp1c3QgaW4gY2FzZSBzb21ldGhpbmcgaXMgb2ZmIHVwc3RyZWFtLFxuXHRcdC8vIG1lcmdlIGFsbCBvZiB0aGUgaW4gYmV0d2VlbiBwb2ludHMuXG5cdFx0dmFyIGRvdDtcblx0XHR2YXIgZmxhZztcblx0XHR2YXIgbm90ZTtcblx0XHRpZiAoZHVyYXRpb24gPD0gMS8zMikgeyBub3RlID0gXCJub3RlaGVhZHMucXVhcnRlclwiOyBmbGFnID0gXCJmbGFncy51MzJuZFwiOyBkb3QgPSAwOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMS8xNikgeyBub3RlID0gXCJub3RlaGVhZHMucXVhcnRlclwiOyBmbGFnID0gXCJmbGFncy51MTZ0aFwiOyBkb3QgPSAwOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMy8zMikgeyBub3RlID0gXCJub3RlaGVhZHMucXVhcnRlclwiOyBmbGFnID0gXCJmbGFncy51MTZuZFwiOyBkb3QgPSAxOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMS84KSB7IG5vdGUgPSBcIm5vdGVoZWFkcy5xdWFydGVyXCI7IGZsYWcgPSBcImZsYWdzLnU4dGhcIjsgZG90ID0gMDsgfVxuXHRcdGVsc2UgaWYgKGR1cmF0aW9uIDw9IDMvMTYpIHsgbm90ZSA9IFwibm90ZWhlYWRzLnF1YXJ0ZXJcIjsgZmxhZyA9IFwiZmxhZ3MudTh0aFwiOyBkb3QgPSAxOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMS80KSB7IG5vdGUgPSBcIm5vdGVoZWFkcy5xdWFydGVyXCI7IGRvdCA9IDA7IH1cblx0XHRlbHNlIGlmIChkdXJhdGlvbiA8PSAzLzgpIHsgbm90ZSA9IFwibm90ZWhlYWRzLnF1YXJ0ZXJcIjsgZG90ID0gMTsgfVxuXHRcdGVsc2UgaWYgKGR1cmF0aW9uIDw9IDEvMikgeyBub3RlID0gXCJub3RlaGVhZHMuaGFsZlwiOyBkb3QgPSAwOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMy80KSB7IG5vdGUgPSBcIm5vdGVoZWFkcy5oYWxmXCI7IGRvdCA9IDE7IH1cblx0XHRlbHNlIGlmIChkdXJhdGlvbiA8PSAxKSB7IG5vdGUgPSBcIm5vdGVoZWFkcy53aG9sZVwiOyBkb3QgPSAwOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMS41KSB7IG5vdGUgPSBcIm5vdGVoZWFkcy53aG9sZVwiOyBkb3QgPSAxOyB9XG5cdFx0ZWxzZSBpZiAoZHVyYXRpb24gPD0gMikgeyBub3RlID0gXCJub3RlaGVhZHMuZGJsXCI7IGRvdCA9IDA7IH1cblx0XHRlbHNlIHsgbm90ZSA9IFwibm90ZWhlYWRzLmRibFwiOyBkb3QgPSAxOyB9XG5cblx0XHR2YXIgcmV0ID0gY3JlYXRlTm90ZUhlYWQoYWJzRWxlbSxcblx0XHRcdG5vdGUsXG5cdFx0XHR7IHZlcnRpY2FsUG9zOiAwfSwgLy8gVGhpcyBpcyBqdXN0IHRlbXBvcmFyeTogd2UnbGwgb2Zmc2V0IHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZyB3aGVuIHdlIGdldCB0aGUgYWN0dWFsIHZlcnRpY2FsIHNwb3QuXG5cdFx0XHRcInVwXCIsXG5cdFx0XHQwLFxuXHRcdFx0MCxcblx0XHRcdGZsYWcsXG5cdFx0XHRkb3QsXG5cdFx0XHQwLFxuXHRcdFx0dGVtcG9zY2FsZSxcblx0XHRcdFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXHRcdHZhciB0ZW1wb05vdGUgPSByZXQubm90ZWhlYWQ7XG5cdFx0YWJzRWxlbS5hZGRIZWFkKHRlbXBvTm90ZSk7XG5cdFx0dmFyIHN0ZW07XG5cdFx0aWYgKG5vdGUgIT09IFwibm90ZWhlYWRzLndob2xlXCIgJiYgbm90ZSAhPT0gXCJub3RlaGVhZHMuZGJsXCIpIHtcblx0XHRcdHZhciBwMSA9IDEgLyAzICogdGVtcG9zY2FsZTtcblx0XHRcdHZhciBwMiA9IDcgKiB0ZW1wb3NjYWxlO1xuXHRcdFx0dmFyIGR4ID0gdGVtcG9Ob3RlLmR4ICsgdGVtcG9Ob3RlLnc7XG5cdFx0XHR2YXIgd2lkdGggPSAtMC42O1xuXHRcdFx0c3RlbSA9IG5ldyBSZWxhdGl2ZUVsZW1lbnQobnVsbCwgZHgsIDAsIHAxLCB7XCJ0eXBlXCI6IFwic3RlbVwiLCBcInBpdGNoMlwiOiBwMiwgbGluZXdpZHRoOiB3aWR0aH0pO1xuXHRcdFx0YWJzRWxlbS5hZGRFeHRyYShzdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFic0VsZW07XG5cdH07XG5cblx0VGVtcG9FbGVtZW50LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcblx0XHR2YXIgeCA9IHRoaXMueDtcblx0XHRpZiAodGhpcy5waXRjaCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0d2luZG93LmNvbnNvbGUuZXJyb3IoXCJUZW1wbyBFbGVtZW50IHktY29vcmRpbmF0ZSBub3Qgc2V0LlwiKTtcblxuXHRcdHZhciB5ID0gcmVuZGVyZXIuY2FsY1kodGhpcy5waXRjaCk7XG5cdFx0dmFyIHRleHQ7XG5cdFx0aWYgKHRoaXMudGVtcG8ucHJlU3RyaW5nKSB7XG5cdFx0XHR0ZXh0ID0gcmVuZGVyZXIucmVuZGVyVGV4dCh4LCB5LCB0aGlzLnRlbXBvLnByZVN0cmluZywgJ3RlbXBvZm9udCcsICd0ZW1wbycsIFwic3RhcnRcIik7XG5cdFx0XHR2YXIgc2l6ZSA9IHJlbmRlcmVyLmdldFRleHRTaXplKHRoaXMudGVtcG8ucHJlU3RyaW5nLCAndGVtcG9mb250JywgJ3RlbXBvJywgdGV4dCk7XG5cdFx0XHR2YXIgcHJlV2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0dmFyIGNoYXJXaWR0aCA9IHByZVdpZHRoIC8gdGhpcy50ZW1wby5wcmVTdHJpbmcubGVuZ3RoOyAvLyBKdXN0IGdldCBzb21lIGF2ZXJhZ2UgbnVtYmVyIHRvIGluY3JlYXNlIHRoZSBzcGFjaW5nLlxuXHRcdFx0eCArPSBwcmVXaWR0aCArIGNoYXJXaWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMubm90ZSkge1xuXHRcdFx0aWYgKHRoaXMubm90ZSlcblx0XHRcdFx0dGhpcy5ub3RlLnNldFgoeCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm90ZS5jaGlsZHJlbi5sZW5ndGg7IGkrKylcblx0XHRcdFx0dGhpcy5ub3RlLmNoaWxkcmVuW2ldLmRyYXcocmVuZGVyZXIsIHgpO1xuXHRcdFx0eCArPSAodGhpcy5ub3RlLncgKyA1KTtcblx0XHRcdHZhciBzdHIgPSBcIj0gXCIgKyB0aGlzLnRlbXBvLmJwbTtcblx0XHRcdHRleHQgPSByZW5kZXJlci5yZW5kZXJUZXh0KHgsIHksIHN0ciwgJ3RlbXBvZm9udCcsICd0ZW1wbycsIFwic3RhcnRcIik7XG5cdFx0XHRzaXplID0gcmVuZGVyZXIuZ2V0VGV4dFNpemUoc3RyLCAndGVtcG9mb250JywgJ3RlbXBvJywgdGV4dCk7XG5cdFx0XHR2YXIgcG9zdFdpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdHZhciBjaGFyV2lkdGgyID0gcG9zdFdpZHRoIC8gc3RyLmxlbmd0aDsgLy8gSnVzdCBnZXQgc29tZSBhdmVyYWdlIG51bWJlciB0byBpbmNyZWFzZSB0aGUgc3BhY2luZy5cblx0XHRcdHggKz0gcG9zdFdpZHRoICsgY2hhcldpZHRoMjtcblx0XHR9XG5cdFx0aWYgKHRoaXMudGVtcG8ucG9zdFN0cmluZykge1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyVGV4dCh4LCB5LCB0aGlzLnRlbXBvLnBvc3RTdHJpbmcsICd0ZW1wb2ZvbnQnLCAndGVtcG8nLCBcInN0YXJ0XCIpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGVtcG9FbGVtZW50O1xuIiwiLy8gICAgYWJjX3RpZV9lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBUaWVFbGVtZW50IGNsYXNzLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSBhbmQgUGF1bCBSb3NlblxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vICAgIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgVGllRWxlbSA9IGZ1bmN0aW9uIFRpZUVsZW0ob3B0aW9ucykge1xuLy9cdGNvbnNvbGUubG9nKFwiY29uc3RydWN0b3JcIiwgb3B0aW9ucy5hbmNob3IxID8gb3B0aW9ucy5hbmNob3IxLnBpdGNoIDogXCJOL0FcIiwgb3B0aW9ucy5hbmNob3IyID8gb3B0aW9ucy5hbmNob3IyLnBpdGNoIDogXCJOL0FcIiwgb3B0aW9ucy5pc1RpZSwgb3B0aW9ucy5pc0dyYWNlKTtcblx0dGhpcy5hbmNob3IxID0gb3B0aW9ucy5hbmNob3IxOyAvLyBtdXN0IGhhdmUgYSAueCBhbmQgYSAucGl0Y2gsIGFuZCBhIC5wYXJlbnQgcHJvcGVydHkgb3IgYmUgbnVsbCAobWVhbnMgc3RhcnRzIGF0IHRoZSBcImJlZ2lubmluZ1wiIG9mIHRoZSBsaW5lIC0gYWZ0ZXIga2V5c2lnKVxuXHR0aGlzLmFuY2hvcjIgPSBvcHRpb25zLmFuY2hvcjI7IC8vIG11c3QgaGF2ZSBhIC54IGFuZCBhIC5waXRjaCBwcm9wZXJ0eSBvciBiZSBudWxsIChtZWFucyBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUpXG5cdGlmIChvcHRpb25zLmlzR3JhY2UpXG5cdFx0dGhpcy5pc0dyYWNlID0gdHJ1ZTtcblx0aWYgKG9wdGlvbnMuZml4ZWRZKVxuXHRcdHRoaXMuZml4ZWRZID0gdHJ1ZTtcblx0aWYgKG9wdGlvbnMuc3RlbURpcilcblx0XHR0aGlzLnN0ZW1EaXIgPSBvcHRpb25zLnN0ZW1EaXI7XG5cdGlmIChvcHRpb25zLnZvaWNlTnVtYmVyICE9PSB1bmRlZmluZWQpXG5cdFx0dGhpcy52b2ljZU51bWJlciA9IG9wdGlvbnMudm9pY2VOdW1iZXI7XG5cdHRoaXMuaW50ZXJuYWxOb3RlcyA9IFtdO1xufTtcblxuVGllRWxlbS5wcm90b3R5cGUuYWRkSW50ZXJuYWxOb3RlID0gZnVuY3Rpb24obm90ZSkge1xuXHR0aGlzLmludGVybmFsTm90ZXMucHVzaChub3RlKTtcbn07XG5cblRpZUVsZW0ucHJvdG90eXBlLnNldEVuZEFuY2hvciA9IGZ1bmN0aW9uKGFuY2hvcjIpIHtcbi8vXHRjb25zb2xlLmxvZyhcImVuZFwiLCB0aGlzLmFuY2hvcjEgPyB0aGlzLmFuY2hvcjEucGl0Y2ggOiBcIk4vQVwiLCBhbmNob3IyID8gYW5jaG9yMi5waXRjaCA6IFwiTi9BXCIsIHRoaXMuaXNUaWUsIHRoaXMuaXNHcmFjZSk7XG5cdHRoaXMuYW5jaG9yMiA9IGFuY2hvcjI7IC8vIG11c3QgaGF2ZSBhIC54IGFuZCBhIC5waXRjaCBwcm9wZXJ0eSBvciBiZSBudWxsIChtZWFucyBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUpXG59O1xuXG4vLyBJZiB3ZSBlbmNvdW50ZXIgYSByZXBlYXQgc2lnbiwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIGV4dGVuZCBlaXRoZXIgYSB0aWUgb3IgYSBzbHVyIHBhc3QgaXQsIHNvIHRoZXNlIGFyZSBjYWxsZWQgdG8gYmUgYSBsaW1pdC5cblRpZUVsZW0ucHJvdG90eXBlLnNldFN0YXJ0WCA9IGZ1bmN0aW9uKHN0YXJ0TGltaXRFbGVtKSB7XG5cdHRoaXMuc3RhcnRMaW1pdFggPSBzdGFydExpbWl0RWxlbTtcbn07XG5cblRpZUVsZW0ucHJvdG90eXBlLnNldEVuZFggPSBmdW5jdGlvbihlbmRMaW1pdEVsZW0pIHtcblx0dGhpcy5lbmRMaW1pdFggPSBlbmRMaW1pdEVsZW07XG59O1xuXG5UaWVFbGVtLnByb3RvdHlwZS5zZXRIaW50ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmhpbnQgPSB0cnVlO1xufTtcblxuVGllRWxlbS5wcm90b3R5cGUuc2V0VXBwZXJBbmRMb3dlckVsZW1lbnRzID0gZnVuY3Rpb24ocG9zaXRpb25ZKSB7XG5cdC8vIERvZXNuJ3QgZGVwZW5kIG9uIHRoZSBoaWdoZXN0IGFuZCBsb3dlc3QsIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBkbyBoZXJlLlxufTtcblxuVGllRWxlbS5wcm90b3R5cGUuY2FsY1RpZURpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gVGhlIHJ1bGVzOlxuXHQvLyAxKSBJZiBpdCBpcyBpbiBhIGdyYWNlIG5vdGUgZ3JvdXAsIHRoZW4gdGhlIGRpcmVjdGlvbiBpcyBhbHdheXMgQkVMT1cuXG5cdC8vIDIpIElmIGl0IGlzIGluIGEgc2luZ2xlIHZvaWNlLCB0aGVuIHRoZSBkaXJlY3Rpb24gaXMgYWx3YXlzIE9QUE9TSVRFIG9mIHRoZSBzdGVtIChvciB3aGVyZSB0aGUgc3RlbSB3b3VsZCBoYXZlIGJlZW4gaW4gdGhlIGNhc2Ugb2Ygd2hvbGUgbm90ZXMuKVxuXHQvLyAzKSBJZiB0aGUgc3RlbSBkaXJlY3Rpb24gaXMgZm9yY2VkIChwcm9iYWJseSBiZWNhdXNlIHRoZXJlIGFyZSB0d28gdm9pY2VzIG9uIHRoZSBzYW1lIGxpbmUpLCB0aGVuIHRoZSBkaXJlY3Rpb24gaXMgdGhlIFNBTUUgYXMgdGhlIHN0ZW0gZGlyZWN0aW9uLlxuXG5cdGlmICh0aGlzLmlzR3JhY2UpXG5cdFx0dGhpcy5hYm92ZSA9IGZhbHNlO1xuXHRlbHNlIGlmICh0aGlzLnZvaWNlTnVtYmVyID09PSAwKVxuXHRcdHRoaXMuYWJvdmUgPSB0cnVlO1xuXHRlbHNlIGlmICh0aGlzLnZvaWNlTnVtYmVyID4gMClcblx0XHR0aGlzLmFib3ZlID0gZmFsc2U7XG5cdGVsc2Uge1xuXHRcdHZhciByZWZlcmVuY2VQaXRjaDtcblx0XHRpZiAodGhpcy5hbmNob3IxKVxuXHRcdFx0cmVmZXJlbmNlUGl0Y2ggPSB0aGlzLmFuY2hvcjEucGl0Y2g7XG5cdFx0ZWxzZSBpZiAodGhpcy5hbmNob3IyKVxuXHRcdFx0cmVmZXJlbmNlUGl0Y2ggPSB0aGlzLmFuY2hvcjIucGl0Y2g7XG5cdFx0ZWxzZVxuXHRcdFx0cmVmZXJlbmNlUGl0Y2ggPSAxNDsgLy8gVE9ETy1QRVI6IHRoaXMgY2FuJ3QgcmVhbGx5IGhhcHBlbiBub3JtYWxseS4gVGhpcyB3b3VsZCBpbXBseSB0aGF0IGEgdGllIGNyb3NzZWQgb3ZlciB0aHJlZSBsaW5lcywgc29tZXRoaW5nIGxpa2UgXCJDLVxcbnpcXG5DXCJcblx0XHQvLyBQdXQgdGhlIGFyYyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtLiBUaGF0IGlzbid0IGFsd2F5cyB0aGUgcGl0Y2ggaWYgb25lIG9yIGJvdGggb2YgdGhlIG5vdGVzIGFyZSBiZWFtZWQgd2l0aCBzb21ldGhpbmcgdGhhdCBhZmZlY3RzIGl0cyBzdGVtLlxuXHRcdGlmICgodGhpcy5hbmNob3IxICYmIHRoaXMuYW5jaG9yMS5zdGVtRGlyID09PSAnZG93bicpICYmICh0aGlzLmFuY2hvcjIgJiYgdGhpcy5hbmNob3IyLnN0ZW1EaXIgPT09IFwiZG93blwiKSlcblx0XHRcdHRoaXMuYWJvdmUgPSB0cnVlO1xuXHRcdGVsc2UgaWYgKCh0aGlzLmFuY2hvcjEgJiYgdGhpcy5hbmNob3IxLnN0ZW1EaXIgPT09ICd1cCcpICYmICh0aGlzLmFuY2hvcjIgJiYgdGhpcy5hbmNob3IyLnN0ZW1EaXIgPT09IFwidXBcIikpXG5cdFx0XHR0aGlzLmFib3ZlID0gZmFsc2U7XG5cdFx0ZWxzZSBpZiAodGhpcy5hbmNob3IxICYmIHRoaXMuYW5jaG9yMilcblx0XHRcdHRoaXMuYWJvdmUgPSByZWZlcmVuY2VQaXRjaCA+PSA2O1xuXHRcdGVsc2UgaWYgKHRoaXMuYW5jaG9yMSlcblx0XHRcdHRoaXMuYWJvdmUgPSB0aGlzLmFuY2hvcjEuc3RlbURpciA9PT0gXCJkb3duXCI7XG5cdFx0ZWxzZSBpZiAodGhpcy5hbmNob3IyKVxuXHRcdFx0dGhpcy5hYm92ZSA9IHRoaXMuYW5jaG9yMi5zdGVtRGlyID09PSBcImRvd25cIjtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmFib3ZlID0gcmVmZXJlbmNlUGl0Y2ggPj0gNjtcblx0fVxufTtcblxuLy8gRnJvbSBcInN0YW5kYXJkIG11c2ljIG5vdGF0aW9uIHByYWN0aWNlXCIgYnkgTXVzaWMgUHVibGlzaGVyc+KAmSBBc3NvY2lhdGlvbjpcbi8vIDEpIFNsdXJzIGFyZSBwbGFjZWQgdW5kZXIgdGhlIG5vdGUgaGVhZHMgaWYgYWxsIHN0ZW1zIGdvIHVwLlxuLy8gMikgU2x1cnMgYXJlIHBsYWNlZCBvdmVyIHRoZSBub3RlIGhlYWRzIGlmIGFsbCBzdGVtcyBnbyBkb3duLlxuLy8gMykgSWYgdGhlcmUgYXJlIGJvdGggdXAgc3RlbXMgYW5kIGRvd24gc3RlbXMsIHByZWZlciBwbGFjaW5nIHRoZSBzbHVyIG92ZXIuXG4vLyA0KSBXaGVuIHRoZSBzdGFmZiBoYXMgb3Bwb3NpdGUgc3RlbW1lZCB2b2ljZXMsIGFsbCBzbHVycyBzaG91bGQgYmUgb24gdGhlIHN0ZW1tZWQgc2lkZS5cblxuVGllRWxlbS5wcm90b3R5cGUuY2FsY1NsdXJEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLmlzR3JhY2UpXG5cdFx0dGhpcy5hYm92ZSA9IGZhbHNlO1xuXHRlbHNlIGlmICh0aGlzLnZvaWNlTnVtYmVyID09PSAwKVxuXHRcdHRoaXMuYWJvdmUgPSB0cnVlO1xuXHRlbHNlIGlmICh0aGlzLnZvaWNlTnVtYmVyID4gMClcblx0XHR0aGlzLmFib3ZlID0gZmFsc2U7XG5cdGVsc2Uge1xuXHRcdHZhciBoYXNEb3duU3RlbSA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLmFuY2hvcjEgJiYgdGhpcy5hbmNob3IxLnN0ZW1EaXIgPT09IFwiZG93blwiKVxuXHRcdFx0aGFzRG93blN0ZW0gPSB0cnVlO1xuXHRcdGlmICh0aGlzLmFuY2hvcjIgJiYgdGhpcy5hbmNob3IyLnN0ZW1EaXIgPT09IFwiZG93blwiKVxuXHRcdFx0aGFzRG93blN0ZW0gPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnRlcm5hbE5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMuaW50ZXJuYWxOb3Rlc1tpXTtcblx0XHRcdGlmIChuLnN0ZW1EaXIgPT09IFwiZG93blwiKVxuXHRcdFx0XHRoYXNEb3duU3RlbSA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMuYWJvdmUgPSBoYXNEb3duU3RlbTtcblx0fVxufTtcblxuVGllRWxlbS5wcm90b3R5cGUuY2FsY1ggPSBmdW5jdGlvbiAobGluZVN0YXJ0WCwgbGluZUVuZFgpIHtcblx0aWYgKHRoaXMuYW5jaG9yMSkge1xuXHRcdHRoaXMuc3RhcnRYID0gdGhpcy5hbmNob3IxLng7IC8vIFRoZSBub3JtYWwgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIHN0YXJ0aW5nIGVsZW1lbnQgdG8gYXR0YWNoIHRvLlxuXHRcdGlmICh0aGlzLmFuY2hvcjEuc2NhbGV4IDwgMSkgLy8gdGhpcyBpcyBhIGdyYWNlIG5vdGUgLSBkb24ndCBvZmZzZXQgdGhlIHRpZSBhcyBtdWNoLlxuXHRcdFx0dGhpcy5zdGFydFggLT0gMztcblx0fSBlbHNlIGlmICh0aGlzLnN0YXJ0TGltaXRYKVxuXHRcdHRoaXMuc3RhcnRYID0gdGhpcy5zdGFydExpbWl0WC54K3RoaXMuc3RhcnRMaW1pdFgudzsgLy8gaWYgdGhlcmUgaXMgbm8gc3RhcnQgZWxlbWVudCwgYnV0IHRoZXJlIGlzIGEgcmVwZWF0IG1hcmsgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cblx0ZWxzZVxuXHRcdHRoaXMuc3RhcnRYID0gbGluZVN0YXJ0WDsgLy8gVGhlcmUgaXMgbm8gZWxlbWVudCBhbmQgbm8gcmVwZWF0IG1hcms6IGV4dGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLlxuXG5cdGlmICh0aGlzLmFuY2hvcjIpXG5cdFx0dGhpcy5lbmRYID0gdGhpcy5hbmNob3IyLng7IC8vIFRoZSBub3JtYWwgY2FzZSB3aGVyZSB0aGVyZSBpcyBhIHN0YXJ0aW5nIGVsZW1lbnQgdG8gYXR0YWNoIHRvLlxuXHRlbHNlIGlmICh0aGlzLmVuZExpbWl0WClcblx0XHR0aGlzLmVuZFggPSB0aGlzLmVuZExpbWl0WC54OyAvLyBpZiB0aGVyZSBpcyBubyBzdGFydCBlbGVtZW50LCBidXQgdGhlcmUgaXMgYSByZXBlYXQgbWFyayBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuXHRlbHNlXG5cdFx0dGhpcy5lbmRYID0gbGluZUVuZFg7IC8vIFRoZXJlIGlzIG5vIGVsZW1lbnQgYW5kIG5vIHJlcGVhdCBtYXJrOiBleHRlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZS5cbn07XG5cblRpZUVsZW0ucHJvdG90eXBlLmNhbGNUaWVZID0gZnVuY3Rpb24gKCkge1xuXHQvLyBJZiB0aGUgdGllIGNvbWVzIGZyb20gYW5vdGhlciBsaW5lLCB0aGVuIG9uZSBvciBib3RoIGFuY2hvcnMgd2lsbCBiZSBtaXNzaW5nLlxuXHRpZiAodGhpcy5hbmNob3IxKVxuXHRcdHRoaXMuc3RhcnRZID0gdGhpcy5hbmNob3IxLnBpdGNoO1xuXHRlbHNlIGlmICh0aGlzLmFuY2hvcjIpXG5cdFx0dGhpcy5zdGFydFkgPSB0aGlzLmFuY2hvcjIucGl0Y2g7XG5cdGVsc2Vcblx0XHR0aGlzLnN0YXJ0WSA9IHRoaXMuYWJvdmUgPyAxNCA6IDA7XG5cblx0aWYgKHRoaXMuYW5jaG9yMilcblx0XHR0aGlzLmVuZFkgPSB0aGlzLmFuY2hvcjIucGl0Y2g7XG5cdGVsc2UgaWYgKHRoaXMuYW5jaG9yMSlcblx0XHR0aGlzLmVuZFkgPSB0aGlzLmFuY2hvcjEucGl0Y2g7XG5cdGVsc2Vcblx0XHR0aGlzLmVuZFkgPSB0aGlzLmFib3ZlID8gMTQgOiAwO1xufTtcblxuLy8gRnJvbSBcInN0YW5kYXJkIG11c2ljIG5vdGF0aW9uIHByYWN0aWNlXCIgYnkgTXVzaWMgUHVibGlzaGVyc+KAmSBBc3NvY2lhdGlvbjpcbi8vIDEpIElmIHRoZSBhbmNob3Igbm90ZSBpcyBkb3duIHN0ZW0sIHRoZSBzbHVyIHBvaW50cyB0byB0aGUgbm90ZSBoZWFkLlxuLy8gMikgSWYgdGhlIGFuY2hvciBub3RlIGlzIHVwIHN0ZW0sIGFuZCB0aGUgc2x1ciBpcyBvdmVyLCB0aGVuIHBvaW50IHRvIG1pZGRsZSBvZiBzdGVtLlxuXG5UaWVFbGVtLnByb3RvdHlwZS5jYWxjU2x1clkgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLmFuY2hvcjEgJiYgdGhpcy5hbmNob3IyKSB7XG5cdFx0aWYgKHRoaXMuYWJvdmUgJiYgdGhpcy5hbmNob3IxLnN0ZW1EaXIgPT09IFwidXBcIiAmJiAhdGhpcy5maXhlZFkpIHtcblx0XHRcdHRoaXMuc3RhcnRZID0gKHRoaXMuYW5jaG9yMS5oaWdoZXN0VmVydCArIHRoaXMuYW5jaG9yMS5waXRjaCkgLyAyO1xuXHRcdFx0dGhpcy5zdGFydFggKz0gdGhpcy5hbmNob3IxLncvMjsgLy8gV2hlbiBnb2luZyB0byB0aGUgbWlkZGxlIG9mIHRoZSBzdGVtLCBidW1wIHRoZSBsaW5lIHRvIHRoZSByaWdodCBhIGxpdHRsZSBiaXQgdG8gbWFrZSBpdCBsb29rIHJpZ2h0LlxuXHRcdH0gZWxzZVxuXHRcdFx0dGhpcy5zdGFydFkgPSB0aGlzLmFuY2hvcjEucGl0Y2g7XG5cblx0XHQvLyBJZiB0aGUgY2xvc2luZyBub3RlIGhhcyBhbiB1cCBzdGVtLCBhbmQgaXQgaXMgYmVhbWVkLCBhbmQgaXQgaXNuJ3QgdGhlIGZpcnN0IG5vdGUgaW4gdGhlIGJlYW0sIHRoZW4gdGhlIGJlYW0gd2lsbCBnZXQgaW4gdGhlIHdheS5cblx0XHR2YXIgYmVhbUludGVyZmVyZXMgPSB0aGlzLmFuY2hvcjIucGFyZW50LmJlYW0gJiYgdGhpcy5hbmNob3IyLnBhcmVudC5iZWFtLnN0ZW1zVXAgJiYgdGhpcy5hbmNob3IyLnBhcmVudC5iZWFtLmVsZW1zWzBdICE9PSB0aGlzLmFuY2hvcjIucGFyZW50O1xuXHRcdHZhciBtaWRQb2ludCA9ICh0aGlzLmFuY2hvcjIuaGlnaGVzdFZlcnQgKyB0aGlzLmFuY2hvcjIucGl0Y2gpIC8gMjtcblx0XHRpZiAodGhpcy5hYm92ZSAmJiB0aGlzLmFuY2hvcjIuc3RlbURpciA9PT0gXCJ1cFwiICYmICF0aGlzLmZpeGVkWSAmJiAhYmVhbUludGVyZmVyZXMgJiYgKG1pZFBvaW50IDwgdGhpcy5zdGFydFkpKSB7XG5cdFx0XHR0aGlzLmVuZFkgPSBtaWRQb2ludDtcblx0XHRcdHRoaXMuZW5kWCArPSB0aGlzLmFuY2hvcjIudy8yOyAvLyBXaGVuIGdvaW5nIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHN0ZW0sIGJ1bXAgdGhlIGxpbmUgdG8gdGhlIHJpZ2h0IGEgbGl0dGxlIGJpdCB0byBtYWtlIGl0IGxvb2sgcmlnaHQuXG5cdFx0fSBlbHNlXG5cdFx0XHR0aGlzLmVuZFkgPSB0aGlzLmFib3ZlICYmIGJlYW1JbnRlcmZlcmVzID8gdGhpcy5hbmNob3IyLmhpZ2hlc3RWZXJ0IDogdGhpcy5hbmNob3IyLnBpdGNoO1xuXG5cdH0gZWxzZSBpZiAodGhpcy5hbmNob3IxKSB7XG5cdFx0dGhpcy5zdGFydFkgPSB0aGlzLmVuZFkgPSB0aGlzLmFuY2hvcjEucGl0Y2g7XG5cdH0gZWxzZSBpZiAodGhpcy5hbmNob3IyKSB7XG5cdFx0dGhpcy5zdGFydFkgPSB0aGlzLmVuZFkgPSB0aGlzLmFuY2hvcjIucGl0Y2g7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB0aGUgc2x1ciBjb3ZlcnMgdGhlIGVudGlyZSBsaW5lLlxuXHRcdC8vIFRPRE8tUEVSOiBmaWd1cmUgb3V0IHdoZXJlIHRoZSByZWFsIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBsaW5lIGFyZS5cblx0XHR0aGlzLnN0YXJ0WSA9IHRoaXMuYWJvdmUgPyAxNCA6IDA7XG5cdFx0dGhpcy5lbmRZID0gdGhpcy5hYm92ZSA/IDE0IDogMDtcblx0fVxufTtcblxuVGllRWxlbS5wcm90b3R5cGUuYXZvaWRDb2xsaXNpb25BYm92ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gRG91YmxlIGNoZWNrIHRoYXQgYW4gaW50ZXJpb3Igbm90ZSBpbiB0aGUgc2x1ciBpc24ndCBzbyBoaWdoIHRoYXQgaXQgaW50ZXJmZXJlcy5cblx0aWYgKHRoaXMuYWJvdmUpIHtcblx0XHR2YXIgbWF4SW5uZXJIZWlnaHQgPSAtNTA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmludGVybmFsTm90ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmludGVybmFsTm90ZXNbaV0uaGlnaGVzdFZlcnQgPiBtYXhJbm5lckhlaWdodClcblx0XHRcdFx0bWF4SW5uZXJIZWlnaHQgPSB0aGlzLmludGVybmFsTm90ZXNbaV0uaGlnaGVzdFZlcnQ7XG5cdFx0fVxuXHRcdGlmIChtYXhJbm5lckhlaWdodCA+IHRoaXMuc3RhcnRZICYmIG1heElubmVySGVpZ2h0ID4gdGhpcy5lbmRZKVxuXHRcdFx0dGhpcy5zdGFydFkgPSB0aGlzLmVuZFkgPSBtYXhJbm5lckhlaWdodCAtIDE7XG5cdH1cbn07XG5cblRpZUVsZW0ucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIChsaW5lU3RhcnRYLCBsaW5lRW5kWCkge1xuXHQvLyBXZSBub3cgaGF2ZSBhbGwgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyBzZXQsIHNvIHdlIGNhbiBmaWd1cmUgb3V0IHRoZSBzdGFydCBhbmQgZW5kaW5nIHgseSBjb29yZGluYXRlcywgYW5kIGZpbmFsaXplIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFyYy5cblxuXHQvLyBUaWVzIGFuZCBzbHVycyBhcmUgaGFuZGxlZCBhIGxpdHRsZSBkaWZmZXJlbnRseSwgc28gZG8gY2FsY3VsYXRpb25zIGZvciB0aGVtIHNlcGFyYXRlbHkuXG5cdGlmICghdGhpcy5hbmNob3IxIHx8ICF0aGlzLmFuY2hvcjIpXG5cdFx0dGhpcy5pc1RpZSA9IHRydWU7IC8vIGlmIHRoZSBzbHVyIGdvZXMgb2ZmIHRoZSBlbmQgb2YgdGhlIGxpbmUsIHRoZW4gZHJhdyBpdCBsaWtlIGEgdGllXG5cdGVsc2UgaWYgKHRoaXMuYW5jaG9yMS5waXRjaCA9PT0gdGhpcy5hbmNob3IyLnBpdGNoICYmIHRoaXMuaW50ZXJuYWxOb3Rlcy5sZW5ndGggPT09IDApXG5cdFx0dGhpcy5pc1RpZSA9IHRydWU7XG5cdGVsc2Vcblx0XHR0aGlzLmlzVGllID0gZmFsc2U7XG5cblx0Ly8gVE9ETy1QRVI6IE5vdCBzdXJlIHdoeSB0aGlzIHdvdWxkIGJlIG5lZWRlZCwgYnV0IGl0IHdvdWxkIGJlIGJldHRlciB0byBmaWd1cmUgb3V0IGEgd2F5IHRvIGhhdmUgdGhlIGFuY2hvcnMgYmUgaW1tdXRhYmxlIGhlcmUgYW55d2F5LlxuXHQvLyBpZiAodGhpcy5pc1RpZSkge1xuXHQvLyBcdGlmICh0aGlzLmFuY2hvcjEpIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgdGllIGNvbWVzIGZyb20gdGhlIHByZXZpb3VzIGxpbmUuXG5cdC8vIFx0XHR0aGlzLmFuY2hvcjEuaXNUaWUgPSB0cnVlO1xuXHQvLyBcdGlmICh0aGlzLmFuY2hvcjIpIC8vIHRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgdGllIGRvZXMgbm90IGdvIHRvIHRoZSBuZXh0IGxpbmUuXG5cdC8vIFx0XHR0aGlzLmFuY2hvcjIuaXNUaWUgPSB0cnVlO1xuXHQvLyB9XG5cblx0aWYgKHRoaXMuaXNUaWUpIHtcblx0XHR0aGlzLmNhbGNUaWVEaXJlY3Rpb24oKTtcblx0XHQvLyBUT0RPLVBFUjogTm90IHN1cmUgd2h5IHRoaXMgd291bGQgYmUgbmVlZGVkLCBidXQgaXQgd291bGQgYmUgYmV0dGVyIHRvIGZpZ3VyZSBvdXQgYSB3YXkgdG8gaGF2ZSB0aGUgYW5jaG9ycyBiZSBpbW11dGFibGUgaGVyZSBhbnl3YXkuXG5cdFx0Ly8gaWYgKHRoaXMuYW5jaG9yMSkgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSB0aWUgY29tZXMgZnJvbSB0aGUgcHJldmlvdXMgbGluZS5cblx0XHQvLyBcdHRoaXMuYW5jaG9yMS50aWVBYm92ZSA9IHRoaXMuYWJvdmU7XG5cdFx0Ly8gaWYgKHRoaXMuYW5jaG9yMikgLy8gdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSB0aWUgZ29lcyB0byB0aGUgbmV4dCBsaW5lLlxuXHRcdC8vIFx0dGhpcy5hbmNob3IyLnRpZUFib3ZlID0gdGhpcy5hYm92ZTtcblx0XHR0aGlzLmNhbGNYKGxpbmVTdGFydFgsIGxpbmVFbmRYKTtcblx0XHR0aGlzLmNhbGNUaWVZKCk7XG5cblx0fSBlbHNlIHtcblx0XHR0aGlzLmNhbGNTbHVyRGlyZWN0aW9uKCk7XG5cdFx0dGhpcy5jYWxjWChsaW5lU3RhcnRYLCBsaW5lRW5kWCk7XG5cdFx0dGhpcy5jYWxjU2x1clkoKTtcblx0fVxuXHR0aGlzLmF2b2lkQ29sbGlzaW9uQWJvdmUoKTtcbn07XG5cblRpZUVsZW0ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGxpbmVzdGFydHgsIGxpbmVlbmR4KSB7XG5cdHRoaXMubGF5b3V0KGxpbmVzdGFydHgsIGxpbmVlbmR4KTtcblxuXHR2YXIga2xhc3M7XG5cdGlmICh0aGlzLmhpbnQpXG5cdFx0XHRrbGFzcyA9IFwiYWJjanMtaGludFwiO1xuXHR2YXIgZnVkZ2VZID0gIHRoaXMuZml4ZWRZID8gMS41IDogMDsgLy8gVE9ETy1QRVI6IFRoaXMganVzdCBjb21wZW5zYXRlcyBmb3IgZHJhd0FyYywgd2hpY2ggY29udGFpbnMgdG9vIG11Y2gga25vd2xlZGdlIG9mIHRpZXMgYW5kIHNsdXJzLlxuXHRyZW5kZXJlci5kcmF3QXJjKHRoaXMuc3RhcnRYLCB0aGlzLmVuZFgsIHRoaXMuc3RhcnRZK2Z1ZGdlWSwgdGhpcy5lbmRZK2Z1ZGdlWSwgIHRoaXMuYWJvdmUsIGtsYXNzLCB0aGlzLmlzVGllKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWVFbGVtO1xuIiwiLy8gICAgYWJjX3RyaXBsZXRfZWxlbWVudC5qczogRGVmaW5pdGlvbiBvZiB0aGUgVHJpcGxldEVsZW0gY2xhc3MuXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBHcmVnb3J5IER5a2UgKGdyZWdkeWtlIGF0IGdtYWlsIGRvdCBjb20pIGFuZCBQYXVsIFJvc2VuXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgnLi9zcHJpbnRmJyk7XG5cbnZhciBUcmlwbGV0RWxlbTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRUcmlwbGV0RWxlbSA9IGZ1bmN0aW9uIFRyaXBsZXRFbGVtKG51bWJlciwgYW5jaG9yMSwgb3B0aW9ucykge1xuXHRcdHRoaXMuYW5jaG9yMSA9IGFuY2hvcjE7IC8vIG11c3QgaGF2ZSBhIC54IGFuZCBhIC5wYXJlbnQgcHJvcGVydHkgb3IgYmUgbnVsbCAobWVhbnMgc3RhcnRzIGF0IHRoZSBcImJlZ2lubmluZ1wiIG9mIHRoZSBsaW5lIC0gYWZ0ZXIga2V5IHNpZ25hdHVyZSlcblx0XHR0aGlzLm51bWJlciA9IG51bWJlcjtcblx0XHR0aGlzLmR1cmF0aW9uID0gKCcnK2FuY2hvcjEucGFyZW50LmR1cmF0aW9uQ2xhc3MpLnJlcGxhY2UoL1xcLi8sICctJyk7XG5cdFx0dGhpcy5taWRkbGVFbGVtcyA9IFtdOyAvLyBUaGlzIGlzIHRvIGNhbGN1bGF0ZSB0aGUgaGlnaGVzdCBpbnRlcmlvciBwaXRjaC4gSXQgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZHJhd24gYnJhY2tldCBuZXZlciBjcm9zc2VzIGEgcmVhbGx5IGhpZ2ggbWlkZGxlIG5vdGUuXG5cdFx0dGhpcy5mbGF0QmVhbXMgPSBvcHRpb25zLmZsYXRCZWFtcztcblx0fTtcblxuXHRUcmlwbGV0RWxlbS5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hbmNob3IyO1xuXHR9O1xuXG5cdFRyaXBsZXRFbGVtLnByb3RvdHlwZS5taWRkbGVOb3RlID0gZnVuY3Rpb24oZWxlbSkge1xuXHRcdHRoaXMubWlkZGxlRWxlbXMucHVzaChlbGVtKTtcblx0fTtcblxuXHRUcmlwbGV0RWxlbS5wcm90b3R5cGUuc2V0Q2xvc2VBbmNob3IgPSBmdW5jdGlvbihhbmNob3IyKSB7XG5cdFx0dGhpcy5hbmNob3IyID0gYW5jaG9yMjtcblx0XHQvLyBUT0RPLVBFUjogVW5mb3J0dW5hdGVseSwgSSBkb24ndCBrbm93IGlmIHRoZXJlIGlzIGEgYmVhbSBhYm92ZSB1bnRpbCBhZnRlciB0aGUgdmVydGljYWwgcG9zaXRpb25pbmcgaXMgZG9uZSxcblx0XHQvLyBzbyBJIGRvbid0IGtub3cgd2hldGhlciB0byBsZWF2ZSByb29tIGZvciB0aGUgbnVtYmVyIGFib3ZlLiBUaGVyZWZvcmUsIElmIHRoZXJlIGlzIGEgYmVhbSBvbiB0aGUgZmlyc3Qgbm90ZSwgSSdsbCBsZWF2ZSByb29tIGp1c3QgaW4gY2FzZS5cblx0XHRpZiAodGhpcy5hbmNob3IxLnBhcmVudC5iZWFtKVxuXHRcdFx0dGhpcy5lbmRpbmdIZWlnaHRBYm92ZSA9IDQ7XG5cdH07XG5cblx0VHJpcGxldEVsZW0ucHJvdG90eXBlLnNldFVwcGVyQW5kTG93ZXJFbGVtZW50cyA9IGZ1bmN0aW9uKC8qcG9zaXRpb25ZKi8pIHtcblx0fTtcblxuXHRUcmlwbGV0RWxlbS5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETyBlbmQgYW5kIGJlZ2lubmluZyBvZiBsaW5lIChQRVI6IFAuUy4gSSdtIG5vdCBzdXJlIHRoaXMgY2FuIGhhcHBlbjogSSB0aGluayB0aGUgcGFyc2VyIHdpbGwgYWx3YXlzIHNwZWNpZnkgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMuKVxuXHRcdGlmICh0aGlzLmFuY2hvcjEgJiYgdGhpcy5hbmNob3IyKSB7XG5cdFx0XHR0aGlzLmhhc0JlYW0gPSB0aGlzLmFuY2hvcjEucGFyZW50LmJlYW0gJiYgdGhpcy5hbmNob3IxLnBhcmVudC5iZWFtID09PSB0aGlzLmFuY2hvcjIucGFyZW50LmJlYW07XG5cblx0XHRcdGlmICh0aGlzLmhhc0JlYW0pIHtcblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYSBiZWFtIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBkcmF3IGFueXRoaW5nIGV4Y2VwdCB0aGUgdGV4dC4gVGhlIGJlYW0gY291bGQgZWl0aGVyIGJlIGFib3ZlIG9yIGJlbG93LlxuXHRcdFx0XHR2YXIgYmVhbSA9IHRoaXMuYW5jaG9yMS5wYXJlbnQuYmVhbTtcblx0XHRcdFx0dmFyIGxlZnQgPSBiZWFtLmlzQWJvdmUoKSA/IHRoaXMuYW5jaG9yMS54ICsgdGhpcy5hbmNob3IxLncgOiB0aGlzLmFuY2hvcjEueDtcblx0XHRcdFx0dGhpcy55VGV4dFBvcyA9IGJlYW0uaGVpZ2h0QXRNaWRwb2ludChsZWZ0LCAgdGhpcy5hbmNob3IyLngpO1xuXHRcdFx0XHR0aGlzLnlUZXh0UG9zICs9IGJlYW0uaXNBYm92ZSgpID8gMyA6IC0yOyAvLyBUaGlzIGNyZWF0ZXMgc29tZSBzcGFjZSBiZXR3ZWVuIHRoZSBiZWFtIGFuZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHR0aGlzLnRvcCA9IHRoaXMueVRleHRQb3MgKyAxO1xuXHRcdFx0XHR0aGlzLmJvdHRvbSA9IHRoaXMueVRleHRQb3MgLSAyO1xuXHRcdFx0XHRpZiAoYmVhbS5pc0Fib3ZlKCkpXG5cdFx0XHRcdFx0dGhpcy5lbmRpbmdIZWlnaHRBYm92ZSA9IDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiB0aGVyZSBpc24ndCBhIGJlYW0sIHRoZW4gd2UgbmVlZCB0byBkcmF3IHRoZSBicmFja2V0IGFuZCB0aGUgdGV4dC4gVGhlIGJyYWNrZXQgaXMgYWx3YXlzIGFib3ZlLlxuXHRcdFx0XHQvLyBUaGUgYnJhY2tldCBpcyBuZXZlciBsb3dlciB0aGFuIHRoZSAnYScgbGluZSwgYnV0IGlzIDQgcGl0Y2hlcyBhYm92ZSB0aGUgZmlyc3QgYW5kIGxhc3Qgbm90ZXMuIElmIHRoZXJlIGlzXG5cdFx0XHRcdC8vIGEgdGFsbCBub3RlIGluIHRoZSBtaWRkbGUsIHRoZSBicmFja2V0IGlzIGhvcml6b250YWwgYW5kIGFib3ZlIHRoZSBoaWdoZXN0IG5vdGUuXG5cdFx0XHRcdHRoaXMuc3RhcnROb3RlID0gTWF0aC5tYXgodGhpcy5hbmNob3IxLnBhcmVudC50b3AsIDkpICsgNDtcblx0XHRcdFx0dGhpcy5lbmROb3RlID0gTWF0aC5tYXgodGhpcy5hbmNob3IyLnBhcmVudC50b3AsIDkpICsgNDtcblx0XHRcdFx0Ly8gSWYgaXQgc3RhcnRzIG9yIGVuZHMgb24gYSByZXN0LCBtYWtlIHRoZSBiZWFtIGhvcml6b250YWxcblx0XHRcdFx0aWYgKHRoaXMuYW5jaG9yMS5wYXJlbnQudHlwZSA9PT0gXCJyZXN0XCIgJiYgdGhpcy5hbmNob3IyLnBhcmVudC50eXBlICE9PSBcInJlc3RcIilcblx0XHRcdFx0XHR0aGlzLnN0YXJ0Tm90ZSA9IHRoaXMuZW5kTm90ZTtcblx0XHRcdFx0ZWxzZSBpZiAodGhpcy5hbmNob3IyLnBhcmVudC50eXBlID09PSBcInJlc3RcIiAmJiB0aGlzLmFuY2hvcjEucGFyZW50LnR5cGUgIT09IFwicmVzdFwiKVxuXHRcdFx0XHRcdHRoaXMuZW5kTm90ZSA9IHRoaXMuc3RhcnROb3RlO1xuXHRcdFx0XHQvLyBTZWUgaWYgdGhlIG1pZGRsZSBub3RlIGlzIHJlYWxseSBoaWdoLlxuXHRcdFx0XHR2YXIgbWF4ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1pZGRsZUVsZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aGlzLm1pZGRsZUVsZW1zW2ldLnRvcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ICs9IDQ7XG5cdFx0XHRcdGlmIChtYXggPiB0aGlzLnN0YXJ0Tm90ZSB8fCBtYXggPiB0aGlzLmVuZE5vdGUpIHtcblx0XHRcdFx0XHR0aGlzLnN0YXJ0Tm90ZSA9IG1heDtcblx0XHRcdFx0XHR0aGlzLmVuZE5vdGUgPSBtYXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuZmxhdEJlYW1zKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGFydE5vdGUgPSBNYXRoLm1heCh0aGlzLnN0YXJ0Tm90ZSwgdGhpcy5lbmROb3RlKTtcblx0XHRcdFx0XHR0aGlzLmVuZE5vdGUgPSBNYXRoLm1heCh0aGlzLnN0YXJ0Tm90ZSwgdGhpcy5lbmROb3RlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMueVRleHRQb3MgPSB0aGlzLnN0YXJ0Tm90ZSArICh0aGlzLmVuZE5vdGUgLSB0aGlzLnN0YXJ0Tm90ZSkgLyAyO1xuXHRcdFx0XHR0aGlzLnRvcCA9IHRoaXMueVRleHRQb3MgKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRkZWxldGUgdGhpcy5taWRkbGVFbGVtcztcblx0XHRkZWxldGUgdGhpcy5mbGF0QmVhbXM7XG5cdH07XG5cblx0VHJpcGxldEVsZW0ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuXHRcdHZhciB4VGV4dFBvcztcblx0XHRpZiAodGhpcy5oYXNCZWFtKSB7XG5cdFx0XHR2YXIgbGVmdCA9IHRoaXMuYW5jaG9yMS5wYXJlbnQuYmVhbS5pc0Fib3ZlKCkgPyB0aGlzLmFuY2hvcjEueCArIHRoaXMuYW5jaG9yMS53IDogdGhpcy5hbmNob3IxLng7XG5cdFx0XHR4VGV4dFBvcyA9IHRoaXMuYW5jaG9yMS5wYXJlbnQuYmVhbS54QXRNaWRwb2ludChsZWZ0LCB0aGlzLmFuY2hvcjIueCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHhUZXh0UG9zID0gdGhpcy5hbmNob3IxLnggKyAodGhpcy5hbmNob3IyLnggKyB0aGlzLmFuY2hvcjIudyAtIHRoaXMuYW5jaG9yMS54KSAvIDI7XG5cdFx0XHRkcmF3QnJhY2tldChyZW5kZXJlciwgdGhpcy5hbmNob3IxLngsIHRoaXMuc3RhcnROb3RlLCB0aGlzLmFuY2hvcjIueCArIHRoaXMuYW5jaG9yMi53LCB0aGlzLmVuZE5vdGUsIHRoaXMuZHVyYXRpb24pO1xuXHRcdH1cblx0XHRyZW5kZXJlci5yZW5kZXJUZXh0KHhUZXh0UG9zLCByZW5kZXJlci5jYWxjWSh0aGlzLnlUZXh0UG9zKSwgXCJcIiArIHRoaXMubnVtYmVyLCAndHJpcGxldGZvbnQnLCByZW5kZXJlci5hZGRDbGFzc2VzKCd0cmlwbGV0IGQnK3RoaXMuZHVyYXRpb24pLCBcIm1pZGRsZVwiLCB0cnVlKTtcblx0fTtcblxuXHRmdW5jdGlvbiBkcmF3TGluZShyZW5kZXJlciwgbCwgdCwgciwgYiwgZHVyYXRpb24pIHtcblx0XHR2YXIgcGF0aFN0cmluZyA9IHNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIixcblx0XHRcdGwsIHQsIHIsIGIpO1xuXHRcdHJlbmRlcmVyLnByaW50UGF0aCh7cGF0aDogcGF0aFN0cmluZywgc3Ryb2tlOiBcIiMwMDAwMDBcIiwgJ2NsYXNzJzogcmVuZGVyZXIuYWRkQ2xhc3NlcygndHJpcGxldCBkJytkdXJhdGlvbil9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRyYXdCcmFja2V0KHJlbmRlcmVyLCB4MSwgeTEsIHgyLCB5MiwgZHVyYXRpb24pIHtcblx0XHR5MSA9IHJlbmRlcmVyLmNhbGNZKHkxKTtcblx0XHR5MiA9IHJlbmRlcmVyLmNhbGNZKHkyKTtcblx0XHR2YXIgYnJhY2tldEhlaWdodCA9IDU7XG5cblx0XHQvLyBEcmF3IHZlcnRpY2FsIGxpbmVzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZFxuXHRcdGRyYXdMaW5lKHJlbmRlcmVyLCB4MSwgeTEsIHgxLCB5MSArIGJyYWNrZXRIZWlnaHQsIGR1cmF0aW9uKTtcblx0XHRkcmF3TGluZShyZW5kZXJlciwgeDIsIHkyLCB4MiwgeTIgKyBicmFja2V0SGVpZ2h0LCBkdXJhdGlvbik7XG5cblx0XHQvLyBmaWd1cmUgb3V0IG1pZHBvaW50cyB0byBkcmF3IHRoZSBicm9rZW4gbGluZS5cblx0XHR2YXIgbWlkWCA9IHgxICsgKHgyLXgxKS8yO1xuXHRcdC8vdmFyIG1pZFkgPSB5MSArICh5Mi15MSkvMjtcblx0XHR2YXIgZ2FwV2lkdGggPSA4O1xuXHRcdHZhciBzbG9wZSA9ICh5MiAtIHkxKSAvICh4MiAtIHgxKTtcblx0XHR2YXIgbGVmdEVuZFggPSBtaWRYIC0gZ2FwV2lkdGg7XG5cdFx0dmFyIGxlZnRFbmRZID0geTEgKyAobGVmdEVuZFggLSB4MSkgKiBzbG9wZTtcblx0XHRkcmF3TGluZShyZW5kZXJlciwgeDEsIHkxLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGR1cmF0aW9uKTtcblx0XHR2YXIgcmlnaHRTdGFydFggPSBtaWRYICsgZ2FwV2lkdGg7XG5cdFx0dmFyIHJpZ2h0U3RhcnRZID0geTEgKyAocmlnaHRTdGFydFggLSB4MSkgKiBzbG9wZTtcblx0XHRkcmF3TGluZShyZW5kZXJlciwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCB4MiwgeTIsIGR1cmF0aW9uKTtcblx0fVxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmlwbGV0RWxlbTtcbiIsIi8vICAgIGFiY192b2ljZV9lbGVtZW50LmpzOiBEZWZpbml0aW9uIG9mIHRoZSBWb2ljZUVsZW1lbnQgY2xhc3MuXG4vLyAgICBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxOCBHcmVnb3J5IER5a2UgKGdyZWdkeWtlIGF0IGdtYWlsIGRvdCBjb20pIGFuZCBQYXVsIFJvc2VuXG4vL1xuLy8gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkXG4vLyAgICBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuLy8gICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZFxuLy8gICAgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xuLy8gICAgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gICAgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwYXJzZUNvbW1vbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2FiY19jb21tb24nKTtcblxudmFyIFZvaWNlRWxlbWVudCA9IGZ1bmN0aW9uIFZvaWNlRWxlbWVudCh2b2ljZW51bWJlciwgdm9pY2V0b3RhbCkge1xuXHR0aGlzLmNoaWxkcmVuID0gW107XG5cdHRoaXMuYmVhbXMgPSBbXTtcblx0dGhpcy5vdGhlcmNoaWxkcmVuID0gW107IC8vIHRpZXMsIHNsdXJzLCB0cmlwbGV0c1xuXHR0aGlzLncgPSAwO1xuXHR0aGlzLmR1cGxpY2F0ZSA9IGZhbHNlO1xuXHR0aGlzLnZvaWNlbnVtYmVyID0gdm9pY2VudW1iZXI7IC8vbnVtYmVyIG9mIHRoZSB2b2ljZSBvbiBhIGdpdmVuIHN0YXZlIChub3Qgc3RhZmZncm91cClcblx0dGhpcy52b2ljZXRvdGFsID0gdm9pY2V0b3RhbDtcblx0dGhpcy5ib3R0b20gPSA3O1xuXHR0aGlzLnRvcCA9IDc7XG5cdHRoaXMuc3BlY2lhbFkgPSB7XG5cdFx0dGVtcG9IZWlnaHRBYm92ZTogMCxcblx0XHRwYXJ0SGVpZ2h0QWJvdmU6IDAsXG5cdFx0dm9sdW1lSGVpZ2h0QWJvdmU6IDAsXG5cdFx0ZHluYW1pY0hlaWdodEFib3ZlOiAwLFxuXHRcdGVuZGluZ0hlaWdodEFib3ZlOiAwLFxuXHRcdGNob3JkSGVpZ2h0QWJvdmU6IDAsXG5cdFx0bHlyaWNIZWlnaHRBYm92ZTogMCxcblxuXHRcdGx5cmljSGVpZ2h0QmVsb3c6IDAsXG5cdFx0Y2hvcmRIZWlnaHRCZWxvdzogMCxcblx0XHR2b2x1bWVIZWlnaHRCZWxvdzogMCxcblx0XHRkeW5hbWljSGVpZ2h0QmVsb3c6IDBcblx0fTtcbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcblx0aWYgKGNoaWxkLnR5cGUgPT09ICdiYXInKSB7XG5cdFx0dmFyIGZpcnN0SXRlbSA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGZpcnN0SXRlbSAmJiBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuY2hpbGRyZW5baV0udHlwZSAhPT0gXCJzdGFmZi1leHRyYVwiICYmIHRoaXMuY2hpbGRyZW5baV0udHlwZSAhPT0gXCJ0ZW1wb1wiKVxuXHRcdFx0XHRmaXJzdEl0ZW0gPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFmaXJzdEl0ZW0pIHtcblx0XHRcdHRoaXMuYmVhbXMucHVzaChcImJhclwiKTtcblx0XHRcdHRoaXMub3RoZXJjaGlsZHJlbi5wdXNoKFwiYmFyXCIpO1xuXHRcdH1cblx0fVxuXHR0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoXSA9IGNoaWxkO1xuXHR0aGlzLnNldFJhbmdlKGNoaWxkKTtcbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUuc2V0TGltaXQgPSBmdW5jdGlvbihtZW1iZXIsIGNoaWxkKSB7XG5cdC8vIFNvbWV0aW1lcyB3ZSBnZXQgYW4gYWJzb2x1dGUgZWxlbWVudCBpbiBoZXJlIGFuZCBzb21ldGltZXMgd2UgZ2V0IHNvbWUgdHlwZSBvZiByZWxhdGl2ZSBlbGVtZW50LlxuXHQvLyBJZiB0aGVyZSBpcyBhIFwic3BlY2lhbFlcIiBlbGVtZW50LCB0aGVuIGFzc3VtZSBpdCBpcyBhbiBhYnNvbHV0ZSBlbGVtZW50LiBJZiB0aGF0IGRvZXNuJ3QgZXhpc3QsIGxvb2sgZm9yIHRoZVxuXHQvLyBzYW1lIG1lbWJlcnMgYXQgdGhlIHRvcCBsZXZlbCwgYmVjYXVzZSB0aGF0J3Mgd2hlcmUgdGhleSBhcmUgaW4gcmVsYXRpdmUgZWxlbWVudHMuXG5cdHZhciBzcGVjaWFsWSA9IGNoaWxkLnNwZWNpYWxZO1xuXHRpZiAoIXNwZWNpYWxZKSBzcGVjaWFsWSA9IGNoaWxkO1xuXHRpZiAoIXNwZWNpYWxZW21lbWJlcl0pIHJldHVybjtcblx0aWYgKCF0aGlzLnNwZWNpYWxZW21lbWJlcl0pXG5cdFx0dGhpcy5zcGVjaWFsWVttZW1iZXJdID0gc3BlY2lhbFlbbWVtYmVyXTtcblx0ZWxzZVxuXHRcdHRoaXMuc3BlY2lhbFlbbWVtYmVyXSA9IE1hdGgubWF4KHRoaXMuc3BlY2lhbFlbbWVtYmVyXSwgc3BlY2lhbFlbbWVtYmVyXSk7XG59O1xuXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLm1vdmVEZWNvcmF0aW9ucyA9IGZ1bmN0aW9uKGJlYW0pIHtcblx0dmFyIHBhZGRpbmcgPSAxLjU7IC8vIFRoaXMgaXMgdGhlIHZlcnRpY2FsIHBhZGRpbmcgYmV0d2VlbiBlbGVtZW50cywgaW4gcGl0Y2hlcy5cblx0Zm9yICh2YXIgY2ggPSAwOyBjaCA8IGJlYW0uZWxlbXMubGVuZ3RoOyBjaCsrKSB7XG5cdFx0dmFyIGNoaWxkID0gYmVhbS5lbGVtc1tjaF07XG5cdFx0aWYgKGNoaWxkLnRvcCkge1xuXHRcdFx0Ly8gV2Ugbm93IGtub3cgd2hlcmUgdGhlIG9ybmFtZW50cyBzaG91bGQgaGF2ZSBiZWVuIHBsYWNlZCwgc28gbW92ZSB0aGVtIGlmIHRoZXkgd291bGQgb3ZlcmxhcC5cblx0XHRcdHZhciB0b3AgPSBiZWFtLnlBdE5vdGUoY2hpbGQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZWwgPSBjaGlsZC5jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGVsLmtsYXNzID09PSAnb3JuYW1lbnQnKSB7XG5cdFx0XHRcdFx0aWYgKGVsLmJvdHRvbSAtIHBhZGRpbmcgPCB0b3ApIHtcblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHRvcCAtIGVsLmJvdHRvbSArIHBhZGRpbmc7IC8vIEZpbmQgdGhlIGRpc3RhbmNlIHRoYXQgaXQgbmVlZHMgdG8gbW92ZSBhbmQgYWRkIGEgbGl0dGxlIG1hcmdpbiBzbyB0aGUgZWxlbWVudCBkb2Vzbid0IHRvdWNoIHRoZSBiZWFtLlxuXHRcdFx0XHRcdFx0ZWwuYm90dG9tICs9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdFx0ZWwudG9wICs9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdFx0ZWwucGl0Y2ggKz0gZGlzdGFuY2U7XG5cdFx0XHRcdFx0XHR0b3AgPSBjaGlsZC50b3AgPSBlbC50b3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmFkanVzdFJhbmdlID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0aWYgKGNoaWxkLmJvdHRvbSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuYm90dG9tID0gTWF0aC5taW4odGhpcy5ib3R0b20sIGNoaWxkLmJvdHRvbSk7XG5cdGlmIChjaGlsZC50b3AgIT09IHVuZGVmaW5lZClcblx0XHR0aGlzLnRvcCA9IE1hdGgubWF4KHRoaXMudG9wLCBjaGlsZC50b3ApO1xufTtcblxuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdHRoaXMuYWRqdXN0UmFuZ2UoY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCd0ZW1wb0hlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdwYXJ0SGVpZ2h0QWJvdmUnLCBjaGlsZCk7XG5cdHRoaXMuc2V0TGltaXQoJ3ZvbHVtZUhlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdkeW5hbWljSGVpZ2h0QWJvdmUnLCBjaGlsZCk7XG5cdHRoaXMuc2V0TGltaXQoJ2VuZGluZ0hlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdjaG9yZEhlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdseXJpY0hlaWdodEFib3ZlJywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdseXJpY0hlaWdodEJlbG93JywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCdjaG9yZEhlaWdodEJlbG93JywgY2hpbGQpO1xuXHR0aGlzLnNldExpbWl0KCd2b2x1bWVIZWlnaHRCZWxvdycsIGNoaWxkKTtcblx0dGhpcy5zZXRMaW1pdCgnZHluYW1pY0hlaWdodEJlbG93JywgY2hpbGQpO1xufTtcblxuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5zZXRVcHBlckFuZExvd2VyRWxlbWVudHMgPSBmdW5jdGlvbihwb3NpdGlvblkpIHtcblx0dmFyIGk7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGFic2VsZW0gPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdGFic2VsZW0uc2V0VXBwZXJBbmRMb3dlckVsZW1lbnRzKHBvc2l0aW9uWSk7XG5cdH1cblx0Zm9yIChpID0gMDsgaSA8IHRoaXMub3RoZXJjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBhYnNlbGVtID0gdGhpcy5vdGhlcmNoaWxkcmVuW2ldO1xuXHRcdGlmICh0eXBlb2YgYWJzZWxlbSAhPT0gJ3N0cmluZycpXG5cdFx0XHRhYnNlbGVtLnNldFVwcGVyQW5kTG93ZXJFbGVtZW50cyhwb3NpdGlvblkpO1xuXHR9XG59O1xuXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmFkZE90aGVyID0gZnVuY3Rpb24gKGNoaWxkKSB7XG5cdHRoaXMub3RoZXJjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0dGhpcy5zZXRSYW5nZShjaGlsZCk7XG59O1xuXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmFkZEJlYW0gPSBmdW5jdGlvbiAoY2hpbGQpIHtcblx0dGhpcy5iZWFtcy5wdXNoKGNoaWxkKTtcbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUudXBkYXRlSW5kaWNlcyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKCF0aGlzLmxheW91dEVuZGVkKCkpIHtcblx0XHR0aGlzLmR1cmF0aW9uaW5kZXggKz0gdGhpcy5jaGlsZHJlblt0aGlzLmldLmR1cmF0aW9uO1xuXHRcdGlmICh0aGlzLmNoaWxkcmVuW3RoaXMuaV0udHlwZSA9PT0gJ2JhcicpIHRoaXMuZHVyYXRpb25pbmRleCA9IE1hdGgucm91bmQodGhpcy5kdXJhdGlvbmluZGV4KjY0KS82NDsgLy8gZXZlcnl0aW1lIHdlIG1lZXQgYSBiYXJsaW5lLCBkbyByb3VuZGluZyB0byBuZWFyZXN0IDY0dGhcblx0XHR0aGlzLmkrKztcblx0fVxufTtcblxuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5sYXlvdXRFbmRlZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLmk+PXRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUuZ2V0RHVyYXRpb25JbmRleCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZHVyYXRpb25pbmRleCAtICh0aGlzLmNoaWxkcmVuW3RoaXMuaV0gJiYgKHRoaXMuY2hpbGRyZW5bdGhpcy5pXS5kdXJhdGlvbj4wKT8wOjAuMDAwMDAwNSk7IC8vIGlmIHRoZSBpdGggZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBkdXJhdGlvbiAoaXMgbm90IGEgbm90ZSksIGl0cyBkdXJhdGlvbiBpbmRleCBpcyBmcmFjdGlvbmFsbHkgYmVmb3JlLiBUaGlzIGVuYWJsZXMgQ0xFRiBLRVlTSUcgVElNRVNJRyBQQVJULCBldGMuIHRvIGJlIGxhaWQgb3V0IGJlZm9yZSB3ZSBnZXQgdG8gdGhlIGZpcnN0IG5vdGUgb2Ygb3RoZXIgdm9pY2VzXG59O1xuXG4vLyBudW1iZXIgb2Ygc3BhY2luZyB1bml0cyBleHBlY3RlZCBmb3IgbmV4dCBwb3NpdGlvbmluZ1xuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5nZXRTcGFjaW5nVW5pdHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBNYXRoLnNxcnQodGhpcy5zcGFjaW5nZHVyYXRpb24qOCk7XG5cdC8vIFRPRE8tUEVSOiBPbiBzaG9ydCBsaW5lcywgdGhpcyB3b3VsZCBuZXZlciB0cmlnZ2VyLCBzbyB0aGUgc3BhY2luZyB3YXMgd3JvbmcuIEkganVzdCBjaGFuZ2VkIHRoaXMgbGluZSBlbXBpcmljYWxseSwgdGhvdWdoLCBzbyBJIGRvbid0IGtub3cgaWYgdGhlcmUgYXJlIG90aGVyIHJhbWlmaWNhdGlvbnMuXG5cdC8vcmV0dXJuICh0aGlzLm1pbng8dGhpcy5uZXh0eCkgPyBNYXRoLnNxcnQodGhpcy5zcGFjaW5nZHVyYXRpb24qOCkgOiAwOyAvLyB3ZSBoYXZlbid0IHVzZWQgYW55IHNwYWNpbmcgdW5pdHMgaWYgd2UgZW5kIHVwIHVzaW5nIG1pbnhcbn07XG5cbi8vXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmdldE5leHRYID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gTWF0aC5tYXgodGhpcy5taW54LCB0aGlzLm5leHR4KTtcbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUuYmVnaW5MYXlvdXQgPSBmdW5jdGlvbiAoc3RhcnR4KSB7XG5cdHRoaXMuaT0wO1xuXHR0aGlzLmR1cmF0aW9uaW5kZXg9MDtcblx0Ly90aGlzLmlpPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuXHR0aGlzLnN0YXJ0eD1zdGFydHg7XG5cdHRoaXMubWlueD1zdGFydHg7IC8vIGZ1cnRoZXN0IGxlZnQgdG8gd2hlcmUgbmVnYXRpdmVseSBwb3NpdGlvbmVkIGVsZW1lbnRzIGFyZSBhbGxvd2VkIHRvIGdvXG5cdHRoaXMubmV4dHg9c3RhcnR4OyAvLyB4IHBvc2l0aW9uIHdoZXJlIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhpcyB2b2ljZSBzaG91bGQgYmUgcGxhY2VkIGFzc3VtaW5nIG5vIG90aGVyIHZvaWNlcyBhbmQgbm8gZml4ZWQgd2lkdGggY29uc3RyYWludHNcblx0dGhpcy5zcGFjaW5nZHVyYXRpb249MDsgLy8gZHVyYXRpb24gbGVmdCB0byBiZSBsYWlkIG91dCBpbiBjdXJyZW50IGl0ZXJhdGlvbiAob21pdHRpbmcgYWRkaXRpb25hbCBzcGFjaW5nIGR1ZSB0byBvdGhlciBhc3BlY3RzLCBzdWNoIGFzIGJhcnMsIGRvdHMsIHNoYXJwcyBhbmQgZmxhdHMpXG59O1xuXG4vLyBUcnkgdG8gbGF5b3V0IHRoZSBlbGVtZW50IGF0IGluZGV4IHRoaXMuaVxuLy8geCAtIHBvc2l0aW9uIHRvIHRyeSB0byBsYXlvdXQgdGhlIGVsZW1lbnQgYXRcbi8vIHNwYWNpbmcgLSBiYXNlIHNwYWNpbmdcbi8vIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBtb3JlIHRoYW4gb25jZSBwZXIgaXRlcmF0aW9uXG5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmxheW91dE9uZUl0ZW0gPSBmdW5jdGlvbiAoeCwgc3BhY2luZykge1xuXHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuaV07XG5cdGlmICghY2hpbGQpIHJldHVybiAwO1xuXHR2YXIgZXIgPSB4IC0gdGhpcy5taW54OyAvLyBhdmFpbGFibGUgZXh0cmF3aWR0aCB0byB0aGUgbGVmdFxuXHR2YXIgZXh0cmFXaWR0aCA9IGNoaWxkLmdldEV4dHJhV2lkdGgoKTtcblx0aWYgKGVyPGV4dHJhV2lkdGgpIHsgLy8gc2hpZnQgcmlnaHQgYnkgbmVlZGVkIGFtb3VudFxuXHRcdC8vIFRoZXJlJ3MgYW4gZXhjZXB0aW9uIGlmIGEgYmFyIGVsZW1lbnQgaXMgYWZ0ZXIgYSBQYXJ0IGVsZW1lbnQsIHRoZXJlIGlzIG5vIHNoaWZ0LlxuXHRcdGlmICh0aGlzLmkgPT09IDAgfHwgY2hpbGQudHlwZSAhPT0gJ2JhcicgfHwgKHRoaXMuY2hpbGRyZW5bdGhpcy5pLTFdLnR5cGUgIT09ICdwYXJ0JyAmJiB0aGlzLmNoaWxkcmVuW3RoaXMuaS0xXS50eXBlICE9PSAndGVtcG8nKSApXG5cdFx0XHR4Kz1leHRyYVdpZHRoLWVyO1xuXHR9XG5cdGNoaWxkLnNldFgoeCk7XG5cblx0dGhpcy5zcGFjaW5nZHVyYXRpb24gPSBjaGlsZC5kdXJhdGlvbjtcblx0Ly91cGRhdGUgbWlueFxuXHR0aGlzLm1pbnggPSB4K2NoaWxkLmdldE1pbldpZHRoKCk7IC8vIGFkZCBuZWNlc3NhcnkgbGF5b3V0IHNwYWNlXG5cdGlmICh0aGlzLmkhPT10aGlzLmNoaWxkcmVuLmxlbmd0aC0xKSB0aGlzLm1pbngrPWNoaWxkLm1pbnNwYWNpbmc7IC8vIGFkZCBtaW5pbXVtc3BhY2luZyBleGNlcHQgb24gbGFzdCBlbGVtXG5cblx0dGhpcy51cGRhdGVOZXh0WCh4LCBzcGFjaW5nKTtcblxuXHQvLyBjb250cmlidXRlIHRvIHN0YWZmIHkgcG9zaXRpb25cblx0Ly90aGlzLnN0YWZmLnRvcCA9IE1hdGgubWF4KGNoaWxkLnRvcCx0aGlzLnN0YWZmLnRvcCk7XG5cdC8vdGhpcy5zdGFmZi5ib3R0b20gPSBNYXRoLm1pbihjaGlsZC5ib3R0b20sdGhpcy5zdGFmZi5ib3R0b20pO1xuXG5cdHJldHVybiB4OyAvLyB3aGVyZSB3ZSBlbmQgdXAgaGF2aW5nIHBsYWNlZCB0aGUgY2hpbGRcbn07XG5cbi8vIGNhbGwgd2hlbiBzcGFjaW5nZHVyYXRpb24gaGFzIGJlZW4gdXBkYXRlZFxuVm9pY2VFbGVtZW50LnByb3RvdHlwZS51cGRhdGVOZXh0WCA9IGZ1bmN0aW9uICh4LCBzcGFjaW5nKSB7XG5cdHRoaXMubmV4dHg9IHggKyAoc3BhY2luZypNYXRoLnNxcnQodGhpcy5zcGFjaW5nZHVyYXRpb24qOCkpO1xufTtcblxuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKGR4KSB7XG5cdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5pXTtcblx0aWYgKCFjaGlsZCkgcmV0dXJuO1xuXHRjaGlsZC5zZXRYKGNoaWxkLngrZHgpO1xuXHR0aGlzLm1pbngrPWR4O1xuXHR0aGlzLm5leHR4Kz1keDtcbn07XG5cbmZ1bmN0aW9uIGlzTm9uU3BhY2VyUmVzdChlbGVtKSB7XG5cdGlmIChlbGVtLnR5cGUgIT09ICdyZXN0Jylcblx0XHRyZXR1cm4gZmFsc2U7XG5cdGlmIChlbGVtLmFiY2VsZW0gJiYgZWxlbS5hYmNlbGVtLnJlc3QgJiYgZWxlbS5hYmNlbGVtLnJlc3QudHlwZSAhPT0gJ3NwYWNlcicpXG5cdFx0cmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblZvaWNlRWxlbWVudC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChyZW5kZXJlciwgYmFydG9wKSB7XG5cdHZhciB3aWR0aCA9IHRoaXMudy0xO1xuXHRyZW5kZXJlci5zdGFmZmJvdHRvbSA9IHRoaXMuc3RhZmYuYm90dG9tO1xuXHQvL3RoaXMuYmFyYm90dG9tID0gcmVuZGVyZXIuY2FsY1koMik7XG5cblx0cmVuZGVyZXIubWVhc3VyZU51bWJlciA9IG51bGw7XG5cdHJlbmRlcmVyLm5vdGVOdW1iZXIgPSBudWxsO1xuXHRpZiAodGhpcy5oZWFkZXIpIHsgLy8gcHJpbnQgdm9pY2UgbmFtZVxuXHRcdHZhciB0ZXh0cGl0Y2ggPSAxNCAtICh0aGlzLnZvaWNlbnVtYmVyKzEpKigxMi8odGhpcy52b2ljZXRvdGFsKzEpKTtcblx0XHRyZW5kZXJlci5yZW5kZXJUZXh0KHJlbmRlcmVyLnBhZGRpbmcubGVmdCwgcmVuZGVyZXIuY2FsY1kodGV4dHBpdGNoKSwgdGhpcy5oZWFkZXIsICd2b2ljZWZvbnQnLCAnc3RhZmYtZXh0cmEgdm9pY2UtbmFtZScsICdzdGFydCcpO1xuXHR9XG5cblx0Zm9yICh2YXIgaT0wLCBpaT10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxpaTsgaSsrKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0XHR2YXIganVzdEluaXRpYWxpemVkTWVhc3VyZU51bWJlciA9IGZhbHNlO1xuXHRcdGlmIChjaGlsZC50eXBlICE9PSAnc3RhZmYtZXh0cmEnICYmIHJlbmRlcmVyLm1lYXN1cmVOdW1iZXIgPT09IG51bGwpIHtcblx0XHRcdHJlbmRlcmVyLm1lYXN1cmVOdW1iZXIgPSAwO1xuXHRcdFx0cmVuZGVyZXIubm90ZU51bWJlciA9IDA7XG5cdFx0XHRqdXN0SW5pdGlhbGl6ZWRNZWFzdXJlTnVtYmVyID0gdHJ1ZTtcblx0XHR9XG5cdFx0Y2hpbGQuZHJhdyhyZW5kZXJlciwgKHRoaXMuYmFydG8gfHwgaT09PWlpLTEpP2JhcnRvcDowKTtcblx0XHRpZiAoY2hpbGQudHlwZSA9PT0gJ25vdGUnIHx8IGlzTm9uU3BhY2VyUmVzdChjaGlsZCkpXG5cdFx0XHRyZW5kZXJlci5ub3RlTnVtYmVyKys7XG5cdFx0aWYgKGNoaWxkLnR5cGUgPT09ICdiYXInICYmICFqdXN0SW5pdGlhbGl6ZWRNZWFzdXJlTnVtYmVyKSB7XG5cdFx0XHRyZW5kZXJlci5tZWFzdXJlTnVtYmVyKys7XG5cdFx0XHRyZW5kZXJlci5ub3RlTnVtYmVyID0gMDtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXJlci5tZWFzdXJlTnVtYmVyID0gMDtcblx0cmVuZGVyZXIubm90ZU51bWJlciA9IDA7XG5cdHBhcnNlQ29tbW9uLmVhY2godGhpcy5iZWFtcywgZnVuY3Rpb24oYmVhbSkge1xuXHRcdGlmIChiZWFtID09PSAnYmFyJykge1xuXHRcdFx0cmVuZGVyZXIubWVhc3VyZU51bWJlcisrO1xuXHRcdFx0cmVuZGVyZXIubm90ZU51bWJlciA9IDA7XG5cdFx0fSBlbHNlXG5cdFx0XHRiZWFtLmRyYXcocmVuZGVyZXIpOyAvLyBiZWFtcyBtdXN0IGJlIGRyYXduIGZpcnN0IGZvciBwcm9wZXIgcHJpbnRpbmcgb2YgdHJpcGxldHMsIHNsdXJzIGFuZCB0aWVzLlxuXHR9KTtcblxuXHRyZW5kZXJlci5tZWFzdXJlTnVtYmVyID0gMDtcblx0cmVuZGVyZXIubm90ZU51bWJlciA9IDA7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cGFyc2VDb21tb24uZWFjaCh0aGlzLm90aGVyY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0aWYgKGNoaWxkID09PSAnYmFyJykge1xuXHRcdFx0cmVuZGVyZXIubWVhc3VyZU51bWJlcisrO1xuXHRcdFx0cmVuZGVyZXIubm90ZU51bWJlciA9IDA7XG5cdFx0fSBlbHNlXG5cdFx0XHRjaGlsZC5kcmF3KHJlbmRlcmVyLHNlbGYuc3RhcnR4KzEwLHdpZHRoKTtcblx0fSk7XG5cbn07XG5cblZvaWNlRWxlbWVudC5wcm90b3R5cGUubGF5b3V0QmVhbXMgPSBmdW5jdGlvbigpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJlYW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHRoaXMuYmVhbXNbaV0ubGF5b3V0KSB7XG5cdFx0XHR0aGlzLmJlYW1zW2ldLmxheW91dCgpO1xuXHRcdFx0dGhpcy5tb3ZlRGVjb3JhdGlvbnModGhpcy5iZWFtc1tpXSk7XG5cdFx0XHQvLyBUaGUgYWJvdmUgd2lsbCBjaGFuZ2UgdGhlIHRvcCBhbmQgYm90dG9tIG9mIHRoZSBhYnNlbGVtIGNoaWxkcmVuLCBzbyBzZWUgaWYgd2UgbmVlZCB0byBleHBhbmQgb3VyIHJhbmdlLlxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmJlYW1zW2ldLmVsZW1zLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHRoaXMuYWRqdXN0UmFuZ2UodGhpcy5iZWFtc1tpXS5lbGVtc1tqXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIE5vdyB3ZSBjYW4gbGF5b3V0IHRoZSB0cmlwbGV0c1xuXHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5vdGhlcmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5vdGhlcmNoaWxkcmVuW2ldO1xuXHRcdGlmIChjaGlsZC5sYXlvdXQpIHtcblx0XHRcdGNoaWxkLmxheW91dCgpO1xuXHRcdFx0dGhpcy5hZGp1c3RSYW5nZShjaGlsZCk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuc3RhZmYudG9wID0gTWF0aC5tYXgodGhpcy5zdGFmZi50b3AsIHRoaXMudG9wKTtcblx0dGhpcy5zdGFmZi5ib3R0b20gPSBNYXRoLm1pbih0aGlzLnN0YWZmLmJvdHRvbSwgdGhpcy5ib3R0b20pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWb2ljZUVsZW1lbnQ7XG4iLCIvKipcbiAqIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCB2LjAuNFxuICpcbiBDb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgQWxleGFuZHJ1IE3Eg3LEg8iZdGVhbnUgPGhlbGxvQGFsZXhlaS5ybz5cbiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoaXMgc29mdHdhcmUgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxuIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SXG4gQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vL2Z1bmN0aW9uIHN0cl9yZXBlYXQoaSwgbSkgeyBmb3IgKHZhciBvID0gW107IG0gPiAwOyBvWy0tbV0gPSBpKTsgcmV0dXJuKG8uam9pbignJykpOyB9XG5cbnZhciBzcHJpbnRmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpID0gMCwgYSwgZiA9IGFyZ3VtZW50c1tpKytdLCBvID0gW10sIG0sIHAsIGMsIHg7XG4gIHdoaWxlIChmKSB7XG4gICAgaWYgKG0gPSAvXlteXFx4MjVdKy8uZXhlYyhmKSkgby5wdXNoKG1bMF0pO1xuICAgIGVsc2UgaWYgKG0gPSAvXlxceDI1ezJ9Ly5leGVjKGYpKSBvLnB1c2goJyUnKTtcbiAgICBlbHNlIGlmIChtID0gL15cXHgyNSg/OihcXGQrKVxcJCk/KFxcKyk/KDB8J1teJF0pPygtKT8oXFxkKyk/KD86XFwuKFxcZCspKT8oW2ItZm9zdXhYXSkvLmV4ZWMoZikpIHtcbiAgICAgIGlmICgoKGEgPSBhcmd1bWVudHNbbVsxXSB8fCBpKytdKSA9PSBudWxsKSB8fCAoYSA9PSB1bmRlZmluZWQpKSB0aHJvdyhcIlRvbyBmZXcgYXJndW1lbnRzLlwiKTtcbiAgICAgIGlmICgvW15zXS8udGVzdChtWzddKSAmJiAodHlwZW9mKGEpICE9ICdudW1iZXInKSlcbiAgICAgICAgdGhyb3coXCJFeHBlY3RpbmcgbnVtYmVyIGJ1dCBmb3VuZCBcIiArIHR5cGVvZihhKSk7XG4gICAgICBzd2l0Y2ggKG1bN10pIHtcbiAgICAgICAgY2FzZSAnYic6IGEgPSBhLnRvU3RyaW5nKDIpOyBicmVhaztcbiAgICAgICAgY2FzZSAnYyc6IGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGEpOyBicmVhaztcbiAgICAgICAgY2FzZSAnZCc6IGEgPSBwYXJzZUludChhKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2UnOiBhID0gbVs2XSA/IGEudG9FeHBvbmVudGlhbChtWzZdKSA6IGEudG9FeHBvbmVudGlhbCgpOyBicmVhaztcbiAgICAgICAgY2FzZSAnZic6IGEgPSBtWzZdID8gcGFyc2VGbG9hdChhKS50b0ZpeGVkKG1bNl0pIDogcGFyc2VGbG9hdChhKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ28nOiBhID0gYS50b1N0cmluZyg4KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOiBhID0gKChhID0gU3RyaW5nKGEpKSAmJiBtWzZdID8gYS5zdWJzdHJpbmcoMCwgbVs2XSkgOiBhKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3UnOiBhID0gTWF0aC5hYnMoYSk7IGJyZWFrO1xuICAgICAgICBjYXNlICd4JzogYSA9IGEudG9TdHJpbmcoMTYpOyBicmVhaztcbiAgICAgICAgY2FzZSAnWCc6IGEgPSBhLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGEgPSAoL1tkZWZdLy50ZXN0KG1bN10pICYmIG1bMl0gJiYgYSA+IDAgPyAnKycgKyBhIDogYSk7XG4gICAgICBjID0gbVszXSA/IG1bM10gPT0gJzAnID8gJzAnIDogbVszXS5jaGFyQXQoMSkgOiAnICc7XG4gICAgICB4ID0gbVs1XSAtIFN0cmluZyhhKS5sZW5ndGg7XG4gICAgICBwID0gbVs1XSA/IHN0cl9yZXBlYXQoYywgeCkgOiAnJztcbiAgICAgIG8ucHVzaChtWzRdID8gYSArIHAgOiBwICsgYSk7XG4gICAgfVxuICAgIGVsc2UgdGhyb3cgKFwiSHVoID8hXCIpO1xuICAgIGYgPSBmLnN1YnN0cmluZyhtWzBdLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIG8uam9pbignJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNwcmludGY7XG4iLCIvLyAgICBhYmNfdm9pY2VfZWxlbWVudC5qczogRGVmaW5pdGlvbiBvZiB0aGUgVm9pY2VFbGVtZW50IGNsYXNzLlxuLy8gICAgQ29weXJpZ2h0IChDKSAyMDEwLTIwMTggR3JlZ29yeSBEeWtlIChncmVnZHlrZSBhdCBnbWFpbCBkb3QgY29tKSBhbmQgUGF1bCBSb3NlblxuLy9cbi8vICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZFxuLy8gICAgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbi8vICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmRcbi8vICAgIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkdcbi8vICAgIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gICAgTk9OLUlORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyAgICBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLypnbG9iYWwgbW9kdWxlICovXG5cbnZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcblxuZnVuY3Rpb24gU3ZnKHdyYXBwZXIpIHtcblx0dGhpcy5zdmcgPSBjcmVhdGVTdmcoKTtcblx0d3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG59XG5cblN2Zy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuc3ZnKSB7XG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLnN2Zy5wYXJlbnROb2RlO1xuXHRcdHRoaXMuc3ZnID0gY3JlYXRlU3ZnKCk7XG5cdFx0aWYgKHdyYXBwZXIpIHtcblx0XHRcdC8vIFRPRE8tUEVSOiBJZiB0aGUgd3JhcHBlciBpcyBub3QgcHJlc2VudCwgdGhlbiB0aGUgdW5kZXJseWluZyBkaXYgd2FzIHB1bGxlZCBvdXQgZnJvbSB1bmRlciB0aGlzIGluc3RhbmNlLiBJdCdzIHBvc3NpYmxlIHRoYXQgaXMgc3RpbGwgdXNlZnVsIChmb3IgY3JlYXRpbmcgdGhlIG11c2ljIG9mZiBwYWdlPylcblx0XHRcdHdyYXBwZXIuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuXHRcdH1cblx0fVxufTtcblxuU3ZnLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlKSB7XG5cdHZhciB0aXRsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIpO1xuXHR2YXIgdGl0bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGl0bGUpO1xuXHR0aXRsZUVsLmFwcGVuZENoaWxkKHRpdGxlTm9kZSk7XG5cdHRoaXMuc3ZnLmluc2VydEJlZm9yZSh0aXRsZUVsLCB0aGlzLnN2Zy5maXJzdENoaWxkKTtcbn07XG5cblN2Zy5wcm90b3R5cGUuc2V0UmVzcG9uc2l2ZVdpZHRoID0gZnVuY3Rpb24odywgaCkge1xuXHQvLyB0aGlzIHRlY2huaXF1ZSBpcyBmcm9tOiBodHRwOi8vdGhlbmV3Y29kZS5jb20vNzQ0L01ha2UtU1ZHLVJlc3BvbnNpdmUsIHRoeCB0byBodHRwczovL2dpdGh1Yi5jb20vaWFudHJlc21hblxuXHR0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiICsgdyArIFwiIFwiICsgaCk7XG5cdHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJ4TWluWU1pbiBtZWV0XCIpO1xuXHR0aGlzLnN2Zy5yZW1vdmVBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG5cdHRoaXMuc3ZnLnJlbW92ZUF0dHJpYnV0ZShcIndpZHRoXCIpO1xuXHR0aGlzLnN2Zy5zdHlsZVsnZGlzcGxheSddID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0dGhpcy5zdmcuc3R5bGVbJ3Bvc2l0aW9uJ10gPSBcImFic29sdXRlXCI7XG5cdHRoaXMuc3ZnLnN0eWxlWyd0b3AnXSA9IFwiMFwiO1xuXHR0aGlzLnN2Zy5zdHlsZVsnbGVmdCddID0gXCIwXCI7XG5cblx0aWYgKHRoaXMuc3ZnLnBhcmVudE5vZGUpIHtcblx0XHR2YXIgY2xzID0gdGhpcy5zdmcucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcblx0XHRpZiAoIWNscylcblx0XHRcdHRoaXMuc3ZnLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhYmNqcy1jb250YWluZXJcIik7XG5cdFx0ZWxzZSBpZiAoY2xzLmluZGV4T2YoXCJhYmNqcy1jb250YWluZXJcIikgPCAwKVxuXHRcdFx0dGhpcy5zdmcucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjbHMgKyBcIiBhYmNqcy1jb250YWluZXJcIik7XG5cdFx0dGhpcy5zdmcucGFyZW50Tm9kZS5zdHlsZVsnZGlzcGxheSddID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR0aGlzLnN2Zy5wYXJlbnROb2RlLnN0eWxlWydwb3NpdGlvbiddID0gXCJyZWxhdGl2ZVwiO1xuXHRcdHRoaXMuc3ZnLnBhcmVudE5vZGUuc3R5bGVbJ3dpZHRoJ10gPSBcIjEwMCVcIjtcblx0XHQvLyBQRVI6IEkgY2hhbmdlZCB0aGUgcGFkZGluZyBmcm9tIDEwMCUgdG8gdGhpcyB0aHJvdWdoIHRyaWFsIGFuZCBlcnJvci5cblx0XHQvLyBUaGUgZXhhbXBsZSB3YXMgdXNpbmcgYSBzcXVhcmUgaW1hZ2UsIGJ1dCB0aGlzIG11c2ljIG1pZ2h0IGJlIGVpdGhlciB3aWRlciBvciB0YWxsZXIuXG5cdFx0dmFyIHBhZGRpbmcgPSBoIC8gdyAqIDEwMDtcblx0XHR0aGlzLnN2Zy5wYXJlbnROb2RlLnN0eWxlWydwYWRkaW5nLWJvdHRvbSddID0gcGFkZGluZyArIFwiJVwiO1xuXHRcdHRoaXMuc3ZnLnBhcmVudE5vZGUuc3R5bGVbJ3ZlcnRpY2FsLWFsaWduJ10gPSBcIm1pZGRsZVwiO1xuXHRcdHRoaXMuc3ZnLnBhcmVudE5vZGUuc3R5bGVbJ292ZXJmbG93J10gPSBcImhpZGRlblwiO1xuXHR9XG59O1xuXG5TdmcucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG5cdHRoaXMuc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3KTtcblx0dGhpcy5zdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoKTtcblx0Ly8gVE9ETy1QRVI6IElzIHRoaXMgaGFjayBzdGlsbCBuZWVkZWQ/XG5cdC8vIENvcnJlY3QgZm9yIElFIHByb2JsZW0gaW4gY2FsY3VsYXRpbmcgaGVpZ2h0XG5cdC8vIHZhciBpc0lFID0gLypAY2Nfb24hQCovZmFsc2U7Ly9JRSBkZXRlY3RvclxuXHQvLyBpZiAoaXNJRSkge1xuXHQvLyBcdHRoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc3R5bGUud2lkdGggPSB3ICsgXCJweFwiO1xuXHQvLyBcdHRoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCJcIiArIGggKyBcInB4XCI7XG5cdC8vIH0gZWxzZVxuXHQvLyBcdHRoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ3aWR0aDpcIiArIHcgKyBcInB4XCIpO1xufTtcblxuU3ZnLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG5cdGlmIChzY2FsZSAhPT0gMSkge1xuXHRcdHRoaXMuc3ZnLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIrc2NhbGUrXCIsXCIrc2NhbGUrXCIpXCI7XG5cdFx0dGhpcy5zdmcuc3R5bGVbJy1tcy10cmFuc2Zvcm0nXSA9IFwic2NhbGUoXCIrc2NhbGUrXCIsXCIrc2NhbGUrXCIpXCI7XG5cdFx0dGhpcy5zdmcuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBcInNjYWxlKFwiK3NjYWxlK1wiLFwiK3NjYWxlK1wiKVwiO1xuXHRcdHRoaXMuc3ZnLnN0eWxlWyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSBcIjAgMFwiO1xuXHRcdHRoaXMuc3ZnLnN0eWxlWyctbXMtdHJhbnNmb3JtLW9yaWdpbi14J10gPSBcIjBcIjtcblx0XHR0aGlzLnN2Zy5zdHlsZVsnLW1zLXRyYW5zZm9ybS1vcmlnaW4teSddID0gXCIwXCI7XG5cdFx0dGhpcy5zdmcuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbi14J10gPSBcIjBcIjtcblx0XHR0aGlzLnN2Zy5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luLXknXSA9IFwiMFwiO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc3ZnLnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7XG5cdFx0dGhpcy5zdmcuc3R5bGVbJy1tcy10cmFuc2Zvcm0nXSA9IFwiXCI7XG5cdFx0dGhpcy5zdmcuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBcIlwiO1xuXHR9XG59O1xuXG5TdmcucHJvdG90eXBlLnNldFBhcmVudFN0eWxlcyA9IGZ1bmN0aW9uKGF0dHIpIHtcblx0Ly8gVGhpcyBpcyBuZWVkZWQgdG8gZ2V0IHRoZSBzaXplIHJpZ2h0IHdoZW4gdGhlcmUgaXMgc2NhbGluZyBpbnZvbHZlZC5cblx0Zm9yICh2YXIga2V5IGluIGF0dHIpIHtcblx0XHRpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRpZiAodGhpcy5zdmcucGFyZW50Tm9kZSlcblx0XHRcdFx0dGhpcy5zdmcucGFyZW50Tm9kZS5zdHlsZVtrZXldID0gYXR0cltrZXldO1xuXHRcdH1cblx0fVxuXHQvLyBUaGlzIGlzIHRoZSBsYXN0IHRoaW5nIHRoYXQgZ2V0cyBjYWxsZWQsIHNvIGRlbGV0ZSB0aGUgdGVtcG9yYXJ5IFNWRyBpZiBvbmUgd2FzIGNyZWF0ZWRcblx0aWYgKHRoaXMuZHVtbXlTdmcpIHtcblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblx0XHRib2R5LnJlbW92ZUNoaWxkKHRoaXMuZHVtbXlTdmcpO1xuXHRcdHRoaXMuZHVtbXlTdmcgPSBudWxsO1xuXHR9XG5cbn07XG5cblN2Zy5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uKGF0dHIpIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcInJlY3RcIik7XG5cdGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG5cdFx0aWYgKGF0dHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0dmFyIHRtcCA9IFwiXCIgKyBhdHRyW2tleV07XG5cdFx0XHRpZiAodG1wLmluZGV4T2YoXCJOYU5cIikgPj0gMClcblx0XHRcdFx0ZGVidWdnZXI7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBrZXksIGF0dHJba2V5XSk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuYXBwZW5kKGVsKTtcblx0cmV0dXJuIGVsO1xufTtcblxuU3ZnLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odGV4dCwgYXR0ciwgdGFyZ2V0KSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgJ3RleHQnKTtcblx0Zm9yICh2YXIga2V5IGluIGF0dHIpIHtcblx0XHRpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyW2tleV0pO1xuXHRcdH1cblx0fVxuXHR2YXIgbGluZXMgPSAoXCJcIit0ZXh0KS5zcGxpdChcIlxcblwiKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCAndHNwYW4nKTtcblx0XHRsaW5lLnRleHRDb250ZW50ID0gbGluZXNbaV07XG5cdFx0bGluZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGF0dHIueCA/IGF0dHIueCA6IDApO1xuXHRcdGlmIChpICE9PSAwKVxuXHRcdFx0bGluZS5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBcIjEuMmVtXCIpO1xuXHRcdGVsLmFwcGVuZENoaWxkKGxpbmUpO1xuXHR9XG5cdGlmICh0YXJnZXQpXG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcblx0ZWxzZVxuXHRcdHRoaXMuYXBwZW5kKGVsKTtcblx0cmV0dXJuIGVsO1xufTtcblxuU3ZnLnByb3RvdHlwZS5ndWVzc1dpZHRoID0gZnVuY3Rpb24odGV4dCwgYXR0cikge1xuXHR2YXIgc3ZnID0gdGhpcy5jcmVhdGVEdW1teVN2ZygpO1xuXHR2YXIgZWwgPSB0aGlzLnRleHQodGV4dCwgYXR0ciwgc3ZnKTtcblx0dmFyIHNpemU7XG5cdHRyeSB7XG5cdFx0c2l6ZSAgPSBlbC5nZXRCQm94KCk7XG5cdFx0aWYgKGlzTmFOKHNpemUuaGVpZ2h0KSB8fCAhc2l6ZS5oZWlnaHQpIC8vIFRPRE8tUEVSOiBJIGRvbid0IHRoaW5rIHRoaXMgY2FuIGhhcHBlbiB1bmxlc3MgdGhlcmUgaXNuJ3QgYSBicm93c2VyIGF0IGFsbC5cblx0XHRcdHNpemUgPSB7IHdpZHRoOiBhdHRyWydmb250LXNpemUnXS8yLCBoZWlnaHQ6IGF0dHJbJ2ZvbnQtc2l6ZSddICsgMiB9OyAvLyBKdXN0IGEgd2lsZCBndWVzcy5cblx0XHRlbHNlXG5cdFx0XHRzaXplID0ge3dpZHRoOiBzaXplLndpZHRoLCBoZWlnaHQ6IHNpemUuaGVpZ2h0fTtcblx0fSBjYXRjaCAoZXgpIHtcblx0XHRzaXplID0geyB3aWR0aDogYXR0clsnZm9udC1zaXplJ10vMiwgaGVpZ2h0OiBhdHRyWydmb250LXNpemUnXSArIDIgfTsgLy8gSnVzdCBhIHdpbGQgZ3Vlc3MuXG5cdH1cblx0c3ZnLnJlbW92ZUNoaWxkKGVsKTtcblx0cmV0dXJuIHNpemU7XG59O1xuXG5TdmcucHJvdG90eXBlLmNyZWF0ZUR1bW15U3ZnID0gZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5kdW1teVN2Zykge1xuXHRcdHRoaXMuZHVtbXlTdmcgPSBjcmVhdGVTdmcoKTtcblx0XHR2YXIgc3R5bGVzID0gW1xuXHRcdFx0XCJkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1wiLFxuXHRcdFx0XCJoZWlnaHQ6IDFweDtcIixcblx0XHRcdFwid2lkdGg6IDFweDtcIixcblx0XHRcdFwicG9zaXRpb246IGFic29sdXRlO1wiXG5cdFx0XTtcblx0XHR0aGlzLmR1bW15U3ZnLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXMuam9pbihcIlwiKSk7XG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG5cdFx0Ym9keS5hcHBlbmRDaGlsZCh0aGlzLmR1bW15U3ZnKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmR1bW15U3ZnO1xufTtcblxuU3ZnLnByb3RvdHlwZS5nZXRUZXh0U2l6ZSA9IGZ1bmN0aW9uKHRleHQsIGF0dHIsIGVsKSB7XG5cdGlmICh0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpXG5cdFx0dGV4dCA9ICcnK3RleHQ7XG5cdGlmICghdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSlcblx0XHRyZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdHZhciByZW1vdmVMYXRlciA9ICFlbDtcblx0aWYgKCFlbClcblx0XHRlbCA9IHRoaXMudGV4dCh0ZXh0LCBhdHRyKTtcblx0dmFyIHNpemU7XG5cdHRyeSB7XG5cdFx0c2l6ZSAgPSBlbC5nZXRCQm94KCk7XG5cdFx0aWYgKGlzTmFOKHNpemUuaGVpZ2h0KSB8fCAhc2l6ZS5oZWlnaHQpXG5cdFx0XHRzaXplID0gdGhpcy5ndWVzc1dpZHRoKHRleHQsIGF0dHIpO1xuXHRcdGVsc2Vcblx0XHRcdHNpemUgPSB7d2lkdGg6IHNpemUud2lkdGgsIGhlaWdodDogc2l6ZS5oZWlnaHR9O1xuXHR9IGNhdGNoIChleCkge1xuXHRcdHNpemUgPSB0aGlzLmd1ZXNzV2lkdGgodGV4dCwgYXR0cik7XG5cdH1cblx0aWYgKHJlbW92ZUxhdGVyKSB7XG5cdFx0aWYgKHRoaXMuY3VycmVudEdyb3VwKVxuXHRcdFx0dGhpcy5jdXJyZW50R3JvdXAucmVtb3ZlQ2hpbGQoZWwpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc3ZnLnJlbW92ZUNoaWxkKGVsKTtcblx0fVxuXHRyZXR1cm4gc2l6ZTtcbn07XG5cblN2Zy5wcm90b3R5cGUub3Blbkdyb3VwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcImdcIik7XG5cdGlmIChvcHRpb25zLnByZXBlbmQpXG5cdFx0dGhpcy5zdmcuaW5zZXJ0QmVmb3JlKGVsLCB0aGlzLnN2Zy5maXJzdENoaWxkKTtcblx0ZWxzZVxuXHRcdHRoaXMuc3ZnLmFwcGVuZENoaWxkKGVsKTtcblx0dGhpcy5jdXJyZW50R3JvdXAgPSBlbDtcblx0cmV0dXJuIGVsO1xufTtcblxuU3ZnLnByb3RvdHlwZS5jbG9zZUdyb3VwID0gZnVuY3Rpb24oKSB7XG5cdHZhciBnID0gdGhpcy5jdXJyZW50R3JvdXA7XG5cdHRoaXMuY3VycmVudEdyb3VwID0gbnVsbDtcblx0cmV0dXJuIGc7XG59O1xuXG5TdmcucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihhdHRyKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgXCJwYXRoXCIpO1xuXHRmb3IgKHZhciBrZXkgaW4gYXR0cikge1xuXHRcdGlmIChhdHRyLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGlmIChrZXkgPT09ICdwYXRoJylcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBhdHRyLnBhdGgpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBrZXksIGF0dHJba2V5XSk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuYXBwZW5kKGVsKTtcblx0cmV0dXJuIGVsO1xufTtcblxuU3ZnLnByb3RvdHlwZS5wYXRoVG9CYWNrID0gZnVuY3Rpb24oYXR0cikge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwicGF0aFwiKTtcblx0Zm9yICh2YXIga2V5IGluIGF0dHIpIHtcblx0XHRpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAncGF0aCcpXG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgYXR0ci5wYXRoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlTlMobnVsbCwga2V5LCBhdHRyW2tleV0pO1xuXHRcdH1cblx0fVxuXHR0aGlzLnByZXBlbmQoZWwpO1xuXHRyZXR1cm4gZWw7XG59O1xuXG5TdmcucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGVsKSB7XG5cdGlmICh0aGlzLmN1cnJlbnRHcm91cClcblx0XHR0aGlzLmN1cnJlbnRHcm91cC5hcHBlbmRDaGlsZChlbCk7XG5cdGVsc2Vcblx0XHR0aGlzLnN2Zy5hcHBlbmRDaGlsZChlbCk7XG59O1xuXG5TdmcucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihlbCkge1xuXHQvLyBUaGUgZW50aXJlIGdyb3VwIGlzIHByZXBlbmRlZCwgc28gZG9uJ3QgcHJlcGVuZCB0aGUgaW5kaXZpZHVhbCBlbGVtZW50cy5cblx0aWYgKHRoaXMuY3VycmVudEdyb3VwKVxuXHRcdHRoaXMuY3VycmVudEdyb3VwLmFwcGVuZENoaWxkKGVsKTtcblx0ZWxzZVxuXHRcdHRoaXMuc3ZnLmluc2VydEJlZm9yZShlbCwgdGhpcy5zdmcuZmlyc3RDaGlsZCk7XG59O1xuXG5TdmcucHJvdG90eXBlLnNldEF0dHJpYnV0ZU9uRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG5cdGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG5cdFx0aWYgKGF0dHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlTlMobnVsbCwga2V5LCBhdHRyW2tleV0pO1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlU3ZnKCkge1xuXHR2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcInN2Z1wiKTtcblx0c3ZnLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7XG5cdHN2Zy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnaW1nJyk7ICAgIC8vIGZvciBhY2Nlc3NpYmlsaXR5XG5cdHJldHVybiBzdmc7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdmc7XG4iLCJ2YXIgdmVyc2lvbiA9ICc1LjEyLjAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcclxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiLCJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIkM6XFxcXFVzZXJzXFxcXFNoZXJ3aW5cXFxcRGVza3RvcFxcXFxUaGVHaXRTdHVmZlxcXFxTb25hdGluYS1BbHBoYVxcXFxwYWdlc1xcXFxpbmRleC5qc1wiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBhYmNqc09iaiBmcm9tICdhYmNqcyc7XG5cbnZhciBBYmNqcyA9IGZ1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQWJjanMsIF9QdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBBYmNqcygpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFiY2pzKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1B1cmVDb21wb25lbnQuY2FsbC5hcHBseShfUHVyZUNvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnVuaXF1ZU51bWJlciA9IERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEFiY2pzLnByb3RvdHlwZS5yZW5kZXJBYmNOb3RhdGlvbiA9IGZ1bmN0aW9uIHJlbmRlckFiY05vdGF0aW9uKGFiY05vdGF0aW9uLCBwYXJzZXJQYXJhbXMsIGVuZ3JhdmVyUGFyYW1zLCByZW5kZXJQYXJhbXMpIHtcbiAgICB2YXIgcmVzID0gYWJjanNPYmoucmVuZGVyQWJjKCdhYmNqcy1yZXN1bHQtJyArIHRoaXMudW5pcXVlTnVtYmVyLCBhYmNOb3RhdGlvbiwgcGFyc2VyUGFyYW1zLCBlbmdyYXZlclBhcmFtcywgcmVuZGVyUGFyYW1zKTtcbiAgfTtcblxuICBBYmNqcy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWJjTm90YXRpb24gPSBfcHJvcHMuYWJjTm90YXRpb24sXG4gICAgICAgIHBhcnNlclBhcmFtcyA9IF9wcm9wcy5wYXJzZXJQYXJhbXMsXG4gICAgICAgIGVuZ3JhdmVyUGFyYW1zID0gX3Byb3BzLmVuZ3JhdmVyUGFyYW1zLFxuICAgICAgICByZW5kZXJQYXJhbXMgPSBfcHJvcHMucmVuZGVyUGFyYW1zO1xuXG4gICAgdGhpcy5yZW5kZXJBYmNOb3RhdGlvbihhYmNOb3RhdGlvbiwgcGFyc2VyUGFyYW1zLCBlbmdyYXZlclBhcmFtcywgcmVuZGVyUGFyYW1zKTtcbiAgfTtcblxuICBBYmNqcy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYWJjTm90YXRpb24gPSBfcHJvcHMyLmFiY05vdGF0aW9uLFxuICAgICAgICBwYXJzZXJQYXJhbXMgPSBfcHJvcHMyLnBhcnNlclBhcmFtcyxcbiAgICAgICAgZW5ncmF2ZXJQYXJhbXMgPSBfcHJvcHMyLmVuZ3JhdmVyUGFyYW1zLFxuICAgICAgICByZW5kZXJQYXJhbXMgPSBfcHJvcHMyLnJlbmRlclBhcmFtcztcblxuICAgIHRoaXMucmVuZGVyQWJjTm90YXRpb24oYWJjTm90YXRpb24sIHBhcnNlclBhcmFtcywgZW5ncmF2ZXJQYXJhbXMsIHJlbmRlclBhcmFtcyk7XG4gIH07XG5cbiAgQWJjanMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdkaXYnLFxuICAgICAgeyBzdHlsZTogeyB3aWR0aDogJzEwMCUnIH0gfSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgaWQ6ICdhYmNqcy1yZXN1bHQtJyArIHRoaXMudW5pcXVlTnVtYmVyLCBzdHlsZTogeyB3aWR0aDogJzEwMCUnIH0gfSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBBYmNqcztcbn0oUHVyZUNvbXBvbmVudCk7XG5cbkFiY2pzLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgYWJjTm90YXRpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gIHBhcnNlclBhcmFtczogUHJvcFR5cGVzLm9iamVjdCxcbiAgZW5ncmF2ZXJQYXJhbXM6IFByb3BUeXBlcy5vYmplY3QsXG4gIHJlbmRlclBhcmFtczogUHJvcFR5cGVzLm9iamVjdFxufSA6IHt9O1xuXG5BYmNqcy5kZWZhdWx0UHJvcHMgPSB7XG4gIGFiY05vdGF0aW9uOiAnJyxcbiAgcGFyc2VyUGFyYW1zOiB7fSxcbiAgZW5ncmF2ZXJQYXJhbXM6IHsgcmVzcG9uc2l2ZTogJ3Jlc2l6ZScgfSxcbiAgcmVuZGVyUGFyYW1zOiB7IHZpZXdwb3J0SG9yaXpvbnRhbDogdHJ1ZSB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBYmNqczsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIjtcbmltcG9ydCBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59Il0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkFiY2pzIiwiSW5kZXgiLCJyZXNwb25zaXZlIiwidmlld3BvcnRIb3Jpem9udGFsIl0sInNvdXJjZVJvb3QiOiIifQ==