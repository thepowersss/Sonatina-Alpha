/*!
 * react-abc2svg v0.0.0-development
 * LGPL-3.0 Licensed
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactAbc2svg"] = factory(require("react"));
	else
		root["ReactAbc2svg"] = factory(root["React"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(0);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  var invariant = __webpack_require__(1);
  var warning = __webpack_require__(2);
  var ReactPropTypesSecret = __webpack_require__(6);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(8);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_abc2svg_abc2svg_1_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_abc2svg_abc2svg_1_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_abc2svg_abc2svg_1_js__);
function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }






var Abc2svgCallbacks = function Abc2svgCallbacks() {
  var _this = this;

  _classCallCheck(this, Abc2svgCallbacks);

  this.abc_svg_output = "";
  this.abc_error_output = "";
  this.img_out = function (data) {
    _this.abc_svg_output += data;
  };
  this.errmsg = function (msg, ln, cn) {
    _this.abc_error_output += msg + "<br/>\n";
  };
  this.read_file = function (fn) {
    return "";
  };
  this.anno_start = function (music_type, start_offset, stop_offset, x, y, w, h) {};
  this.anno_stop = function (music_type, start_offset, stop_offset, x, y, w, h) {};
  this.get_abcmodel = function (tsfirst, voice_tb, music_types, info) {};
  this.page_format = true;
};

var Abc2Svg = function (_PureComponent) {
  _inherits(Abc2Svg, _PureComponent);

  function Abc2Svg() {
    var _temp, _this2, _ret;

    _classCallCheck(this, Abc2Svg);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this2), _this2.state = {
      containerWidth: ''
    }, _this2.uniqueNumber = Date.now() + Math.random(), _this2.abcCallbacks = new Abc2svgCallbacks(), _this2.fitWidth = function () {
      _this2.setState({ containerWidth: '%%pagewidth ' + window.getComputedStyle(Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__["findDOMNode"])(_this2)).width + '\n' });
    }, _temp), _possibleConstructorReturn(_this2, _ret);
  }

  Abc2Svg.prototype.componentDidMount = function componentDidMount() {
    this.fitWidth();
    window.addEventListener('resize', this.fitWidth);
  };

  Abc2Svg.prototype.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener('resize', this.fitWidth);
  };

  Abc2Svg.prototype.render = function render() {
    var _props = this.props,
        abcNotation = _props.abcNotation,
        showErrors = _props.showErrors;
    var containerWidth = this.state.containerWidth;


    var abc = new __WEBPACK_IMPORTED_MODULE_3_abc2svg_abc2svg_1_js__["Abc"](this.abcCallbacks);
    this.abcCallbacks.abc_svg_output = '';
    this.abcCallbacks.abc_error_output = '';
    abc.tosvg('ABC NOTATION', '%%fullsvg ra2s' + this.uniqueNumber + '\n' + containerWidth + abcNotation);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
      'div',
      { style: { width: '100%' } },
      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div', { className: 'abc2svg-result', style: { width: '100%' },
        dangerouslySetInnerHTML: { __html: this.abcCallbacks.abc_svg_output }
      }),
      showErrors && this.abcCallbacks.abc_error_output !== '' && __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div', { className: 'abc2svg-errors', style: { width: '100%', textAlign: 'center' },
        dangerouslySetInnerHTML: { __html: this.abcCallbacks.abc_error_output }
      })
    );
  };

  return Abc2Svg;
}(__WEBPACK_IMPORTED_MODULE_0_react__["PureComponent"]);

Abc2Svg.propTypes = {
  abcNotation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  showErrors: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.bool
};

Abc2Svg.defaultProps = {
  abcNotation: '',
  showErrors: false
};

/* harmony default export */ __webpack_exports__["default"] = (Abc2Svg);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = require('./cjs/react-dom.production.min.js');
} else {
  module.exports = __webpack_require__(10);
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var React = __webpack_require__(3);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);
var ExecutionEnvironment = __webpack_require__(11);
var _assign = __webpack_require__(4);
var emptyFunction = __webpack_require__(0);
var EventListener = __webpack_require__(12);
var getActiveElement = __webpack_require__(13);
var shallowEqual = __webpack_require__(14);
var containsNode = __webpack_require__(15);
var focusNode = __webpack_require__(18);
var emptyObject = __webpack_require__(19);
var checkPropTypes = __webpack_require__(5);
var hyphenateStyleName = __webpack_require__(20);
var camelizeStyleName = __webpack_require__(22);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work — work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary -— we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(0);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (true) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(16);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(17);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(21);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(23);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(25)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(0);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);
var assign = __webpack_require__(4);

var ReactPropTypesSecret = __webpack_require__(6);
var checkPropTypes = __webpack_require__(5);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// abc2svg - ABC to SVG translator
// @source: https://github.com/moinejf/abc2svg.git
// Copyright (C) 2014-2017 Jean-Francois Moine - LGPL3+
var abc2svg={version:"1.15.9",vdate:"2018-01-28"}
function Abc(user){"use strict";var require=empty_function,system=empty_function,write=empty_function,XMLHttpRequest=empty_function;this.user=user;var BAR=0,CLEF=1,CUSTOS=2,GRACE=4,KEY=5,METER=6,MREST=7,NOTE=8,PART=9,REST=10,SPACE=11,STAVES=12,STBRK=13,TEMPO=14,BLOCK=16,REMARK=17,FULL=0,EMPTY=1,OVAL=2,OVALBARS=3,SQUARE=4,SL_ABOVE=1,SL_BELOW=2,SL_AUTO=3,SL_HIDDEN=4,SL_DOTTED=8,OPEN_BRACE=1,CLOSE_BRACE=2,OPEN_BRACKET=4,CLOSE_BRACKET=8,OPEN_PARENTH=16,CLOSE_PARENTH=32,STOP_BAR=64,FL_VOICE=128,OPEN_BRACE2=256,CLOSE_BRACE2=512,OPEN_BRACKET2=1024,CLOSE_BRACKET2=2048,MASTER_VOICE=4096,BASE_LEN=1536,IN=96,CM=37.8,YSTEP=256;var glovar={meter:{type:METER,wmeasure:1,a_meter:[]}},info={},mac={},maci=new Int8Array(128),parse={ctx:{},prefix:"%",state:0,line:new scanBuf},psvg;function clone(obj){if(!obj)return obj;var tmp=new obj.constructor;for(var k in obj)if(obj.hasOwnProperty(k))tmp[k]=obj[k];return tmp}function errbld(sev,txt,fn,idx){var i,j,l,c,h;if(user.errbld){switch(sev){case 0:sev="warn";break;case 1:sev="error";break;default:sev="fatal";break}user.errbld(sev,txt,fn,idx);return}if(idx!=undefined&&idx>=0){i=l=0;while(1){j=parse.file.indexOf("\n",i);if(j<0||j>idx)break;l++;i=j+1}c=idx-i}h="";if(fn){h=fn;if(l)h+=":"+(l+1)+":"+(c+1);h+=" "}switch(sev){case 0:h+="Warning: ";break;case 1:h+="Error: ";break;default:h+="Internal bug: ";break}user.errmsg(h+txt,l,c)}function error(sev,s,msg,a1,a2,a3,a4){var i,j,regex,tmp;if(user.textrans){tmp=user.textrans[msg];if(tmp)msg=tmp}if(arguments.length>3)msg=msg.replace(/\$./g,function(a){switch(a){case"$1":return a1;case"$2":return a2;case"$3":return a3;default:return a4}});if(s&&s.ctx)errbld(sev,msg,s.ctx.fname,s.istart);else errbld(sev,msg)}function scanBuf(){this.index=0;scanBuf.prototype.char=function(){return this.buffer[this.index]};scanBuf.prototype.next_char=function(){return this.buffer[++this.index]};scanBuf.prototype.get_int=function(){var val=0,c=this.buffer[this.index];while(c>="0"&&c<="9"){val=val*10+Number(c);c=this.next_char()}return val}}function syntax(sev,msg,a1,a2,a3,a4){var s={ctx:parse.ctx,istart:parse.istart+parse.line.index};error(sev,s,msg,a1,a2,a3,a4)}function is_secure(js){return!js.match(/eval *\(|Function/)}var dd_tb={},a_de,od;var std_deco={dot:"0 stc 5 1 1",tenuto:"0 emb 5 3 3",slide:"1 sld 3 7 0",arpeggio:"2 arp 12 10 0",roll:"3 roll 7 6 6",fermata:"3 hld 12 7 7",emphasis:"3 accent 7 4 4",lowermordent:"3 lmrd 10 5 5",coda:"3 coda 24 10 10",uppermordent:"3 umrd 10 5 5",segno:"3 sgno 20 8 8",trill:"3 trl 14 5 5",upbow:"3 upb 10 5 5",downbow:"3 dnb 9 5 5",gmark:"3 grm 6 5 5",wedge:"3 wedge 8 3 3",turnx:"3 turnx 10 0 5",breath:"3 brth 0 1 20",longphrase:"3 lphr 0 1 1",mediumphrase:"3 mphr 0 1 1",shortphrase:"3 sphr 0 1 1",invertedfermata:"3 hld 12 7 7",invertedturn:"3 turn 10 0 5",invertedturnx:"3 turnx 10 0 5",0:"3 fng 8 3 3 0",1:"3 fng 8 3 3 1",2:"3 fng 8 3 3 2",3:"3 fng 8 3 3 3",4:"3 fng 8 3 3 4",5:"3 fng 8 3 3 5",plus:"3 dplus 7 3 3","+":"3 dplus 7 3 3",accent:"3 accent 6 4 4",">":"3 accent 6 4 4",marcato:"3 marcato 9 3 3","^":"3 marcato 9 3 3",mordent:"3 lmrd 10 5 5",open:"3 opend 10 3 3",snap:"3 snap 14 3 3",thumb:"3 thumb 14 3 3","D.C.":"3 dacs 16 10 10 D.C.","D.S.":"3 dacs 16 10 10 D.S.",fine:"3 dacs 16 10 10 FINE",turn:"3 turn 10 0 5","trill(":"3 ltr 8 0 0","trill)":"3 ltr 8 0 0",f:"6 pf 18 1 7",ff:"6 pf 18 2 10",fff:"6 pf 18 4 13",ffff:"6 pf 18 6 16",mf:"6 pf 18 6 13",mp:"6 pf 18 6 16",p:"6 pf 18 2 8",pp:"6 pf 18 5 14",ppp:"6 pf 18 8 20",pppp:"6 pf 18 10 25",pralltriller:"3 umrd 10 5 5",sfz:'6 sfz 18 4 10 ""',ped:"4 ped 20 0 0","ped-up":"4 pedoff 20 0 0","crescendo(":"7 cresc 18 0 0","crescendo)":"7 cresc 18 0 0","<(":"7 cresc 18 0 0","<)":"7 cresc 18 0 0","diminuendo(":"7 dim 18 0 0","diminuendo)":"7 dim 18 0 0",">(":"7 dim 18 0 0",">)":"7 dim 18 0 0","-(":"8 gliss 0 0 0","-)":"8 gliss 0 0 0","~(":"8 glisq 0 0 0","~)":"8 glisq 0 0 0","8va(":"3 8va 10 0 0","8va)":"3 8va 10 0 0","8vb(":"4 8vb 10 0 0","8vb)":"4 8vb 10 0 0","15ma(":"3 15ma 10 0 0","15ma)":"3 15ma 10 0 0","15mb(":"4 15mb 10 0 0","15mb)":"4 15mb 10 0 0",invisible:"32 0 0 0 0",beamon:"33 0 0 0 0",trem1:"34 0 0 0 0",trem2:"34 0 0 0 0",trem3:"34 0 0 0 0",trem4:"34 0 0 0 0",xstem:"35 0 0 0 0",beambr1:"36 0 0 0 0",beambr2:"36 0 0 0 0",rbstop:"37 0 0 0 0","/":"38 0 0 6 6","//":"38 0 0 6 6","///":"38 0 0 6 6","beam-accel":"39 0 0 0 0","beam-rall":"39 0 0 0 0",stemless:"40 0 0 0 0",rbend:"41 0 0 0 0"},f_near=[true,true,true],f_note=[false,false,false,true,true,true,false,false,true],f_staff=[false,false,false,false,false,false,true,true];var user_deco={};function y_get(st,up,x,w){var y,p_staff=staff_tb[st],i=x/realwidth*YSTEP|0,j=(x+w)/realwidth*YSTEP|0;if(i<0)i=0;if(j>=YSTEP){j=YSTEP-1;if(i>j)i=j}if(up){y=p_staff.top[i++];while(i<=j){if(y<p_staff.top[i])y=p_staff.top[i];i++}}else{y=p_staff.bot[i++];while(i<=j){if(y>p_staff.bot[i])y=p_staff.bot[i];i++}}return y}function y_set(st,up,x,w,y){var p_staff=staff_tb[st],i=x/realwidth*YSTEP|0,j=(x+w)/realwidth*YSTEP|0;if(i<0)i=0;if(j>=YSTEP){j=YSTEP-1;if(i>j)i=j}if(up){while(i<=j){if(p_staff.top[i]<y)p_staff.top[i]=y;i++}}else{while(i<=j){if(p_staff.bot[i]>y)p_staff.bot[i]=y;i++}}}function up_p(s,pos){switch(pos){case SL_ABOVE:return true;case SL_BELOW:return false}if(s.multi&&s.multi!=0)return s.multi>0;if(!s.p_v.have_ly)return false;return s.pos.voc!=SL_ABOVE}function d_arp(de){var m,h,dx,s=de.s,dd=de.dd,xc=5;if(s.type==NOTE){for(m=0;m<=s.nhd;m++){if(s.notes[m].acc){dx=5+s.notes[m].shac}else{dx=6-s.notes[m].shhd;switch(s.head){case SQUARE:dx+=3.5;break;case OVALBARS:case OVAL:dx+=2;break}}if(dx>xc)xc=dx}}h=3*(s.notes[s.nhd].pit-s.notes[0].pit)+4;m=dd.h;if(h<m)h=m;de.has_val=true;de.val=h;de.x-=xc;de.y=3*(s.notes[0].pit-18)-3}function d_cresc(de){if(de.ldst)return;var s,dd,dd2,up,x,dx,x2,i,s2=de.s,de2=de.start,de2_prev,de_next;s=de2.s;x=s.x+3;i=de2.ix;if(i>0)de2_prev=a_de[i-1];de.st=s2.st;de.lden=false;de.has_val=true;up=up_p(s2,s2.pos.dyn);if(up)de.up=true;if(de2_prev&&de2_prev.s==s&&(de.up&&!de2_prev.up||!de.up&&de2_prev.up)){dd2=de2_prev.dd;if(f_staff[dd2.func]){x2=de2_prev.x+de2_prev.val+4;if(x2>x)x=x2}}if(de.defl.noen){dx=de.x-x;if(dx<20){x=de.x-20-3;dx=20}}else{x2=s2.x;de_next=a_de[de.ix+1];if(de_next&&de_next.s==s&&(de.up&&!de_next.up||!de.up&&de_next.up)){dd2=de_next.dd;if(f_staff[dd2.func])x2-=5}dx=x2-x-4;if(dx<20){x-=(20-dx)*.5;dx=20}}de.val=dx;de.x=x;de.y=y_get(de.st,up,x,dx);if(!up){dd=de.dd;de.y-=dd.h}}function d_near(de){var y,up,s=de.s,dd=de.dd;if(dd.str){return}if(s.multi)up=s.multi>0;else up=s.stem<0;if(up)y=s.ymx|0;else y=s.ymn-dd.h|0;if(y>-6&&y<24){if(up)y+=3;y=((y+6)/6|0)*6-6}if(up)s.ymx=y+dd.h;else s.ymn=y;de.y=y;if(s.type==NOTE)de.x+=s.notes[s.stem>=0?0:s.nhd].shhd;if(dd.name[0]=="d"&&s.nflags>=-1){if(up){if(s.stem>0)de.x+=3.5}else{if(s.stem<0)de.x-=3.5}}}function d_pf(de){var dd2,x2,str,x,up,s=de.s,dd=de.dd,de_prev;de.val=dd.wl+dd.wr;up=up_p(s,s.pos.vol);if(up)de.up=true;x=s.x-dd.wl;if(de.ix>0){de_prev=a_de[de.ix-1];if(de_prev.s==s&&(de.up&&!de_prev.up||!de.up&&de_prev.up)){dd2=de_prev.dd;if(f_staff[dd2.func]){x2=de_prev.x+de_prev.val+4;if(x2>x)x=x2}}}de.x=x;de.y=y_get(s.st,up,x,de.val);if(!up)de.y-=dd.h}function d_slide(de){var m,dx,s=de.s,yc=s.notes[0].pit,xc=5;for(m=0;m<=s.nhd;m++){if(s.notes[m].acc){dx=4+s.notes[m].shac}else{dx=5-s.notes[m].shhd;switch(s.head){case SQUARE:dx+=3.5;break;case OVALBARS:case OVAL:dx+=2;break}}if(s.notes[m].pit<=yc+3&&dx>xc)xc=dx}de.x-=xc;de.y=3*(yc-18)}function d_trill(de){if(de.ldst)return;var dd,up,y,w,tmp,s2=de.s,st=s2.st,s=de.start.s,x=s.x;if(de.prev){x=de.prev.x+10;y=de.prev.y}de.st=st;if(de.dd.func!=4){switch(de.dd.glyph){case"8va":case"15ma":up=1;break;default:up=s2.multi>=0;break}}if(de.defl.noen){w=de.x-x;if(w<20){x=de.x-20-3;w=20}}else{w=s2.x-x-6;if(s2.type==NOTE)w-=6;if(w<20){x-=(20-w)*.5;w=20}}dd=de.dd;if(!y)y=y_get(st,up,x,w);if(up){tmp=staff_tb[s.st].topbar+2;if(y<tmp)y=tmp}else{y-=dd.h;tmp=staff_tb[s.st].botbar-2;if(y>tmp)y=tmp}de.lden=false;de.has_val=true;de.val=w;de.x=x;de.y=y;if(up)y+=dd.h;y_set(st,up,x,w,y);if(up)s.ymx=s2.ymx=y;else s.ymn=s2.ymn=y}function d_upstaff(de){if(de.ldst)return;if(de.start){d_trill(de);return}var yc,up,inv,s=de.s,dd=de.dd,x=s.x,w=dd.wl+dd.wr,stafft=staff_tb[s.st].topbar+2,staffb=staff_tb[s.st].botbar-2;if(s.nhd)x+=s.notes[s.stem>=0?0:s.nhd].shhd;up=-1;if(dd.func==4){up=0}else if(s.pos){switch(s.pos.orn){case SL_ABOVE:up=1;break;case SL_BELOW:up=0;break}}switch(dd.glyph){case"accent":case"roll":if(!up||up<0&&(s.multi<0||!s.multi&&s.stem>0)){yc=y_get(s.st,false,s.x-dd.wl,w);if(yc>staffb)yc=staffb;yc-=dd.h;y_set(s.st,false,s.x,0,yc);inv=true;s.ymn=yc}else{yc=y_get(s.st,true,s.x,0);if(yc<stafft)yc=stafft;y_set(s.st,true,s.x-dd.wl,w,yc+dd.h);s.ymx=yc+dd.h}break;case"brth":case"lphr":case"mphr":case"sphr":yc=stafft+1;if(dd.glyph=="brth"){if(yc<s.ymx)yc=s.ymx}for(s=s.ts_next;s;s=s.ts_next)if(s.shrink)break;x+=((s?s.x:realwidth)-x)*.4;break;default:if(dd.name.indexOf("invert")==0)inv=true;if(dd.name!="invertedfermata"&&(up>0||up<0&&s.multi>=0)){yc=y_get(s.st,true,s.x-dd.wl,w);if(yc<stafft)yc=stafft;y_set(s.st,true,s.x-dd.wl,w,yc+dd.h);s.ymx=yc+dd.h}else{yc=y_get(s.st,false,s.x-dd.wl,w);if(yc>staffb)yc=staffb;yc-=dd.h;y_set(s.st,false,s.x-dd.wl,w,yc);if(dd.name=="fermata")inv=true;s.ymn=yc}break}if(inv){yc+=dd.h;de.inv=true}de.x=x;de.y=yc}var func_tb=[d_near,d_slide,d_arp,d_upstaff,d_upstaff,d_trill,d_pf,d_cresc];function deco_add(param){var dv=param.match(/(\S*)\s+(.*)/);user_deco[dv[1]]=dv[2]}function deco_build(nm,text){var a,dd,dd2,name2,c,i,elts,str;a=text.match(/(\d+)\s+(.+?)\s+([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)/);if(!a){error(1,null,"Invalid decoration '$1'",nm);return}var c_func=Number(a[1]),h=parseFloat(a[3]),wl=parseFloat(a[4]),wr=parseFloat(a[5]);if(isNaN(c_func)){error(1,null,"%%deco: bad C function value '$1'",a[1]);return}if((c_func<0||c_func>10)&&(c_func<32||c_func>41)){error(1,null,"%%deco: bad C function index '$1'",c_func);return}if(h<0||wl<0||wr<0){error(1,null,"%%deco: cannot have a negative value '$1'",text);return}if(h>50||wl>80||wr>80){error(1,null,"%%deco: abnormal h/wl/wr value '$1'",text);return}dd=dd_tb[nm];if(!dd){dd={name:nm};dd_tb[nm]=dd}dd.func=dd.name.indexOf("head-")==0?9:c_func;dd.glyph=a[2];dd.h=h;dd.wl=wl;dd.wr=wr;str=text.replace(a[0],"").trim();if(str){if(str[0]=='"')str=str.slice(1,-1);dd.str=str}if(dd.func==6&&dd.str==undefined)dd.str=dd.name;c=dd.name.slice(-1);if(c=="("||c==")"&&dd.name.indexOf("(")<0){name2=dd.name.slice(0,-1)+(c=="("?")":"(");dd2=dd_tb[name2];if(dd2){if(c=="("){dd.dd_en=dd2;dd2.dd_st=dd}else{dd.dd_st=dd2;dd2.dd_en=dd}}else{dd2=deco_def(name2);if(!dd2)return}}return dd}function deco_cnv(a_dcn,s,prev){var i,j,dd,dcn,note,nd=a_dcn.length;for(i=0;i<nd;i++){dcn=a_dcn[i];dd=dd_tb[dcn];if(!dd){dd=deco_def(dcn);if(!dd)continue}switch(dd.func){case 0:if(s.type==BAR&&dd.name=="dot"){s.bar_dotted=true;break}case 1:case 2:if(!s.notes){error(1,s,"!$1! must be on a note or a rest",dd.name);continue}break;case 8:if(s.type!=NOTE){error(1,s,"!$1! must be on a note",dd.name);continue}note=s.notes[s.nhd];if(!note.a_dcn)note.a_dcn=[];note.a_dcn.push(dd.name);continue;case 9:if(!s.notes){error(1,s,"!$1! must be on a note or rest",dd.name);continue}for(j=0;j<=s.nhd;j++){note=s.notes[j];if(!note.a_dcn)note.a_dcn=[];note.a_dcn.push(dd.name)}continue;default:break;case 10:if(s.notes){for(j=0;j<=s.nhd;j++)s.notes[j].color=dd.name}else{s.color=dd.name}continue;case 32:s.invis=true;continue;case 33:if(s.type!=BAR){error(1,s,"!beamon! must be on a bar");continue}s.beam_on=true;continue;case 34:if(s.type!=NOTE||!prev||prev.type!=NOTE||s.nflags!=prev.nflags){error(1,s,"!$1! must be on the last of a couple of notes",dd.name);continue}s.trem2=true;s.beam_end=true;prev.trem2=true;prev.beam_st=true;s.ntrem=prev.ntrem=Number(dd.name[4]);prev.nflags=--s.nflags;prev.head=++s.head;if(s.nflags>0){s.nflags+=s.ntrem}else{if(s.nflags<=-2){s.stemless=true;prev.stemless=true}s.nflags=s.ntrem}prev.nflags=s.nflags;for(j=0;j<=s.nhd;j++)s.notes[j].dur*=2;for(j=0;j<=prev.nhd;j++)prev.notes[j].dur*=2;continue;case 35:if(s.type!=NOTE){error(1,s,"!xstem! must be on a note");continue}s.xstem=true;s.nflags=0;continue;case 36:if(s.type!=NOTE){error(1,s,"!$1! must be on a note",dd.name);continue}if(dd.name[6]=="1")s.beam_br1=true;else s.beam_br2=true;continue;case 37:s.rbstop=1;continue;case 38:if(s.type!=NOTE){error(1,s,"!$1! must be on a note",dd.name);continue}s.trem1=true;s.ntrem=dd.name.length;if(s.nflags>0)s.nflags+=s.ntrem;else s.nflags=s.ntrem;continue;case 39:if(s.type!=NOTE){error(1,s,"!$1! must be on a note",dd.name);continue}s.feathered_beam=dd.name[5]=="a"?1:-1;continue;case 40:s.stemless=true;continue;case 41:s.rbstop=2;continue}if(!s.a_dd)s.a_dd=[];s.a_dd.push(dd)}}function deco_def(nm){if(user_deco&&user_deco[nm])return deco_build(nm,user_deco[nm]);if(std_deco[nm])return deco_build(nm,std_deco[nm]);if(cfmt.decoerr)error(1,null,"Unknown decoration '$1'",nm);return}function deco_update(s,dx){var i,de,nd=a_de.length;for(i=0;i<nd;i++){de=a_de[i];if(de.s==s)de.x+=dx}}function deco_width(s){var dd,i,wl=0,a_dd=s.a_dd,nd=a_dd.length;for(i=0;i<nd;i++){dd=a_dd[i];switch(dd.func){case 1:if(wl<7)wl=7;break;case 2:if(wl<14)wl=14;break}}if(wl!=0&&s.prev&&s.prev.type==BAR)wl-=3;return wl}function draw_all_deco(){if(a_de.length==0)return;var de,de2,dd,s,note,f,st,x,y,y2,ym,uf,i,str,a,new_de=[],ymid=[];if(!cfmt.dynalign){st=nstaff;y=staff_tb[st].y;while(--st>=0){y2=staff_tb[st].y;ymid[st]=(y+24+y2)*.5;y=y2}}while(1){de=a_de.shift();if(!de)break;dd=de.dd;if(!dd)continue;if(dd.dd_en)continue;s=de.s;f=dd.glyph;i=f.indexOf("/");if(i>0){if(s.stem>=0)f=f.slice(0,i);else f=f.slice(i+1)}if(f_staff[dd.func])set_sscale(-1);else set_scale(s);st=de.st;if(!staff_tb[st].topbar)continue;x=de.x;y=de.y+staff_tb[st].y;if(de.m!=undefined){note=s.notes[de.m];x+=note.shhd*stv_g.scale}else if(f_staff[dd.func]&&!cfmt.dynalign&&(de.up&&st>0||!de.up&&st<nstaff)){if(de.up)ym=ymid[--st];else ym=ymid[st++];ym-=dd.h*.5;if(de.up&&y<ym||!de.up&&y>ym){y2=y_get(st,!de.up,de.x,de.val)+staff_tb[st].y;if(de.up)y2-=dd.h;if(de.up&&y2>ym||!de.up&&y2<ym){y=ym}}}uf=user[f];if(uf&&typeof uf=="function"){uf(x,y,de);continue}if(psdeco(f,x,y,de))continue;anno_start(s,"deco");if(de.inv){g_open(x,y,0,1,-1);x=y=0}if(de.has_val){if(dd.func!=2||stv_g.st<0)out_deco_val(x,y,f,de.val/stv_g.scale,de.defl);else out_deco_val(x,y,f,de.val,de.defl);if(de.defl.noen)new_de.push(de.start)}else if(dd.str!=undefined&&dd.str!="sfz"){str=dd.str;if(str[0]=="@"){a=str.match(/^@([0-9.-]+),([0-9.-]+);?/);x+=Number(a[1]);y+=Number(a[2]);str=str.replace(a[0],"")}out_deco_str(x,y,f,str)}else if(de.lden){out_deco_long(x,y,de)}else{xygl(x,y,f)}if(stv_g.g)g_close();anno_stop(s,"deco")}a_de=new_de}var ottava={"8va(":1,"8va)":1,"15ma(":1,"15ma)":1,"8vb(":1,"8vb)":1,"15mb(":1,"15mb)":1};function draw_deco_near(){var s,g;function ldeco_update(s){var i,de,x=s.x-s.wl,nd=a_de.length;for(i=0;i<nd;i++){de=a_de[i];de.ix=i;de.s.x=de.x=x;de.defl.nost=true}}function create_deco(s){var dd,k,l,pos,de,x,nd=s.a_dd.length;for(k=0;k<nd;k++){dd=s.a_dd[k];switch(dd.func){default:pos=0;break;case 3:case 4:case 5:if(ottava[dd.name]){x=dd.name.slice(0,-1)+s.st.toString();if(od[x]){if(dd.name[dd.name.length-1]=="("){od[x]++;continue}od[x]--;if(s.v+1!=od[x]>>8||!od[x])continue;od[x]&=255}else if(dd.name[dd.name.length-1]=="("){od[x]=1+(s.v+1<<8)}}pos=s.pos.orn;break;case 6:pos=s.pos.vol;break;case 7:pos=s.pos.dyn;break}if(pos==SL_HIDDEN)continue;de={s:s,dd:dd,st:s.st,ix:a_de.length,defl:{},x:s.x,y:s.y};a_de.push(de);if(dd.dd_en){de.ldst=true}else if(dd.dd_st){de.lden=true;de.defl.nost=true}if(!f_near[dd.func])continue;func_tb[dd.func](de)}}function create_dh(s,m){var f,str,de,uf,k,dcn,dd,note=s.notes[m],nd=note.a_dcn.length;for(k=0;k<nd;k++){dcn=note.a_dcn[k];dd=dd_tb[dcn];if(!dd){dd=deco_def(dcn);if(!dd)continue}switch(dd.func){case 0:case 1:case 3:case 4:break;default:case 2:case 5:case 7:error(1,null,"Cannot have !$1! on a head",dd.name);continue;case 9:note.invis=true;break;case 10:note.color=dd.name;continue;case 32:note.invis=true;continue;case 40:s.stemless=true;continue}de={s:s,dd:dd,st:s.st,m:m,ix:0,defl:{},x:s.x,y:3*(note.pit-18)};a_de.push(de);if(dd.dd_en){de.ldst=true}else if(dd.dd_st){de.lden=true;de.defl.nost=true}}}function create_all(s){var m;if(s.a_dd)create_deco(s);if(s.notes){for(m=0;m<s.notes.length;m++){if(s.notes[m].a_dcn)create_dh(s,m)}}}function ll_deco(){var i,j,de,de2,dd,dd2,v,s,st,n_de=a_de.length;for(i=0;i<n_de;i++){de=a_de[i];if(!de.ldst)continue;dd=de.dd;dd2=dd.dd_en;s=de.s;v=s.v;for(j=i+1;j<n_de;j++){de2=a_de[j];if(!de2.start&&de2.dd==dd2&&de2.s.v==v)break}if(j==n_de){st=s.st;for(j=i+1;j<n_de;j++){de2=a_de[j];if(!de2.start&&de2.dd==dd2&&de2.s.st==st)break}}if(j==n_de){de2={s:de.s,st:de.st,dd:dd2,ix:a_de.length-1,x:realwidth-6,y:de.s.y,lden:true,defl:{noen:true}};if(de2.x<s.x+10)de2.x=s.x+10;if(de.m!=undefined)de2.m=de.m;a_de.push(de2)}de2.start=de;de2.defl.nost=de.defl.nost;if(dd.name=="trill("&&i>0&&a_de[i-1].dd.name=="trill")de2.prev=a_de[i-1]}for(i=0;i<n_de;i++){de2=a_de[i];if(!de2.lden||de2.start)continue;s=de2.s;de={s:prev_scut(s),st:de2.st,dd:de2.dd.dd_st,ix:a_de.length-1,y:s.y,ldst:true};de.x=de.s.x;if(de2.m!=undefined)de.m=de2.m;a_de.push(de);de2.start=de}}for(s=tsfirst;s;s=s.ts_next){switch(s.type){case CLEF:case KEY:case METER:continue}break}if(a_de.length!=0)ldeco_update(s);for(;s;s=s.ts_next){switch(s.type){case BAR:case MREST:case NOTE:case REST:case SPACE:break;case GRACE:for(g=s.extra;g;g=g.next)create_all(g);default:continue}create_all(s)}ll_deco()}function draw_deco_note(){var i,de,dd,f,nd=a_de.length;for(i=0;i<nd;i++){de=a_de[i];dd=de.dd;f=dd.func;if(f_note[f]&&de.m==undefined)func_tb[f](de)}}function draw_deco_staff(){var s,first_gchord,p_voice,x,y,w,i,v,de,dd,gch,gch2,ix,top,bot,minmax=new Array(nstaff),nd=a_de.length;function draw_repbra(p_voice){var s,s1,y,y2,i,p,w,first_repeat;y=staff_tb[p_voice.st].topbar+25;for(s=p_voice.sym;s;s=s.next){if(s.type!=BAR)continue;if(!s.rbstart||s.norepbra)continue;if(!s.next)break;if(!first_repeat){first_repeat=s;set_font("repeat")}s1=s;for(;;){if(!s.next)break;s=s.next;if(s.rbstop)break}y2=y_get(p_voice.st,true,s1.x,s.x-s1.x);if(y<y2)y=y2;if(s1.text){w=strw(s1.text);y2=y_get(p_voice.st,true,s1.x+4,w);y2+=gene.curfont.size;if(y<y2)y=y2}if(s.rbstart)s=s.prev}s=first_repeat;if(!s)return;set_dscale(p_voice.st,true);y2=y*staff_tb[p_voice.st].staffscale;for(;s;s=s.next){if(!s.rbstart||s.norepbra)continue;s1=s;while(1){if(!s.next)break;s=s.next;if(s.rbstop)break}if(s1==s)break;x=s1.x;if(s.type!=BAR){w=s.rbstop?0:s.x-realwidth+4}else if(s.bar_type.length>1&&s.bar_type!="[]"||s.bar_type=="]"){if(s1.st>0&&!(cur_sy.staves[s1.st-1].flags&STOP_BAR))w=s.wl;else if(s.bar_type.slice(-1)==":")w=12;else if(s.bar_type[0]!=":")w=0;else w=8}else{w=s.rbstop?0:8}w=s.x-x-w;if(!s.next&&!s.rbstop&&!p_voice.bar_start){p_voice.bar_start=clone(s);p_voice.bar_start.type=BAR;p_voice.bar_start.bar_type="[";delete p_voice.bar_start.text;p_voice.bar_start.rbstart=1;delete p_voice.bar_start.a_gch}if(s1.text)xy_str(x+4,y2-gene.curfont.size-3,s1.text);xypath(x,y2);if(s1.rbstart==2)output.push("m0 20v-20");output.push("h");output.push(w.toFixed(2));if(s.rbstop==2)output.push("v20");output.push('"/>\n');y_set(s1.st,true,x,w,y+2);if(s.rbstart)s=s.prev}}for(i=0;i<=nstaff;i++)minmax[i]={ymin:0,ymax:24};for(s=tsfirst;s;s=s.ts_next){if(!s.a_gch)continue;if(!first_gchord)first_gchord=s;gch2=null;for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];if(gch.type!="g")continue;gch2=gch;if(gch.y<0)break}if(gch2){w=gch2.w;if(gch2.y>=0){y=y_get(s.st,true,s.x,w);if(y>minmax[s.st].ymax)minmax[s.st].ymax=y}else{y=y_get(s.st,false,s.x,w);if(y<minmax[s.st].ymin)minmax[s.st].ymin=y}}}if(first_gchord){for(i=0;i<=nstaff;i++){bot=staff_tb[i].botbar;minmax[i].ymin-=3;if(minmax[i].ymin>bot-10)minmax[i].ymin=bot-10;top=staff_tb[i].topbar;minmax[i].ymax+=3;if(minmax[i].ymax<top+10)minmax[i].ymax=top+10}set_sscale(-1);for(s=first_gchord;s;s=s.ts_next){if(!s.a_gch)continue;draw_gchord(s,minmax[s.st].ymin,minmax[s.st].ymax)}}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.second||!p_voice.sym)continue;draw_repbra(p_voice)}for(i=0;i<=nstaff;i++)minmax[i]={ymin:0,ymax:0};for(i=0;i<nd;i++){de=a_de[i];dd=de.dd;if(!dd)continue;if(!f_staff[dd.func]||de.m!=undefined)continue;func_tb[dd.func](de);if(dd.dd_en)continue;if(cfmt.dynalign){if(de.up){if(de.y>minmax[de.st].ymax)minmax[de.st].ymax=de.y}else{if(de.y<minmax[de.st].ymin)minmax[de.st].ymin=de.y}}}for(i=0;i<nd;i++){de=a_de[i];dd=de.dd;if(!dd)continue;if(dd.dd_en||!f_staff[dd.func])continue;if(cfmt.dynalign){if(de.up)y=minmax[de.st].ymax;else y=minmax[de.st].ymin;de.y=y}else{y=de.y}if(de.up)y+=dd.h;y_set(de.st,de.up,de.x,de.val,y)}}function draw_measnb(){var s,st,bar_num,x,y,w,any_nb,font_size,sy=cur_sy;for(st=0;st<=nstaff;st++){if(sy.st_print[st])break}if(st>nstaff)return;set_dscale(st);if(staff_tb[st].staffscale!=1){font_size=get_font("measure").size;param_set_font("measurefont","* "+(font_size/staff_tb[st].staffscale).toString())}set_font("measure");s=tsfirst;bar_num=gene.nbar;if(bar_num>1){if(cfmt.measurenb==0){any_nb=true;y=y_get(st,true,0,20);if(y<staff_tb[st].topbar+14)y=staff_tb[st].topbar+14;xy_str(0,y,bar_num.toString());y_set(st,true,0,20,y+gene.curfont.size+2)}else if(bar_num%cfmt.measurenb==0){for(;;s=s.ts_next){switch(s.type){case METER:case CLEF:case KEY:case STBRK:continue}break}while(s.st!=st)s=s.ts_next;if(s.prev&&s.prev.type!=CLEF)s=s.prev;x=s.x-s.wl;any_nb=true;w=cwid("0")*gene.curfont.swfac;if(bar_num>=10)w*=bar_num>=100?3:2;if(cfmt.measurebox)w+=4;y=y_get(st,true,x,w);if(y<staff_tb[st].topbar+6)y=staff_tb[st].topbar+6;y+=2;if(cfmt.measurebox){xy_str_b(x,y,bar_num.toString());w+=3}else{xy_str(x,y,bar_num.toString())}y+=gene.curfont.size;y_set(st,true,x,w,y);s.ymx=y}}for(;s;s=s.ts_next){switch(s.type){case STAVES:sy=s.sy;for(st=0;st<nstaff;st++){if(sy.st_print[st])break}set_sscale(st);continue;default:continue;case BAR:if(!s.bar_num)continue;break}bar_num=s.bar_num;if(cfmt.measurenb==0||bar_num%cfmt.measurenb!=0||!s.next)continue;if(!any_nb)any_nb=true;w=cwid("0")*gene.curfont.swfac;if(bar_num>=10)w*=bar_num>=100?3:2;if(cfmt.measurebox)w+=4;x=s.x-w*.4;y=y_get(st,true,x,w);if(y<staff_tb[st].topbar+6)y=staff_tb[st].topbar+6;if(s.next.type==NOTE){if(s.next.stem>0){if(y<s.next.ys-gene.curfont.size)y=s.next.ys-gene.curfont.size}else{if(y<s.next.y)y=s.next.y}}y+=2;if(cfmt.measurebox){xy_str_b(x,y,bar_num.toString());w+=3}else{xy_str(x,y,bar_num.toString())}y+=gene.curfont.size;y_set(st,true,x,w,y);s.ymx=y}gene.nbar=bar_num;if(font_size)param_set_font("measurefont","* "+font_size.toString())}function draw_notempo(s,x,y,dur,sc){var dx,p,dotx,elts=identify_note(s,dur),head=elts[0],dots=elts[1],nflags=elts[2];if(stv_g.started){output.push("</g>\n");stv_g.started=false}out_XYAB('<g transform="translate(X,Y) scale(F)">\n',x+4,y+2,sc);switch(head){case OVAL:p="HD";break;case EMPTY:p="Hd";break;default:p="hd";break}xygl(-posx,posy,p);dx=4;if(dots){dotx=9;if(nflags>0)dotx+=4;switch(head){case SQUARE:dotx+=3;break;case OVALBARS:case OVAL:dotx+=2;break;case EMPTY:dotx+=1;break}dx=dotx*dots;dotx-=posx;while(--dots>=0){xygl(dotx,posy,"dot");dotx+=3.5}}if(dur<BASE_LEN){if(nflags<=0){out_stem(-posx,posy,21)}else{out_stem(-posx,posy,21,false,nflags);if(dx<6)dx=6}}output.push("</g>\n");return(dx+15)*sc}function tempo_width(s){var w=0;set_font("tempo");if(s.tempo_str1)w=strw(s.tempo_str1);if(s.tempo_ca)w+=strw(s.tempo_ca);if(s.tempo_notes)w+=10*s.tempo_notes.length+6+cwid(" ")*gene.curfont.swfac*6+10;if(s.tempo_str2)w+=strw(s.tempo_str2);return w}function write_tempo(s,x,y){var j,dx,sc=.6*gene.curfont.size/15;set_font("tempo");if(s.tempo_str1){xy_str(x,y,s.tempo_str1);x+=strw(s.tempo_str1)+3}if(s.tempo_notes){for(j=0;j<s.tempo_notes.length;j++)x+=draw_notempo(s,x,y,s.tempo_notes[j],sc);xy_str(x,y,"=");x+=strw("= ");if(s.tempo_ca){xy_str(x,y,s.tempo_ca);x+=strw(s.tempo_ca)}if(s.tempo){xy_str(x,y,s.tempo.toString());dx=cwid("0")*gene.curfont.swfac;x+=dx+5;if(s.tempo>=10){x+=dx;if(s.tempo>=100)x+=dx}}else{x+=draw_notempo(s,x,y,s.new_beat,sc)}}if(s.tempo_str2)xy_str(x,y,s.tempo_str2);s.del=true}function draw_partempo(st,top){var s,some_part,some_tempo,h,w,y,dy=0,ht=0;var ymin=staff_tb[st].topbar+12,dosh=0,shift=1,x=0;for(s=tsfirst;s;s=s.ts_next){if(s.type!=TEMPO||s.del)continue;if(!some_tempo)some_tempo=s;w=tempo_width(s);y=y_get(st,true,s.x-5,w)+2;if(y>ymin)ymin=y;if(x>=s.x-5&&!(dosh&shift>>1))dosh|=shift;shift<<=1;x=s.x-5+w}if(some_tempo){set_sscale(-1);set_font("tempo");ht=gene.curfont.size+2+2;y=2-ht;h=y-ht;if(dosh!=0)ht*=2;if(top<ymin+ht)dy=ymin+ht-top;for(s=some_tempo;s;s=s.ts_next){if(s.type!=TEMPO||s.del)continue;if(user.anno_start||user.anno_stop){s.wl=5;s.wr=40;s.ymn=dosh&1?h:y;s.ymx=s.ymn+14;anno_start(s)}write_tempo(s,s.x-5,dosh&1?h:y);anno_stop(s);dosh>>=1}}ymin=staff_tb[st].topbar+14;for(s=tsfirst;s;s=s.ts_next){if(s.type!=PART)continue;if(!some_part){some_part=s;set_font("parts");h=gene.curfont.size+2+2}w=strw(s.text);y=y_get(st,true,s.x-10,w+3)+5;if(ymin<y)ymin=y}if(some_part){set_sscale(-1);if(top<ymin+h+ht)dy=ymin+h+ht-top;for(s=some_part;s;s=s.ts_next){if(s.type!=PART)continue;s.x-=10;if(user.anno_start||user.anno_stop){w=strw(s.text);s.wl=0;s.wr=w;s.ymn=-ht-h;s.ymx=s.ymn+h;anno_start(s)}if(cfmt.partsbox)xy_str_b(s.x,2-ht-h,s.text);else xy_str(s.x,2-ht-h,s.text);anno_stop(s)}}return dy}var STEM_MIN=16,STEM_MIN2=14,STEM_MIN3=12,STEM_MIN4=10,STEM_CH_MIN=14,STEM_CH_MIN2=10,STEM_CH_MIN3=9,STEM_CH_MIN4=9,BEAM_DEPTH=3.2,BEAM_OFFSET=.25,BEAM_SHIFT=5,BEAM_SLOPE=.4,BEAM_STUB=8,SLUR_SLOPE=.5,GSTEM=15,GSTEM_XOFF=2.3;var cache;function b_pos(grace,stem,nflags,b){var top,bot,d1,d2,shift=!grace?BEAM_SHIFT:3.5,depth=!grace?BEAM_DEPTH:1.8;function rnd6(y){var iy=Math.round((y+12)/6)*6-12;return iy-y}if(stem>0){bot=b-(nflags-1)*shift-depth;if(bot>26)return 0;top=b}else{top=b+(nflags-1)*shift+depth;if(top<-2)return 0;bot=b}d1=rnd6(top-BEAM_OFFSET);d2=rnd6(bot+BEAM_OFFSET);return d1*d1>d2*d2?d2:d1}function sym_dup(s_orig){var m,note,s=clone(s_orig);s.invis=true;delete s.text;delete s.a_gch;delete s.a_ly;delete s.a_dd;s.notes=clone(s_orig.notes);for(m=0;m<=s.nhd;m++){note=s.notes[m]=clone(s_orig.notes[m]);delete note.a_dcn}return s}var min_tb=[[STEM_MIN,STEM_MIN,STEM_MIN2,STEM_MIN3,STEM_MIN4,STEM_MIN4],[STEM_CH_MIN,STEM_CH_MIN,STEM_CH_MIN2,STEM_CH_MIN3,STEM_CH_MIN4,STEM_CH_MIN4]];function calculate_beam(bm,s1){var s,s2,notes,nflags,st,v,two_staves,two_dir,x,y,ys,a,b,stem_err,max_stem_err,p_min,p_max,s_closest,stem_xoff,scale,visible,dy;if(!s1.beam_st){s=sym_dup(s1);lkvsym(s,s1);lktsym(s,s1);s.x-=12;if(s.x>s1.prev.x+12)s.x=s1.prev.x+12;s.beam_st=true;delete s.beam_end;s.tmp=true;delete s.slur_start;delete s.slur_end;s1=s}notes=nflags=0;two_staves=two_dir=false;st=s1.st;v=s1.v;stem_xoff=s1.grace?GSTEM_XOFF:3.5;for(s2=s1;;s2=s2.next){if(s2.type==NOTE){if(s2.nflags>nflags)nflags=s2.nflags;notes++;if(s2.st!=st)two_staves=true;if(s2.stem!=s1.stem)two_dir=true;if(!visible&&!s2.invis&&(!s2.stemless||s2.trem2))visible=true;if(s2.beam_end)break}if(!s2.next){for(;;s2=s2.prev){if(s2.type==NOTE)break}s=sym_dup(s2);s.next=s2.next;if(s.next)s.next.prev=s;s2.next=s;s.prev=s2;s.ts_next=s2.ts_next;if(s.ts_next)s.ts_next.ts_prev=s;s2.ts_next=s;s.ts_prev=s2;delete s.beam_st;s.beam_end=true;s.tmp=true;delete s.slur_start;delete s.slur_end;s.x+=12;if(s.x<realwidth-12)s.x=realwidth-12;s2=s;notes++;break}}if(!visible)return false;bm.s2=s2;if(staff_tb[st].y==0){if(two_staves)return false}else{if(!two_staves){bm.s1=s1;bm.a=(s1.ys-s2.ys)/(s1.xs-s2.xs);bm.b=s1.ys-s1.xs*bm.a+staff_tb[st].y;bm.nflags=nflags;return true}}s_closest=s1;p_min=100;p_max=0;for(s=s1;;s=s.next){if(s.type!=NOTE)continue;if((scale=s.p_v.scale)==1)scale=staff_tb[s.st].staffscale;if(s.stem>=0){x=stem_xoff+s.notes[0].shhd;if(s.notes[s.nhd].pit>p_max){p_max=s.notes[s.nhd].pit;s_closest=s}}else{x=-stem_xoff+s.notes[s.nhd].shhd;if(s.notes[0].pit<p_min){p_min=s.notes[0].pit;s_closest=s}}s.xs=s.x+x*scale;if(s==s2)break}if(cfmt.flatbeams)a=0;else if(!two_dir&&notes>=3&&s_closest!=s1&&s_closest!=s2)a=0;y=s1.ys+staff_tb[st].y;if(a==undefined)a=(s2.ys+staff_tb[s2.st].y-y)/(s2.xs-s1.xs);if(a!=0){if(a>0)a=BEAM_SLOPE*a/(BEAM_SLOPE+a);else a=BEAM_SLOPE*a/(BEAM_SLOPE-a)}b=y-a*s1.xs;max_stem_err=0;s=s1;if(two_dir){ys=((s1.grace?3.5:BEAM_SHIFT)*(nflags-1)+BEAM_DEPTH)*.5;if(s1.stem!=s2.stem&&s1.nflags<s2.nflags)ys*=s2.stem;else ys*=s1.stem;b+=ys}else if(!s1.grace){var beam_h=BEAM_DEPTH+BEAM_SHIFT*(nflags-1);while(s.ts_prev&&s.ts_prev.type==NOTE&&s.ts_prev.time==s.time&&s.ts_prev.x>s1.xs)s=s.ts_prev;for(;s&&s.time<=s2.time;s=s.ts_next){if(s.type!=NOTE||s.invis||s.st!=st&&s.v!=v){continue}x=s.v==v?s.xs:s.x;ys=a*x+b-staff_tb[s.st].y;if(s.v==v){stem_err=min_tb[s.nhd==0?0:1][s.nflags];if(s.stem>0){if(s.notes[s.nhd].pit>26){stem_err-=2;if(s.notes[s.nhd].pit>28)stem_err-=2}stem_err-=ys-3*(s.notes[s.nhd].pit-18)}else{if(s.notes[0].pit<18){stem_err-=2;if(s.notes[0].pit<16)stem_err-=2}stem_err-=3*(s.notes[0].pit-18)-ys}stem_err+=BEAM_DEPTH+BEAM_SHIFT*(s.nflags-1)}else{if(s1.stem>0){if(s.stem>0){if(s.ymn>ys+4||s.ymx<ys-beam_h-2)continue;if(s.v>v)stem_err=s.ymx-ys;else stem_err=s.ymn+8-ys}else{stem_err=s.ymx-ys}}else{if(s.stem<0){if(s.ymx<ys-4||s.ymn>ys-beam_h-2)continue;if(s.v<v)stem_err=ys-s.ymn;else stem_err=ys-s.ymx+8}else{stem_err=ys-s.ymn}}stem_err+=2+beam_h}if(stem_err>max_stem_err)max_stem_err=stem_err}}else{for(;;s=s.next){ys=a*s.xs+b-staff_tb[s.st].y;stem_err=GSTEM-2;if(s.stem>0)stem_err-=ys-3*(s.notes[s.nhd].pit-18);else stem_err+=ys-3*(s.notes[0].pit-18);stem_err+=3*(s.nflags-1);if(stem_err>max_stem_err)max_stem_err=stem_err;if(s==s2)break}}if(max_stem_err>0)b+=s1.stem*max_stem_err;if(!two_staves&&!two_dir)for(s=s1.next;;s=s.next){var g;switch(s.type){case REST:g=s.ts_next;if(!g||g.st!=st||g.type!=NOTE&&g.type!=REST)break;case BAR:if(s.invis)break;case CLEF:y=a*s.x+b;if(s1.stem>0){y=s.ymx-y+BEAM_DEPTH+BEAM_SHIFT*(nflags-1)+2;if(y>0)b+=y}else{y=s.ymn-y-BEAM_DEPTH-BEAM_SHIFT*(nflags-1)-2;if(y<0)b+=y}break;case GRACE:for(g=s.extra;g;g=g.next){y=a*g.x+b;if(s1.stem>0){y=g.ymx-y+BEAM_DEPTH+BEAM_SHIFT*(nflags-1)+2;if(y>0)b+=y}else{y=g.ymn-y-BEAM_DEPTH-BEAM_SHIFT*(nflags-1)-2;if(y<0)b+=y}}break}if(s==s2)break}if(a==0)b+=b_pos(s1.grace,s1.stem,nflags,b-staff_tb[st].y);for(s=s1;;s=s.next){switch(s.type){case NOTE:s.ys=a*s.xs+b-staff_tb[s.st].y;if(s.stem>0){s.ymx=s.ys+2.5;if(s.ts_prev&&s.ts_prev.stem>0&&s.ts_prev.st==s.st&&s.ts_prev.ymn<s.ymx&&s.ts_prev.x==s.x&&s.notes[0].shhd==0){s.ts_prev.x-=5;s.ts_prev.xs-=5}}else{s.ymn=s.ys-2.5}break;case REST:y=a*s.x+b-staff_tb[s.st].y;dy=BEAM_DEPTH+BEAM_SHIFT*(nflags-1)+(s.head!=FULL?4:9);if(s1.stem>0){y-=dy;if(s1.multi==0&&y>12)y=12;if(s.y<=y)break}else{y+=dy;if(s1.multi==0&&y<12)y=12;if(s.y>=y)break}if(s.head!=FULL)y=((y+3+12)/6|0)*6-12;s.y=y;break}if(s==s2)break}if(staff_tb[st].y==0)return false;bm.s1=s1;bm.a=a;bm.b=b;bm.nflags=nflags;return true}function draw_beams(bm){var s,i,beam_dir,shift,bshift,bstub,bh,da,k,k1,k2,x1,s1=bm.s1,s2=bm.s2;function draw_beam(x1,x2,dy,h,bm,n){var y1,dy2,s=bm.s1,nflags=s.nflags;if(s.ntrem)nflags-=s.ntrem;if(s.trem2&&n>nflags){if(s.dur>=BASE_LEN/2){x1=s.x+6;x2=bm.s2.x-6}else if(s.dur<BASE_LEN/4){x1+=5;x2-=6}}y1=bm.a*x1+bm.b-dy;x2-=x1;x2/=stv_g.scale;dy2=bm.a*x2*stv_g.scale;xypath(x1,y1,true);output.push("l"+x2.toFixed(2)+" "+(-dy2).toFixed(2)+"v"+h.toFixed(2)+"l"+(-x2).toFixed(2)+" "+dy2.toFixed(2)+'"/>\n')}anno_start(s1,"beam");if(!s1.grace){bshift=BEAM_SHIFT;bstub=BEAM_STUB;shift=.34;bh=BEAM_DEPTH}else{bshift=3.5;bstub=3.2;shift=.29;bh=1.8}beam_dir=s1.stem;if(s1.stem!=s2.stem&&s1.nflags<s2.nflags)beam_dir=s2.stem;if(beam_dir<0)bh=-bh;draw_beam(s1.xs-shift,s2.xs+shift,0,bh,bm,1);da=0;for(s=s1;;s=s.next){if(s.type==NOTE&&s.stem!=beam_dir)s.ys=bm.a*s.xs+bm.b-staff_tb[s.st].y+bshift*(s.nflags-1)*s.stem-bh;if(s==s2)break}if(s1.feathered_beam){da=bshift/(s2.xs-s1.xs);if(s1.feathered_beam>0){da=-da;bshift=da*s1.xs}else{bshift=da*s2.xs}da=da*beam_dir}shift=0;for(i=2;i<=bm.nflags;i++){shift+=bshift;if(da!=0)bm.a+=da;for(s=s1;;s=s.next){if(s.type!=NOTE||s.nflags<i){if(s==s2)break;continue}if(s.trem1&&i>s.nflags-s.ntrem){x1=s.dur>=BASE_LEN/2?s.x:s.xs;draw_beam(x1-5,x1+5,(shift+2.5)*beam_dir,bh,bm,i);if(s==s2)break;continue}k1=s;while(1){if(s==s2)break;k=s.next;if(k.type==NOTE||k.type==REST){if(k.trem1){if(k.nflags-k.ntrem<i)break}else if(k.nflags<i){break}}if(k.beam_br1||k.beam_br2&&i>2)break;s=k}k2=s;while(k2.type!=NOTE)k2=k2.prev;x1=k1.xs;if(k1==k2){if(k1==s1){x1+=bstub}else if(k1==s2){x1-=bstub}else if(k1.beam_br1||k1.beam_br2&&i>2){x1+=bstub}else{k=k1.next;while(k.type!=NOTE)k=k.next;if(k.beam_br1||k.beam_br2&&i>2){x1-=bstub}else{k1=k1.prev;while(k1.type!=NOTE)k1=k1.prev;if(k1.nflags<k.nflags||k1.nflags==k.nflags&&k1.dots<k.dots)x1+=bstub;else x1-=bstub}}}draw_beam(x1,k2.xs,shift*beam_dir,bh,bm,i);if(s==s2)break}}if(s1.tmp)unlksym(s1);else if(s2.tmp)unlksym(s2);anno_stop(s1,"beam")}function draw_lstaff(x){var i,j,yb,h,nst=cur_sy.nstaff,l=0;function draw_sysbra(x,st,flag){var i,st_end,yt,yb;while(!cur_sy.st_print[st]){if(cur_sy.staves[st].flags&flag)return;st++}i=st_end=st;while(1){if(cur_sy.st_print[i])st_end=i;if(cur_sy.staves[i].flags&flag)break;i++}yt=staff_tb[st].y+staff_tb[st].topbar*staff_tb[st].staffscale;yb=staff_tb[st_end].y+staff_tb[st_end].botbar*staff_tb[st_end].staffscale;if(flag&(CLOSE_BRACE|CLOSE_BRACE2))out_brace(x,yb,yt-yb);else out_bracket(x,yt,yt-yb)}for(i=0;;i++){if(cur_sy.staves[i].flags&(OPEN_BRACE|OPEN_BRACKET))l++;if(cur_sy.st_print[i])break;if(cur_sy.staves[i].flags&(CLOSE_BRACE|CLOSE_BRACKET))l--;if(i==nst)break}for(j=nst;j>i;j--){if(cur_sy.st_print[j])break}if(i==j&&l==0)return;yb=staff_tb[j].y+staff_tb[j].botbar*staff_tb[j].staffscale;h=staff_tb[i].y+staff_tb[i].topbar*staff_tb[i].staffscale-yb;xypath(x,yb);output.push("v"+(-h).toFixed(2)+'"/>\n');for(i=0;i<=nst;i++){if(cur_sy.staves[i].flags&OPEN_BRACE)draw_sysbra(x,i,CLOSE_BRACE);if(cur_sy.staves[i].flags&OPEN_BRACKET)draw_sysbra(x,i,CLOSE_BRACKET);if(cur_sy.staves[i].flags&OPEN_BRACE2)draw_sysbra(x-6,i,CLOSE_BRACE2);if(cur_sy.staves[i].flags&OPEN_BRACKET2)draw_sysbra(x-6,i,CLOSE_BRACKET2)}}function draw_meter(x,s){if(!s.a_meter)return;var dx,i,st=s.st,p_staff=staff_tb[st],y=p_staff.y;if(p_staff.stafflines!="|||||"){for(i=0;i<p_staff.stafflines.length;i++){if(p_staff.stafflines[i].match(/[\[|]/))break}if(i==p_staff.stafflines.length)i--;y+=(i+p_staff.stafflines.length)*3-15}x-=s.wl;for(i=0;i<s.a_meter.length;i++){var f,meter=s.a_meter[i];if(meter.top=="C|")dx=13;else dx=13*meter.top.length;if(meter.bot){if(meter.bot.length>meter.top.length)dx=13*meter.bot.length;out_XYAB('<g style="font-family:serif; font-weight:bold; font-size: 16px"\n\ttransform="translate(X,Y) scale(1.2,1)">\n\t<text y="-12" text-anchor="middle">A</text>\n\t<text text-anchor="middle">B</text>\n</g>\n',x+dx*.5,y,meter.top,meter.bot)}else{switch(meter.top[0]){case"C":f=meter.top[1]!="|"?"csig":"ctsig";x-=5;y+=12;break;case"c":f=meter.top[1]!="."?"imsig":"iMsig";break;case"o":f=meter.top[1]!="."?"pmsig":"pMsig";break;default:out_XYAB('<g style="font-family:serif; font-weight:bold; font-size: 18px"\n\ttransform="translate(X,Y) scale(1.2,1)">\n\t<text y="-6" text-anchor="middle">A</text>\n</g>\n',x+dx*.5,y,meter.top);break}}if(f)xygl(x+dx*.5,y,f);x+=dx}}function draw_acc(x,y,acc,micro_n,micro_d){if(micro_n){if(micro_n==micro_d){acc=acc==-1?-2:2}else if(micro_n*2!=micro_d){xygl(x,y,"acc"+acc+"_"+micro_n+"_"+micro_d);return}}xygl(x,y,"acc"+acc)}function draw_hl(x,yl,yu,st,hltype){var i,p_staff=staff_tb[st],staffb=p_staff.y,top=(p_staff.stafflines.length-1)*6;yl=Math.ceil(yl/6)*6;for(;yl<p_staff.botline;yl+=6)xygl(x,staffb+yl,hltype);yu-=yu%6;for(;yu>top;yu-=6)xygl(x,staffb+yu,hltype)}var sharp_cl=new Int8Array([24,9,15,21,6,12,18]),flat_cl=new Int8Array([12,18,24,9,15,21,6]),sharp1=new Int8Array([-9,12,-9,-9,12,-9]),sharp2=new Int8Array([12,-9,12,-9,12,-9]),flat1=new Int8Array([9,-12,9,-12,9,-12]),flat2=new Int8Array([-12,9,-12,9,-12,9]);function draw_keysig(p_voice,x,s){if(s.k_none)return;var old_sf=s.k_old_sf,st=p_voice.st,staffb=staff_tb[st].y,i,shift,p_seq,clef_ix=s.k_y_clef;if(clef_ix&1)clef_ix+=7;clef_ix/=2;while(clef_ix<0)clef_ix+=7;clef_ix%=7;if(!s.k_a_acc){if(cfmt.cancelkey||s.k_sf==0){if(s.k_sf==0||old_sf*s.k_sf<0){shift=sharp_cl[clef_ix];p_seq=shift>9?sharp1:sharp2;for(i=0;i<old_sf;i++){xygl(x,staffb+shift,"acc3");shift+=p_seq[i];x+=5.5}shift=flat_cl[clef_ix];p_seq=shift<18?flat1:flat2;for(i=0;i>old_sf;i--){xygl(x,staffb+shift,"acc3");shift+=p_seq[-i];x+=5.5}if(s.k_sf!=0)x+=3}}if(s.k_sf>0){shift=sharp_cl[clef_ix];p_seq=shift>9?sharp1:sharp2;for(i=0;i<s.k_sf;i++){xygl(x,staffb+shift,"acc1");shift+=p_seq[i];x+=5.5}if(cfmt.cancelkey&&i<old_sf){x+=2;for(;i<old_sf;i++){xygl(x,staffb+shift,"acc3");shift+=p_seq[i];x+=5.5}}}if(s.k_sf<0){shift=flat_cl[clef_ix];p_seq=shift<18?flat1:flat2;for(i=0;i>s.k_sf;i--){xygl(x,staffb+shift,"acc-1");shift+=p_seq[-i];x+=5.5}if(cfmt.cancelkey&&i>old_sf){x+=2;for(;i>old_sf;i--){xygl(x,staffb+shift,"acc3");shift+=p_seq[-i];x+=5.5}}}}else if(s.k_a_acc.length){var acc,last_acc=s.k_a_acc[0].acc,last_shift=100;for(i=0;i<s.k_a_acc.length;i++){acc=s.k_a_acc[i];shift=(s.k_y_clef+acc.pit-18)*3;if(i!=0&&(shift>last_shift+18||shift<last_shift-18))x-=5.5;else if(acc.acc!=last_acc)x+=3;last_acc=acc.acc;draw_hl(x,shift,shift,st,"hl");last_shift=shift;draw_acc(x,staffb+shift,acc.acc,acc.micro_n,acc.micro_d);x+=5.5}}}function bar_cnv(bar_type){switch(bar_type){case"[":case"[]":return"";case"|:":case"|::":case"|:::":return"["+bar_type;case":|":case"::|":case":::|":return bar_type+"]";case"::":return cfmt.dblrepbar;case"||:":return"[|:"}return bar_type}function draw_bar(s,bot,h){var i,s2,yb,bar_type,st=s.st,x=s.x;bar_type=bar_cnv(s.bar_type);if(!bar_type)return;if(st!=0&&s.ts_prev&&s.ts_prev.type!=BAR)h=staff_tb[st].topbar*staff_tb[st].staffscale;s.ymx=s.ymn+h;set_sscale(-1);anno_start(s);if(s.bar_mrep){yb=staff_tb[st].y+12;set_sscale(st);if(s.bar_mrep==1){for(s2=s.prev;s2.type!=REST;s2=s2.prev);xygl(s2.x,yb,"mrep")}else{xygl(x,yb,"mrep2");if(s.v==cur_sy.top_voice){set_font("annotation");xy_str(x,yb+staff_tb[st].topbar-9,s.bar_mrep.toString(),"c")}}}for(i=bar_type.length;--i>=0;){switch(bar_type[i]){case"|":set_sscale(-1);out_bar(x,bot,h,s.bar_dotted);break;default:x-=3;set_sscale(-1);out_thbar(x,bot,h);break;case":":x-=2;set_sscale(st);xygl(x+1,staff_tb[st].y,"rdots");break}x-=3}set_sscale(-1);anno_stop(s)}var rest_tb=["r128","r64","r32","r16","r8","r4","r2","r1","r0","r00"];function draw_rest(s){var s2,i,j,x,y,dotx,staffb,yb,yt,head,p_staff=staff_tb[s.st];if(!p_staff.topbar)return;if(s.dur==s.p_v.meter.wmeasure||s.rep_nb&&s.rep_nb>=0){s2=s.ts_next;while(s2&&s2.time!=s.time+s.dur)s2=s2.ts_next;x=s2?s2.x:realwidth;s2=s;while(!s2.seqst)s2=s2.ts_prev;s2=s2.ts_prev;x=(x+s2.x)/2;if(s.a_dd)deco_update(s,x-s.x);s.x=x}else{x=s.x;if(s.notes[0].shhd)x+=s.notes[0].shhd*stv_g.scale}if(s.invis)return;staffb=p_staff.y;if(s.rep_nb){set_sscale(s.st);anno_start(s);staffb+=12;if(s.rep_nb<0){xygl(x,staffb,"srep")}else{xygl(x,staffb,"mrep");if(s.rep_nb>2&&s.v==cur_sy.top_voice){set_font("annotation");xy_str(x,staffb+p_staff.topbar-9,s.rep_nb.toString(),"c")}}anno_stop(s);return}set_scale(s);anno_start(s);y=s.y;i=5-s.nflags;if(i==7&&y==12&&p_staff.stafflines.length<=2)y-=6;xygl(x,y+staffb,s.notes[0].head?s.notes[0].head:rest_tb[i]);if(i>=6){j=y/6;switch(i){default:switch(p_staff.stafflines[j+1]){case"|":case"[":break;default:xygl(x,y+6+staffb,"hl1");break}if(i==9){y-=6;j--}break;case 7:y+=6;j++;case 6:break}switch(p_staff.stafflines[j]){case"|":case"[":break;default:xygl(x,y+staffb,"hl1");break}}x+=8;y+=staffb+3;for(i=0;i<s.dots;i++){xygl(x,y,"dot");x+=3.5}anno_stop(s)}function draw_gracenotes(s){var yy,x0,y0,x1,y1,x2,y2,x3,y3,bet1,bet2,dy1,dy2,g,last,note,bm={};for(g=s.extra;g;g=g.next){if(g.beam_st&&!g.beam_end){if(calculate_beam(bm,g))draw_beams(bm)}anno_start(g);draw_note(g,!bm.s2);if(g==bm.s2)bm.s2=null;anno_stop(g);if(!g.next)break}if(s.sappo){g=s.extra;if(!g.next){x1=9;y1=g.stem>0?5:-5}else{x1=(g.next.x-g.x)*.5+4;y1=(g.ys+g.next.ys)*.5-g.y;if(g.stem>0)y1-=1;else y1+=1}note=g.notes[g.stem<0?0:g.nhd];out_acciac(x_head(g,note),y_head(g,note),x1,y1,g.stem>0)}if(s.p_v.key.k_bagpipe||!cfmt.graceslurs||s.slur_start||!s.next||s.next.type!=NOTE)return;last=g;if(last.stem>=0){yy=127;for(g=s.extra;g;g=g.next){if(g.y<yy){yy=g.y;last=g}}x0=last.x;y0=last.y-5;if(s.extra!=last){x0-=4;y0+=1}s=s.next;x3=s.x-1;if(s.stem<0)x3-=4;y3=3*(s.notes[0].pit-18)-5;dy1=(x3-x0)*.4;if(dy1>3)dy1=3;dy2=dy1;bet1=.2;bet2=.8;if(y0>y3+7){x0=last.x-1;y0+=.5;y3+=6.5;x3=s.x-5.5;dy1=(y0-y3)*.8;dy2=(y0-y3)*.2;bet1=0}else if(y3>y0+4){y3=y0+4;x0=last.x+2;y0=last.y-4}}else{yy=-127;for(g=s.extra;g;g=g.next){if(g.y>yy){yy=g.y;last=g}}x0=last.x;y0=last.y+5;if(s.extra!=last){x0-=4;y0-=1}s=s.next;x3=s.x-1;if(s.stem>=0)x3-=2;y3=3*(s.notes[s.nhd].pit-18)+5;dy1=(x0-x3)*.4;if(dy1<-3)dy1=-3;dy2=dy1;bet1=.2;bet2=.8;if(y0<y3-7){x0=last.x-1;y0-=.5;y3-=6.5;x3=s.x-5.5;dy1=(y0-y3)*.8;dy2=(y0-y3)*.2;bet1=0}else if(y3<y0-4){y3=y0-4;x0=last.x+2;y0=last.y+4}}x1=bet1*x3+(1-bet1)*x0-x0;y1=bet1*y3+(1-bet1)*y0-dy1-y0;x2=bet2*x3+(1-bet2)*x0-x0;y2=bet2*y3+(1-bet2)*y0-dy2-y0;anno_start(s,"slur");xypath(x0,y0+staff_tb[s.st].y);output.push("c"+x1.toFixed(2)+" "+(-y1).toFixed(2)+" "+x2.toFixed(2)+" "+(-y2).toFixed(2)+" "+(x3-x0).toFixed(2)+" "+(-y3+y0).toFixed(2)+'"/>\n');anno_stop(s,"slur")}function setdoty(s,y_tb){var m,m1,y;for(m=0;m<=s.nhd;m++){y=3*(s.notes[m].pit-18);if(y%6==0){if(s.dot_low)y-=3;else y+=3}y_tb[m]=y}for(m=0;m<s.nhd;m++){if(y_tb[m+1]>y_tb[m])continue;m1=m;while(m1>0){if(y_tb[m1]>y_tb[m1-1]+6)break;m1--}if(3*(s.notes[m1].pit-18)-y_tb[m1]<y_tb[m+1]-3*(s.notes[m+1].pit-18)){while(m1<=m)y_tb[m1++]-=6}else{y_tb[m+1]=y_tb[m]+6}}}function x_head(s,note){return s.x+note.shhd}function y_head(s,note){return staff_tb[s.st].y+3*(note.pit-18)}function draw_basic_note(x,s,m,y_tb){var i,k,y,p,yy,dotx,doty,old_color=false,note=s.notes[m],staffb=staff_tb[s.st].y,y=3*(note.pit-18),shhd=note.shhd*stv_g.scale,x_note=x+shhd,y_note=y+staffb;var elts=identify_note(s,note.dur),head=elts[0],dots=elts[1],nflags=elts[2];if(y%6==0&&shhd!=(s.stem>0?s.notes[0].shhd:s.notes[s.nhd].shhd)){yy=0;if(y>=30){yy=y;if(yy%6)yy-=3}else if(y<=-6){yy=y;if(yy%6)yy+=3}if(yy)xygl(x_note,yy+staffb,"hl")}if(note.invis){}else if(s.grace){p="ghd";x_note-=4.5*stv_g.scale}else if(note.map&&note.map[0]){i=s.head;p=note.map[0][i];if(!p)p=note.map[0][note.map[0].length-1];i=p.indexOf("/");if(i>=0){if(s.stem>=0)p=p.slice(0,i);else p=p.slice(i+1)}}else if(s.type==CUSTOS){p="custos"}else{switch(head){case OVAL:p="HD";break;case OVALBARS:if(s.head!=SQUARE){p="HDD";break}case SQUARE:p=note.dur<BASE_LEN*4?"breve":"longa";if(!tsnext&&s.next&&s.next.type==BAR&&!s.next.next)dots=0;break;case EMPTY:p="Hd";break;default:p="hd";break}}if(note.color)old_color=set_color(note.color);else if(note.map&&note.map[2])old_color=set_color(note.map[2]);if(p){if(!psxygl(x_note,y_note,p))xygl(x_note,y_note,p)}if(dots){dotx=x+(7.7+s.xmx)*stv_g.scale;if(y_tb[m]==undefined){y_tb[m]=3*(s.notes[m].pit-18);if((s.notes[m].pit&1)==0)y_tb[m]+=3}doty=y_tb[m]+staffb;while(--dots>=0){xygl(dotx,doty,"dot");dotx+=3.5}}if(note.acc){x-=note.shac*stv_g.scale;if(!s.grace){draw_acc(x,y+staffb,note.acc,note.micro_n,note.micro_d)}else{g_open(x,y+staffb,0,.75);draw_acc(0,0,note.acc,note.micro_n,note.micro_d);g_close()}}if(old_color!=false)set_color(old_color)}function draw_note(s,fl){var s2,i,m,y,staffb,slen,c,hltype,nflags,x,y,note,y_tb=new Array(s.nhd+1);if(s.dots)setdoty(s,y_tb);note=s.notes[s.stem<0?s.nhd:0];x=x_head(s,note);staffb=staff_tb[s.st].y;if(s.grace){hltype="ghl"}else{switch(s.head){default:hltype="hl";break;case OVAL:case OVALBARS:hltype="hl1";break;case SQUARE:hltype="hl2";break}}draw_hl(x,3*(s.notes[0].pit-18),3*(s.notes[s.nhd].pit-18),s.st,hltype);y=y_head(s,note);if(!s.stemless){slen=s.ys-s.y;nflags=s.nflags;if(s.ntrem)nflags-=s.ntrem;if(!fl||nflags<=0){if(s.nflags>0){if(s.stem>=0)slen-=1;else slen+=1}out_stem(x,y,slen,s.grace)}else{out_stem(x,y,slen,s.grace,nflags,cfmt.straightflags)}}else if(s.xstem){s2=s.ts_prev;slen=(s2.stem>0?s2.y:s2.ys)-s.y;slen+=staff_tb[s2.st].y-staffb;slen/=s.p_v.scale;out_stem(x,y,slen)}if(fl&&s.trem1){var ntrem=s.ntrem||0,x1=x;slen=3*(s.notes[s.stem>0?s.nhd:0].pit-18);if(s.head==FULL||s.head==EMPTY){x1+=(s.grace?GSTEM_XOFF:3.5)*s.stem;if(s.stem>0)slen+=6+5.4*ntrem;else slen-=6+5.4}else{if(s.stem>0)slen+=5+5.4*ntrem;else slen-=5+5.4}slen/=s.p_v.scale;out_trem(x1,staffb+slen,ntrem)}x=s.x;for(m=0;m<=s.nhd;m++)draw_basic_note(x,s,m,y_tb)}function next_scut(s){var prev=s;for(s=s.next;s;s=s.next){if(s.rbstop)return s;prev=s}return prev}function prev_scut(s){while(s.prev){s=s.prev;if(s.rbstart)return s}s=s.p_v.sym;while(s.type!=CLEF)s=s.ts_prev;if(s.next&&s.next.type==KEY)s=s.next;if(s.next&&s.next.type==METER)return s.next;return s}function slur_direction(k1,k2){var s,some_upstem,low;if(k1.grace&&k1.stem>0)return-1;for(s=k1;;s=s.next){if(s.type==NOTE){if(!s.stemless){if(s.stem<0)return 1;some_upstem=true}if(s.notes[0].pit<22)low=true}if(s==k2)break}if(!some_upstem&&!low)return 1;return-1}function slur_out(x1,y1,x2,y2,dir,height,dotted){var dx,dy,dz,alfa=.3,beta=.45;dy=y2-y1;if(dy<0)dy=-dy;dx=x2-x1;if(dx>40&&dy/dx<.7){alfa=.3+.002*(dx-40);if(alfa>.7)alfa=.7}var mx=.5*(x1+x2),my=.5*(y1+y2),xx1=mx+alfa*(x1-mx),yy1=my+alfa*(y1-my)+height;xx1=x1+beta*(xx1-x1);yy1=y1+beta*(yy1-y1);var xx2=mx+alfa*(x2-mx),yy2=my+alfa*(y2-my)+height;xx2=x2+beta*(xx2-x2);yy2=y2+beta*(yy2-y2);dx=.03*(x2-x1);dy=2*dir;dz=.2+.001*(x2-x1);if(dz>.6)dz=.6;dz*=dir;var scale_y=stv_g.v?stv_g.scale:1;if(!dotted)output.push('<path class="fill" d="M');else output.push('<path class="stroke" stroke-dasharray="5,5" d="M');out_sxsy(x1," ",y1);output.push("c"+((xx1-x1)/stv_g.scale).toFixed(2)+" "+((y1-yy1)/scale_y).toFixed(2)+" "+((xx2-x1)/stv_g.scale).toFixed(2)+" "+((y1-yy2)/scale_y).toFixed(2)+" "+((x2-x1)/stv_g.scale).toFixed(2)+" "+((y1-y2)/scale_y).toFixed(2));if(!dotted)output.push("\n\tv"+(-dz).toFixed(2)+"c"+((xx2-dx-x2)/stv_g.scale).toFixed(2)+" "+((y2+dz-yy2-dy)/scale_y).toFixed(2)+" "+((xx1+dx-x2)/stv_g.scale).toFixed(2)+" "+((y2+dz-yy1-dy)/scale_y).toFixed(2)+" "+((x1-x2)/stv_g.scale).toFixed(2)+" "+((y2+dz-y1)/scale_y).toFixed(2));output.push('"/>\n')}function slur_multi(k1,k2){while(1){if(k1.multi)return k1.multi;if(k1==k2)break;k1=k1.next}return 0}function draw_slur(k1_o,k2,m1,m2,slur_type){var k1=k1_o,k,g,x1,y1,x2,y2,height,addy,a,y,z,h,dx,dy,dir;while(k1.v!=k2.v)k1=k1.ts_next;switch(slur_type&7){case SL_ABOVE:dir=1;break;case SL_BELOW:dir=-1;break;default:dir=slur_multi(k1,k2);if(!dir)dir=slur_direction(k1,k2);break}var nn=1,upstaff=k1.st,two_staves=false;if(k1!=k2){k=k1.next;while(1){if(k.type==NOTE||k.type==REST){nn++;if(k.st!=upstaff){two_staves=true;if(k.st<upstaff)upstaff=k.st}}if(k==k2)break;k=k.next}}if(two_staves)error(2,k1,"*** multi-staves slurs not treated yet");x1=k1_o.x;if(k1_o.notes&&k1_o.notes[0].shhd)x1+=k1_o.notes[0].shhd;if(k1_o!=k2){x2=k2.x;if(k2.notes)x2+=k2.notes[0].shhd}else{for(k=k2.ts_next;k;k=k.ts_next)if(k.type==STAVES)break;x2=k?k.x:realwidth}if(m1>=0){y1=3*(k1.notes[m1].pit-18)+5*dir}else{y1=dir>0?k1.ymx+2:k1.ymn-2;if(k1.type==NOTE){if(dir>0){if(k1.stem>0){x1+=5;if(k1.beam_end&&k1.nflags>=-1&&!k1.in_tuplet){if(k1.nflags>0){x1+=2;y1=k1.ys-3}else{y1=k1.ys-6}}}}else{if(k1.stem<0){x1-=1;if(k2.grace){y1=k1.y-8}else if(k1.beam_end&&k1.nflags>=-1&&(!k1.in_tuplet||k1.ys<y1+3)){if(k1.nflags>0){x1+=2;y1=k1.ys+3}else{y1=k1.ys+6}}}}}}if(m2>=0){y2=3*(k2.notes[m2].pit-18)+5*dir}else{y2=dir>0?k2.ymx+2:k2.ymn-2;if(k2.type==NOTE){if(dir>0){if(k2.stem>0){x2+=1;if(k2.beam_st&&k2.nflags>=-1&&!k2.in_tuplet)y2=k2.ys-6}}else{if(k2.stem<0){x2-=5;if(k2.beam_st&&k2.nflags>=-1&&!k2.in_tuplet)y2=k2.ys+6}}}}if(k1.type!=NOTE){y1=y2+1.2*dir;x1=k1.x+k1.wr*.5;if(x1>x2-12)x1=x2-12}if(k2.type!=NOTE){if(k1.type==NOTE)y2=y1+1.2*dir;else y2=y1;if(k1!=k2)x2=k2.x-k2.wl*.3}if(nn>=3){if(k1.next.type!=BAR&&k1.next.x<x1+48){if(dir>0){y=k1.next.ymx-2;if(y1<y)y1=y}else{y=k1.next.ymn+2;if(y1>y)y1=y}}if(k2.prev&&k2.prev.type!=BAR&&k2.prev.x>x2-48){if(dir>0){y=k2.prev.ymx-2;if(y2<y)y2=y}else{y=k2.prev.ymn+2;if(y2>y)y2=y}}}a=(y2-y1)/(x2-x1);if(a>SLUR_SLOPE||a<-SLUR_SLOPE){a=a>SLUR_SLOPE?SLUR_SLOPE:-SLUR_SLOPE;if(a*dir>0)y1=y2-a*(x2-x1);else y2=y1+a*(x2-x1)}y=y2-y1;if(y>8)y=8;else if(y<-8)y=-8;z=y;if(z<0)z=-z;dx=.5*z;dy=.3*y;if(y*dir>0){x2-=dx;y2-=dy}else{x1+=dx;y1+=dy}if(k1.grace)x1=k1.x-GSTEM_XOFF*.5;if(k2.grace)x2=k2.x+GSTEM_XOFF*1.5;h=0;a=(y2-y1)/(x2-x1);if(k1!=k2&&k1.v==k2.v){addy=y1-a*x1;for(k=k1.next;k!=k2;k=k.next){if(k.st!=upstaff)continue;switch(k.type){case NOTE:case REST:if(dir>0){y=3*(k.notes[k.nhd].pit-18)+6;if(y<k.ymx)y=k.ymx;y-=a*k.x+addy;if(y>h)h=y}else{y=3*(k.notes[0].pit-18)-6;if(y>k.ymn)y=k.ymn;y-=a*k.x+addy;if(y<h)h=y}break;case GRACE:for(g=k.extra;g;g=g.next){if(dir>0){y=3*(g.notes[g.nhd].pit-18)+6;if(y<g.ymx)y=g.ymx;y-=a*g.x+addy;if(y>h)h=y}else{y=3*(g.notes[0].pit-18)-6;if(y>g.ymn)y=g.ymn;y-=a*g.x+addy;if(y<h)h=y}}break}}y1+=.45*h;y2+=.45*h;h*=.65}if(nn>3)height=(.08*(x2-x1)+12)*dir;else height=(.03*(x2-x1)+8)*dir;if(dir>0){if(height<3*h)height=3*h;if(height>40)height=40}else{if(height>3*h)height=3*h;if(height<-40)height=-40}y=y2-y1;if(y<0)y=-y;if(dir>0){if(height<.8*y)height=.8*y}else{if(height>-.8*y)height=-.8*y}height*=cfmt.slurheight;slur_out(x1,y1,x2,y2,dir,height,slur_type&SL_DOTTED);dx=x2-x1;a=(y2-y1)/dx;addy=y1-a*x1+.4*height;if(k1.v==k2.v)for(k=k1;k!=k2;k=k.next){if(k.st!=upstaff)continue;y=a*k.x+addy;if(k.ymx<y)k.ymx=y;else if(k.ymn>y)k.ymn=y;if(k.next==k2){dx=x2;if(k2.sl1)dx-=5}else{dx=k.next.x}if(k!=k1)x1=k.x;dx-=x1;y_set(upstaff,dir>0,x1,dx,y)}return(dir>0?SL_ABOVE:SL_BELOW)|slur_type&SL_DOTTED}function draw_slurs(first,last){var s1,k,gr1,gr2,i,m1,m2,slur_type,cont,s=first;while(1){if(!s||s==last){if(!gr1||!(s=gr1.next)||s==last)break;gr1=null}if(s.type==GRACE){gr1=s;s=s.extra;continue}if(s.type!=NOTE&&s.type!=REST&&s.type!=SPACE||!s.slur_start&&!s.sl1){s=s.next;continue}k=null;s1=s.next;var gr1_out=false;while(1){if(!s1){if(gr2){s1=gr2.next;gr2=null;continue}if(!gr1||gr1_out)break;s1=gr1.next;gr1_out=true;continue}if(s1.type==GRACE){gr2=s1;s1=s1.extra;continue}if(s1.type==BAR&&(s1.bar_type[0]==":"||s1.bar_type=="|]"||s1.bar_type=="[|"||s1.text&&s1.text[0]!="1")){k=s1;break}if(s1.type!=NOTE&&s1.type!=REST&&s1.type!=SPACE){s1=s1.next;continue}if(s1.slur_end||s1.sl2){k=s1;break}if(s1.slur_start||s1.sl1){if(gr2){for(k=s1;k.next;k=k.next);k.next=gr2.next;if(gr2.next)gr2.next.prev=k;k=null}draw_slurs(s1,last);if(gr2&&gr2.next){gr2.next.prev.next=null;gr2.next.prev=gr2}}if(s1==last)break;s1=s1.next}if(!s1){k=next_scut(s)}else if(!k){s=s1;if(s==last)break;continue}if(gr1){for(s1=s;s1.next;s1=s1.next);s1.next=gr1.next;if(gr1.next)gr1.next.prev=s1;gr1.slur_start=SL_AUTO}if(gr2){gr2.prev.next=gr2.extra;gr2.extra.prev=gr2.prev;gr2.slur_start=SL_AUTO}if(s.slur_start){slur_type=s.slur_start&15;s.slur_start>>=4;m1=-1}else{for(m1=0;m1<=s.nhd;m1++)if(s.notes[m1].sl1)break;slur_type=s.notes[m1].sl1&15;s.notes[m1].sl1>>=4;s.sl1--}m2=-1;cont=0;if((k.type==NOTE||k.type==REST||k.type==SPACE)&&(k.slur_end||k.sl2)){if(k.slur_end){k.slur_end--}else{for(m2=0;m2<=k.nhd;m2++)if(k.notes[m2].sl2)break;k.notes[m2].sl2--;k.sl2--}}else{if(k.type!=BAR||k.bar_type[0]!=":"&&k.bar_type!="|]"&&k.bar_type!="[|"&&(!k.text||k.text[0]=="1"))cont=1}slur_type=draw_slur(s,k,m1,m2,slur_type);if(cont){if(!k.p_v.slur_start)k.p_v.slur_start=0;k.p_v.slur_start<<=4;k.p_v.slur_start+=slur_type}if(gr1&&gr1.next){gr1.next.prev.next=null;gr1.next.prev=gr1}if(gr2){gr2.prev.next=gr2;gr2.extra.prev=null}if(s.slur_start||s.sl1)continue;if(s==last)break;s=s.next}}function draw_tuplet(s1,lvl){var s2,s3,g,upstaff,nb_only,some_slur,x1,x2,y1,y2,xm,ym,a,s0,yy,yx,dy,a,b,dir,p,q,r;upstaff=s1.st;for(s2=s1;s2;s2=s2.next){if(s2.type!=NOTE&&s2.type!=REST){if(s2.type==GRACE){for(g=s2.extra;g;g=g.next){if(g.slur_start||g.sl1)some_slur=true}}continue}if(s2.slur_start||s2.slur_end||s2.sl1||s2.sl2)some_slur=true;if(s2.st<upstaff)upstaff=s2.st;if(lvl==0){if(s2.tp1)draw_tuplet(s2,1);if(s2.te0)break}else if(s2.te1)break}if(!s2){error(1,s1,"No end of tuplet in this music line");if(lvl==0)s1.tp0=0;else s1.tp1=0;return}if(some_slur){draw_slurs(s1,s2);if(s1.slur_start||s1.sl1)return;for(s3=s1.next;s3!=s2;s3=s3.next){if(s3.slur_start||s3.slur_end||s3.sl1||s3.sl2)return}if(s2.slur_end||s2.sl2)return}if(lvl==0){p=s1.tp0;s1.tp0=0;q=s1.tq0}else{p=s1.tp1;s1.tp1=0;q=s1.tq1}if(s1.tf[0]==1)return;dir=s1.tf[3];if(!dir)dir=s1.stem>0?SL_ABOVE:SL_BELOW;if(s1==s2){nb_only=true}else if(s1.tf[1]==1){nb_only=true;draw_slur(s1,s2,-1,-1,dir)}else{if(s1.tf[0]==2||s1.type!=NOTE||s2.type!=NOTE){nb_only=false}else{nb_only=true;for(s3=s1;;s3=s3.next){if(s3.type!=NOTE&&s3.type!=REST){if(s3.type==GRACE||s3.type==SPACE)continue;nb_only=false;break}if(s3==s2)break;if(s3.beam_end){nb_only=false;break}}if(nb_only&&!s1.beam_st&&!s1.beam_br1&&!s1.beam_br2){for(s3=s1.prev;s3;s3=s3.prev){if(s3.type==NOTE||s3.type==REST){if(s3.nflags>=s1.nflags)nb_only=false;break}}}if(nb_only&&!s2.beam_end){for(s3=s2.next;s3;s3=s3.next){if(s3.type==NOTE||s3.type==REST){if(!s3.beam_br1&&!s3.beam_br2&&s3.nflags>=s2.nflags)nb_only=false;break}}}}}if(nb_only){if(s1.tf[2]==1)return;xm=(s2.x+s1.x)/2;if(s1==s2)a=0;else a=(s2.ys-s1.ys)/(s2.x-s1.x);b=s1.ys-a*s1.x;yy=a*xm+b;if(dir==SL_ABOVE){ym=y_get(upstaff,1,xm-4,8);if(ym>yy)b+=ym-yy;b+=2}else{ym=y_get(upstaff,0,xm-4,8);if(ym<yy)b+=ym-yy;b-=10}for(s3=s1;;s3=s3.next){if(s3.x>=xm)break}if(s1.stem*s2.stem>0){if(s1.stem>0)xm+=1.5;else xm-=1.5}ym=a*xm+b;if(s1.tf[2]==0)out_bnum(xm,ym,p);else out_bnum(xm,ym,p+":"+q);if(dir==SL_ABOVE){ym+=10;if(s3.ymx<ym)s3.ymx=ym;y_set(upstaff,true,xm-3,6,ym)}else{if(s3.ymn>ym)s3.ymn=ym;y_set(upstaff,false,xm-3,6,ym)}return}if(s1.tf[1]!=0)error(2,s1,"'what' value of %%tuplets not yet coded");dir=s1.tf[3];if(!dir)dir=s1.multi>=0?SL_ABOVE:SL_BELOW;if(dir==SL_ABOVE){if(s1.st==s2.st){y1=y2=staff_tb[upstaff].topbar+4}else{y1=s1.ymx;y2=s2.ymx}x1=s1.x-4;if(s1.st==upstaff){for(s3=s1;!s3.dur;s3=s3.next);ym=y_get(upstaff,1,s3.x-4,8);if(ym>y1)y1=ym;if(s1.stem>0)x1+=3}if(s2.st==upstaff){for(s3=s2;!s3.dur;s3=s3.prev);ym=y_get(upstaff,1,s3.x-4,8);if(ym>y2)y2=ym}if(s2.dur>s2.prev.dur){if(s2.next)x2=s2.next.x-s2.next.wl-5;else x2=realwidth-6}else{x2=s2.x+4;r=s2.stem>=0?0:s2.nhd;if(s2.notes[r].shhd>0)x2+=s2.notes[r].shhd;if(s2.st==upstaff&&s2.stem>0)x2+=3.5}xm=.5*(x1+x2);ym=.5*(y1+y2);a=(y2-y1)/(x2-x1);s0=3*(s2.notes[s2.nhd].pit-s1.notes[s1.nhd].pit)/(x2-x1);if(s0>0){if(a<0)a=0;else if(a>s0)a=s0}else{if(a>0)a=0;else if(a<s0)a=s0}if(a*a<.1*.1)a=0;dy=0;for(s3=s1;;s3=s3.next){if(!s3.dur||s3.st!=upstaff){if(s3==s2)break;continue}yy=ym+(s3.x-xm)*a;yx=y_get(upstaff,1,s3.x-4,8)+2;if(yx-yy>dy)dy=yx-yy;if(s3==s2)break}ym+=dy;y1=ym+a*(x1-xm);y2=ym+a*(x2-xm);ym+=8;for(s3=s1;;s3=s3.next){if(s3.st==upstaff){yy=ym+(s3.x-xm)*a;if(s3.ymx<yy)s3.ymx=yy;if(s3==s2)break;y_set(upstaff,true,s3.x,s3.next.x-s3.x,yy)}else if(s3==s2){break}}}else{x1=s1.x-7;if(s2.dur>s2.prev.dur){if(s2.next)x2=s2.next.x-s2.next.wl-8;else x2=realwidth-6}else{x2=s2.x+2;if(s2.notes[s2.nhd].shhd>0)x2+=s2.notes[s2.nhd].shhd}if(s1.stem>=0){x1+=2;x2+=2}if(s1.st==upstaff){for(s3=s1;!s3.dur;s3=s3.next);y1=y_get(upstaff,0,s3.x-4,8)}else{y1=0}if(s2.st==upstaff){for(s3=s2;!s3.dur;s3=s3.prev);y2=y_get(upstaff,0,s3.x-4,8)}else{y2=0}xm=.5*(x1+x2);ym=.5*(y1+y2);a=(y2-y1)/(x2-x1);s0=3*(s2.notes[0].pit-s1.notes[0].pit)/(x2-x1);if(s0>0){if(a<0)a=0;else if(a>s0)a=s0}else{if(a>0)a=0;else if(a<s0)a=s0}if(a*a<.1*.1)a=0;dy=0;for(s3=s1;;s3=s3.next){if(!s3.dur||s3.st!=upstaff){if(s3==s2)break;continue}yy=ym+(s3.x-xm)*a;yx=y_get(upstaff,0,s3.x-4,8);if(yx-yy<dy)dy=yx-yy;if(s3==s2)break}ym+=dy-10;y1=ym+a*(x1-xm);y2=ym+a*(x2-xm);ym-=2;for(s3=s1;;s3=s3.next){if(s3.st==upstaff){if(s3==s2)break;yy=ym+(s3.x-xm)*a;if(s3.ymn>yy)s3.ymn=yy;y_set(upstaff,false,s3.x,s3.next.x-s3.x,yy)}if(s3==s2)break}}if(s1.tf[2]==1){out_tubr(x1,y1+4,x2-x1,y2-y1,dir==SL_ABOVE);return}out_tubrn(x1,y1,x2-x1,y2-y1,dir==SL_ABOVE,s1.tf[2]==0?p.toString():p+":"+q);yy=.5*(y1+y2);if(dir==SL_ABOVE)y_set(upstaff,true,xm-3,6,yy+9);else y_set(upstaff,false,xm-3,6,yy)}function draw_note_ties(k1,k2,mhead1,mhead2,job){var i,dir,m1,m2,p,p2,y,st,k,x1,x2,h,sh,time;for(i=0;i<mhead1.length;i++){m1=mhead1[i];p=k1.notes[m1].pit;m2=mhead2[i];p2=job!=2?k2.notes[m2].pit:p;dir=(k1.notes[m1].ti1&7)==SL_ABOVE?1:-1;x1=k1.x;sh=k1.notes[m1].shhd;if(dir>0){if(m1<k1.nhd&&p+1==k1.notes[m1+1].pit)if(k1.notes[m1+1].shhd>sh)sh=k1.notes[m1+1].shhd}else{if(m1>0&&p==k1.notes[m1-1].pit+1)if(k1.notes[m1-1].shhd>sh)sh=k1.notes[m1-1].shhd}x1+=sh*.6;x2=k2.x;if(job!=2){sh=k2.notes[m2].shhd;if(dir>0){if(m2<k2.nhd&&p2+1==k2.notes[m2+1].pit)if(k2.notes[m2+1].shhd<sh)sh=k2.notes[m2+1].shhd}else{if(m2>0&&p2==k2.notes[m2-1].pit+1)if(k2.notes[m2-1].shhd<sh)sh=k2.notes[m2-1].shhd}x2+=sh*.6}st=k1.st;switch(job){case 0:if(p!=p2&&!(p&1))p=p2;break;case 3:dir=-dir;case 1:x1=k1.x;if(x1>x2-20)x1=x2-20;p=p2;st=k2.st;break;default:if(k1!=k2){x2-=k2.wl;if(k2.type==BAR)x2+=5}else{time=k1.time+k1.dur;for(k=k1.ts_next;k;k=k.ts_next)if(k.time>time)break;x2=k?k.x:realwidth}if(x2<x1+16)x2=x1+16;break}if(x2-x1>20){x1+=3.5;x2-=3.5}else{x1+=1.5;x2-=1.5}y=3*(p-18);if(job!=1&&job!=3){if(dir>0){if(!(p&1)&&k1.dots)y=3*(p-18)+6}}h=(.04*(x2-x1)+10)*dir;slur_out(x1,staff_tb[st].y+y,x2,staff_tb[st].y+y,dir,h,k1.notes[m1].ti1&SL_DOTTED)}}function draw_ties(k1,k2,job){var k3,i,j,m1,pit,tie2,mhead1=[],mhead2=[],mhead3=[],nh1=k1.nhd,time=k1.time+k1.dur;if(job==2){for(i=0;i<=nh1;i++){if(k1.notes[i].ti1)mhead3.push(i)}draw_note_ties(k1,k2||k1,mhead3,mhead3,job);return}for(i=0;i<=nh1;i++){if(!k1.notes[i].ti1)continue;tie2=-1;pit=k1.notes[i].apit;for(m1=k2.nhd;m1>=0;m1--){switch(k2.notes[m1].apit-pit){case 1:case-1:if(k1.notes[i].acc!=k2.notes[m1].acc)tie2=m1;default:continue;case 0:tie2=m1;break}break}if(tie2>=0){mhead1.push(i);mhead2.push(tie2)}else{mhead3.push(i)}}draw_note_ties(k1,k2,mhead1,mhead2,job);if(!mhead3.length)return;k3=k1.ts_next;while(k3&&k3.time<time)k3=k3.ts_next;while(k3&&k3.time==time){if(k3.type!=NOTE||k3.st!=k1.st){k3=k3.ts_next;continue}mhead1.length=0;mhead2.length=0;for(i=mhead3.length;--i>=0;){j=mhead3[i];pit=k1.notes[j].apit;for(m1=k3.nhd;m1>=0;m1--){if(k3.notes[m1].apit==pit){mhead1.push(j);mhead2.push(m1);mhead3[i]=mhead3.pop();break}}}if(mhead1.length>0){draw_note_ties(k1,k3,mhead1,mhead2,job==1?1:0);if(mhead3.length==0)return}k3=k3.ts_next}if(mhead3.length!=0)error(1,k1,"Bad tie")}function tie_comb(s){var s1,time,st;time=s.time+s.dur;st=s.st;for(s1=s.ts_next;s1;s1=s1.ts_next){if(s1.st!=st)continue;if(s1.time==time){if(s1.type==NOTE)return s1;continue}if(s1.time>time)return s}return}function draw_all_ties(p_voice){var s1,s2,s3,clef_chg,time,s_rtie,s_tie,x,dx;function draw_ties_g(s1,s2,job){var g;if(s1.type==GRACE){for(g=s1.extra;g;g=g.next){if(g.ti1)draw_ties(g,s2,job)}}else{draw_ties(s1,s2,job)}}for(s1=p_voice.sym;s1;s1=s1.next){switch(s1.type){case CLEF:case KEY:case METER:continue}break}s_rtie=p_voice.s_rtie;for(s2=s1;s2;s2=s2.next){if(s2.dur||s2.type==GRACE)break;if(s2.type!=BAR||!s2.text)continue;if(s2.text[0]=="1")s_rtie=p_voice.s_tie;else p_voice.s_tie=s_rtie}if(!s2)return;if(p_voice.s_tie){p_voice.s_tie.x=s1.x+s1.wr;s1=p_voice.s_tie;p_voice.s_tie=null;s1.st=s2.st;s1.ts_next=s2.ts_next;s1.time=s2.time-s1.dur;draw_ties(s1,s2,1)}while(1){for(s1=s2;s1;s1=s1.next){if(s1.ti1)break;if(!s_rtie)continue;if(s1.type!=BAR||!s1.text)continue;if(s1.text[0]=="1"){s_rtie=null;continue}if(s1.bar_type=="|")continue;for(s2=s1.next;s2;s2=s2.next)if(s2.type==NOTE)break;if(!s2){s1=null;break}s_tie=clone(s_rtie);s_tie.x=s1.x;s_tie.next=s2;s_tie.st=s2.st;s_tie.time=s2.time-s_tie.dur;draw_ties(s_tie,s2,1)}if(!s1)break;time=s1.time+s1.dur;for(s2=s1.next;s2;s2=s2.next){if(s2.dur)break;if(s2.text){if(s2.text[0]!="1")break;s_rtie=s1}}if(!s2){for(s2=s1.ts_next;s2;s2=s2.ts_next){if(s2.st!=s1.st)continue;if(s2.time<time)continue;if(s2.time>time){s2=null;break}if(s2.dur)break}if(!s2){draw_ties_g(s1,null,2);p_voice.s_tie=s1;break}}else{if(s2.type!=NOTE&&s2.type!=BAR){error(1,s1,"Bad tie");continue}if(s2.time!=time){s3=tie_comb(s1);if(s3==s1){error(1,s1,"Bad tie");continue}s2=s3}}for(s3=s1.ts_next;s3;s3=s3.ts_next){if(s3.st!=s1.st)continue;if(s3.time>time)break;if(s3.type==CLEF){clef_chg=true;continue}}if(clef_chg||s1.st!=s2.st){clef_chg=false;dx=(s2.x-s1.x)*.4;x=s2.x;s2.x-=dx;if(s2.x>s1.x+32)s2.x=s1.x+32;draw_ties_g(s1,s2,2);s2.x=x;x=s1.x;s1.x+=dx;if(s1.x<s2.x-24)s1.x=s2.x-24;draw_ties(s1,s2,3);s1.x=x;continue}draw_ties_g(s1,s2,s2.type==NOTE?0:2)}p_voice.s_rtie=s_rtie}function draw_all_slurs(p_voice){var k,i,m2,s=p_voice.sym,slur_type=p_voice.slur_start,slur_st=0;if(!s)return;if(slur_type){p_voice.slur_start=0;while(slur_type!=0){slur_st<<=4;slur_st|=slur_type&15;slur_type>>=4}}draw_slurs(s,undefined);for(;s;s=s.next){if(s.type!=NOTE&&s.type!=REST&&s.type!=SPACE)continue;while(s.slur_end||s.sl2){if(s.slur_end){s.slur_end--;m2=-1}else{for(m2=0;m2<=s.nhd;m2++)if(s.notes[m2].sl2)break;s.notes[m2].sl2--;s.sl2--}slur_type=slur_st&15;k=prev_scut(s);draw_slur(k,s,-1,m2,slur_type);if(k.type!=BAR||k.bar_type[0]!=":"&&k.bar_type!="|]"&&k.bar_type!="[|"&&(!k.text||k.text[0]=="1"))slur_st>>=4}}s=p_voice.sym;while(slur_st!=0){slur_type=slur_st&15;slur_st>>=4;k=next_scut(s);draw_slur(s,k,-1,-1,slur_type);if(k.type!=BAR||k.bar_type[0]!=":"&&k.bar_type!="|]"&&k.bar_type!="[|"&&(!k.text||k.text[0]=="1")){if(!p_voice.slur_start)p_voice.slur_start=0;p_voice.slur_start<<=4;p_voice.slur_start+=slur_type}}}function draw_sym_near(){var p_voice,p_st,s,v,st,y,g,w,i,st,dx,top,bot;for(v=0;v<voice_tb.length;v++){var bm={},first_note=true;p_voice=voice_tb[v];for(s=p_voice.sym;s;s=s.next){switch(s.type){case GRACE:for(g=s.extra;g;g=g.next){if(g.beam_st&&!g.beam_end)calculate_beam(bm,g)}break;case NOTE:if(s.beam_st&&!s.beam_end||first_note&&!s.beam_st){first_note=false;calculate_beam(bm,s)}break}}}for(st=0;st<=nstaff;st++){p_st=staff_tb[st];if(!p_st.top){p_st.top=new Float32Array(YSTEP);p_st.bot=new Float32Array(YSTEP)}for(i=0;i<YSTEP;i++){p_st.top[i]=0;p_st.bot[i]=24}}set_tie_room();draw_deco_near();for(s=tsfirst;s;s=s.ts_next){if(s.invis)continue;switch(s.type){case GRACE:for(g=s.extra;g;g=g.next){y_set(s.st,true,g.x-2,4,g.ymx+1);y_set(s.st,false,g.x-2,4,g.ymn-1)}continue;case MREST:y_set(s.st,true,s.x+16,32,s.ymx+2);continue;default:y_set(s.st,true,s.x-s.wl,s.wl+s.wr,s.ymx+2);y_set(s.st,false,s.x-s.wl,s.wl+s.wr,s.ymn-2);continue;case NOTE:break}if(s.stem>0){if(s.beam_st){dx=3;w=s.beam_end?4:10}else{dx=-8;w=s.beam_end?11:16}y_set(s.st,true,s.x+dx,w,s.ymx+2);y_set(s.st,false,s.x-s.wl,s.wl+s.wr,s.ymn-2)}else{y_set(s.st,true,s.x-s.wl,s.wl+s.wr,s.ymx+2);if(s.beam_st){dx=-6;w=s.beam_end?4:10}else{dx=-8;w=s.beam_end?5:16}y_set(s.st,false,s.x+dx,w,s.ymn-2)}if(s.notes[s.nhd].acc){y=s.y+8;if(s.ymx<y)s.ymx=y;y_set(s.st,true,s.x,0,y)}if(s.notes[0].acc){y=s.y;if(s.notes[0].acc==1||s.notes[0].acc==3)y-=7;else y-=5;if(s.ymn>y)s.ymn=y;y_set(s.st,false,s.x,0,y)}}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];s=p_voice.sym;if(!s)continue;set_color(s.color);st=p_voice.st;set_dscale(st);for(;s;s=s.next){if(s.tp0)draw_tuplet(s,0)}draw_all_slurs(p_voice);for(s=p_voice.sym;s;s=s.next){if(s.tp0)draw_tuplet(s,0)}}for(st=0;st<=nstaff;st++){p_st=staff_tb[st];top=p_st.topbar+2;bot=p_st.botbar-2;for(i=0;i<YSTEP;i++){if(top>p_st.top[i])p_st.top[i]=top;if(bot<p_st.bot[i])p_st.bot[i]=bot}}set_color(undefined);draw_deco_note();draw_deco_staff();set_sscale(-1);set_dscale(-1);for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.have_ly){draw_all_lyrics();break}}if(cfmt.measurenb>=0)draw_measnb()}function draw_vname(indent){var p_voice,n,st,v,a_p,p,y,name_type,staff_d=[];for(st=cur_sy.nstaff;st>=0;st--){if(cur_sy.st_print[st])break}if(st<0)return;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(!p_voice.sym)continue;st=cur_sy.voices[v].st;if(!cur_sy.st_print[st])continue;if(p_voice.new_name){name_type=2;break}if(p_voice.snm)name_type=1}if(!name_type)return;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(!p_voice.sym)continue;st=cur_sy.voices[v].st;if(!cur_sy.st_print[st])continue;if(p_voice.new_name)delete p_voice.new_name;p=name_type==2?p_voice.nm:p_voice.snm;if(!p)continue;if(cur_sy.staves[st].flags&CLOSE_BRACE2){while(!(cur_sy.staves[st].flags&OPEN_BRACE2))st--}else if(cur_sy.staves[st].flags&CLOSE_BRACE){while(!(cur_sy.staves[st].flags&OPEN_BRACE))st--}if(!staff_d[st])staff_d[st]=p;else staff_d[st]+="\\n"+p}if(staff_d.length==0)return;set_font("voice");indent=-indent*.5;for(st=0;st<staff_d.length;st++){if(!staff_d[st])continue;a_p=staff_d[st].split("\\n");y=staff_tb[st].y+staff_tb[st].topbar*.5*staff_tb[st].staffscale+9*(a_p.length-1)-gene.curfont.size*.3;n=st;if(cur_sy.staves[st].flags&OPEN_BRACE2){while(!(cur_sy.staves[n].flags&CLOSE_BRACE2))n++}else if(cur_sy.staves[st].flags&OPEN_BRACE){while(!(cur_sy.staves[n].flags&CLOSE_BRACE))n++}if(n!=st)y-=(staff_tb[st].y-staff_tb[n].y)*.5;for(n=0;n<a_p.length;n++){p=a_p[n];xy_str(indent,y,p,"c");y-=18}}}function set_staff(){var s,i,st,prev_staff,v,y,staffsep,dy,maxsep,mbot,val,p_voice,p_staff;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.scale!=1)p_voice.scale_str='transform="scale('+p_voice.scale.toFixed(2)+')"'}for(st=0;st<=nstaff;st++){if(gene.st_print[st])break}y=0;if(st>nstaff){st--;p_staff=staff_tb[st]}else{p_staff=staff_tb[st];for(i=0;i<YSTEP;i++){val=p_staff.top[i];if(y<val)y=val}}y+=draw_partempo(st,y);if(!gene.st_print[st])return y;y*=p_staff.staffscale;staffsep=cfmt.staffsep*.5+p_staff.topbar*p_staff.staffscale;if(y<staffsep)y=staffsep;if(y<p_staff.ann_top)y=p_staff.ann_top;p_staff.y=-y;prev_staff=st;var sy_staff_prev=cur_sy.staves[prev_staff];for(st++;st<=nstaff;st++){p_staff=staff_tb[st];if(!gene.st_print[st])continue;staffsep=sy_staff_prev.sep||cfmt.sysstaffsep;maxsep=sy_staff_prev.maxsep||cfmt.maxsysstaffsep;dy=0;if(p_staff.staffscale==staff_tb[prev_staff].staffscale){for(i=0;i<YSTEP;i++){val=p_staff.top[i]-staff_tb[prev_staff].bot[i];if(dy<val)dy=val}dy*=p_staff.staffscale}else{for(i=0;i<YSTEP;i++){val=p_staff.top[i]*p_staff.staffscale-staff_tb[prev_staff].bot[i]*staff_tb[prev_staff].staffscale;if(dy<val)dy=val}}staffsep+=p_staff.topbar*p_staff.staffscale;if(dy<staffsep)dy=staffsep;maxsep+=p_staff.topbar*p_staff.staffscale;if(dy>maxsep)dy=maxsep;y+=dy;p_staff.y=-y;prev_staff=st;sy_staff_prev=cur_sy.staves[prev_staff]}mbot=0;for(i=0;i<YSTEP;i++){val=staff_tb[prev_staff].bot[i];if(mbot>val)mbot=val}if(mbot>p_staff.ann_bot)mbot=p_staff.ann_bot;mbot*=staff_tb[prev_staff].staffscale;for(st=0;st<=nstaff;st++){p_staff=staff_tb[st];dy=p_staff.y;if(p_staff.staffscale!=1){p_staff.scale_str='transform="translate(0,'+(posy-dy).toFixed(2)+") "+"scale("+p_staff.staffscale.toFixed(2)+')"'}}if(mbot==0){for(st=nstaff;st>=0;st--){if(gene.st_print[st])break}if(st<0)return y}dy=-mbot;staffsep=cfmt.staffsep*.5;if(dy<staffsep)dy=staffsep;maxsep=cfmt.maxstaffsep*.5;if(dy>maxsep)dy=maxsep;return y+dy}function draw_systems(indent){var s,s2,st,x,x2,res,staves_bar,bar_force,xstaff=[],bar_bot=[],bar_height=[];function bar_set(){var st,staffscale,top,bot,dy=0;for(st=0;st<=cur_sy.nstaff;st++){if(xstaff[st]<0){bar_bot[st]=bar_height[st]=0;continue}staffscale=staff_tb[st].staffscale;top=staff_tb[st].topbar*staffscale;bot=staff_tb[st].botbar*staffscale;if(dy==0)dy=staff_tb[st].y+top;bar_bot[st]=staff_tb[st].y+bot;bar_height[st]=dy-bar_bot[st];dy=cur_sy.staves[st].flags&STOP_BAR?0:bar_bot[st]}}function draw_staff(st,x1,x2){var w,ws,i,dy,ty,y=0,ln="",stafflines=staff_tb[st].stafflines,l=stafflines.length;if(!stafflines.match(/[\[|]/))return;w=x2-x1;set_sscale(st);ws=w/stv_g.scale;if(cache&&cache.st_l==stafflines&&cache.st_ws==ws){xygl(x1,staff_tb[st].y,"stdef"+cfmt.fullsvg);return}for(i=0;i<l;i++,y-=6){if(stafflines[i]==".")continue;dy=0;for(;i<l;i++,y-=6,dy-=6){switch(stafflines[i]){case".":continue;case ty:ln+="m-"+ws.toFixed(2)+" "+dy+"h"+ws.toFixed(2);dy=0;continue}if(ty!=undefined)ln+='"/>\n';ty=stafflines[i];ln+='<path class="stroke"';if(ty=="[")ln+=' stroke-width="1.5"';ln+=' d="m0 '+y+"h"+ws.toFixed(2);dy=0}ln+='"/>\n'}y=staff_tb[st].y;if(!cache&&w==get_lwidth()){cache={st_l:stafflines,st_ws:ws};i="stdef"+cfmt.fullsvg;glyphs[i]='<g id="'+i+'">\n'+ln+"</g>";xygl(x1,y,i);return}out_XYAB('<g transform="translate(X, Y)">\n'+ln+"</g>\n",x1,y)}draw_vname(indent);for(st=0;st<=nstaff;st++)xstaff[st]=!cur_sy.st_print[st]?-1:0;bar_set();draw_lstaff(0);for(s=tsfirst;s;s=s.ts_next){if(bar_force&&s.time!=bar_force){bar_force=0;for(st=0;st<=nstaff;st++){if(!cur_sy.st_print[st])xstaff[st]=-1}bar_set()}switch(s.type){case STAVES:staves_bar=0;for(s2=s.ts_next;s2;s2=s2.ts_next){if(s2.time!=s.time)break;switch(s2.type){case BAR:case CLEF:case KEY:case METER:staves_bar=s2.x;continue}break}if(!s2)staves_bar=realwidth;cur_sy=s.sy;for(st=0;st<=nstaff;st++){x=xstaff[st];if(x<0){if(cur_sy.st_print[st])xstaff[st]=s.ts_next.type==BAR?s.x:s.x-s.wl-2;continue}if(cur_sy.st_print[st])continue;if(staves_bar){x2=staves_bar;bar_force=s.time}else{x2=s.x-s.wl-2;xstaff[st]=-1}draw_staff(st,x,x2)}bar_set();continue;case BAR:st=s.st;if(s.second||s.invis)break;if(xstaff[st]<0){for(s2=s.ts_next;s2&&s2.time==s.time;s2=s2.ts_next){if(s2.type==STAVES)break}if(!s2||s2.type!=STAVES)break;xstaff[st]=s.x;bar_set()}draw_bar(s,bar_bot[st],bar_height[st]);break;case STBRK:if(cur_sy.voices[s.v].range==0){if(s.xmx>14){var nv=0;for(var i=0;i<voice_tb.length;i++){if(cur_sy.voices[i].range>0)nv++}for(s2=s.ts_next;s2;s2=s2.ts_next){if(s2.type!=STBRK)break;nv--}if(nv==0)draw_lstaff(s.x)}}s2=s.prev;if(!s2)break;x2=s2.x;if(s2.type!=BAR)x2+=s2.wr;st=s.st;x=xstaff[st];if(x>=0){if(x>=x2)continue;draw_staff(st,x,x2)}xstaff[st]=s.x;break}}for(st=0;st<=nstaff;st++){if(bar_force&&!cur_sy.st_print[st])continue;x=xstaff[st];if(x<0||x>=realwidth)continue;draw_staff(st,x,realwidth)}}function draw_symbols(p_voice){var bm={},s,g,x,y,st;for(s=p_voice.sym;s;s=s.next){if(s.invis){switch(s.type){case KEY:p_voice.key=s;default:continue;case NOTE:break}}x=s.x;set_color(s.color);switch(s.type){case NOTE:set_scale(s);if(s.beam_st&&!s.beam_end){if(calculate_beam(bm,s))draw_beams(bm)}if(!s.invis){anno_start(s);draw_note(s,!bm.s2);anno_stop(s)}if(s==bm.s2)bm.s2=null;break;case REST:draw_rest(s);break;case BAR:break;case CLEF:st=s.st;if(s.time>staff_tb[st].clef.time)staff_tb[st].clef=s;if(s.second)break;if(!staff_tb[s.st].topbar)break;set_color(undefined);set_sscale(st);anno_start(s);y=staff_tb[st].y;if(s.clef_name)xygl(x,y+s.y,s.clef_name);else if(!s.clef_small)xygl(x,y+s.y,s.clef_type+"clef");else xygl(x,y+s.y,"s"+s.clef_type+"clef");if(s.clef_octave){if(s.clef_octave>0){y+=s.ymx-10;if(s.clef_small)y-=1}else{y+=s.ymn+2;if(s.clef_small)y+=1}xygl(x-2,y,"oct")}anno_stop(s);break;case METER:p_voice.meter=s;if(s.second||!staff_tb[s.st].topbar)break;if(cfmt.alignbars&&s.st!=0)break;set_color(undefined);set_sscale(s.st);anno_start(s);draw_meter(x,s);anno_stop(s);break;case KEY:p_voice.key=s;if(s.second||!staff_tb[s.st].topbar)break;set_color(undefined);set_sscale(s.st);anno_start(s);draw_keysig(p_voice,x,s);anno_stop(s);break;case MREST:set_scale(s);x+=32;anno_start(s);xygl(x,staff_tb[s.st].y+12,"mrest");out_XYAB('<text style="font-family:serif; font-weight:bold; font-size: 15px"\n\tx ="X" y="Y" text-anchor="middle">A</text>\n',x,staff_tb[s.st].y+28,s.nmes);anno_stop(s);break;case GRACE:set_scale(s);draw_gracenotes(s);break;case SPACE:case STBRK:break;case CUSTOS:set_scale(s);draw_note(s,0);break;case BLOCK:case PART:case REMARK:case STAVES:case TEMPO:break;default:error(2,s,"draw_symbols - Cannot draw symbol "+s.type);break}}set_scale(p_voice.sym);draw_all_ties(p_voice);set_color(undefined)}function draw_all_sym(){var p_voice,v,n=voice_tb.length;for(v=0;v<n;v++){p_voice=voice_tb[v];if(p_voice.sym&&p_voice.sym.x!=undefined)draw_symbols(p_voice)}draw_all_deco();set_sscale(-1)}function set_tie_dir(sym){var s,i,ntie,dir,sec,pit,ti;for(s=sym;s;s=s.next){if(!s.ti1)continue;if(s.multi!=0){dir=s.multi>0?SL_ABOVE:SL_BELOW;for(i=0;i<=s.nhd;i++){ti=s.notes[i].ti1;if(!((ti&7)==SL_AUTO))continue;s.notes[i].ti1=ti&SL_DOTTED|dir}continue}sec=ntie=0;pit=128;for(i=0;i<=s.nhd;i++){if(s.notes[i].ti1){ntie++;if(pit<128&&s.notes[i].pit<=pit+1)sec++;pit=s.notes[i].pit}}if(ntie<=1){dir=s.stem<0?SL_ABOVE:SL_BELOW;for(i=0;i<=s.nhd;i++){ti=s.notes[i].ti1;if(ti){if((ti&7)==SL_AUTO)s.notes[i].ti1=ti&SL_DOTTED|dir;break}}continue}if(sec==0){if(ntie&1){ntie=(ntie-1)/2;dir=SL_BELOW;for(i=0;i<=s.nhd;i++){ti=s.notes[i].ti1;if(ti==0)continue;if(ntie==0){if(s.notes[i].pit>=22)dir=SL_ABOVE}if((ti&7)==SL_AUTO)s.notes[i].ti1=ti&SL_DOTTED|dir;if(ntie--==0)dir=SL_ABOVE}continue}ntie/=2;dir=SL_BELOW;for(i=0;i<=s.nhd;i++){ti=s.notes[i].ti1;if(ti==0)continue;if((ti&7)==SL_AUTO)s.notes[i].ti1=ti&SL_DOTTED|dir;if(--ntie==0)dir=SL_ABOVE}continue}pit=128;for(i=0;i<=s.nhd;i++){if(s.notes[i].ti1){if(pit<128&&s.notes[i].pit<=pit+1){ntie=i;break}pit=s.notes[i].pit}}dir=SL_BELOW;for(i=0;i<=s.nhd;i++){ti=s.notes[i].ti1;if(ti==0)continue;if(ntie==i)dir=SL_ABOVE;if((ti&7)==SL_AUTO)s.notes[i].ti1=ti&SL_DOTTED|dir}}}function set_tie_room(){var p_voice,s,s2,v,dx,y,dy;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];s=p_voice.sym;if(!s)continue;s=s.next;if(!s)continue;set_tie_dir(s);for(;s;s=s.next){if(!s.ti1)continue;if(s.notes[0].pit<20&&(s.notes[0].ti1&7)==SL_BELOW);else if(s.notes[s.nhd].pit>24&&(s.notes[s.nhd].ti1&7)==SL_ABOVE);else continue;s2=s.next;while(s2&&s2.type!=NOTE)s2=s2.next;if(s2){if(s2.st!=s.st)continue;dx=s2.x-s.x-10}else{dx=realwidth-s.x-10}if(dx<100)dy=9;else if(dx<300)dy=12;else dy=16;if(s.notes[s.nhd].pit>24){y=3*(s.notes[s.nhd].pit-18)+dy;if(s.ymx<y)s.ymx=y;if(s2&&s2.ymx<y)s2.ymx=y;y_set(s.st,true,s.x+5,dx,y)}if(s.notes[0].pit<20){y=3*(s.notes[0].pit-18)-dy;if(s.ymn>y)s.ymn=y;if(s2&&s2.ymn>y)s2.ymn=y;y_set(s.st,false,s.x+5,dx,y)}}}}var musicfont='url("data:application/font-woff;base64,d09GRk9UVE8AABjsAAoAAAAAH8wAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAADRAAAFPgAABncbyRwGEZGVE0AABg8AAAAHAAAABx6k9cvT1MvMgAAAVQAAABLAAAAYFjAWjRjbWFwAAAChAAAALEAAAH6kDnc6GhlYWQAAAD0AAAANQAAADYHrbQmaGhlYQAAASwAAAAgAAAAJAihAQhobXR4AAAYWAAAAJMAAAC+V4YAJG1heHAAAAFMAAAABgAAAAYAMFAAbmFtZQAAAaAAAADhAAABhgcU47Fwb3N0AAADOAAAAAwAAAAgAAMAAHicY2BkYGAAYpmvsQ7x/DZfGbhZGEDg4nQlcRB92dO/6P+uvzzMX1imALkcDEwgUQAm/gs4AAAAeJxjYGRgYJnyl4chhoX3/67/+5m/MABFUIA+AJ3hBq4AAFAAADAAAHicY2BmvMs4gYGVgYNpJtMZBgaGfgjN+JrBmJGTgYGJgZWZAQ4EEEyGgDTXFAYHBoaXMczG/40ZYlimMH0BCjPCFSgAISMAm6gMnAB4nHWOMWrDQBBFn2zZwTiEVCHlgps0EtI2wT6ADpDCvWwWYTASrGyTk6TKEVLmGDlAjpBj5EuZJoUXhn3z+TN/gFveSBhewg33xhPxk/GUFa/GqfQP4xlLvozn0n/kTNKFlLtxauCJ+NF4SkVhnEp/N57xwKfxXPo3NTv2eHouNFDv9r6/CF4I6s8c5YhqQ3M+1oKKjpbT+Ec5Ak7TudIcG9X/fX+apyRjrfLylTxrTdeeqi42wfm8cBtnuSJfZuvMF6VM127bKjVKPYy3OG0c8tmG2B+61pV5cXX2FwIWN4EAAAB4nGNgYGBmgGAZBkYGEPgC5DGC+SwMN4C0EYMCkCXEwPCA4YHHg4AHMQ+SHmQ+qHnQ/WDJQ8aHzx+lPFnwZM2TA09ePXn3lPFp+tPcZwHPQl/G/P8PMgyoxx2up+pB14MFYD0JUD0PgXoYgHpy4HoYFZjk98hvlV8lv1R+vny/fJN8nryQnK7sVukq6XzpGGkbaUtpDanDUvsl70reFLsMdTOJgJGNgTyNwwgAANfVUlQAAAB4nGNgZsALAAB9AAR4nJ1YCVhTV76/1xByizYK8dKNBvf246utu7ZjVepS1ypqC1QFBJElQCAQAoR9C+QfwpawBJIQSAgQCDtaKCiVitUuY6m2jk6f045dZtpxtO2c2JP2eweivnnvzZuZ73033/c79+Sc3/mf/zn/7dKUmxtF0zRzPDxiVXJqFEXPomhqi2P3LMcejuNxN5jDgTluQg/qkdQ3XgB42JjD2/5Lyc8lPm4ars8sdq4PRc3zmZXi6UMt9XnCy4taOc3Co/gUS/lQiyk/aiW1gdpM7aD2UYepI1Q4FUMlUjIqmyqiVFQ1paNMVBvVTQ1Ro9QEdYn6mLpG3aS+pv5C/UQ5aQ7tQXvSj9O+9DJ6Ob2G/g39Cr2LPkAHPp8gPhF5UpoQs33FihUzsGa9CzbMwFpX59qtM7BulQtenIH1/i54xQWuIRtcnRtcnf6u6f4rXeCa7r/aBWumYeWKmf9Wbp9ZdtW6FS5Y6YJVLljtgpkJa1yca/xn1luz1fW2faULVrlgtQtcE7avdcE6F6x3wQYXvOgCfxdsn4a1Lk2sdUm2dt16F2x1wbZpWOfSy7q1M9Qvrt16/+wfXAGKohV0CV1KK2mgVXQZrabL6Qq6kq6iq2kNraVr6Fq6jq6ndXQD3UjraQNtpJtoE91Mt9Bm2kK30la6jW6nO2gb3Ul30Xa6m+6he+k+up8eoAepFdO3Ywm1nmqj1bMWcELdyrjbudHuZ3nfMrpHlj9yy+NJjx0e4R4THj/Ndp+9aHbibNNsx5xXHqUfDXo0+dF3H/3s0e/5NJ/lH+E38O/MLZ/3queznns95Z5tXge8srwuzs/x5nq/hHxhzHFgjB4bQxfGOGPejucdQ87n3cecBazjALrgPMDjt4JjCQ2OpRxwcyx1LHEudefjvqZUGlra2jiOWje7XB8FoRCTG5y8Kzu8OBpiYUdb4LsnQu1pAzAClurOOjvTell7Dt6Ci5LhwIaxBssQvAen8s4nfpxtL2gHC4wYBk/ZmYATCYGwA2IrouvCW3bVBEMMhKWLouUM/29lRqS5LruOKoxeiutvWBHz59V//uJ6kFXQk+tYhL5iF3gIPqPwr/unG1UUegwfZgWVWyK6Qz8SWsFabmtoMdpsMMIIaih4J+oqZtAsBonQWFgHjsbD3OiO8K4j3SKb3AYtcOacbYRAS0GDnBFUUqK8nAyQM9LmVIvV0NwsJBT9UadeFYpBrBDJk2UiERwh47bA4e4tiME0g6Pw8JAIRaAhbnfcQMxIlE3UIIJkCDwkOkIguVrewBAhbdraRmhgTClNSUJxWkqKL9+RtXMIHe1HxwZpVHcbufUjt9uc+T6OOMc3LH6ah7m5K5/Jx48zWBiBhO4aPP/WYsTNZfDT/ehpHuLW3PpBg+YzSNiPhe75aP7KHzC3hiF/RTg3sPgob3/1kTEFWsig57yRm7sCLzwStL+AQYVu6ChvsmAkuBwvYvBz3tjNvRwtHRmZrGb4Dr9fBH3o+z70M/Lygq+HUSr2H39/5IO+LwaaPhD8cNaxGBnYNBTBRauR59lbgPYBelxxdd3Xz4uffQHwUditfbF6cVDk0dBkWVjMS79JCmJEByWrYDVgOfLB81Am1EAj1KiYRnyQq8qDfPIsC04MgiRIKZfVMIJ7Z99TjXTBeeZ88Pi+HSFBB9e/vwO5Iap//K4QdEqdsoGRo/3cwfJ2XY/hi8GeT+Ab+Djn/aB3Qs9sse4AJg/ylPlKphbPY+vdEXV99Yu+sDlmE346jon0LoVShRBnwzbkXYI2qtCSj6+jnWgJESaAK/jp7ArJy3vgWdjase1yRpIttQ9s8OHE4G/rmPx7W9iaLwd+/IO2V1q7E47BosWLXzrMEIWU6BRvw1mwqKxqM8NHd5x13Q4f+12748keGtDci9ZP0Ur0G0RxHBJnCisGkSbK0FVjNGqaobqsEqqZgXBbmLDY/ViGVEIM6cVvDn0HF+F868TZ3m7jcMUZRs+D4az+pJ7osVffeY4YSERBeCYTc6XrKncgs7+gC6zQom7R3rJPfQKIJqOLz8iGI7sPnj1g2UvuXlJxckFARlRcRkhxLhDVQKxJ8lYGU+E+NGAb8IXq0kqozLfKGmNqbI0tmn44B70iYomxVdEQDZtOYLdtwMRDfIO8Jqw1dyj5lHRPWkiaOE0skYhSGUeB+FeN1VHBs6WaJQYxeUJMe2qslY0VNc3WkdPniTPoOtm4TRNXHg8JzKqji1YJnZKfJeyvGjT3Zw2Pjz7Hm/4agLKj7/QOeRmQAq1HHh9+JwgxDLAvjay5JmwFq6a5qdVUayUHcfHQ+dfgJOQWxkfqv71x7lM4A105AyFMT5hhD6yHWEVk4QnpwpBn9u9bvRwLDuJFkeiAFvl//dc/3r41hlhA6xm4kPVx/KmgK/52zAUGP4Y5L+LHfQWGe944irUYTW1tyU2JCRmpCb5xJlmbULCpCBWzrUZTpyW1KTE+LT3BN9YobRfyvwPkdxn5cVAiUrPOEuTHK3WUcJ1u3g/bxI6cynbU1IH6/rTyL17wqR3twsKhM71jtimbdUDw2U30e/QIW6Wqgir4Gia3wqvwWuQ+PEvCFH2VhoIAmCLcz5aCskSI90PQj0XoSRXijV9CSxCPEfzpZkVg+fGKgFdk+4JgIwR0hfZLUy15rcSxjr9lf6dGJW/BRsLRlcB2qZtr23WXu9rOwxWYyB8LP8UIrt2MGD5sfJ1YXgExlcKLpW8VjyPB7aEpQM/CT4rJV6/4Szf6A17DQGD1rsoN4fEno9LkMYm796SGJx2TbYPtgPch6ln0GmigFjQqpg4v5KoIHRSCf3R8KKRCulquYQQ3bo6qelthmBmOOBV8OCr82M4PX798Y6D/C2EVj8yrVmqVNUXni6aYnfe+ZzWXbZcuW23xmnByzq+sX747lBG8d7O0VtEHg9Ckai4zEv+03LmyDX1o/b0Vvd9Ow/djpgvICz3xBcfh5ZzPSkFSlaBr1TQ0VumhsqwCKpnOGEuMUOF+MitDRlzMrish12AUhk1vDba3NfaUDzI6HvTmdqS2iwcOn9oMiSAqjM1hEs+3TnI7c2xFrWACY5mhesr67nn4gqnnKQYzeuLbjg0eNQVDGqQWpxUdy0pIzopSTG++AJIaZT1ZTLl7V5e50xcqSyugotAkr0/UWOr1VTY4DR0SwxuapIoEEMO+uFUHgSHhoS5bE2PK70qzpwdlnsyUZkplsqQMxrFA+sukyeHHs2QYZTopeU7qgzSmivpyjd7U1zMMvdAaX3+wSqJOhhRmW+T6bUKn171O9pfJ7+9N8viOHdjnxlF0QHyjo8tLhwKR97fj1wQhuk52d9/294QmMFXpG016rYncmdGQkTchHgqKkuPrr75/+gJRtyWvM4ppj9EFwk5IKokriktfF73xSPD2LUuPYfd45FeNfD+58fH1qf4fAHkz8HbuRLI9/PwB60pgFq3avZAYlaMGv8w2Neibm9MapSlZGSm+Er2cBNNNxegN1tSgtzRlNEiTM7NSfJMa0luE/G6sbEOAnrzURGvQLBQ+XtfIQefQBlbpfhJSY0qTmGjridN95uFhIViyLLJmWXNIayDgx5Sr9wLeCArVCVCoX216oy+y9+SobBQYxC8butB5V6VOV4M65UhahDhZnJyQlwQiSKpLaRMNFl6FTxlAz42fu1DWB2eSyKEolMUliiKVQlWgYvj2/ybSBTua9W8KVQRKZREwd6IX8RZn7twF+Jm/F689oTetr4hZYP9BxSMy9l2y3f7fMuZBsSpfzTh28arL1GXV8A/kw3PxL2xBZWFVoca1F/jBPNndSqLQCsza0eEOGvpUP6FMNEvVz3FkoU0svtuP7vKcFm98t480kNsCdqEHurWXXeTBx5tuowW3aTA7ss0c82XWkY0XOLPdJWiIde41jzqyg82OvZJgZ/Yoj3/1Af8MOwdxLv4XTyh+dgLtnqChAxk6OOj0R6y6qKyIOIYD+ImXXgYppFUVNCgqSeCpgvPoiRvXiIkZCjVypqmOlQyHGY/C87DoZXgB0ipkWpn56JBsmET4H68RN2koNuYRHxCGFyAbCa6fc2Ldtp85+Z6QZFVl+spblquj8Ee4/Hr3HsiEzJIMxeqUTa/DaqKP/VjthmaDY5+jBM8BLv9vwWSjtzmjwazVZLJapSaxWCoVi01Sqy9/MeL30qN25PEBBz2L+GxHS3y0L0TLw+PDE8IkyemlDArlmXuaLcL2XjYC4tNTYhj0WbTzJq8LzljHx8+OW0ZgGN4+2h0KDB/7gxUtMXOsy0gE8kNLTgP24+Iljh1solKpBOenaMsY4FQzgOMT/HIgl794wnynhfP7z9g7bYB3LRVzscEN0O7pt00tAGj7pA4+358JaOek3tXYmgyA93CXJgHaJCHNHQezYM1EA+kjjXUTjYC3cvkL8bwrt6do49TdKQ4KJLnR1NRB98AzXENjZxcJFBMfbyWvQdz0xtiZ161bJ3hjwUHBBwH8pwDOj41xa7P7I8lf/ELk2UsO96vxuvavz3KuIU9W5V4DtQXa7KosdTqkQw5kK7ILorPiUhNSE3IzcmBaYWBqaWlWMZZeNgpS0+UiBk3FOX/H64Tetja7tctkb+yv0Jc3QAMMiYYjyJS1kWw54dXO8JbP8Jbe500nvFkZufd5m+/zRkOqTB5PeOMJbzsMtFntbV1Ge0N/lYv3rbhTx4n4bwAqoUvQVY5exaL+77gadUU1uYnVxdX55Qzu/xtXCUqVkphfQSZkQ5G6qIIc+PGNXK0CFHnFDI54hasoLS0mJp5XmaWFMlBBGXEVzwN6j1zJTlIz9cAt9OaX+M33gdzT97h8JAM0B837Aw1alE5aci0ZpHXXkevAfouWwfSPXa7DfozWHcVgP/QI9pt5GBwrRGe8uyytnbZEa2xcglgkahN3+PKxgjhdDlK7kXzD25VvTHep6fvdWI28kZrHfwV7Ik/SeZYsSJpnkSfpg/tdyPNhH34KxxHpL3EGHE+xN/Cbz+Cd6Cl8gJtSL61KgSMQTgoeOG47/OXh8N7MHmiHPqtlgEB3dncsgykUcRfFExE8RjoJ81MctHmSxVzcPyJHfo6lXEWZDEpLQwPEacdA31RhICWQPcYYHRubHnLotOSscBDqqvXlDHEcJ2wopdOLUOxFTwl+izbjIHYdPn06BwXfW3afJj74eOL/RaOfptmPQ7hF6cnyY8AIbi724FtmWB8QB6CndhDuH5Fykg14OPIhXROhSyN0ydN0NZXGSsa1ftPP/876Rg1ZPwCHElbpzPrf3B8n+OM0tVDwzQN230HQTLPz/+K8L90DAfc/lPEO2ux8sP8/+7hV/X8EuPtAgDsuAe7+TwEC/k5bP/4TNfz9uHtEqzNyS2woYeaX+ED0fTO/LUT6nyk0dYY9hIP+tYoD8NGH3M4t/+osHH4+3Nx/VxeB+MhDXThy/zH1jB5efygo2R9FNuiQLEInSTC8N2DmoAw3Z5gZed4bwJ5mR5gEe/4yMG026CAOJPbsh+bQxQQn0RzOO1fZJR6OzbiZgLP4MIs8XUHHiwQd0v1guAzNcQyR4f3Tw+89PzP8F+lhdqkHDnaWEOBfKrn0Wg9yu3jC7gX1juX1gqMOjx6WhDVtWh2DNyJvrqw+RS1TpYGsKDNbKksXwwmI1SbrpYygsSHDkF9PYqKmFprAkKdNh1zILsnMz6wpqoc26GvqaANGB3X5hmwGbcTeXEGcMctSaAQDsaH6umaj3kryjRHRuZDpiXKlDDI0eQZgiJtX6zS63KosiGdOporEQj6KAJRCd73FXr32I6nuGTRvGpahtdLmTesXonl4Dp63jMAivJx4wog30O9wRaoX6mgVNKGOyyye20oqJnMrVxB2f56sZeM6Mm+7P1fQpERzE0lA85Om3Kdokly95hrK5d97rnQyYBCVdPZ/EjqGNtq8YAL5jde+++25qt7JvtEJ9ML5ykmB9defY0tZfW19Q0NWvTwzM0vuK9dl6YROw5/Y8Cg5KQrEILkSaWF60Xquqhymn7HtelIjlKsqVeWkew0XLSo8vQ2iGcELv5I6KHz6O1CVtJfJzuG2BAwldQMz8s7box/t+g+8B4f646WbfQWyX2MaJK3CD6DFfPZLRl7NTYk4WZAKMshpgBY4PXUdPa4ll1PEVRYpC0koOfhBFhyDEmWJUhGPHzP0LtkbLgk+TrIYhbqkChg9DGinRow1BrMJ6qE2Sx9nD6/PJik8mPTvjjYlDUeSbJdslThmXetQR1BPkQ1uwcQV+AqQEHPQXFz9OaPkQTrate3KUvx4tHgXLGME4l+jQiKThJGQbEpuMxtH7C3DWgO5A/UwmNQeBeEQVpAULU0oSoUIBmJ0iUYR09fKZpkV9dAKk/39dqgDTWm5vKywrIBsIkSasvsAg8Z+w4ZqU5vhFNy0TH7Z3yJuPAShsDUlYKeC4X/0TVNj4beHzh3SW/TN33mhV5vzvt+vb28UTC5AHSiflaRnpaalNzQ3N9YZhQZjdoqv4NIW/HQBa67LzfQlFUpeYaFcnlkqJbE5T5mbk0uSAtIUN2WZQQtatbac6TLHtdu7NZqqihoinzYfEhnBxVwIjSyASEbSktZsatOR2v5SGAweV8I5MFVrtKSM1RRqCuwnEiQWSX1enaIWbNBgghYG6kp0udoEc0rSyc48jVJDlFOvLe8g6m4J6wN1pA0Yu6HJ3JxlCfcVlIfFgvJEMMlxc7WkLq6urNVqGnWaMjswFkNHkzXZIPHNA1lxQb5Y1CYVReXl5CoKIAOKjWBSDduLoJvpSNFLJZIMkRBEPcryUNV0UVkMGfmF019vcioKq0/2W9skltzqnHKSAInkkuQUnWTQtw50iobM6sLy6TI0OydPUkoE3BKiLu5OACZaLk0SG9I7fTtA2TNMkpV/merzVE53MyjvqUg+STJ+gFHivnrmOx5h6+d42Dxs1eOVxoqbc+aYZ5sryyvera2r1c151IdaKqDcaXr+3vDsClJa6k2mdL1Ump4u9ZXq003C2XVt1krieOrcPyi+tLcmvKxQlT/zCaJAUShPSCoSA5Ptvqti78WcgdIqJUnJQFumUVcxs6+vfhv7YJ/Vb67b8uWbyAf5fPn2deHsfxIoZne2tnZ2JrbGxiYmxcS2Jnb6zkZ8lyOeC9zZ/wlF9IlhAAAAAQAAAADVs2WlAAAAANGXIhcAAAAA00lPcnicY2JgYGCcACTCgfSD/3eY4xiqmLkZGJguAfH+/7sYrzEwgPjMfECs/v8E40wGTsYZDJxMgkB5GaCeA0DsCcReQL4ByAwg5mUwYjgBphkYuRlEGPOAtMP/v4wSQDURQLuaIJhRB4IZ3gHxf6g5/UB8A4KZg4Hqjf9/YFb4/5BxK5DtwsALwiy8YLt5GBgAC1ge5AA=")';var defined_font={},font_tb={},fid=1,font_scale_tb={serif:1.05,serifBold:1.05,"sans-serif":1.1,"sans-serifBold":1.1,Palatino:1.1,Mono:1.35},fmt_lock={};var cfmt={aligncomposer:1,breaklimit:.7,breakoneoln:true,cancelkey:true,composerspace:6,dblrepbar:":][:",decoerr:true,dynalign:true,fullsvg:"",gracespace:[6.5,8,12],graceslurs:true,hyphencont:true,indent:0,infoname:'R "Rhythm: "\nB "Book: "\nS "Source: "\nD "Discography: "\nN "Notes: "\nZ "Transcription: "\nH "History: "',infospace:0,keywarn:true,leftmargin:1.4*CM,lineskipfac:1.1,linewarn:true,maxshrink:.65,maxstaffsep:2e3,maxsysstaffsep:2e3,measurefirst:1,measurenb:-1,musicspace:6,parskipfac:.4,partsspace:8,pagewidth:21*CM,printmargin:0,rightmargin:1.4*CM,rbdbstop:true,rbmax:4,rbmin:2,scale:1,slurheight:1,staffnonote:1,staffsep:46,stemheight:21,stretchlast:.25,stretchstaff:true,subtitlespace:3,sysstaffsep:34,textspace:14,titlespace:6,titletrim:true,topspace:22,tuplets:[0,0,0,0],vocalspace:10,writefields:"CMOPQsTWw",wordsspace:5};function get_bool(param){return!param||!param.match(/^(0|n|f)/i)}function get_int(param){var v=parseInt(param);if(isNaN(v)){syntax(1,"Bad integer value");v=1}return v}function get_font_scale(param){var a=param.split(/\s+/);if(a.length<=1)return;var scale=parseFloat(a[a.length-1]);if(isNaN(scale)||a<=0){syntax(1,"Bad scale value in %%font");return}font_scale_tb[a[0]]=scale;for(var fn in font_tb){if(!font_tb.hasOwnProperty(fn))continue;var font=font_tb[fn];if(font.name==a[0])font.swfac=font.size*scale}}function param_set_font(xxxfont,param){var font,fn,old_fn,n,a,new_name,new_fn,new_size,scale,cl;if(xxxfont[xxxfont.length-2]=="-"){n=xxxfont[xxxfont.length-1];if(n<"1"||n>"9")return;xxxfont="u"+n+"font"}fn=cfmt[xxxfont];if(fn){font=font_tb[fn];if(font){old_fn=font.name+"."+font.size;if(font.class)old_fn+="."+font.class}}n=param.indexOf("class=");if(n>=0){n+=6;a=param.indexOf(" ",n);if(a>0)cl=param.slice(n,a);else cl=param.slice(n);param=param.replace(new RegExp("class="+cl),"").trim()}a=param.split(/\s+/);new_name=a[0];if(new_name=="*"&&font){new_name=font.name}else{new_name=new_name.replace("Times-Roman","serif");new_name=new_name.replace("Times","serif");new_name=new_name.replace("Helvetica","sans-serif");new_name=new_name.replace("Courier","monospace")}if(a.length>1){new_size=a[a.length-1];if(new_size=="*"&&font)new_size=font.size}else if(font){new_size=font.size}if(!new_size){return}new_fn=new_name+"."+new_size;if(cl)new_fn+="."+cl;if(new_fn==old_fn)return;font=font_tb[new_fn];if(!font){scale=font_scale_tb[new_name];if(!scale)scale=1.1;font={name:new_name,size:Number(new_size),swfac:new_size*scale};font_tb[new_fn]=font}if(cl)font.class=cl;cfmt[xxxfont]=new_fn}function get_unit(param){var v=parseFloat(param);switch(param.slice(-2)){case"CM":case"cm":v*=CM;break;case"IN":case"in":v*=IN;break;case"PT":case"pt":v*=.75;break}return v}function set_infoname(param){var tmp=cfmt.infoname.split("\n"),letter=param[0];for(var i=0;i<tmp.length;i++){var infoname=tmp[i];if(infoname[0]!=letter)continue;if(param.length==1)tmp.splice(i,1);else tmp[i]=param;cfmt.infoname=tmp.join("\n");return}cfmt.infoname+="\n"+param}var textopt={align:"j",center:"c",fill:"f",justify:"j",ragged:"f",right:"r",skip:"s"};function get_textopt(param){return textopt[param]}var posval={above:SL_ABOVE,auto:0,below:SL_BELOW,down:SL_BELOW,hidden:SL_HIDDEN,opposite:SL_HIDDEN,under:SL_BELOW,up:SL_ABOVE};function set_pos(k,v){if(posval[v]==undefined){syntax(1,err_bad_val_s,k);return}k=k.slice(0,3);if(k=="ste")k="stm";if(curvoice)curvoice.pos=clone(curvoice.pos);set_v_param(k,v,"pos")}function set_writefields(parm){var c,i,a=parm.split(/\s+/);if(get_bool(a[1])){for(i=0;i<a[0].length;i++){c=a[0][i];if(cfmt.writefields.indexOf(c)<0)cfmt.writefields+=c}}else{for(i=0;i<a[0].length;i++){c=a[0][i];if(cfmt.writefields.indexOf(c)>=0)cfmt.writefields=cfmt.writefields.replace(c,"")}}}function set_v_param(k,v,sub){if(curvoice){if(sub)curvoice[sub][k]=posval[v];else curvoice[k]=v;return}k=[k+"=",v];var vid="*";if(!info.V)info.V={};if(info.V[vid])Array.prototype.push.apply(info.V[vid],k);else info.V[vid]=k}function set_page(){if(!img.chg)return;img.chg=false;img.lm=cfmt.leftmargin-cfmt.printmargin;if(img.lm<0)img.lm=0;img.rm=cfmt.rightmargin-cfmt.printmargin;if(img.rm<0)img.rm=0;img.width=cfmt.pagewidth-2*cfmt.printmargin;if(img.width-img.lm-img.rm<100){error(0,undefined,"Bad staff width");img.width=img.lm+img.rm+150}set_posx()}function set_format(cmd,param,lock){var f,f2,v,box,i;if(lock){fmt_lock[cmd]=true}else if(fmt_lock[cmd])return;if(cmd.match(/.+font$/)||cmd.match(/.+font-[\d]$/)){if(param.slice(-4)==" box"){box=true;param=param.slice(0,-4)}param_set_font(cmd,param);switch(cmd){case"gchordfont":cfmt.gchordbox=box;break;case"measurefont":cfmt.measurebox=box;break;case"partsfont":cfmt.partsbox=box;break}return}switch(cmd){case"aligncomposer":case"barsperstaff":case"capo":case"infoline":case"measurefirst":case"measurenb":case"rbmax":case"rbmin":case"shiftunison":case"staffnonote":cfmt[cmd]=get_int(param);break;case"microscale":f=get_int(param);if(isNaN(f)||f<4||f>256||f%1){syntax(1,err_bad_val_s,"%%"+cmd);break}set_v_param("uscale",f);break;case"bgcolor":case"dblrepbar":case"titleformat":cfmt[cmd]=param;break;case"breaklimit":case"lineskipfac":case"maxshrink":case"pagescale":case"parskipfac":case"scale":case"slurheight":case"stemheight":case"stretchlast":f=parseFloat(param);if(isNaN(f)){syntax(1,err_bad_val_s,"%%"+cmd);break}switch(cmd){case"scale":f/=.75;case"pagescale":cmd="scale";img.chg=true;break}cfmt[cmd]=f;break;case"bstemdown":case"breakoneoln":case"cancelkey":case"custos":case"decoerr":case"dynalign":case"flatbeams":case"gchordbox":case"graceslurs":case"graceword":case"hyphencont":case"keywarn":case"linewarn":case"measurebox":case"partsbox":case"rbdbstop":case"singleline":case"squarebreve":case"straightflags":case"stretchstaff":case"timewarn":case"titlecaps":case"titleleft":case"titletrim":cfmt[cmd]=get_bool(param);break;case"chordnames":v=param.split(",");cfmt.chordnames={};for(i=0;i<v.length;i++)cfmt.chordnames["CDEFGAB"[i]]=v[i];break;case"composerspace":case"indent":case"infospace":case"maxstaffsep":case"maxsysstaffsep":case"musicspace":case"partsspace":case"staffsep":case"subtitlespace":case"sysstaffsep":case"textspace":case"titlespace":case"topspace":case"vocalspace":case"wordsspace":f=get_unit(param);if(isNaN(f))syntax(1,"Bad value in $1","%%"+cmd);else cfmt[cmd]=f;break;case"print-leftmargin":syntax(0,"$1 is deprecated - use %%printmargin instead","%%"+cmd);cmd="printmargin";case"printmargin":case"leftmargin":case"pagewidth":case"rightmargin":f=get_unit(param);if(isNaN(f)){syntax(1,"Bad value in $1","%%"+cmd);break}cfmt[cmd]=f;img.chg=true;break;case"concert-score":cfmt.sound="concert";break;case"contbarnb":cfmt.contbarnb=get_int(param);break;case"writefields":set_writefields(param);break;case"dynamic":case"gchord":case"gstemdir":case"ornament":case"stemdir":case"vocal":case"volume":set_pos(cmd,param);break;case"font":get_font_scale(param);break;case"fullsvg":if(parse.state!=0){syntax(1,"Cannot have %%fullsvg inside a tune");break}cfmt[cmd]=param;break;case"gracespace":cfmt[cmd]=param.split(/\s+/);break;case"tuplets":cfmt[cmd]=param.split(/\s+/);v=cfmt[cmd][3];if(v&&posval[v])cfmt[cmd][3]=posval[v];break;case"infoname":set_infoname(param);break;case"notespacingfactor":f=parseFloat(param);if(isNaN(f)||f<1||f>2){syntax(1,err_bad_val_s,"%%"+cmd);break}i=5;f2=space_tb[i];for(;--i>=0;){f2/=f;space_tb[i]=f2}i=5;f2=space_tb[i];for(;++i<space_tb.length;){f2*=f;space_tb[i]=f2}break;case"play":cfmt.sound="play";break;case"pos":cmd=param.split(/\s+/);set_pos(cmd[0],cmd[1]);break;case"sounding-score":cfmt.sound="sounding";break;case"staffwidth":v=get_unit(param);if(isNaN(v)){syntax(1,"Bad value in $1","%%"+cmd);break}if(v<100){syntax(1,"%%staffwidth too small");break}v=cfmt.pagewidth-v-cfmt.leftmargin;if(v<2){syntax(1,"%%staffwidth too big");break}cfmt.rightmargin=v;img.chg=true;break;case"textoption":cfmt[cmd]=get_textopt(param);break;case"combinevoices":case"voicecombine":v=parseInt(param);if(isNaN(v)){syntax(1,err_bad_val_s,"%%"+cmd);return}if(curvoice&&cmd=="combinevoices"){for(f=0;f<voice_tb.length;f++)voice_tb[f].combine=v;break}set_v_param("combine",v);break;case"voicemap":set_v_param("map",param);break;case"voicescale":v=parseFloat(param);if(isNaN(v)||v<.6||v>1.5){syntax(1,err_bad_val_s,"%%"+cmd);return}set_v_param("scale",v);break;default:if(parse.state==0)cfmt[cmd]=param;break}}function font_init(){param_set_font("annotationfont","sans-serif 12");param_set_font("composerfont","serifItalic 14");param_set_font("footerfont","serif 16");param_set_font("gchordfont","sans-serif 12");param_set_font("headerfont","serif 16");param_set_font("historyfont","serif 16");param_set_font("infofont","serifItalic 14");param_set_font("measurefont","serifItalic 14");param_set_font("partsfont","serif 15");param_set_font("repeatfont","serif 13");param_set_font("subtitlefont","serif 16");param_set_font("tempofont","serifBold 15");param_set_font("textfont","serif 16");param_set_font("titlefont","serif 20");param_set_font("vocalfont","serifBold 13");param_set_font("voicefont","serifBold 13");param_set_font("wordsfont","serif 16")}function style_font(fn){var r=fn.split("."),sz=r[1],i=fn.indexOf("Italic"),j=100,o=fn.indexOf("Oblique"),b=fn.indexOf("Bold");fn=r[0];r="";if(b>0){r+="font-weight:bold; ";j=b}if(i>0||o>0){if(i>0){r+="font-style:italic; ";if(i<j)j=i}if(o>0){r+="font-style:oblique; ";if(o<j)j=o}}if(j!=100){if(fn[j-1]=="-")j--;fn=fn.slice(0,j)}return"font-family:"+fn+"; "+r+"font-size:"+sz+"px"}Abc.prototype.style_font=style_font;function font_class(font){if(font.class)return"f"+font.fid+cfmt.fullsvg+" "+font.class;return"f"+font.fid+cfmt.fullsvg}function style_add_font(font){font_style+="\n.f"+font.fid+cfmt.fullsvg+" {"+style_font(font.name+"."+font.size)+"}"}function use_font(font){if(!defined_font[font.fid]){defined_font[font.fid]=true;style_add_font(font)}}function get_font(xxx){xxx+="font";var fn=cfmt[xxx],font=font_tb[fn];if(!font){syntax(1,"Unknown font $1",xxx);font=gene.curfont}if(!font.fid)font.fid=fid++;use_font(font);return font}var abc_utf={"=D":"Đ","=H":"Ħ","=T":"Ŧ","=d":"đ","=h":"ħ","=t":"ŧ","/O":"Ø","/o":"ø","/L":"Ł","/l":"ł",vL:"Ľ",vl:"ľ",vd:"ď",".i":"ı",AA:"Å",aa:"å",AE:"Æ",ae:"æ",DH:"Ð",dh:"ð",OE:"Œ",oe:"œ",ss:"ß",TH:"Þ",th:"þ"};function cnv_escape(src){var c,c2,dst="",i,j=0,codeUnits;while(1){i=src.indexOf("\\",j);if(i<0)break;dst+=src.slice(j,i);c=src[++i];if(!c)return dst+"\\";switch(c){case"0":case"2":if(src[i+1]=="0"){switch(src[i+2]){case"1":dst+="♯";j=i+3;continue;case"2":dst+="♭";j=i+3;continue;case"3":dst+="♮";j=i+3;continue;case"4":dst+="&#x1d12a;";j=i+3;continue;case"5":dst+="&#x1d12b;";j=i+3;continue}}case"1":case"3":if(src[i+1]>="0"&&src[i+1]<="7"&&src[i+2]>="0"&&src[i+2]<="7"){j=parseInt(src.slice(i,i+3),8);dst+=String.fromCharCode(j);j=i+3;continue}break;case"u":j=Number("0x"+src.slice(i+1,i+5));if(isNaN(j)){dst+=src[++i]+"̆";j=i+1;continue}codeUnits=[j];if(j>=55296&&j<=57343){j=Number("0x"+src.slice(i+7,i+11));if(isNaN(j))break;codeUnits.push(j);j=i+11}else{j=i+5}dst+=String.fromCharCode.apply(null,codeUnits);continue;case"t":dst+=" ";j=i+1;continue;default:c2=abc_utf[src.slice(i,i+2)];if(c2){dst+=c2;j=i+2;continue}switch(c){case"`":dst+=src[++i]+"̀";j=i+1;continue;case"'":dst+=src[++i]+"́";j=i+1;continue;case"^":dst+=src[++i]+"̂";j=i+1;continue;case"~":dst+=src[++i]+"̃";j=i+1;continue;case"=":dst+=src[++i]+"̄";j=i+1;continue;case"_":dst+=src[++i]+"̅";j=i+1;continue;case".":dst+=src[++i]+"̇";j=i+1;continue;case'"':dst+=src[++i]+"̈";j=i+1;continue;case"o":dst+=src[++i]+"̊";j=i+1;continue;case":":dst+=src[++i]+"̋";j=i+1;continue;case"v":dst+=src[++i]+"̌";j=i+1;continue;case"c":dst+=src[++i]+"̧";j=i+1;continue;case";":dst+=src[++i]+"̨";j=i+1;continue}break}dst+="\\"+c;j=i+1}return dst+src.slice(j)}var include=0;function do_include(fn){var file,parse_sav;if(!user.read_file){syntax(1,"No read_file support");return}if(include>2){syntax(1,"Too many include levels");return}include++;file=user.read_file(fn);if(!file){syntax(1,"Cannot read file '$1'",fn);return}if(fn.slice(-3)==".js"){if(is_secure(file))eval('"use strict"\n'+file);else syntax(1,"Unsecure code")}else{parse_sav=clone(parse);tosvg(fn,file);parse=parse_sav}include--}var err_ign_s="$1: inside tune - ignored",err_bad_val_s="Bad value in $1";function tosvg(in_fname,file){var i,c,bol,eol,end,ext,select,line0,line1,last_info,opt,text,a,b,s,cfmt_sav,info_sav,char_tb_sav,glovar_sav,maps_sav,mac_sav,maci_sav,pscom,txt_add="\n",eof=file.length;function tune_selected(){var re,res,i=file.indexOf("K:",bol);if(i<0){return false}i=file.indexOf("\n",i);if(parse.select.test(file.slice(bol,i)))return true;re=/\n\w*\n/;re.lastIndex=i;res=re.exec(file);if(res)eol=re.lastIndex;else eol=eof;return false}function uncomment(src,do_escape){src=src.replace(/[ \t]*[^\\]%.*/,"").replace(/\\%/g,"%");if(do_escape&&src.indexOf("\\")>=0)return cnv_escape(src);return src}function end_tune(){generate();if(info.W)put_words(info.W);put_history();blk_flush();parse.state=0;cfmt=cfmt_sav;info=info_sav;char_tb=char_tb_sav;glovar=glovar_sav;maps=maps_sav;mac=mac_sav;maci=maci_sav;init_tune();img.chg=true;set_page()}parse.file=file;parse.ctx={fname:in_fname};bol=0;for(bol=0;bol<eof;bol=parse.eol+1){eol=file.indexOf("\n",bol);if(eol<0)eol=eof;parse.eol=eol;while(1){eol--;switch(file[eol]){case" ":case"\t":continue}break}eol++;if(eol==bol){if(parse.state==1){parse.istart=bol;syntax(1,"Empty line in tune header - ignored")}else if(parse.state>=2){end_tune();if(parse.select){eol=file.indexOf("\nX:",parse.eol);if(eol<0)eol=eof;parse.eol=eol}}continue}parse.istart=parse.bol=bol;parse.iend=eol;parse.line.index=0;line0=file[bol];line1=file[bol+1];if(line0=="%"){if(parse.prefix.indexOf(line1)<0)continue;if(file[bol+2]=="a"&&file[bol+3]=="b"&&file[bol+4]=="c"&&file[bol+5]==" "){bol+=6;line0=file[bol];line1=file[bol+1]}else{pscom=true}}else if(line0=="I"&&line1==":"){pscom=true}if(pscom){pscom=false;bol+=2;while(1){switch(file[bol]){case" ":case"\t":bol++;continue}break}text=file.slice(bol,eol);if(!text||text[0]=="%")continue;a=text.split(/\s+/,2);if(!a[0])a.shift();switch(a[0]){case"abcm2ps":case"ss-pref":parse.prefix=a[1];continue;case"abc-include":ext=a[1].match(/.*\.(.*)/);if(!ext)continue;switch(ext[1]){case"abc":case"js":do_include(a[1]);break}continue}b=a[0].match(/begin(.*)/);if(b){end="\n"+line0+line1+"end"+b[1];i=file.indexOf(end,eol);if(i<0){syntax(1,"No $1 after %%$2",end.slice(1),b[0]);parse.eol=eof;continue}do_begin_end(b[1],a[1],file.slice(eol+1,i).replace(new RegExp("^"+line0+line1,"gm"),""));parse.eol=file.indexOf("\n",i+6);if(parse.eol<0)parse.eol=eof;continue}switch(a[0]){case"select":if(parse.state!=0){syntax(1,"%%select ignored");continue}select=uncomment(text.slice(7).trim(),false);if(select[0]=='"')select=select.slice(1,-1);if(!select){delete parse.select;continue}select=select.replace(/\(/g,"\\(");select=select.replace(/\)/g,"\\)");parse.select=new RegExp(select,"m");continue;case"tune":syntax(1,"%%tune not treated yet");continue;case"voice":if(parse.state!=0){syntax(1,"%%voice ignored");continue}select=uncomment(text.slice(6).trim(),false);if(!select){if(parse.cur_tune_opts)parse.cur_tune_opts.voice_opts=null;else parse.voice_opts=null;continue}if(select=="end")continue;if(parse.cur_tune_opts){if(!parse.cur_tune_opts.voice_opts)parse.cur_tune_opts.voice_opts={};opt=parse.cur_tune_opts.voice_opts}else{if(!parse.voice_opts)parse.voice_opts={};opt=parse.voice_opts}opt[select]=[];while(1){bol=++eol;if(file[bol]!="%")break;eol=file.indexOf("\n",eol);if(file[bol+1]!=line1)continue;bol+=2;if(eol<0)text=file.slice(bol);else text=file.slice(bol,eol);a=text.match(/\S+/);switch(a[0]){default:opt[select].push(uncomment(text.trim(),true));continue;case"score":case"staves":case"tune":case"voice":bol-=2;break}break}parse.eol=bol-1;continue}do_pscom(uncomment(text.trim(),true));continue}if(line1!=":"){last_info=undefined;if(parse.state<2)continue;parse.line.buffer=file.slice(bol,eol);parse_music_line();continue}text=uncomment(file.slice(bol+2,eol).trim(),true);if(line0=="+"){if(!last_info){syntax(1,"+: without previous info field");continue}txt_add=" ";line0=last_info}switch(line0){case"X":if(parse.state!=0){syntax(1,err_ign_s,line0);continue}if(parse.select&&!tune_selected()){eol=file.indexOf("\nX:",parse.eol);if(eol<0)eol=eof;parse.eol=eol;continue}cfmt_sav=clone(cfmt);cfmt.pos=clone(cfmt.pos);info_sav=clone(info);if(info.V){info_sav.V={};for(i in info.V)if(info.V.hasOwnProperty(i))info_sav.V[i]=clone(info.V[i])}char_tb_sav=clone(char_tb);glovar_sav=clone(glovar);maps_sav=maps;mac_sav=clone(mac);maci_sav=new Int8Array(128);for(i=0;i<128;i++)maci_sav[i]=maci[i];info.X=text;parse.state=1;continue;case"T":switch(parse.state){case 0:continue;case 1:if(info.T==undefined)info.T=text;else info.T+="\n"+text;continue}s=new_block("title");s.text=text;continue;case"K":switch(parse.state){case 0:continue;case 1:info.K=text;break}do_info(line0,text);continue;case"W":if(parse.state==0||cfmt.writefields.indexOf(line0)<0)break;if(info.W==undefined)info.W=text;else info.W+=txt_add+text;break;case"m":if(parse.state>=2){syntax(1,err_ign_s,line0);continue}if((!cfmt.sound||cfmt.sound!="play")&&cfmt.writefields.indexOf(line0)<0)break;a=text.match(/(.*?)[= ]+(.*)/);if(!a||!a[2]){syntax(1,err_bad_val_s,"m:");continue}mac[a[1]]=a[2];maci[a[1].charCodeAt(0)]=1;break;case"s":if(parse.state!=3||cfmt.writefields.indexOf(line0)<0)break;get_sym(text,txt_add==" ");break;case"w":if(parse.state!=3||cfmt.writefields.indexOf(line0)<0)break;get_lyrics(text,txt_add==" ");if(text.slice(-1)=="\\"){txt_add=" ";last_info=line0;continue}break;case"|":if(parse.state<2)continue;parse.line.buffer=file.slice(bol,eol);parse_music_line();continue;default:if("ABCDFGHOSZ".indexOf(line0)>=0){if(parse.state>=2){syntax(1,err_ign_s,line0);continue}if(!info[line0])info[line0]=text;else info[line0]+=txt_add+text;break}do_info(line0,text);continue}txt_add="\n";last_info=line0}if(include)return;if(parse.state>=2)end_tune();parse.state=0}Abc.prototype.tosvg=tosvg;var gene,staff_tb,nstaff,tsnext,realwidth,insert_meter,beta_last,space_tb=new Float32Array([7,10,14.15,20,28.3,40,56.6,80,100,120]),smallest_duration;var dx_tb=new Float32Array([10,10,11,13,13]);var hw_tb=new Float32Array([4.5,5,6,7,8]);var w_note=new Float32Array([3.5,3.7,5,6,7]);function set_head_shift(s){var i,i1,i2,d,ps,dx,dx_head=dx_tb[s.head],dir=s.stem,n=s.nhd;if(n==0)return;dx=dx_head*.78;if(s.grace)dx*=.5;if(dir>=0){i1=1;i2=n+1;ps=s.notes[0].pit}else{dx=-dx;i1=n-1;i2=-1;ps=s.notes[n].pit}var shift=false,dx_max=0;for(i=i1;i!=i2;i+=dir){d=s.notes[i].pit-ps;ps=s.notes[i].pit;if(d==0){if(shift){var new_dx=s.notes[i].shhd=s.notes[i-dir].shhd+dx;if(dx_max<new_dx)dx_max=new_dx;continue}if(i+dir!=i2&&ps+dir==s.notes[i+dir].pit){s.notes[i].shhd=-dx;if(dx_max<-dx)dx_max=-dx;continue}}if(d<0)d=-d;if(d>3||d>=2&&s.head!=SQUARE){shift=false}else{shift=!shift;if(shift){s.notes[i].shhd=dx;if(dx_max<dx)dx_max=dx}}}s.xmx=dx_max}function acc_shift(notes,dx_head){var i,i1,dx,dx1,ps,p1,acc,n=notes.length;for(i=n-1;--i>=0;){dx=notes[i].shhd;if(!dx||dx>0)continue;dx=dx_head-dx;ps=notes[i].pit;for(i1=n;--i1>=0;){if(!notes[i1].acc)continue;p1=notes[i1].pit;if(p1<ps-3)break;if(p1>ps+3)continue;if(notes[i1].shac<dx)notes[i1].shac=dx}}for(i=n;--i>=0;){acc=notes[i].acc;if(!acc)continue;dx=notes[i].shac;if(!dx){dx=notes[i].shhd;if(dx<0)dx=dx_head-dx;else dx=dx_head}ps=notes[i].pit;for(i1=n;--i1>i;){if(!notes[i1].acc)continue;p1=notes[i1].pit;if(p1>=ps+4){if(p1>ps+4||acc<0||notes[i1].acc<0)continue}if(dx>notes[i1].shac-6){dx1=notes[i1].shac+7;if(dx1>dx)dx=dx1}}notes[i].shac=dx}}function set_acc_shft(){var s,s2,st,i,acc,st,t,dx_head;s=tsfirst;while(s){if(s.type!=NOTE||s.invis){s=s.ts_next;continue}st=s.st;t=s.time;acc=false;for(s2=s;s2;s2=s2.ts_next){if(s2.time!=t||s2.type!=NOTE||s2.st!=st)break;if(acc)continue;for(i=0;i<=s2.nhd;i++){if(s2.notes[i].acc){acc=true;break}}}if(!acc){s=s2;continue}dx_head=dx_tb[s.head];st={notes:[]};for(;s!=s2;s=s.ts_next)st.notes=st.notes.concat(s.notes);sort_pitch(st);acc_shift(st.notes,dx_head)}}function lkvsym(s,next){s.next=next;s.prev=next.prev;if(s.prev)s.prev.next=s;else s.p_v.sym=s;next.prev=s}function lktsym(s,next){if(next){s.ts_next=next;s.ts_prev=next.ts_prev;if(s.ts_prev)s.ts_prev.ts_next=s;next.ts_prev=s}else{s.ts_next=s.ts_prev=null}}function unlksym(s){if(s.next)s.next.prev=s.prev;if(s.prev)s.prev.next=s.next;else s.p_v.sym=s.next;if(s.ts_next){if(s.seqst&&!s.ts_next.seqst){s.ts_next.seqst=true;s.ts_next.shrink=s.shrink;s.ts_next.space=s.space}s.ts_next.ts_prev=s.ts_prev}if(s.ts_prev)s.ts_prev.ts_next=s.ts_next;if(tsfirst==s)tsfirst=s.ts_next;if(tsnext==s)tsnext=s.ts_next}function may_combine(s){var nhd2,s2=s.ts_next;if(!s2||s2.type!=NOTE&&s2.type!=REST)return false;if(s2.v==s.v||s2.st!=s.st||s2.time!=s.time||s2.dur!=s.dur)return false;if(s.combine<=0&&s2.type!=s.type)return false;if(s.a_gch&&s2.a_gch)return false;if(s.type==REST){if(s.type==s2.type&&s.invis&&!s2.invis)return false;return true}if(s2.a_ly||s2.sl1||s2.sl2||s2.slur_start||s2.slur_end)return false;if(s2.beam_st!=s.beam_st||s2.beam_end!=s.beam_end)return false;nhd2=s2.nhd;if(s.combine<=1&&s.notes[0].pit<=s2.notes[nhd2].pit+1)return false;return true}function combine_notes(s,s2){var nhd,type,m;s.notes=s.notes.concat(s2.notes);s.nhd=nhd=s.notes.length-1;sort_pitch(s);if(s.combine>=3){for(m=nhd;m>0;m--){if(s.notes[m].pit==s.notes[m-1].pit&&s.notes[m].acc==s.notes[m-1].acc)s.notes.splice(m,1)}s.nhd=nhd=s.notes.length-1}s.ymx=3*(s.notes[nhd].pit-18)+4;s.ymn=3*(s.notes[0].pit-18)-4;type=s.notes[0].ti1;if((type&15)==SL_AUTO)s.notes[0].ti1=SL_BELOW|type&~SL_DOTTED;type=s.notes[nhd].ti1;if((type&15)==SL_AUTO)s.notes[nhd].ti1=SL_ABOVE|type&~SL_DOTTED}function do_combine(s){var s2,nhd,nhd2,type;while(1){nhd=s.nhd;s2=s.ts_next;nhd2=s2.nhd;if(s.type!=s2.type){if(s2.type!=REST){s2=s;s=s2.ts_next}}else if(s.type==REST){if(s.invis&&!s2.invis)delete s.invis}else{combine_notes(s,s2)}if(s2.a_gch)s.a_gch=s2.a_gch;if(s2.a_dd){if(!s.a_dd)s.a_dd=s2.a_dd;else s.a_dd=s.a_dd.concat(s2.a_dd)}unlksym(s2);if(s.in_tuplet||!may_combine(s))break}}function combine_voices(){var s,s2,g,i,r;for(s=tsfirst;s;s=s.ts_next){switch(s.type){case REST:if(s.combine<0)continue;if(may_combine(s))do_combine(s);continue;default:continue;case NOTE:if(s.combine<=0)continue;break}if(!s.beam_st)continue;if(s.beam_end){if(may_combine(s))do_combine(s);continue}s2=s;while(1){if(!may_combine(s2)){s2=null;break}if(s2.beam_end)break;do{s2=s2.next}while(s2.type!=NOTE&&s2.type!=REST)}if(!s2)continue;s2=s;while(1){do_combine(s2);if(s2.beam_end)break;do{s2=s2.next}while(s2.type!=NOTE&&s2.type!=REST)}}}function insert_clef(s,clef_type,clef_line){var p_voice=s.p_v,new_s,st=s.st;if(s.type==BAR&&s.prev&&s.prev.type==BAR)s=s.prev;p_voice.last_sym=s.prev;if(!p_voice.last_sym)p_voice.sym=null;p_voice.time=s.time;new_s=sym_add(p_voice,CLEF);new_s.next=s;s.prev=new_s;new_s.clef_type=clef_type;new_s.clef_line=clef_line;new_s.st=st;new_s.clef_small=true;delete new_s.second;new_s.notes=[];new_s.notes[0]={pit:s.notes[0].pit};new_s.nhd=0;while(!s.seqst)s=s.ts_prev;lktsym(new_s,s);if(new_s.ts_prev.type!=CLEF)new_s.seqst=true;return new_s}function set_float(){var p_voice,st,staff_chg,v,s,s1,up,down;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];staff_chg=false;st=p_voice.st;for(s=p_voice.sym;s;s=s.next){if(!s.floating){while(s&&!s.floating)s=s.next;if(!s)break;staff_chg=false}if(!s.dur){if(staff_chg)s.st++;continue}if(s.notes[0].pit>=19){staff_chg=false;continue}if(s.notes[s.nhd].pit<=12){staff_chg=true;s.st++;continue}up=127;for(s1=s.ts_prev;s1;s1=s1.ts_prev){if(s1.st!=st||s1.v==s.v)break;if(s1.type==NOTE)if(s1.notes[0].pit<up)up=s1.notes[0].pit}if(up==127){if(staff_chg)s.st++;continue}if(s.notes[s.nhd].pit>up-3){staff_chg=false;continue}down=-127;for(s1=s.ts_next;s1;s1=s1.ts_next){if(s1.st!=st+1||s1.v==s.v)break;if(s1.type==NOTE)if(s1.notes[s1.nhd].pit>down)down=s1.notes[s1.nhd].pit}if(down==-127){if(staff_chg)s.st++;continue}if(s.notes[0].pit<down+3){staff_chg=true;s.st++;continue}up-=s.notes[s.nhd].pit;down=s.notes[0].pit-down;if(!staff_chg){if(up<down+3)continue;staff_chg=true}else{if(up<down-3){staff_chg=false;continue}}s.st++}}}function set_graceoffs(s){var next,m,dx,gspleft=Number(cfmt.gracespace[0]),gspinside=Number(cfmt.gracespace[1]),gspright=Number(cfmt.gracespace[2]),xx=0,g=s.extra;g.beam_st=true;for(;;g=g.next){set_head_shift(g);acc_shift(g.notes,7);dx=0;for(m=g.nhd;m>=0;m--){if(g.notes[m].shac>dx)dx=g.notes[m].shac}xx+=dx;g.x=xx;if(g.nflags<=0){g.beam_st=true;g.beam_end=true}next=g.next;if(!next){g.beam_end=true;break}if(next.nflags<=0)g.beam_end=true;if(g.beam_end){next.beam_st=true;xx+=gspinside/4}if(g.nflags<=0)xx+=gspinside/4;if(g.y>next.y+8)xx-=1.5;xx+=gspinside}xx+=gspleft+gspright;next=s.next;if(next&&next.type==NOTE){if(g.y>=3*(next.notes[next.nhd].pit-18))xx-=1;else if(g.beam_st&&g.y<3*(next.notes[0].pit-18)-7)xx+=2}return xx}function gchord_width(s,wlnote,wlw){var s2,gch,w,wl,ix,lspc=0,rspc=0,alspc=0,arspc=0;for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];switch(gch.type){default:wl=-gch.x;if(wl>lspc)lspc=wl;w=gch.w+2-wl;if(w>rspc)rspc=w;break;case"<":w=gch.w+wlnote;if(w>alspc)alspc=w;break;case">":w=gch.w+s.wr;if(w>arspc)arspc=w;break}}s2=s.prev;if(s2){if(s2.a_gch){for(s2=s.ts_prev;;s2=s2.ts_prev){if(s2==s.prev){if(wlw<lspc)wlw=lspc;break}if(s2.seqst)lspc-=s2.shrink}}if(alspc!=0)if(wlw<alspc)wlw=alspc}s2=s.next;if(s2){if(s2.a_gch){for(s2=s.ts_next;;s2=s2.ts_next){if(s2==s.next){if(s.wr<rspc)s.wr=rspc;break}if(s2.seqst)rspc-=8}}if(arspc!=0)if(s.wr<arspc)s.wr=alspc}return wlw}function set_width(s){var s2,i,m,xx,w,wlnote,wlw,acc;switch(s.type){case NOTE:case REST:s.wr=wlnote=hw_tb[s.head];if(s.xmx>0)s.wr+=s.xmx+4;for(s2=s.prev;s2;s2=s2.prev){if(w_tb[s2.type]!=0)break}if(s2){switch(s2.type){case BAR:case CLEF:case KEY:case METER:wlnote+=3;break}}for(m=0;m<=s.nhd;m++){xx=s.notes[m].shhd;if(xx<0){if(wlnote<-xx+5)wlnote=-xx+5}if(s.notes[m].acc){var tmp=s.notes[m].shac+(s.notes[m].micro?6.5:4.5);if(wlnote<tmp)wlnote=tmp}}if(s2){switch(s2.type){case BAR:case CLEF:case KEY:case METER:wlnote-=3;break}}if(s.a_dd)wlnote+=deco_width(s);if(s.beam_st&&s.beam_end&&s.stem>0&&s.nflags>0){if(s.wr<s.xmx+9)s.wr=s.xmx+9}if(s.dots>0){switch(s.head){case SQUARE:s.xmx+=4;break;case OVALBARS:case OVAL:s.xmx+=2;break;case EMPTY:s.xmx+=1;break}if(s.wr<s.xmx+12)s.wr=s.xmx+12;if(s.dots>=2)s.wr+=3.5*(s.dots-1)}if(s.trem2&&s.beam_end&&wlnote<20)wlnote=20;wlw=wlnote;if(s2){switch(s2.type){case NOTE:if(s2.stem>0&&s.stem<0){if(wlw<7)wlw=7}if(s.y>27&&s2.y>27||s.y<-3&&s2.y<-3){if(wlw<6)wlw=6}if(s2.ti1){if(wlw<14)wlw=14}break;case CLEF:if(s2.second||s2.clef_small)break;wlw+=8;break;case KEY:wlw+=4;break}}if(s.a_gch)wlw=gchord_width(s,wlnote,wlw);if(s.a_ly)wlw=ly_width(s,wlw);if(s2&&s2.type==GRACE)s.wl=wlnote-4.5;else s.wl=wlw;return;case SPACE:xx=s.width/2;s.wr=xx;if(s.a_gch)xx=gchord_width(s,xx,xx);if(s.a_dd)xx+=deco_width(s);s.wl=xx;return;case BAR:if(s.norepbra)break;if(!s.invis){var bar_type=s.bar_type;switch(bar_type){case"|":w=7;break;case"|:":case":|":w=15;break;case"::":w=26;break;default:if(!bar_type)break;w=4+3*bar_type.length;for(i=0;i<bar_type.length;i++){switch(bar_type[i]){case"[":case"]":w+=3;break;case":":w+=2;break}}break}s.wl=w;if(s.next&&s.next.type!=METER)s.wr=7;else s.wr=5;for(s2=s.prev;s2;s2=s2.prev){if(w_tb[s2.type]!=0){if(s2.type==GRACE)s.wl-=8;break}}}else{s.wl=s.wr=0}if(s.a_dd)s.wl+=deco_width(s);if(s.text&&s.text.length<4&&s.next&&s.next.a_gch){set_font("repeat");s.wr+=strw(s.text)+2}return;case CLEF:s.wl=s.wr=s.clef_small?6:12;return;case KEY:var n1,n2,esp;s.wl=3;esp=4;if(!s.k_a_acc){n1=s.k_sf;if(s.k_old_sf&&(cfmt.cancelkey||n1==0))n2=s.k_old_sf;else n2=0;if(n1*n2>=0){if(n1<0)n1=-n1;if(n2<0)n2=-n2;if(n2>n1)n1=n2}else{n1-=n2;if(n1<0)n1=-n1;esp+=3}}else{n1=n2=s.k_a_acc.length;if(n2)var last_acc=s.k_a_acc[0].acc;for(i=1;i<n2;i++){acc=s.k_a_acc[i];if(acc.pit>s.k_a_acc[i-1].pit+6||acc.pit<s.k_a_acc[i-1].pit-6)n1--;else if(acc.acc!=last_acc)esp+=3;last_acc=acc.acc}}s.wr=5.5*n1+esp;return;case METER:w=0;for(i=0;i<s.a_meter.length;i++){var meter=s.a_meter[i];if(meter.top=="C|"){w+=6.5}else{if(!meter.bot||meter.top.length>meter.bot.length)w+=6.5*meter.top.length;else w+=6.5*meter.bot.length}}s.wl=w;s.wr=w+7;return;case MREST:s.wl=6;s.wr=66;return;case GRACE:s.wl=set_graceoffs(s);s.wr=0;if(s.a_ly)ly_width(s,wlw);return;case STBRK:s.wl=s.xmx;if(s.next&&s.next.type==CLEF){s.wr=2;delete s.next.clef_small}else{s.wr=8}return;case CUSTOS:s.wl=s.wr=4;return;case BLOCK:case PART:case REMARK:case STAVES:case TEMPO:break;default:error(2,s,"set_width - Cannot set width for symbol $1",s.type);break}s.wl=s.wr=0}function set_space(s){var s2,i,l,space,prev_time=s.ts_prev.time,len=s.time-prev_time;if(len==0){switch(s.type){case MREST:return s.wl}return 0}if(s.ts_prev.type==MREST)return 71;if(smallest_duration>=BASE_LEN/2){if(smallest_duration>=BASE_LEN)len/=4;else len/=2}else if(!s.next&&len>=BASE_LEN){len/=2}if(len>=BASE_LEN/4){if(len<BASE_LEN/2)i=5;else if(len<BASE_LEN)i=6;else if(len<BASE_LEN*2)i=7;else if(len<BASE_LEN*4)i=8;else i=9}else{if(len>=BASE_LEN/8)i=4;else if(len>=BASE_LEN/16)i=3;else if(len>=BASE_LEN/32)i=2;else if(len>=BASE_LEN/64)i=1;else i=0}l=len-(BASE_LEN/16/8<<i);space=space_tb[i];if(l!=0){if(l<0){space=space_tb[0]*len/(BASE_LEN/16/8)}else{if(i>=9)i=8;space+=(space_tb[i+1]-space_tb[i])*l/len}}while(!s.dur){switch(s.type){case BAR:return space*.9-7;case CLEF:return space-s.wl;case BLOCK:case PART:case REMARK:case STAVES:case TEMPO:s=s.ts_next;if(!s)return space;continue}break}if(!s.beam_st)space*=.9;if(s.type==NOTE&&s.nflags>=-1&&s.stem>0){var stemdir=true;for(s2=s.ts_prev;s2&&s2.time==prev_time;s2=s2.ts_prev){if(s2.type==NOTE&&(s2.nflags<-1||s2.stem>0)){stemdir=false;break}}if(stemdir){for(s2=s.ts_next;s2&&s2.time==s.time;s2=s2.ts_next){if(s2.type==NOTE&&(s2.nflags<-1||s2.stem<0)){stemdir=false;break}}if(stemdir)space*=.9}}return space}function add_end_bar(s){return{type:BAR,bar_type:"|",ctx:s.ctx,istart:s.istart,iend:s.iend,v:s.v,p_v:s.p_v,st:s.st,dur:0,seqst:true,invis:true,time:s.time+s.dur,nhd:0,notes:[{pit:s.notes[0].pit}],wl:0,wr:0}}function set_allsymwidth(last_s){var new_val,s=tsfirst,xa=0,xl=[];while(1){var maxx=xa,s2=s;do{if(!last_s||!s.dur)set_width(s);new_val=(xl[s.st]||0)+s.wl;if(new_val>maxx)maxx=new_val;s=s.ts_next}while(s!=last_s&&!s.seqst);s2.shrink=maxx-xa;if(s2.ts_prev)s2.space=set_space(s2);else s2.space=0;if(s2.shrink==0&&s2.space==0&&s2.type==CLEF){delete s2.seqst;s2.time=s2.ts_prev.time}if(s==last_s)break;xa=maxx;s=s2;do{if(!xl[s.st]||xl[s.st]<xa+s.wr)xl[s.st]=xa+s.wr;s=s.ts_next}while(!s.seqst)}}function to_rest(s){s.type=REST;delete s.in_tuplet;delete s.sl1;delete s.sl2;delete s.a_dd;delete s.a_gch;s.slur_start=s.slur_end=0}var err_no_s="Not enough notes/rests for %%repeat",err_no_m="Not enough measures for %%repeat";function set_repeat(s){var s2,s3,i,j,dur,n=s.repeat_n,k=s.repeat_k,st=s.st,v=s.v;s.repeat_n=0;if(n<0){n=-n;i=n;for(s3=s.prev;s3;s3=s3.prev){if(!s3.dur){if(s3.type==BAR){error(1,s3,"Bar in repeat sequence");return}continue}if(--i<=0)break}if(!s3){error(1,s,err_no_s);return}dur=s.time-s3.time;i=k*n;for(s2=s;s2;s2=s2.next){if(!s2.dur){if(s2.type==BAR){error(1,s2,"Bar in repeat sequence");return}continue}if(--i<=0)break}if(!s2||!s2.next){error(1,s,err_no_s);return}for(s2=s.prev;s2!=s3;s2=s2.prev){if(s2.type==NOTE){s2.beam_end=true;break}}for(j=k;--j>=0;){i=n;if(s.dur)i--;s2=s.ts_next;while(i>0){if(s2.st==st){unlksym(s2);if(s2.v==v&&s2.dur)i--}s2=s2.ts_next}to_rest(s);s.dur=s.notes[0].dur=dur;s.rep_nb=-1;s.beam_st=true;set_width(s);if(s.seqst)s.space=set_space(s);s.head=SQUARE;for(s=s2;s;s=s.ts_next){if(s.st==st&&s.v==v&&s.dur)break}}return}i=n;for(s2=s.prev.prev;s2;s2=s2.prev){if(s2.type==BAR||s2.time==tsfirst.time){if(--i<=0)break}}if(!s2){error(1,s,err_no_m);return}dur=s.time-s2.time;if(n==1)i=k;else i=n;for(s2=s;s2;s2=s2.next){if(s2.type==BAR){if(--i<=0)break}}if(!s2){error(1,s,err_no_m);return}i=k;if(n==2&&i>1){s2=s2.next;if(!s2){error(1,s,err_no_m);return}s2.repeat_n=n;s2.repeat_k=--i}dur/=n;if(n==2){s3=s;for(s2=s.ts_next;;s2=s2.ts_next){if(s2.st!=st)continue;if(s2.v==v&&s2.type==BAR)break;unlksym(s2)}to_rest(s3);s3.dur=s3.notes[0].dur=dur;s3.invis=true;if(s3.seqst)s3.space=set_space(s3);s2.bar_mrep=2;if(s2.seqst)s2.space=set_space(s2);s3=s2.next;for(s2=s3.ts_next;;s2=s2.ts_next){if(s2.st!=st)continue;if(s2.v==v&&s2.type==BAR)break;unlksym(s2)}to_rest(s3);s3.dur=s3.notes[0].dur=dur;s3.invis=true;set_width(s3);if(s3.seqst)s3.space=set_space(s3);if(s2.seqst)s2.space=set_space(s2);return}s3=s;for(j=k;--j>=0;){for(s2=s3.ts_next;;s2=s2.ts_next){if(s2.st!=st)continue;if(s2.v==v&&s2.type==BAR)break;unlksym(s2)}to_rest(s3);s3.dur=s3.notes[0].dur=dur;s3.beam_st=true;if(s3.seqst)s3.space=set_space(s3);if(s2.seqst)s2.space=set_space(s2);if(k==1){s3.rep_nb=1;break}s3.rep_nb=k-j+1;s3=s2.next}}function custos_add(s){var p_voice,new_s,i,s2=s;while(1){if(s2.type==NOTE)break;s2=s2.next;if(!s2)return}p_voice=s.p_v;p_voice.last_sym=s.prev;p_voice.time=s.time;new_s=sym_add(p_voice,CUSTOS);new_s.next=s;s.prev=new_s;lktsym(new_s,s);new_s.seqst=true;new_s.shrink=s.shrink;if(new_s.shrink<8+4)new_s.shrink=8+4;new_s.space=s2.space;new_s.wl=0;new_s.wr=4;new_s.nhd=s2.nhd;new_s.notes=[];for(i=0;i<s.notes.length;i++){new_s.notes[i]={pit:s2.notes[i].pit,shhd:0,dur:BASE_LEN/4}}new_s.stemless=true}function set_nl(s){var s2,p_voice,done;function set_eol(s){if(cfmt.custos&&voice_tb.length==1)custos_add(s);for(var s2=s.ts_next;s2;s2=s2.ts_next){if(s2.seqst){s.nl=true;break}}}function set_eol_next(s){if(!s.next){set_eol(s);return s}for(s=s.ts_next;s;s=s.ts_next){if(s.seqst){set_eol(s);break}}return s}if(s.eoln&&!cfmt.keywarn&&!cfmt.timewarn)return set_eol_next(s);switch(s.type){case CLEF:case BAR:case STAVES:break;case KEY:if(cfmt.keywarn&&!s.k_none)break;return set_eol_next(s);case METER:if(cfmt.timewarn)break;return set_eol_next(s);case GRACE:s=s.next;if(!s)return s;default:return set_eol_next(s)}for(;s;s=s.ts_prev){if(!s.seqst)continue;switch(s.type){case KEY:case CLEF:case METER:continue}break}done=0;for(;;s=s.ts_next){if(!s)return s;if(!s.seqst)continue;if(done<0)break;switch(s.type){case STAVES:if(s.ts_prev&&s.ts_prev.type==BAR)break;while(s.ts_next){if(w_tb[s.ts_next.type]!=0&&s.ts_next.type!=CLEF)break;s=s.ts_next}if(!s.ts_next||s.ts_next.type!=BAR)continue;s=s.ts_next;case BAR:if(done)break;done=1;continue;case STBRK:if(!s.stbrk_forced)unlksym(s);else done=-1;continue;case METER:if(!cfmt.timewarn)break;continue;case CLEF:if(done)break;continue;case KEY:if(!cfmt.keywarn||s.k_none)break;continue;default:if(!done||s.prev&&s.prev.type==GRACE)continue;break}break}set_eol(s);return s}function get_ck_width(){var r0,r1,p_voice=voice_tb[0];set_width(p_voice.clef);set_width(p_voice.key);set_width(p_voice.meter);return[p_voice.clef.wl+p_voice.clef.wr+p_voice.key.wl+p_voice.key.wr,p_voice.meter.wl+p_voice.meter.wr]}function get_width(s,last){var shrink,space,w=0,sp_fac=1-cfmt.maxshrink;do{if(s.seqst){shrink=s.shrink;if((space=s.space)<shrink)w+=shrink;else w+=shrink*cfmt.maxshrink+space*sp_fac;s.x=w}if(s==last)break;s=s.ts_next}while(s);return w}function set_lines(s,last,lwidth,indent){var first,s2,s3,x,xmin,xmid,xmax,wwidth,shrink,space,nlines,cut_here;for(;last;last=last.ts_next){if(last.eoln)break}wwidth=get_width(s,last)+indent;while(1){nlines=Math.ceil(wwidth/lwidth);if(nlines<=1){if(last)last=set_nl(last);return last}s2=first=s;xmin=s.x-s.shrink-indent;xmax=xmin+lwidth;xmid=xmin+wwidth/nlines;xmin+=wwidth/nlines*cfmt.breaklimit;for(s=s.ts_next;s!=last;s=s.ts_next){if(!s.x)continue;if(s.type==BAR)s2=s;if(s.x>=xmin)break}if(s==last){if(last)last=set_nl(last);return last}cut_here=false;s3=null;for(;s!=last;s=s.ts_next){x=s.x;if(!x)continue;if(x>xmax)break;if(s.type!=BAR)continue;if(x<xmid){s3=s;continue}if(!s3||xmid-s3.x>s.x-xmid)s3=s;break}if(s3){s=s3;cut_here=true}if(!cut_here){var beam=0,bar_time=s2.time;xmax-=8;s=s2;s3=null;for(;s!=last;s=s.ts_next){if(s.beam_st)beam++;if(s.beam_end&&beam>0)beam--;x=s.x;if(!x)continue;if(x+s.wr>=xmax)break;if(beam||s.in_tuplet)continue;if((s.time-bar_time)%(BASE_LEN/4)==0){s3=s;continue}if(!s3||xmid-s3.x>s.x-xmid)s3=s;break}if(s3){s=s3;cut_here=true}}if(!cut_here){s3=s=s2;for(;s!=last;s=s.ts_next){x=s.x;if(!x)continue;if(x<xmid){s3=s;continue}if(xmid-s3.x>s.x-xmid)s3=s;break}s=s3}if(s.nl){error(0,s,"Line split problem - adjust maxshrink and/or breaklimit");nlines=2;for(s=s.ts_next;s!=last;s=s.ts_next){if(!s.x)continue;if(--nlines<=0)break}}s=set_nl(s);if(!s||last&&s.time>=last.time)break;wwidth-=s.x-first.x;indent=0}return s}function cut_tune(lwidth,indent){var s,s2,s3,i,xmin,s=tsfirst;if(indent!=0){i=set_indent();lwidth-=i;indent-=i}i=get_ck_width();lwidth-=i[0];indent+=i[1];if(cfmt.custos&&voice_tb.length==1)lwidth-=12;if(cfmt.barsperstaff){i=cfmt.barsperstaff;for(s2=s;s2;s2=s2.ts_next){if(s2.type!=BAR||!s2.bar_num||--i>0)continue;s2.eoln=true;i=cfmt.barsperstaff}}xmin=indent;s2=s;for(;s;s=s.ts_next){if(!s.seqst&&!s.eoln)continue;xmin+=s.shrink;if(xmin>lwidth){s2=set_lines(s2,s,lwidth,indent)}else{if(!s.eoln)continue;delete s.eoln;if(s.dur){for(s3=s.ts_next;s3;s3=s3.ts_next){if(s3.seqst||s3.dur<s.dur)break}if(s3&&!s3.seqst)s2=set_lines(s2,s,lwidth,indent);else s2=set_nl(s)}else{s2=set_nl(s)}}if(!s2)break;if(!s2.ts_prev){delete s2.nl;continue}xmin=s2.shrink;s=s2.ts_prev;indent=0}}function set_yval(s){switch(s.type){case CLEF:if(s.second||s.invis){s.ymx=s.ymn=12;break}s.y=(s.clef_line-1)*6;switch(s.clef_type){default:s.ymx=s.y+28;s.ymn=s.y-14;break;case"c":s.ymx=s.y+13;s.ymn=s.y-11;break;case"b":s.ymx=s.y+7;s.ymn=s.y-12;break}if(s.clef_small){s.ymx-=2;s.ymn+=2}if(s.ymx<26)s.ymx=26;if(s.ymn>-1)s.ymn=-1;if(s.clef_octave){if(s.clef_octave>0)s.ymx+=12;else s.ymn-=12}break;case KEY:if(s.k_sf>2)s.ymx=24+10;else if(s.k_sf>0)s.ymx=24+6;else s.ymx=24+2;s.ymn=-2;break;default:s.ymx=24+2;s.ymn=-2;break}}function set_auto_clef(st,s_start,clef_type_start){var s,min,max,time,s2,s3;max=12;min=20;for(s=s_start;s;s=s.ts_next){if(s.type==STAVES&&s!=s_start)break;if(s.st!=st)continue;if(s.type!=NOTE){if(s.type==CLEF){if(s.clef_type!="a")break;unlksym(s)}continue}if(s.notes[0].pit<min)min=s.notes[0].pit;else if(s.notes[s.nhd].pit>max)max=s.notes[s.nhd].pit}if(min>=19||min>=13&&clef_type_start!="b")return"t";if(max<=13||max<=19&&clef_type_start!="t")return"b";if(clef_type_start=="a"){if((max+min)/2>=16)clef_type_start="t";else clef_type_start="b"}var clef_type=clef_type_start,s_last=s,s_last_chg=null;for(s=s_start;s!=s_last;s=s.ts_next){if(s.type==STAVES&&s!=s_start)break;if(s.st!=st||s.type!=NOTE)continue;time=s.time;if(clef_type=="t"){if(s.notes[0].pit>12||s.notes[s.nhd].pit>20){if(s.notes[0].pit>20)s_last_chg=s;continue}s2=s.ts_prev;if(s2&&s2.time==time&&s2.st==st&&s2.type==NOTE&&s2.notes[0].pit>=19)continue;s2=s.ts_next;if(s2&&s2.st==st&&s2.time==time&&s2.type==NOTE&&s2.notes[0].pit>=19)continue}else{if(s.notes[0].pit<12||s.notes[s.nhd].pit<20){if(s.notes[s.nhd].pit<12)s_last_chg=s;continue}s2=s.ts_prev;if(s2&&s2.time==time&&s2.st==st&&s2.type==NOTE&&s2.notes[0].pit<=13)continue;s2=s.ts_next;if(s2&&s2.st==st&&s2.time==time&&s2.type==NOTE&&s2.notes[0].pit<=13)continue}if(!s_last_chg){clef_type=clef_type_start=clef_type=="t"?"b":"t";s_last_chg=s;continue}s3=s;for(s2=s.ts_prev;s2!=s_last_chg;s2=s2.ts_prev){if(s2.st!=st)continue;if(s2.type==BAR&&s2.v==s.v){s3=s2;break}if(s2.type!=NOTE)continue;if(s2.beam_st&&!s2.p_v.second)s3=s2}if(s3.time==s_last_chg.time){s_last_chg=s;continue}s_last_chg=s;clef_type=clef_type=="t"?"b":"t";s2=insert_clef(s3,clef_type,clef_type=="t"?2:4);s2.clef_auto=true}return clef_type_start}function set_clefs(){var s,s2,st,v,p_voice,g,new_type,new_line,p_staff,pit,staff_clef=new Array(nstaff),sy=cur_sy,mid=[];staff_tb=new Array(nstaff);for(st=0;st<=nstaff;st++){staff_clef[st]={autoclef:true};staff_tb[st]={output:[],sc_out:[]}}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(sy.voices[v].range<0)continue;st=sy.voices[v].st;if(!sy.voices[v].second){if(p_voice.stafflines!=undefined)sy.staves[st].stafflines=p_voice.stafflines;if(p_voice.staffscale)sy.staves[st].staffscale=p_voice.staffscale;if(sy.voices[v].sep)sy.staves[st].sep=sy.voices[v].sep;if(sy.voices[v].maxsep)sy.staves[st].maxsep=sy.voices[v].maxsep}if(!sy.voices[v].second&&!p_voice.clef.clef_auto)staff_clef[st].autoclef=false}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(sy.voices[v].range<0||sy.voices[v].second)continue;st=sy.voices[v].st;s=p_voice.clef;if(staff_clef[st].autoclef){s.clef_type=set_auto_clef(st,tsfirst,s.clef_type);s.clef_line=s.clef_type=="t"?2:4}staff_clef[st].clef=staff_tb[st].clef=s}for(st=0;st<=sy.nstaff;st++)mid[st]=(sy.staves[st].stafflines.length-1)*3;for(s=tsfirst;s;s=s.ts_next){if(s.repeat_n)set_repeat(s);switch(s.type){case STAVES:sy=s.sy;for(st=0;st<=nstaff;st++)staff_clef[st].autoclef=true;for(v=0;v<voice_tb.length;v++){if(sy.voices[v].range<0)continue;p_voice=voice_tb[v];st=sy.voices[v].st;if(!sy.voices[v].second){if(p_voice.stafflines!=undefined)sy.staves[st].stafflines=p_voice.stafflines;if(p_voice.staffscale)sy.staves[st].staffscale=p_voice.staffscale;if(sy.voices[v].sep)sy.staves[st].sep=sy.voices[v].sep;if(sy.voices[v].maxsep)sy.staves[st].maxsep=sy.voices[v].maxsep}s2=p_voice.clef;if(!s2.clef_auto)staff_clef[st].autoclef=false}for(st=0;st<=sy.nstaff;st++)mid[st]=(sy.staves[st].stafflines.length-1)*3;for(v=0;v<voice_tb.length;v++){if(sy.voices[v].range<0||sy.voices[v].second)continue;p_voice=voice_tb[v];st=sy.voices[v].st;s2=p_voice.clef;if(s2.clef_auto){new_type=set_auto_clef(st,s,staff_clef[st].clef?staff_clef[st].clef.clef_type:"a");new_line=new_type=="t"?2:4}else{new_type=s2.clef_type;new_line=s2.clef_line}if(!staff_clef[st].clef){if(s2.clef_auto){if(s2.type!="a")p_voice.clef=clone(p_voice.clef);p_voice.clef.clef_type=new_type;p_voice.clef.clef_line=new_line}staff_tb[st].clef=staff_clef[st].clef=p_voice.clef;continue}if(new_type==staff_clef[st].clef.clef_type&&new_line==staff_clef[st].clef.clef_line)continue;g=s.ts_next;while(g&&(g.v!=v||g.st!=st))g=g.ts_next;if(!g)continue;if(g.type!=CLEF){g=insert_clef(g,new_type,new_line);if(s2.clef_auto)g.clef_auto=true}staff_clef[st].clef=p_voice.clef=g}continue;default:s.mid=mid[s.st];continue;case CLEF:break}if(s.clef_type=="a"){s.clef_type=set_auto_clef(s.st,s.ts_next,staff_clef[s.st].clef.clef_type);s.clef_line=s.clef_type=="t"?2:4}p_voice=s.p_v;p_voice.clef=s;if(s.second){unlksym(s);continue}st=s.st;if(staff_clef[st].clef){if(s.clef_type==staff_clef[st].clef.clef_type&&s.clef_line==staff_clef[st].clef.clef_line){continue}}else{staff_tb[st].clef=s}staff_clef[st].clef=s}sy=cur_sy;for(v=0;v<voice_tb.length;v++){if(sy.voices[v].range<0)continue;s2=voice_tb[v].sym;if(!s2||s2.notes[0].pit!=127)continue;st=sy.voices[v].st;switch(staff_tb[st].clef.clef_type){default:pit=22;break;case"c":pit=16;break;case"b":pit=10;break}for(s=s2;s;s=s.next)s.notes[0].pit=pit}}var delta_tb={t:0-2*2,c:6-3*2,b:12-4*2,p:0-3*2};var rest_sp=[[18,18],[12,18],[12,12],[0,12],[6,8],[10,10],[6,4],[10,0],[10,4],[10,10]];function set_pitch(last_s){var s,s2,g,st,delta,m,pitch,note,dur=BASE_LEN,staff_delta=new Array(nstaff),sy=cur_sy;for(st=0;st<=nstaff;st++){s=staff_tb[st].clef;staff_delta[st]=delta_tb[s.clef_type]+s.clef_line*2;if(s.clefpit)staff_delta[st]+=s.clefpit;if(cfmt.sound){if(s.clef_octave&&!s.clef_oct_transp)staff_delta[st]+=s.clef_octave}else{if(s.clef_oct_transp)staff_delta[st]-=s.clef_octave}}for(s=tsfirst;s!=last_s;s=s.ts_next){st=s.st;switch(s.type){case CLEF:staff_delta[st]=delta_tb[s.clef_type]+s.clef_line*2;if(s.clefpit)staff_delta[st]+=s.clefpit;if(cfmt.sound){if(s.clef_octave&&!s.clef_oct_transp)staff_delta[st]+=s.clef_octave}else{if(s.clef_oct_transp)staff_delta[st]-=s.clef_octave}set_yval(s);break;case GRACE:for(g=s.extra;g;g=g.next){delta=staff_delta[g.st];if(delta!=0&&!s.p_v.key.k_drum){for(m=0;m<=g.nhd;m++){note=g.notes[m];note.pit+=delta}}g.ymn=3*(g.notes[0].pit-18)-2;g.ymx=3*(g.notes[g.nhd].pit-18)+2}set_yval(s);break;case KEY:s.k_y_clef=staff_delta[st];default:set_yval(s);break;case MREST:if(s.invis)break;s.y=12;s.ymx=24+15;s.ymn=-2;break;case REST:if(voice_tb.length==1){s.y=12;s.ymx=24;s.ymn=0;break}case NOTE:delta=staff_delta[st];if(delta!=0&&!s.p_v.key.k_drum){for(m=s.nhd;m>=0;m--)s.notes[m].pit+=delta}if(s.type==NOTE){s.ymx=3*(s.notes[s.nhd].pit-18)+4;s.ymn=3*(s.notes[0].pit-18)-4}else{s.y=((s.notes[0].pit-18)/2|0)*6;s.ymx=s.y+rest_sp[5-s.nflags][0];s.ymn=s.y-rest_sp[5-s.nflags][1]}if(s.dur<dur)dur=s.dur;break}}if(!last_s)smallest_duration=dur}function set_stem_dir(){var t,u,i,st,rvoice,v,v_st,st_v,vobj,v_st_tb,st_v_tb=[],s=tsfirst,sy=cur_sy,nst=sy.nstaff;while(s){for(st=0;st<=nst;st++)st_v_tb[st]=[];v_st_tb=[];for(u=s;u;u=u.ts_next){if(u.type==BAR)break;if(u.type==STAVES){if(u!=s)break;sy=s.sy;for(st=nst;st<=sy.nstaff;st++)st_v_tb[st]=[];nst=sy.nstaff;continue}if(u.type!=NOTE&&u.type!=REST||u.invis)continue;st=u.st;if(st>nst){var msg="*** fatal set_stem_dir(): bad staff number "+st+" max "+nst;error(2,null,msg);throw new Error(msg)}v=u.v;v_st=v_st_tb[v];if(!v_st){v_st={st1:-1,st2:-1};v_st_tb[v]=v_st}if(v_st.st1<0){v_st.st1=st}else if(v_st.st1!=st){if(st>v_st.st1){if(st>v_st.st2)v_st.st2=st}else{if(v_st.st1>v_st.st2)v_st.st2=v_st.st1;v_st.st1=st}}st_v=st_v_tb[st];rvoice=sy.voices[v].range;for(i=st_v.length;--i>=0;){vobj=st_v[i];if(vobj.v==rvoice)break}if(i<0){vobj={v:rvoice,ymx:0,ymn:24};for(i=0;i<st_v.length;i++){if(rvoice<st_v[i].v){st_v.splice(i,0,vobj);break}}if(i==st_v.length)st_v.push(vobj)}if(u.type!=NOTE)continue;if(u.ymx>vobj.ymx)vobj.ymx=u.ymx;if(u.ymn<vobj.ymn)vobj.ymn=u.ymn;if(u.xstem){if(u.ts_prev.st!=st-1||u.ts_prev.type!=NOTE){error(1,s,"Bad !xstem!");u.xstem=false}else{u.ts_prev.multi=1;u.multi=1;u.stemless=true}}}for(;s!=u;s=s.ts_next){if(s.multi)continue;if(s.type!=NOTE&&s.type!=REST&&s.type!=GRACE)continue;st=s.st;v=s.v;v_st=v_st_tb[v];st_v=st_v_tb[st];if(v_st&&v_st.st2>=0){if(st==v_st.st1)s.multi=-1;else if(st==v_st.st2)s.multi=1;continue}if(st_v.length<=1){if(s.floating)s.multi=st==voice_tb[v].st?-1:1;continue}rvoice=sy.voices[v].range;for(i=st_v.length;--i>=0;){if(st_v[i].v==rvoice)break}if(i<0)continue;if(i==st_v.length-1){s.multi=-1}else{s.multi=1;if(i!=0&&i+2==st_v.length){if(st_v[i].ymn-cfmt.stemheight>st_v[i+1].ymx)s.multi=-1;t=s.ts_next;if(s.ts_prev&&s.ts_prev.time==s.time&&s.ts_prev.st==s.st&&s.notes[s.nhd].pit==s.ts_prev.notes[0].pit&&s.beam_st&&s.beam_end&&(!t||t.st!=s.st||t.time!=s.time))s.multi=-1}}}while(s&&s.type==BAR)s=s.ts_next}}function set_rest_offset(){var s,s2,v,end_time,not_alone,v_s,y,ymax,ymin,shift,dots,dx,v_s_tb=[],sy=cur_sy;for(s=tsfirst;s;s=s.ts_next){if(s.invis)continue;if(s.type==STAVES)sy=s.sy;if(!s.dur)continue;v_s=v_s_tb[s.v];if(!v_s){v_s={};v_s_tb[s.v]=v_s}v_s.s=s;v_s.st=s.st;v_s.end_time=s.time+s.dur;if(s.type!=REST)continue;ymin=-127;ymax=127;not_alone=dots=false;for(v=0;v<=v_s_tb.length;v++){v_s=v_s_tb[v];if(!v_s||!v_s.s||v_s.st!=s.st||v==s.v)continue;if(v_s.end_time<=s.time)continue;not_alone=true;s2=v_s.s;if(sy.voices[v].range<sy.voices[s.v].range){if(s2.time==s.time){if(s2.ymn<ymax){ymax=s2.ymn;if(s2.dots)dots=true}}else{if(s2.y<ymax)ymax=s2.y}}else{if(s2.time==s.time){if(s2.ymx>ymin){ymin=s2.ymx;if(s2.dots)dots=true}}else{if(s2.y>ymin)ymin=s2.y}}}end_time=s.time+s.dur;for(s2=s.ts_next;s2;s2=s2.ts_next){if(s2.time>=end_time)break;if(s2.st!=s.st||!s2.dur||s2.invis)continue;not_alone=true;if(sy.voices[s2.v].range<sy.voices[s.v].range){if(s2.time==s.time){if(s2.ymn<ymax){ymax=s2.ymn;if(s2.dots)dots=true}}else{if(s2.y<ymax)ymax=s2.y}}else{if(s2.time==s.time){if(s2.ymx>ymin){ymin=s2.ymx;if(s2.dots)dots=true}}else{if(s2.y>ymin)ymin=s2.y}}}if(!not_alone){s.y=12;s.ymx=24;s.ymn=0;continue}if(ymax==127&&s.y<12){shift=12-s.y;s.y+=shift;s.ymx+=shift;s.ymn+=shift}if(ymin==-127&&s.y>12){shift=s.y-12;s.y-=shift;s.ymx-=shift;s.ymn-=shift}shift=ymax-s.ymx;if(shift<0){shift=Math.ceil(-shift/6)*6;if(s.ymn-shift>=ymin){s.y-=shift;s.ymx-=shift;s.ymn-=shift;continue}dx=dots?15:10;s.notes[0].shhd=dx;s.xmx=dx;continue}shift=ymin-s.ymn;if(shift>0){shift=Math.ceil(shift/6)*6;if(s.ymx+shift<=ymax){s.y+=shift;s.ymx+=shift;s.ymn+=shift;continue}dx=dots?15:10;s.notes[0].shhd=dx;s.xmx=dx;continue}}}function new_sym(type,p_voice,last_s){var s={type:type,ctx:last_s.ctx,v:p_voice.v,p_v:p_voice,st:p_voice.st,time:last_s.time,next:p_voice.last_sym.next};if(s.next)s.next.prev=s;p_voice.last_sym.next=s;s.prev=p_voice.last_sym;p_voice.last_sym=s;lktsym(s,last_s);if(s.ts_prev.type!=type)s.seqst=true;if(last_s.type==type&&s.v!=last_s.v){delete last_s.seqst;last_s.shrink=0}return s}function init_music_line(){var p_voice,s,s2,last_s,v,st,nv=voice_tb.length;for(v=0;v<nv;v++){if(cur_sy.voices[v].range<0)continue;p_voice=voice_tb[v];p_voice.second=cur_sy.voices[v].second;st=cur_sy.voices[v].st;while(st<nstaff&&!cur_sy.st_print[st])st++;p_voice.st=st}last_s=tsfirst;while(last_s.type==CLEF){v=last_s.v;if(cur_sy.voices[v].range>=0&&!cur_sy.voices[v].second){delete last_s.clef_small;p_voice=last_s.p_v;p_voice.last_sym=p_voice.sym=last_s}last_s=last_s.ts_next}for(v=0;v<nv;v++){p_voice=voice_tb[v];if(p_voice.sym&&p_voice.sym.type==CLEF)continue;if(cur_sy.voices[v].range<0||cur_sy.voices[v].second&&!p_voice.bar_start)continue;st=cur_sy.voices[v].st;if(!staff_tb[st]||!staff_tb[st].clef)continue;s=clone(staff_tb[st].clef);s.v=v;s.p_v=p_voice;s.st=st;s.time=tsfirst.time;s.prev=null;s.next=p_voice.sym;if(s.next)s.next.prev=s;p_voice.sym=s;p_voice.last_sym=s;s.ts_next=last_s;if(last_s)s.ts_prev=last_s.ts_prev;else s.ts_prev=null;if(!s.ts_prev){tsfirst=s;s.seqst=true}else{s.ts_prev.ts_next=s;delete s.seqst}if(last_s){last_s.ts_prev=s;if(last_s.type==CLEF)delete last_s.seqst}delete s.clef_small;s.second=cur_sy.voices[v].second;if(!cur_sy.st_print[st])s.invis=true}for(v=0;v<nv;v++){if(cur_sy.voices[v].range<0||cur_sy.voices[v].second||!cur_sy.st_print[cur_sy.voices[v].st])continue;p_voice=voice_tb[v];if(last_s&&last_s.v==v&&last_s.type==KEY){p_voice.last_sym=last_s;last_s.k_old_sf=last_s.k_sf;last_s=last_s.ts_next;continue}s2=p_voice.key;if(s2.k_sf||s2.k_a_acc){s=new_sym(KEY,p_voice,last_s);s.k_sf=s2.k_sf;s.k_old_sf=s2.k_sf;s.k_none=s2.k_none;s.k_a_acc=s2.k_a_acc;s.istart=s2.istart;s.iend=s2.iend;if(s2.k_bagpipe){s.k_bagpipe=s2.k_bagpipe;if(s.k_bagpipe=="p")s.k_old_sf=3}}}if(insert_meter&1){for(v=0;v<nv;v++){p_voice=voice_tb[v];s2=p_voice.meter;if(cur_sy.voices[v].range<0||cur_sy.voices[v].second||!cur_sy.st_print[cur_sy.voices[v].st]||s2.a_meter.length==0)continue;if(last_s&&last_s.v==v&&last_s.type==METER){p_voice.last_sym=last_s;last_s=last_s.ts_next;continue}s=new_sym(METER,p_voice,last_s);s.istart=s2.istart;s.iend=s2.iend;s.wmeasure=s2.wmeasure;s.a_meter=s2.a_meter}insert_meter&=~1}for(v=0;v<nv;v++){p_voice=voice_tb[v];if(last_s&&last_s.v==v&&last_s.type==BAR){p_voice.last_sym=last_s;last_s=last_s.ts_next;continue}s2=p_voice.bar_start;if(!s2)continue;p_voice.bar_start=null;if(cur_sy.voices[v].range<0||!cur_sy.st_print[cur_sy.voices[v].st])continue;s2.next=p_voice.last_sym.next;if(s2.next)s2.next.prev=s2;p_voice.last_sym.next=s2;s2.prev=p_voice.last_sym;p_voice.last_sym=s2;lktsym(s2,last_s);s2.time=tsfirst.time;if(s2.ts_prev.type!=s2.type)s2.seqst=true;if(last_s&&last_s.type==s2.type&&s2.v!=last_s.v){delete last_s.seqst;last_s.shrink=0}}set_pitch(last_s);for(s=last_s;s;s=s.ts_next){if(s.seqst){for(s=s.ts_next;s;s=s.ts_next)if(s.seqst)break;break}}set_allsymwidth(s)}function set_words(p_voice){var s,s2,nflags,lastnote,start_flag=true,pitch=127;for(s=p_voice.sym;s;s=s.next){if(s.type==NOTE){pitch=s.notes[0].pit;break}}for(s=p_voice.sym;s;s=s.next){switch(s.type){case MREST:start_flag=true;break;case BAR:if(!s.beam_on)start_flag=true;if(!s.next&&s.prev&&s.prev.head==OVALBARS)s.prev.head=SQUARE;break;case NOTE:case REST:if(s.trem2)break;nflags=s.nflags;if(s.ntrem)nflags+=s.ntrem;if(s.type==REST&&s.beam_end){s.beam_end=false;start_flag=true}if(start_flag||nflags<=0){if(lastnote){lastnote.beam_end=true;lastnote=null}if(nflags<=0){s.beam_st=true;s.beam_end=true}else if(s.type==NOTE){s.beam_st=true;start_flag=false}}if(s.beam_end)start_flag=true;if(s.type==NOTE)lastnote=s;break}if(s.type==NOTE){if(s.nhd!=0)sort_pitch(s);pitch=s.notes[0].pit;for(s2=s.prev;s2;s2=s2.prev){if(s2.type!=REST)break;s2.notes[0].pit=pitch}}else{if(!s.notes){s.notes=[];s.notes[0]={};s.nhd=0}s.notes[0].pit=pitch}}if(lastnote)lastnote.beam_end=true}function set_rb(p_voice){var s2,mx,n,s=p_voice.sym;while(s){if(s.type!=BAR||!s.rbstart||s.norepbra){s=s.next;continue}mx=cfmt.rbmax;if(s.text&&s.text[0]=="1"){n=0;s2=null;for(s=s.next;s;s=s.next){if(s.type!=BAR)continue;n++;if(s.rbstop){if(n<=cfmt.rbmax){mx=n;s2=null}break}if(n==cfmt.rbmin)s2=s}if(s2){s2.rbstop=1;mx=cfmt.rbmin}}while(s){if(s.rbstart!=2){s=s.next;if(!s)break;if(s.rbstart!=2){s=s.next;if(!s)break;if(s.rbstart!=2)break}}n=0;s2=null;for(s=s.next;s;s=s.next){if(s.type!=BAR)continue;n++;if(s.rbstop)break;if(!s.next)s.rbstop=2;else if(n==mx)s.rbstop=1}}}}var delpit=[0,-7,-14,0];function set_global(){var p_voice,st,v,nv,sy;sy=cur_sy;st=sy.nstaff;while(1){sy=sy.next;if(!sy)break;if(sy.nstaff>st)st=sy.nstaff}nstaff=st;nv=voice_tb.length;for(v=0;v<nv;v++){p_voice=voice_tb[v];set_words(p_voice);set_rb(p_voice)}set_float();set_clefs();set_pitch(null)}function set_indent(first){var st,v,w,p_voice,p,i,j,font,nv=voice_tb.length,maxw=0;for(v=0;v<nv;v++){p_voice=voice_tb[v];if(cur_sy.voices[v].range<0)continue;st=cur_sy.voices[v].st;p=(first||p_voice.new_name)&&p_voice.nm?p_voice.nm:p_voice.snm;if(!p)continue;if(!font){font=get_font("voice");gene.curfont=gene.deffont=font}i=0;while(1){j=p.indexOf("\\n",i);if(j<0)w=strw(p.slice(i));else w=strw(p.slice(i,j));if(w>maxw)maxw=w;if(j<0)break;i=j+1}}if(font)maxw+=4*cwid(" ")*font.swfac;w=0;for(st=0;st<=cur_sy.nstaff;st++){if(cur_sy.staves[st].flags&(OPEN_BRACE2|OPEN_BRACKET2)){w=16;break}if(cur_sy.staves[st].flags&(OPEN_BRACE|OPEN_BRACKET))w=8}maxw+=w;if(first)maxw+=cfmt.indent;return maxw}function set_beams(sym){var s,t,g,beam,s_opp,dy,avg,n,m,mid_p,pu,pd,laststem=-1;for(s=sym;s;s=s.next){if(s.type!=NOTE){if(s.type!=GRACE)continue;g=s.extra;if(g.stem==2){s_opp=s;continue}if(!s.stem&&(s.stem=s.multi)==0)s.stem=1;for(;g;g=g.next){g.stem=s.stem;g.multi=s.multi}continue}if(!s.stem&&(s.stem=s.multi)==0){mid_p=s.mid/3+18;if(beam){s.stem=laststem}else if(s.beam_st&&!s.beam_end){beam=true;pu=s.notes[s.nhd].pit;pd=s.notes[0].pit;for(g=s.next;g;g=g.next){if(g.type!=NOTE)continue;if(g.stem||g.multi){s.stem=g.stem||g.multi;break}if(g.notes[g.nhd].pit>pu)pu=g.notes[g.nhd].pit;if(g.notes[0].pit<pd)pd=g.notes[0].pit;if(g.beam_end)break}if(g.beam_end){if((pu+pd)/2<mid_p){s.stem=1}else if((pu+pd)/2>mid_p){s.stem=-1}else{if(cfmt.bstemdown)s.stem=-1}}if(!s.stem)s.stem=laststem}else{n=(s.notes[s.nhd].pit+s.notes[0].pit)/2;if(n==mid_p){n=0;for(m=0;m<=s.nhd;m++)n+=s.notes[m].pit;n/=s.nhd+1}if(n<mid_p)s.stem=1;else if(n>mid_p)s.stem=-1;else if(cfmt.bstemdown)s.stem=-1;else s.stem=laststem}}else{if(s.beam_st&&!s.beam_end)beam=true}if(s.beam_end)beam=false;laststem=s.stem;if(s_opp){for(g=s_opp.extra;g;g=g.next)g.stem=-laststem;s_opp.stem=-laststem;s_opp=null}}}function same_head(s1,s2){var i1,i2,l1,l2,head,i11,i12,i21,i22,sh1,sh2;if(s1.shiftunison&&s1.shiftunison>=3)return false;if((l1=s1.dur)>=BASE_LEN)return false;if((l2=s2.dur)>=BASE_LEN)return false;if(s1.stemless&&s2.stemless)return false;if(s1.dots!=s2.dots){if(s1.shiftunison&&s1.shiftunison&1||s1.dots*s2.dots!=0)return false}if(s1.stem*s2.stem>0)return false;i1=i2=0;if(s1.notes[0].pit>s2.notes[0].pit){if(s1.stem<0)return false;while(s2.notes[i2].pit!=s1.notes[0].pit){if(++i2>s2.nhd)return false}}else if(s1.notes[0].pit<s2.notes[0].pit){if(s2.stem<0)return false;while(s2.notes[0].pit!=s1.notes[i1].pit){if(++i1>s1.nhd)return false}}if(s2.notes[i2].acc!=s1.notes[i1].acc)return false;i11=i1;i21=i2;sh1=s1.notes[i1].shhd;sh2=s2.notes[i2].shhd;do{i1++;i2++;if(i1>s1.nhd){break}if(i2>s2.nhd){break}if(s2.notes[i2].acc!=s1.notes[i1].acc)return false;if(sh1<s1.notes[i1].shhd)sh1=s1.notes[i1].shhd;if(sh2<s2.notes[i2].shhd)sh2=s2.notes[i2].shhd}while(s2.notes[i2].pit==s1.notes[i1].pit);if(i1<=s1.nhd){if(i2<=s2.nhd)return false;if(s2.stem>0)return false}else if(i2<=s2.nhd){if(s1.stem>0)return false}i12=i1;i22=i2;head=0;if(l1!=l2){if(l1<l2){l1=l2;l2=s1.dur}if(l1<BASE_LEN/2){if(s2.dots>0)head=2;else if(s1.dots>0)head=1}else if(l2<BASE_LEN/4){if(s1.shiftunison&&s1.shiftunison&2)return false;head=s2.dur>=BASE_LEN/2?2:1}else{return false}}if(head==0)head=s1.p_v.scale<s2.p_v.scale?2:1;if(head==1){for(i2=i21;i2<i22;i2++){s2.notes[i2].invis=true;delete s2.notes[i2].acc}for(i2=0;i2<=s2.nhd;i2++)s2.notes[i2].shhd+=sh1}else{for(i1=i11;i1<i12;i1++){s1.notes[i1].invis=true;delete s1.notes[i1].acc}for(i1=0;i1<=s1.nhd;i1++)s1.notes[i1].shhd+=sh2}return true}function unison_acc(s1,s2,i1,i2){var m,d;if(!s2.notes[i2].acc){d=w_note[s2.head]*2+s2.xmx+s1.notes[i1].shac+2;if(s1.notes[i1].micro)d+=2;if(s2.dots)d+=6;for(m=0;m<=s1.nhd;m++){s1.notes[m].shhd+=d;s1.notes[m].shac-=d}s1.xmx+=d}else{d=w_note[s1.head]*2+s1.xmx+s2.notes[i2].shac+2;if(s2.notes[i2].micro)d+=2;if(s1.dots)d+=6;for(m=0;m<=s2.nhd;m++){s2.notes[m].shhd+=d;s2.notes[m].shac-=d}s2.xmx+=d}}var MAXPIT=48*2;function set_left(s){var m,i,j,shift,w_base=w_note[s.head],w=w_base,left=[];for(i=0;i<MAXPIT;i++)left.push(-100);if(s.nflags>-2){if(s.stem>0){w=-w;i=s.notes[0].pit*2;j=(Math.ceil((s.ymx-2)/3)+18)*2}else{i=(Math.ceil((s.ymn+2)/3)+18)*2;j=s.notes[s.nhd].pit*2}if(i<0)i=0;if(j>=MAXPIT)j=MAXPIT-1;while(i<=j)left[i++]=w}shift=s.notes[s.stem>0?0:s.nhd].shhd;for(m=0;m<=s.nhd;m++){w=-s.notes[m].shhd+w_base+shift;i=s.notes[m].pit*2;if(i<0)i=0;else if(i>=MAXPIT-1)i=MAXPIT-2;if(w>left[i])left[i]=w;if(s.head!=SQUARE)w-=1;if(w>left[i-1])left[i-1]=w;if(w>left[i+1])left[i+1]=w}return left}function set_right(s){var m,i,j,k,shift,w_base=w_note[s.head],w=w_base,flags=s.nflags>0&&s.beam_st&&s.beam_end,right=[];for(i=0;i<MAXPIT;i++)right.push(-100);if(s.nflags>-2){if(s.stem<0){w=-w;i=(Math.ceil((s.ymn+2)/3)+18)*2;j=s.notes[s.nhd].pit*2;k=i+4}else{i=s.notes[0].pit*2;j=(Math.ceil((s.ymx-2)/3)+18)*2}if(i<0)i=0;if(j>MAXPIT)j=MAXPIT;while(i<j)right[i++]=w}if(flags){if(s.stem>0){if(s.xmx==0)i=s.notes[s.nhd].pit*2;else i=s.notes[0].pit*2;i+=4;if(i<0)i=0;for(;i<MAXPIT&&i<=j-4;i++)right[i]=11}else{i=k;if(i<0)i=0;for(;i<MAXPIT&&i<=s.notes[0].pit*2-4;i++)right[i]=3.5}}shift=s.notes[s.stem>0?0:s.nhd].shhd;for(m=0;m<=s.nhd;m++){w=s.notes[m].shhd+w_base-shift;i=s.notes[m].pit*2;if(i<0)i=0;else if(i>=MAXPIT-1)i=MAXPIT-2;if(w>right[i])right[i]=w;if(s.head!=SQUARE)w-=1;if(w>right[i-1])right[i-1]=w;if(w>right[i+1])right[i+1]=w}return right}function set_overlap(){var s,s1,s2,s3,i,i1,i2,m,sd,t,dp,d,d2,dr,dr2,dx,left1,right1,left2,right2,right3,pl,pr;function v_invert(){s1=s2;s2=s;d=d2;pl=left1;pr=right1;dr2=dr}for(s=tsfirst;s;s=s.ts_next){if(s.type!=NOTE||s.invis)continue;if(s.xstem&&s.ts_prev.stem<0){s2=s.ts_prev;for(m=0;m<=s2.nhd;m++){s2.notes[m].shhd+=3.5*2;s2.notes[m].shac-=3.5*2}s2.xmx+=3.5*2}s2=s;while(1){s2=s2.ts_next;if(!s2)break;if(s2.time!=s.time){s2=null;break}if(s2.type==NOTE&&!s2.invis&&s2.st==s.st)break}if(!s2)continue;s1=s;if(cur_sy.voices[s1.v].range<cur_sy.voices[s2.v].range)s2.dot_low=true;else s1.dot_low=true;if(s1.ymn>s2.ymx||s1.ymx<s2.ymn)continue;if(same_head(s1,s2))continue;right1=set_right(s1);left2=set_left(s2);s3=s1.ts_prev;if(s3&&s3.time==s1.time&&s3.st==s1.st&&s3.type==NOTE&&!s3.invis){right3=set_right(s3);for(i=0;i<MAXPIT;i++){if(right3[i]>right1[i])right1[i]=right3[i]}}else{s3=null}d=-10;for(i=0;i<MAXPIT;i++){if(left2[i]+right1[i]>d)d=left2[i]+right1[i]}if(d<-3){if(!s1.dots||!s2.dots||!s2.dot_low||s1.stem>0||s2.stem<0||s1.notes[s1.nhd].pit+2!=s2.notes[0].pit||s2.notes[0].pit&1)continue}right2=set_right(s2);left1=set_left(s1);if(s3){right3=set_left(s3);for(i=0;i<MAXPIT;i++){if(right3[i]>left1[i])left1[i]=right3[i]}}d2=dr=dr2=-100;for(i=0;i<MAXPIT;i++){if(left1[i]+right2[i]>d2)d2=left1[i]+right2[i];if(right2[i]>dr2)dr2=right2[i];if(right1[i]>dr)dr=right1[i]}t=0;i1=s1.nhd;i2=s2.nhd;while(1){dp=s1.notes[i1].pit-s2.notes[i2].pit;switch(dp){case 0:if(s1.notes[i1].acc!=s2.notes[i2].acc){t=-1;break}if(s2.notes[i2].acc)s2.notes[i2].acc=0;if(s1.dots&&s2.dots&&s1.notes[i1].pit&1)t=1;break;case-1:if(s1.dots&&s2.dots){if(s1.notes[i1].pit&1){s1.dot_low=false;s2.dot_low=false}else{s1.dot_low=true;s2.dot_low=true}}break;case-2:if(s1.dots&&s2.dots&&!(s1.notes[i1].pit&1)){s1.dot_low=false;s2.dot_low=false;break}break}if(t<0)break;if(dp>=0){if(--i1<0)break}if(dp<=0){if(--i2<0)break}}if(t<0){unison_acc(s1,s2,i1,i2);continue}sd=0;if(s1.dots){if(s2.dots){if(!t)sd=1}}else if(s2.dots){if(d2+dr<d+dr2)sd=1}pl=left2;pr=right2;if(!s3&&d2+dr<d+dr2)v_invert();d+=3;if(d<0)d=0;m=s1.stem>=0?0:s1.nhd;d+=s1.notes[m].shhd;m=s2.stem>=0?0:s2.nhd;d-=s2.notes[m].shhd;if(s1.dots){dx=7.7+s1.xmx+3.5*s1.dots-3.5+3;if(!sd){d2=-100;for(i1=0;i1<=s1.nhd;i1++){i=s1.notes[i1].pit;if(!(i&1)){if(!s1.dot_low)i++;else i--}i*=2;if(i<1)i=1;else if(i>=MAXPIT-1)i=MAXPIT-2;if(pl[i]>d2)d2=pl[i];if(pl[i-1]+1>d2)d2=pl[i-1]+1;if(pl[i+1]+1>d2)d2=pl[i+1]+1}if(dx+d2+2>d)d=dx+d2+2}else{if(dx<d+dr2+s2.xmx){d2=0;for(i1=0;i1<=s1.nhd;i1++){i=s1.notes[i1].pit;if(!(i&1)){if(!s1.dot_low)i++;else i--}i*=2;if(i<1)i=1;else if(i>=MAXPIT-1)i=MAXPIT-2;if(pr[i]>d2)d2=pr[i];if(pr[i-1]+1>d2)d2=pr[i-1]=1;if(pr[i+1]+1>d2)d2=pr[i+1]+1}if(d2>4.5&&7.7+s1.xmx+2<d+d2+s2.xmx)s2.xmx=d2+3-7.7}}}for(m=s2.nhd;m>=0;m--){s2.notes[m].shhd+=d}s2.xmx+=d;if(sd)s1.xmx=s2.xmx}}function set_stems(){var s,s2,g,slen,scale,ymn,ymx,nflags,ymin,ymax;for(s=tsfirst;s;s=s.ts_next){if(s.type!=NOTE){if(s.type!=GRACE)continue;ymin=ymax=s.mid;for(g=s.extra;g;g=g.next){slen=GSTEM;if(g.nflags>1)slen+=1.2*(g.nflags-1);ymn=3*(g.notes[0].pit-18);ymx=3*(g.notes[g.nhd].pit-18);if(s.stem>=0){g.y=ymn;g.ys=ymx+slen;ymx=Math.round(g.ys)}else{g.y=ymx;g.ys=ymn-slen;ymn=Math.round(g.ys)}ymx+=2;ymn-=2;if(ymn<ymin)ymin=ymn;else if(ymx>ymax)ymax=ymx;g.ymx=ymx;g.ymn=ymn}s.ymx=ymax;s.ymn=ymin;continue}set_head_shift(s);nflags=s.nflags;if(s.beam_st&&!s.beam_end){if(s.feathered_beam)nflags=++s.nflags;for(s2=s.next;;s2=s2.next){if(s2.type==NOTE){if(s.feathered_beam)s2.nflags++;if(s2.beam_end)break}}if(s2.nflags>nflags)nflags=s2.nflags}else if(!s.beam_st&&s.beam_end){for(s2=s.prev;;s2=s2.prev){if(s2.beam_st)break}if(s2.nflags>nflags)nflags=s2.nflags}slen=cfmt.stemheight;switch(nflags){case 2:slen+=2;break;case 3:slen+=5;break;case 4:slen+=10;break;case 5:slen+=16;break}if((scale=s.p_v.scale)!=1)slen*=(scale+1)*.5;ymn=3*(s.notes[0].pit-18);if(s.nhd>0){slen-=2;ymx=3*(s.notes[s.nhd].pit-18)}else{ymx=ymn}if(s.ntrem)slen+=2*s.ntrem;if(s.stemless){if(s.stem>=0){s.y=ymn;s.ys=ymx}else{s.ys=ymn;s.y=ymx}if(nflags==-4)ymn-=6;s.ymx=ymx+4;s.ymn=ymn-4}else if(s.stem>=0){if(nflags>=2)slen-=1;if(s.notes[s.nhd].pit>26&&(nflags<=0||!s.beam_st||!s.beam_end)){slen-=2;if(s.notes[s.nhd].pit>28)slen-=2}s.y=ymn;if(s.notes[0].ti1)ymn-=3;s.ymn=ymn-4;s.ys=ymx+slen;if(s.ys<s.mid)s.ys=s.mid;s.ymx=s.ys+2.5|0}else{if(s.notes[0].pit<18&&(nflags<=0||!s.beam_st||!s.beam_end)){slen-=2;if(s.notes[0].pit<16)slen-=2}s.ys=ymn-slen;if(s.ys>s.mid)s.ys=s.mid;s.ymn=s.ys-2.5|0;s.y=ymx;if(s.notes[s.nhd].ti1)ymx+=3;s.ymx=ymx+4}}}function check_bar(s){var bar_type,i,b1,b2,p_voice=s.p_v;while(s.type==CLEF||s.type==KEY||s.type==METER){if(s.type==METER&&s.time>p_voice.sym.time)insert_meter|=1;s=s.prev;if(!s)return}if(s.type!=BAR)return;if(s.text!=undefined){p_voice.bar_start=clone(s);p_voice.bar_start.bar_type="[";delete s.text;delete s.a_gch}bar_type=s.bar_type;if(bar_type==":")return;if(bar_type.slice(-1)!=":")return;if(!p_voice.bar_start)p_voice.bar_start=clone(s);if(bar_type[0]!=":"){if(bar_type=="||:"){p_voice.bar_start.bar_type="|:";s.bar_type="||";return}p_voice.bar_start.bar_type=bar_type;if(s.prev&&s.prev.type==BAR)unlksym(s);else s.bar_type="|";return}if(bar_type=="::"){p_voice.bar_start.bar_type="|:";s.bar_type=":|";return}if(bar_type=="||:"){p_voice.bar_start.bar_type="|:";s.bar_type="||";return}i=0;while(bar_type[i]==":")i++;if(i<bar_type.length){s.bar_type=bar_type.slice(0,i)+"|";i=bar_type.length-1;while(bar_type[i]==":")i--;p_voice.bar_start.bar_type="|"+bar_type.slice(i+1)}else{i=bar_type.length/2|0;s.bar_type=bar_type.slice(0,i)+"|";p_voice.bar_start.bar_type="|"+bar_type.slice(i)}}function sym_staff_move(st){for(var s=tsfirst;s;s=s.ts_next){if(s.nl)break;if(s.st==st&&s.type!=CLEF){s.st++;s.invis=true}}}var blocks=[];function block_gen(s){switch(s.subtype){case"leftmargin":case"rightmargin":case"pagescale":case"pagewidth":case"scale":case"staffwidth":set_format(s.subtype,s.param);break;case"ml":svg_flush();user.img_out(s.text);break;case"newpage":blk_flush();block.newpage=true;blk_out();break;case"sep":set_page();vskip(s.sk1);output.push('<path class="stroke"\n\td="M');out_sxsy(s.x," ",0);output.push("h"+s.l.toFixed(2)+'"/>\n');vskip(s.sk2);break;case"text":write_text(s.text,s.opt);break;case"title":write_title(s.text,true);break;case"vskip":vskip(s.sk);break;default:error(2,s,"Block $1 not treated",s.subtype);break}}function set_piece(){var s,last,p_voice,st,v,nst,nv,non_empty=[],non_empty_gl=[],sy=cur_sy;function reset_staff(st){var p_staff=staff_tb[st],sy_staff=sy.staves[st];if(!p_staff)p_staff=staff_tb[st]={};p_staff.y=0;p_staff.stafflines=sy_staff.stafflines;p_staff.staffscale=sy_staff.staffscale;p_staff.ann_top=p_staff.ann_bot=0}function set_brace(){var st,i,empty_fl,n=sy.staves.length;for(st=0;st<n;st++){if(!(sy.staves[st].flags&(OPEN_BRACE|OPEN_BRACE2)))continue;empty_fl=0;i=st;while(st<n){empty_fl|=non_empty[st]?1:2;if(sy.staves[st].flags&(CLOSE_BRACE|CLOSE_BRACE2))break;st++}if(empty_fl==3){while(i<=st){non_empty[i]=true;non_empty_gl[i++]=true}}}}function set_top_bot(){var st,p_staff,i,l,hole;for(st=0;st<=nstaff;st++){p_staff=staff_tb[st];if(!non_empty_gl[st]){p_staff.botbar=p_staff.topbar=0;continue}l=p_staff.stafflines.length;p_staff.topbar=6*(l-1);for(i=0;i<l-1;i++)if(p_staff.stafflines[i]!=".")break;p_staff.botline=p_staff.botbar=i*6;if(i>=l-2){p_staff.botbar-=6;p_staff.topbar+=6}}}nstaff=nst=sy.nstaff;for(st=0;st<=nst;st++)reset_staff(st);for(s=tsfirst;s;s=s.ts_next){if(s.nl){break}if(!s.ts_next)last=s;switch(s.type){case STAVES:set_brace();sy.st_print=new Uint8Array(non_empty);sy=s.sy;nst=sy.nstaff;if(nstaff<nst){for(st=nstaff+1;st<=nst;st++)reset_staff(st);nstaff=nst}non_empty=[];continue;case BLOCK:blocks.push(s);unlksym(s);if(last)last=s.ts_prev;continue}st=s.st;if(non_empty[st])continue;switch(s.type){case CLEF:if(st>nstaff){staff_tb[st].clef=s;unlksym(s)}break;case BAR:if(cfmt.staffnonote<=1)break;case GRACE:non_empty_gl[st]=non_empty[st]=true;break;case NOTE:case REST:case SPACE:case MREST:if(cfmt.staffnonote>1){non_empty_gl[st]=non_empty[st]=true}else if(!s.invis){if(cfmt.staffnonote!=0||s.type==NOTE)non_empty_gl[st]=non_empty[st]=true}break}}tsnext=s;set_brace();sy.st_print=new Uint8Array(non_empty);set_top_bot();for(st=0;st<nstaff;st++){if(!non_empty_gl[st])sym_staff_move(st)}if(!non_empty_gl[nstaff])staff_tb[nstaff].topbar=0;init_music_line();gene.st_print=new Uint8Array(non_empty_gl);if(tsnext){s=tsnext;delete s.nl;last=s.ts_prev;last.ts_next=null;nv=voice_tb.length;for(v=0;v<nv;v++){p_voice=voice_tb[v];if(p_voice.sym&&p_voice.sym.time<=tsnext.time){for(s=tsnext.ts_prev;s;s=s.ts_prev){if(s.v==v){p_voice.s_next=s.next;s.next=null;check_bar(s);break}}if(s)continue}p_voice.s_next=p_voice.sym;p_voice.sym=null}}if(last.type!=BAR){s=add_end_bar(last);s.prev=s.ts_prev=last;last.ts_next=last.next=s;s.shrink=last.wr+2;s.space=set_space(s);if(s.space<s.shrink)s.space=s.shrink}}function set_sym_glue(width){var space,beta0,alfa,beta,min,g,spafac,xmax;var some_grace,s=tsfirst,xmin=0,x=0;while(1){if(s.type==GRACE&&!some_grace)some_grace=s;if(s.seqst){space=s.space;xmin+=s.shrink;if(space<s.shrink)space=s.shrink;x+=space}if(!s.ts_next)break;s=s.ts_next}if(x==0){realwidth=0;return}xmax=x;if(cfmt.stretchstaff)xmax*=1.8;beta0=1;if(tsnext){if(x>=width){beta_last=0}else{beta_last=(width-x)/(xmax-x);if(beta_last>beta0){if(cfmt.stretchstaff){if(cfmt.linewarn){error(0,s,"Line underfull ($1pt of $2pt)",(beta0*xmax+(1-beta0)*x).toFixed(2),width.toFixed(2))}}else{width=x;beta_last=0}}}}else{if(x<width){beta=(width-x)/(xmax-x);if(beta>=beta_last){beta=beta_last*xmax+(1-beta_last)*x;if(beta<width*(1-cfmt.stretchlast))width=beta}}}spafac=width/x;x=xmax=0;s=tsfirst;while(1){if(s.seqst){space=s.shrink;if(s.space!=0)xmax+=s.space*spafac*1.8;x+=space;xmax+=space;s.x=x;s.xmax=xmax}if(!s.ts_next)break;s=s.ts_next}if(x>=width){beta=0;if(x==xmin){alfa=1}else{alfa=(x-width)/(x-xmin);if(alfa>1){error(1,s,"Line too much shrunk $1 $2 $3",xmin.toFixed(2),x.toFixed(2),width.toFixed(2))}}realwidth=xmin*alfa+x*(1-alfa)}else{alfa=0;if(xmax>x)beta=(width-x)/(xmax-x);else beta=1;if(beta>beta0){if(!cfmt.stretchstaff)beta=0}realwidth=xmax*beta+x*(1-beta)}s=tsfirst;if(alfa!=0){if(alfa<1){x=xmin=0;for(;s;s=s.ts_next){if(s.seqst){xmin+=s.shrink*alfa;x=xmin+s.x*(1-alfa)}s.x=x}}else{alfa=realwidth/x;x=0;for(;s;s=s.ts_next){if(s.seqst)x=s.x*alfa;s.x=x}}}else{x=0;for(;s;s=s.ts_next){if(s.seqst)x=s.xmax*beta+s.x*(1-beta);s.x=x}}for(s=some_grace;s;s=s.ts_next){if(s.type!=GRACE)continue;if(s.gr_shift)x=s.prev.x+s.prev.wr+Number(cfmt.gracespace[0]);else x=s.x-s.wl+Number(cfmt.gracespace[0]);for(g=s.extra;g;g=g.next)g.x+=x}}function set_sym_line(){var p_voice,s,v,nv=voice_tb.length;for(v=0;v<nv;v++){p_voice=voice_tb[v];s=p_voice.s_next;p_voice.sym=s;if(s)s.prev=null}}function set_posx(){posx=img.lm/cfmt.scale}function gen_init(){var s=tsfirst,tim=s.time;for(;s;s=s.ts_next){if(s.time!=tim){set_page();return}switch(s.type){case NOTE:case REST:case MREST:set_page();return;default:continue;case STAVES:cur_sy=s.sy;break;case BLOCK:block_gen(s);break}unlksym(s);if(s.p_v.s_next==s)s.p_v.s_next=s.next}tsfirst=null}function output_music(){var output_sav,v,lwidth,indent,line_height;gen_init();if(!tsfirst)return;set_global();if(voice_tb.length>1){combine_voices();set_stem_dir()}for(v=0;v<voice_tb.length;v++)set_beams(voice_tb[v].sym);set_stems();if(voice_tb.length>1){set_rest_offset();set_overlap()}set_acc_shft();set_allsymwidth(null);indent=set_indent(true);if(cfmt.singleline){v=get_ck_width();lwidth=indent+v[0]+v[1]+get_width(tsfirst,null);img.width=lwidth*cfmt.scale+img.lm+img.rm+2}else{lwidth=get_lwidth();cut_tune(lwidth,indent)}beta_last=0;while(1){set_piece();set_sym_glue(lwidth-indent);if(realwidth!=0){if(indent!=0)posx+=indent;output_sav=output;output=undefined;draw_sym_near();output=output_sav;line_height=set_staff();delayed_update();draw_systems(indent);draw_all_sym();vskip(line_height);if(indent!=0){posx-=indent;insert_meter&=~2}while(blocks.length!=0)block_gen(blocks.shift())}tsfirst=tsnext;svg_flush();if(!tsnext)break;gen_init();if(!tsfirst)break;tsfirst.ts_prev=null;set_sym_line();lwidth=get_lwidth();indent=set_indent()}}function reset_gen(){insert_meter=cfmt.writefields.indexOf("M")>=0?3:2}var a_gch,a_dcn,multicol,maps={};var not_ascii="Not an ASCII character",bar_grace="Cannot have a bar in grace notes",qplet_tb=new Int8Array([0,1,3,2,3,0,2,0,3,0]),ntb="CDEFGABcdefgab";function set_ref(s){s.ctx=parse.ctx;s.istart=parse.istart;s.iend=parse.iend}function new_clef(clef_def){var s={type:CLEF,clef_line:2,clef_type:"t",v:curvoice.v,p_v:curvoice,time:curvoice.time,dur:0},i=1;set_ref(s);switch(clef_def[0]){case'"':i=clef_def.indexOf('"',1);s.clef_name=clef_def.slice(1,i);i++;break;case"a":if(clef_def[1]=="u"){s.clef_type="a";s.clef_auto=true;i=4;break}i=4;case"C":s.clef_type="c";s.clef_line=3;break;case"b":i=4;case"F":s.clef_type="b";s.clef_line=4;break;case"n":i=4;s.invis=true;break;case"t":if(clef_def[1]=="e"){s.clef_type="c";s.clef_line=4;break}i=6;case"G":break;case"p":i=4;case"P":s.clef_type="p";s.clef_line=3;break;default:syntax(1,"Unknown clef '$1'",clef_def);return}if(clef_def[i]>="1"&&clef_def[i]<="9"){s.clef_line=Number(clef_def[i]);i++}if(clef_def[i+1]!="8")return s;switch(clef_def[i]){case"^":s.clef_oct_transp=true;case"+":s.clef_octave=7;break;case"_":s.clef_oct_transp=true;case"-":s.clef_octave=-7;break}return s}function get_transp(param,type){var i,val,tmp,note,pit=[];if(param[0]=="0")return 0;if("123456789-+".indexOf(param[0])>=0){val=parseInt(param)*3;if(isNaN(val)||val<-108||val>108){syntax(1,"Bad transpose value");return}switch(param.slice(-1)){default:return val;case"#":val++;break;case"b":val+=2;break}if(val>0)return val;return val-3}if(type=="instr"){tmp=param.indexOf("/");if(!cfmt.sound){if(tmp<0)return 0;param=param.replace("/","")}else{if(tmp<0)param="c"+param;else param=param.replace(/.*\//,"c")}}tmp=new scanBuf;tmp.buffer=param;for(i=0;i<2;i++){note=parse_acc_pit(tmp);if(!note){syntax(1,"Bad transpose value");return}note.pit+=124;val=(note.pit/7|0)*12+note_pit[note.pit%7];if(note.acc&&note.acc!=3)val+=note.acc;pit[i]=val}if(cfmt.sound)pit[0]=252;val=(pit[1]-pit[0])*3;if(note){switch(note.acc){default:return val;case 2:case 1:val++;break;case-1:case-2:val+=2;break}}if(val>0)return val;return val-3}function set_linebreak(param){var i,item;for(i=0;i<128;i++){if(char_tb[i]=="\n")char_tb[i]=nil}param=param.split(/\s+/);for(i=0;i<param.length;i++){item=param[i];switch(item){case"!":case"$":case"*":case";":case"?":case"@":break;case"<none>":continue;case"<EOL>":item="\n";break;default:syntax(1,"Bad value '$1' in %%linebreak - ignored",item);continue}char_tb[item.charCodeAt(0)]="\n"}}function set_user(parm){var k,c,v,a=parm.match(/(.*?)[= ]*([!"].*[!"])/);if(!a){syntax(1,'Lack of starting ! or " in U: / %%user');return}c=a[1];v=a[2];if(v.slice(-1)!=v[0]){syntax(1,"Lack of ending $1 in U:/%%user",v[0]);return}if(c[0]=="\\"){if(c[1]=="t")c="\t";else if(!c[1])c=" "}k=c.charCodeAt(0);if(k>=128){syntax(1,not_ascii);return}switch(char_tb[k][0]){case"0":case"d":case"i":case" ":break;case'"':case"!":if(char_tb[k].length>1)break;default:syntax(1,"Bad user character '$1'",c);return}switch(v){case"!beambreak!":v=" ";break;case"!ignore!":v="i";break;case"!nil!":case"!none!":v="d";break}char_tb[k]=v}function get_st_lines(param){var n,val;if(!param)return;if(param.match(/^[\]\[|.]+$/))return param.replace(/\]/g,"[");n=parseInt(param);switch(n){case 0:return"...";case 1:return"..|";case 2:return".||";case 3:return".|||"}if(isNaN(n)||n<0||n>16)return;val="|";while(--n>0)val+="|";return val}function new_block(subtype){var s={type:BLOCK,subtype:subtype,dur:0};if(parse.state==2)goto_tune();var voice_s=curvoice;curvoice=voice_tb[par_sy.top_voice];sym_link(s);curvoice=voice_s;return s}function set_kv_parm(a){var s,item,pos,val,clefpit;if(!curvoice.init){curvoice.init=true;if(info.V){if(info.V["*"])a=info.V["*"].concat(a);if(info.V[curvoice.id])a=info.V[curvoice.id].concat(a)}}if(a.length==0)return 0;while(1){item=a.shift();if(!item)break;if(item[item.length-1]=="="&&!a[0]){syntax(1,err_bad_val_s,item);break}switch(item){case"clef=":s=a.shift();break;case"clefpitch=":item=a.shift();if(item){val=ntb.indexOf(item[0]);if(val>=0){switch(item[1]){case"'":val+=7;break;case",":val-=7;if(item[2]==",")val-=7;break}clefpit=4-val;break}}syntax(1,err_bad_val_s,item);break;case"combine=":case"octave=":case"uscale=":val=parseInt(a.shift());if(isNaN(val))syntax(1,err_bad_val_s,item);else curvoice[item.slice(0,-1)]=val;break;case"cue=":curvoice.scale=a.shift()=="on"?.7:1;break;case"instrument=":curvoice.transp=get_transp(a.shift(),"instr");break;case"map=":item=item.slice(0,-1);curvoice[item]=a.shift();break;case"name=":case"nm=":curvoice.nm=a.shift();if(curvoice.nm[0]=='"')curvoice.nm=curvoice.nm.slice(1,-1);curvoice.new_name=true;break;case"stem=":item="stm=";case"dyn=":case"gch=":case"gst=":case"orn=":case"stm=":case"voc=":case"vol=":val=posval[a.shift()];if(val==undefined){syntax(1,err_bad_val_s,item);break}item=item.slice(0,-1);if(!pos)pos={};pos[item]=val;break;case"scale=":do_pscom("voicescale "+a.shift());break;case"score=":if(cfmt.sound)break;item=a.shift();if(item.indexOf("/")<0)item+="/c";curvoice.transp=get_transp(item);break;case"shift=":curvoice.shift=get_transp(a.shift());break;case"sound=":case"transpose=":if(!cfmt.sound)break;curvoice.transp=get_transp(a.shift());break;case"subname=":case"sname=":case"snm=":curvoice.snm=a.shift();if(curvoice.snm[0]=='"')curvoice.snm=curvoice.snm.slice(1,-1);break;case"stafflines=":do_pscom("stafflines "+a.shift());break;case"staffscale=":do_pscom("staffscale "+a.shift());break;default:switch(item.slice(0,4)){case"treb":case"bass":case"alto":case"teno":case"perc":s=item;break;default:if("GFC".indexOf(item[0])>=0)s=item;else if(item.slice(-1)=="=")a.shift();break}break}}if(pos){curvoice.pos=clone(curvoice.pos);for(item in pos)if(pos.hasOwnProperty(item))curvoice.pos[item]=pos[item]}if(s){s=new_clef(s);if(s){if(clefpit)s.clefpit=clefpit;get_clef(s)}}}function memo_kv_parm(vid,a){if(a.length==0)return;if(!info.V)info.V={};if(info.V[vid])Array.prototype.push.apply(info.V[vid],a);else info.V[vid]=a}function new_key(param){var i,clef,key_end,c,tmp,mode=0,s={type:KEY,k_delta:0,dur:0};set_ref(s);i=1;switch(param[0]){case"A":s.k_sf=3;break;case"B":s.k_sf=5;break;case"C":s.k_sf=0;break;case"D":s.k_sf=2;break;case"E":s.k_sf=4;break;case"F":s.k_sf=-1;break;case"G":s.k_sf=1;break;case"H":switch(param[1]){case"P":s.k_bagpipe="P";i++;break;case"p":s.k_bagpipe="p";s.k_sf=2;i++;break;default:syntax(1,"Unknown bagpipe-like key");break}key_end=true;break;case"P":s.k_drum=true;key_end=true;break;case"n":if(param.indexOf("none")==0){s.k_sf=0;s.k_none=true;i=4}default:key_end=true;break}if(!key_end){switch(param[i]){case"#":s.k_sf+=7;i++;break;case"b":s.k_sf-=7;i++;break}param=param.slice(i).trim();switch(param.slice(0,3).toLowerCase()){case"aeo":case"m":case"min":s.k_sf-=3;mode=5;break;case"dor":s.k_sf-=2;mode=1;break;case"ion":case"maj":break;case"loc":s.k_sf-=5;mode=6;break;case"lyd":s.k_sf+=1;mode=3;break;case"mix":s.k_sf-=1;mode=4;break;case"phr":s.k_sf-=4;mode=2;break;default:if(param[0]=="m"&&(param[1]==" "||param[1]=="\t"||param[1]=="\n")){s.k_sf-=3;mode=5;break}key_end=true;break}if(!key_end)param=param.replace(/\w+\s*/,"");if(param.indexOf("exp ")==0){param=param.replace(/\w+\s*/,"");if(!param)syntax(1,"No accidental after 'exp'");s.k_exp=true}c=param[0];if(c=="^"||c=="_"||c=="="){s.k_a_acc=[];tmp=new scanBuf;tmp.buffer=param;do{var note=parse_acc_pit(tmp);if(!note)return[s,null];s.k_a_acc.push(note);c=param[tmp.index];while(c==" ")c=param[++tmp.index]}while(c=="^"||c=="_"||c=="=");param=param.slice(tmp.index)}else if(s.k_exp&&param.indexOf("none")==0){s.k_sf=0;param=param.replace(/\w+\s*/,"")}}s.k_delta=cgd2cde[(s.k_sf+7)%7];s.k_mode=mode;return[s,info_split(param,0)]}function new_meter(text){var s={type:METER,dur:0,a_meter:[]},meter={},val,v,m1=0,m2,i=0,j,wmeasure,p=text,in_parenth;set_ref(s);if(p.indexOf("none")==0){i=4;wmeasure=1}else{wmeasure=0;while(i<text.length){if(p[i]=="=")break;switch(p[i]){case"C":meter.top=p[i++];if(p[i]=="|")meter.top+=p[i++];m1=4;m2=4;break;case"c":case"o":m1=p[i]=="c"?4:3;m2=4;meter.top=p[i++];if(p[i]==".")meter.top+=p[i++];break;case"(":if(p[i+1]=="("){in_parenth=true;meter.top=p[i++];s.a_meter.push(meter);meter={}}j=i+1;while(j<text.length){if(p[j]==")"||p[j]=="/")break;j++}if(p[j]==")"&&p[j+1]=="/"){i++;continue}case")":in_parenth=p[i]=="(";meter.top=p[i++];s.a_meter.push(meter);meter={};continue;default:if(p[i]<="0"||p[i]>"9"){syntax(1,"Bad char '$1' in M:",p[i]);return}m2=2;meter.top=p[i++];for(;;){while(p[i]>="0"&&p[i]<="9")meter.top+=p[i++];if(p[i]==")"){if(p[i+1]!="/")break;i++}if(p[i]=="/"){i++;if(p[i]<="0"||p[i]>"9"){syntax(1,"Bad char '$1' in M:",p[i]);return}meter.bot=p[i++];while(p[i]>="0"&&p[i]<="9")meter.bot+=p[i++];break}if(p[i]!=" "&&p[i]!="+")break;if(i>=text.length||p[i+1]=="(")break;meter.top+=p[i++]}m1=parseInt(meter.top);break}if(!in_parenth){if(meter.bot)m2=parseInt(meter.bot);wmeasure+=m1*BASE_LEN/m2}s.a_meter.push(meter);meter={};while(p[i]==" ")i++;if(p[i]=="+"){meter.top=p[i++];s.a_meter.push(meter);meter={}}}}if(p[i]=="="){val=p.substring(++i).match(/^(\d+)\/(\d+)$/);if(!val){syntax(1,"Bad duration '$1' in M:",p.substring(i));return}wmeasure=BASE_LEN*val[1]/val[2]}s.wmeasure=wmeasure;if(parse.state!=3){info.M=text;glovar.meter=s;if(parse.state>=1){if(!glovar.ulen){if(wmeasure<=1||wmeasure>=BASE_LEN*3/4)glovar.ulen=BASE_LEN/8;else glovar.ulen=BASE_LEN/16}for(v=0;v<voice_tb.length;v++){voice_tb[v].meter=s;voice_tb[v].wmeasure=wmeasure}}}else{curvoice.wmeasure=wmeasure;if(is_voice_sig()){curvoice.meter=s;reset_gen()}else{sym_link(s)}}}function new_tempo(text){var i=0,j,c,nd,tmp,s={type:TEMPO,dur:0};set_ref(s);if(cfmt.writefields.indexOf("Q")<0)s.del=true;if(text[0]=='"'){i=text.indexOf('"',1);if(i<0){syntax(1,"Unterminated string in Q:");return}s.tempo_str1=text.slice(1,i);i++;while(text[i]==" ")i++}tmp=new scanBuf;tmp.buffer=text;tmp.index=i;while(1){c=text[tmp.index];if(c==undefined||c<="0"||c>"9")break;nd=parse_dur(tmp);if(!s.tempo_notes)s.tempo_notes=[];s.tempo_notes.push(BASE_LEN*nd[0]/nd[1]);while(1){c=text[tmp.index];if(c!=" ")break;tmp.index++}}if(c=="="){c=text[++tmp.index];while(c==" ")c=text[++tmp.index];i=tmp.index;if(c=="c"&&text[i+1]=="a"&&text[i+2]=="."&&text[i+3]==" "){s.tempo_ca="ca. ";tmp.index+=4}if(text[tmp.index+1]!="/"){s.tempo=tmp.get_int()}else{nd=parse_dur(tmp);s.new_beat=BASE_LEN*nd[0]/nd[1]}c=text[tmp.index];while(c==" ")c=text[++tmp.index]}if(c=='"'){tmp.index++;i=text.indexOf('"',tmp.index+1);if(i<0){syntax(1,"Unterminated string in Q:");return}s.tempo_str2=text.slice(tmp.index,i)}if(parse.state!=3){if(parse.state==1){info.Q=text;glovar.tempo=s;return}goto_tune()}if(curvoice.v==par_sy.top_voice){sym_link(s);if(glovar.tempo&&curvoice.time==0)glovar.tempo.del=true}}function do_info(info_type,text){var s,d1,d2,a,vid;switch(info_type){case"I":do_pscom(text);break;case"L":if(parse.state==2)goto_tune();a=text.match(/^(\d+)\/(\d+)(=(\d+)\/(\d+))?$/);if(a){d1=Number(a[2]);if(!d1||(d1&d1-1)!=0)break;d1=Number(a[1])/d1*BASE_LEN;if(a[3]){d2=Number(a[5]);if(!d2||(d2&d2-1)!=0){d2=0;break}d2=Number(a[4])/d2*BASE_LEN}else{d2=d1}}else if(text=="auto"){d1=d2=-1}if(!d2){syntax(1,"Bad L: value");break}if(parse.state<2){glovar.ulen=d1}else{curvoice.ulen=d1;curvoice.dur_fact=d2/d1}break;case"M":new_meter(text);break;case"U":set_user(text);break;case"P":if(parse.state==0)break;if(parse.state==1){info.P=text;break}if(parse.state==2)goto_tune();if(cfmt.writefields.indexOf(info_type)<0)break;s={type:PART,text:text,dur:0};var p_voice=voice_tb[par_sy.top_voice];if(curvoice.v!=p_voice.v){if(curvoice.time!=p_voice.time)break;if(p_voice.last_sym&&p_voice.last_sym.type==PART)break;var voice_sav=curvoice;curvoice=p_voice;sym_link(s);curvoice=voice_sav}else{sym_link(s)}break;case"Q":if(parse.state==0)break;new_tempo(text);break;case"V":get_voice(text);break;case"K":if(parse.state==0)break;get_key(text);break;case"N":case"R":if(!info[info_type])info[info_type]=text;else info[info_type]+="\n"+text;break;case"r":if(!user.keep_remark||parse.state!=3)break;s={type:REMARK,text:text,dur:0};sym_link(s);break;default:syntax(0,"'$1:' line ignored",info_type);break}}function adjust_dur(s){var s2,time,auto_time,i,res;s2=curvoice.last_sym;if(!s2)return;if(s2.type==MREST||s2.type==BAR)return;while(s2.type!=BAR&&s2.prev)s2=s2.prev;time=s2.time;auto_time=curvoice.time-time;if(time==0){while(s2&&!s2.dur)s2=s2.next;if(s2&&s2.type==REST&&s2.invis){time+=s2.dur*curvoice.wmeasure/auto_time;if(s2.prev)s2.prev.next=s2.next;else curvoice.sym=s2.next;if(s2.next)s2.next.prev=s2.prev;s2=s2.next}}if(curvoice.wmeasure==auto_time)return;for(;s2;s2=s2.next){s2.time=time;if(!s2.dur||s2.grace)continue;s2.dur=s2.dur*curvoice.wmeasure/auto_time;s2.dur_orig=s2.dur_orig*curvoice.wmeasure/auto_time;time+=s2.dur;if(s2.type!=NOTE&&s2.type!=REST)continue;for(i=0;i<=s2.nhd;i++)s2.notes[i].dur=s2.notes[i].dur*curvoice.wmeasure/auto_time;res=identify_note(s2,s2.dur_orig);s2.head=res[0];s2.dots=res[1];s2.nflags=res[2];if(s2.nflags<=-2)s2.stemless=true;else delete s2.stemless}curvoice.time=s.time=time}function new_bar(){var s2,c,bar_type,line=parse.line,s={type:BAR,ctx:parse.ctx,istart:parse.bol+line.index,dur:0,multi:0};if(vover&&vover.bar)get_vover("|");if(glovar.new_nbar){s.bar_num=glovar.new_nbar;glovar.new_nbar=0}bar_type=line.char();while(1){c=line.next_char();switch(c){case"|":case"[":case"]":case":":bar_type+=c;continue}break}if(bar_type[0]==":"){if(bar_type.length==1){bar_type="|";s.bar_dotted=true}else{s.rbstop=2}}if(a_gch)gch_build(s);if(a_dcn){deco_cnv(a_dcn,s);a_dcn=null}switch(bar_type.slice(-1)){case"[":if(bar_type.length==1){s.text="";break}if(c>"0"&&c<="9")break;bar_type=bar_type.slice(0,-1);line.index--;c="[";break;case":":s.rbstop=2;break}if(c>"0"&&c<="9"){s.text=c;while(1){c=line.next_char();if("0123456789,.-".indexOf(c)<0)break;s.text+=c}s.rbstop=2;s.rbstart=2}else if(c=='"'&&bar_type=="["){while(1){c=line.next_char();if(!c){syntax(1,"No end of repeat string");return}if(c=='"'){line.index++;break}if(c=="\\"){s.text+=c;c=line.next_char()}s.text+=c}s.text=cnv_escape(s.text);s.rbstop=2;s.rbstart=2}if(bar_type[0]=="]"){s.rbstop=2;if(bar_type.length!=1)bar_type=bar_type.slice(1);else s.invis=true}s.iend=parse.bol+line.index;if(s.rbstart&&curvoice.norepbra&&!curvoice.second)s.norepbra=true;if(curvoice.ulen<0)adjust_dur(s);s2=curvoice.last_sym;if(s2&&s2.type==SPACE){s2.time--}else if(s2&&s2.type==BAR&&!s2.a_gch&&!s2.a_dd&&!s.a_gch&&!s.a_dd){if(bar_type=="["&&!s2.text&&(curvoice.st==0||par_sy.staves[curvoice.st-1].flags&STOP_BAR||s.norepbra)){if(s.text)s2.text=s.text;if(s.a_gch)s2.a_gch=s.a_gch;if(s.norepbra)s2.norepbra=s.norepbra;if(s.rbstart)s2.rbstart=s.rbstart;if(s.rbstop)s2.rbstop=s.rbstop;return}if(bar_type=="|:"){if(s2.bar_type==":|"){s2.bar_type="::";s2.rbstop=2;return}if(s2.bar_type=="||"){s2.bar_type="||:";s2.rbstop=2;return}}}switch(bar_type){case"[":s.rbstop=2;case"[]":case"[|]":s.invis=true;bar_type="[]";break;case":|:":case":||:":bar_type="::";break;case"||":if(!cfmt.rbdbstop)break;case"[|":case"|]":s.rbstop=2;break}s.bar_type=bar_type;if(!curvoice.lyric_restart)curvoice.lyric_restart=s;if(!curvoice.sym_restart)curvoice.sym_restart=s;if(s2&&s2.type==KEY&&(!s2.prev||s2.prev.type!=BAR)){curvoice.last_sym=s2.prev;if(!s2.prev)curvoice.sym=s2.prev;sym_link(s);s.next=s2;s2.prev=s;curvoice.last_sym=s2}else{sym_link(s)}s.st=curvoice.st;if(s.rbstart&&!curvoice.norepbra&&curvoice.st>0&&!(par_sy.staves[curvoice.st-1].flags&STOP_BAR)){s2={type:BAR,ctx:s.ctx,istart:s.istart,iend:s.iend,bar_type:"[",multi:0,invis:true,text:s.text,rbstart:2};sym_link(s2);s2.st=curvoice.st;delete s.text;s.rbstart=0}}var err_mispl_sta_s="Misplaced '$1' in %%staves";function parse_staves(p){var v,vid,a_vf=[],err=false,flags=0,brace=0,bracket=0,parenth=0,flags_st=0,i=0;while(i<p.length){switch(p[i]){case" ":case"\t":break;case"[":if(parenth||brace+bracket>=2){syntax(1,err_mispl_sta_s,"[");err=true;break}flags|=brace+bracket==0?OPEN_BRACKET:OPEN_BRACKET2;bracket++;flags_st<<=8;flags_st|=OPEN_BRACKET;break;case"{":if(parenth||brace||bracket>=2){syntax(1,err_mispl_sta_s,"{");err=true;break}flags|=!bracket?OPEN_BRACE:OPEN_BRACE2;brace++;flags_st<<=8;flags_st|=OPEN_BRACE;break;case"(":if(parenth){syntax(1,err_mispl_sta_s,"(");err=true;break}flags|=OPEN_PARENTH;parenth++;flags_st<<=8;flags_st|=OPEN_PARENTH;break;case"*":if(brace&&!parenth&&!(flags&(OPEN_BRACE|OPEN_BRACE2)))flags|=FL_VOICE;break;case"+":flags|=MASTER_VOICE;break;default:if(!p[i].match(/\w/)){syntax(1,"Bad voice ID in %%staves");err=true;break}vid="";while(i<p.length){if(" \t()[]{}|*".indexOf(p[i])>=0)break;vid+=p[i++]}for(;i<p.length;i++){switch(p[i]){case" ":case"\t":continue;case"]":if(!(flags_st&OPEN_BRACKET)){syntax(1,err_mispl_sta_s,"]");err=true;break}bracket--;flags|=brace+bracket==0?CLOSE_BRACKET:CLOSE_BRACKET2;flags_st>>=8;continue;case"}":if(!(flags_st&OPEN_BRACE)){syntax(1,err_mispl_sta_s,"}");err=true;break}brace--;flags|=!bracket?CLOSE_BRACE:CLOSE_BRACE2;flags&=~FL_VOICE;flags_st>>=8;continue;case")":if(!(flags_st&OPEN_PARENTH)){syntax(1,err_mispl_sta_s,")");err=true;break}parenth--;flags|=CLOSE_PARENTH;flags_st>>=8;continue;case"|":flags|=STOP_BAR;continue}break}a_vf.push([vid,flags]);flags=0;continue}i++}if(flags_st!=0){syntax(1,"'}', ')' or ']' missing in %%staves");err=true}if(err||a_vf.length==0)return;return a_vf}function info_split(text){var a=[],item="",i,j,n=text.length;for(i=0;i<n;i++){switch(text[i]){case"=":if(!item){item="=";break}item+="=";a.push(item);item="";break;case" ":case"\t":if(!item)break;a.push(item);item="";break;case'"':if(item){a.push(item);item=""}j=i++;while(i<n){if(text[i]=='"')break;if(text[i]=="\\")i++;i++}if(text[i]!='"'){syntax(1,"Unterminated string");break}a.push(text.slice(j,i+1));break;case"\\":item+=text[i++];default:item+=text[i];break}}if(item)a.push(item);return a}function identify_note(s,dur){var head,dots,flags;if(dur%12!=0)syntax(1,"Invalid note duration $1",dur);dur/=12;if(dur==0)syntax(1,"Note too short");for(flags=5;dur!=0;dur>>=1,flags--){if(dur&1)break}dur>>=1;switch(dur){case 0:dots=0;break;case 1:dots=1;break;case 3:dots=2;break;default:dots=3;break}flags-=dots;if(flags>=0){head=FULL}else switch(flags){default:syntax(1,"Note too long");flags=-4;case-4:head=SQUARE;break;case-3:head=cfmt.squarebreve?SQUARE:OVALBARS;break;case-2:head=OVAL;break;case-1:head=EMPTY;break}return[head,dots,flags]}var reg_dur=/(\d*)(\/*)(\d*)/g;function parse_dur(line){var res,num,den;reg_dur.lastIndex=line.index;res=reg_dur.exec(line.buffer);if(!res[0])return[1,1];num=res[1]||1;den=res[3]||1;if(!res[3])den*=1<<res[2].length;line.index=reg_dur.lastIndex;return[num,den]}function parse_acc_pit(line){var note,acc,micro_n,micro_d,pit,nd,c=line.char();switch(c){case"^":c=line.next_char();if(c=="^"){acc=2;c=line.next_char()}else{acc=1}break;case"=":acc=3;c=line.next_char();break;case"_":c=line.next_char();if(c=="_"){acc=-2;c=line.next_char()}else{acc=-1}break}if(acc&&acc!=3&&(c>="1"&&c<="9")||c=="/"){nd=parse_dur(line);micro_n=nd[0];micro_d=nd[1];if(micro_d==1)micro_d=curvoice?curvoice.uscale:1;else micro_d*=2;c=line.char()}pit=ntb.indexOf(c)+16;c=line.next_char();if(pit<16){syntax(1,"'$1' is not a note",line.buffer[line.index-1]);return}while(c=="'"){pit+=7;c=line.next_char()}while(c==","){pit-=7;c=line.next_char()}note={pit:pit,apit:pit,shhd:0,shac:0,ti1:0};if(acc){note.acc=acc;if(micro_n){note.micro_n=micro_n;note.micro_d=micro_d}}return note}function set_map(note){var bn,an,nn,i,map=maps[curvoice.map];bn="abcdefg"[(note.pit+77)%7];if(note.acc)an=["__","_","","^","^^","="][note.acc+2];else an="";nn=an+bn;for(i=note.pit;i>=28;i-=7)nn+="'";for(i=note.pit;i<21;i+=7)nn+=",";if(!map[nn]){nn="octave,"+an+bn;if(!map[nn]){nn="key,"+"abcdefg"[(note.pit+77-curvoice.ckey.k_delta)%7];if(!map[nn]){nn="all";if(!map[nn])return}}}note.map=map[nn];if(note.map[1]){note.apit=note.pit=note.map[1].pit;note.acc=note.map[1].acc}}function parse_basic_note(line,ulen){var nd,note=parse_acc_pit(line);if(!note)return;if(line.char()=="0"){parse.stemless=true;line.index++}nd=parse_dur(line);note.dur=ulen*nd[0]/nd[1];return note}function parse_vpos(){var c,line=parse.line,ti1=0;if(line.buffer[line.index-1]=="."&&!a_dcn)ti1=SL_DOTTED;switch(line.next_char()){case"'":line.index++;return ti1+SL_ABOVE;case",":line.index++;return ti1+SL_BELOW}return ti1+SL_AUTO}var cde2fcg=new Int8Array([0,2,4,-1,1,3,5]),cgd2cde=new Int8Array([0,4,1,5,2,6,3]),acc2=new Int8Array([-2,-1,3,1,2]);function note_transp(s){var i,j,n,d,a,acc,i1,i3,i4,note,m=s.nhd,sf_old=curvoice.okey.k_sf,i2=curvoice.ckey.k_sf-sf_old,dp=cgd2cde[(i2+4*7)%7],t=curvoice.vtransp;if(t<0&&dp!=0)dp-=7;dp+=(t/3/12|0)*7;for(i=0;i<=m;i++){note=s.notes[i];n=note.pit;note.pit+=dp;note.apit=note.pit;i1=cde2fcg[(n+5+16*7)%7];a=note.acc;if(!a){if(!curvoice.okey.a_acc){if(sf_old>0){if(i1<sf_old-1)a=1}else if(sf_old<0){if(i1>=sf_old+6)a=-1}}else{for(j=0;j<curvoice.okey.a_acc.length;j++){acc=curvoice.okey.a_acc[j];if((n+16*7-acc.pit)%7==0){a=acc.acc;break}}}}i3=i1+i2;if(a&&a!=3)i3+=a*7;i1=(((i3+1+21)/7|0)+2-3+32*5)%5;a=acc2[i1];if(note.acc){}else if(curvoice.ckey.k_none){if(a==3||acc_same_pitch(note.pit))continue}else if(curvoice.ckey.a_acc){i4=cgd2cde[(i3+16*7)%7];for(j=0;j<curvoice.ckey.a_acc.length;j++){if((i4+16*7-curvoice.ckey.a_acc[j].pits)%7==0)break}if(j<curvoice.ckey.a_acc.length)continue}else{continue}i1=note.acc;d=note.micro_d;if(d&&i1!=a){n=note.micro_n;switch(a){case 3:if(n>d/2){n-=d/2;note.micro_n=n;a=i1}else{a=-i1}break;case 2:if(n>d/2){note.pit+=1;note.apit=note.pit;n-=d/2}else{n+=d/2}a=i1;note.micro_n=n;break;case-2:if(n>=d/2){note.pit-=1;note.apit=note.pit;n-=d/2}else{n+=d/2}a=i1;note.micro_n=n;break}}note.acc=a}}function sort_pitch(s){s.notes=s.notes.sort(function(n1,n2){return n1.pit-n2.pit})}function new_note(grace,tp_fact){var note,s,in_chord,c,dcn,type,i,n,s2,nd,res,num,dur,sl1=0,line=parse.line,a_dcn_sav=a_dcn;a_dcn=null;parse.stemless=false;s={type:NOTE,ctx:parse.ctx,stem:0,multi:0,nhd:0,xmx:0};s.istart=parse.bol+line.index;if(curvoice.color)s.color=curvoice.color;if(grace){s.grace=true}else{if(a_gch)gch_build(s);if(parse.repeat_n){s.repeat_n=parse.repeat_n;s.repeat_k=parse.repeat_k;parse.repeat_n=0}}c=line.char();switch(c){case"X":s.invis=true;case"Z":s.type=MREST;c=line.next_char();s.nmes=c>"0"&&c<="9"?line.get_int():1;s.dur=curvoice.wmeasure*s.nmes;if(curvoice.second){curvoice.time+=s.dur;return null}break;case"y":s.type=SPACE;s.invis=true;s.dur=0;c=line.next_char();if(c>="0"&&c<="9")s.width=line.get_int();else s.width=10;break;case"x":s.invis=true;case"z":s.type=REST;line.index++;nd=parse_dur(line);s.dur_orig=(curvoice.ulen<0?15120:curvoice.ulen)*nd[0]/nd[1];s.dur=s.dur_orig*curvoice.dur_fact;s.notes=[{pit:18,dur:s.dur_orig}];break;case"[":in_chord=true;c=line.next_char();default:if(curvoice.uscale)s.uscale=curvoice.uscale;s.notes=[];while(1){if(in_chord){while(1){if(!c||c=="%")break;i=c.charCodeAt(0);if(i>=128){syntax(1,not_ascii);return null}type=char_tb[i];switch(type[0]){case"(":sl1<<=4;sl1+=parse_vpos();c=line.char();continue;case"!":if(!a_dcn)a_dcn=[];if(type.length>1){a_dcn.push(type.slice(1,-1))}else{dcn="";while(1){c=line.next_char();if(!c||c=="%"){syntax(1,"No end of decoration");return}if(c=="!")break;dcn+=c}a_dcn.push(dcn)}c=line.next_char();continue}break}}note=parse_basic_note(line,s.grace?BASE_LEN/4:curvoice.ulen<0?15120:curvoice.ulen);if(!note)return;if(curvoice.octave)note.apit=note.pit+=curvoice.octave*7;if(curvoice.ottava)note.pit+=curvoice.ottava;if(sl1){note.sl1=sl1;if(s.sl1)s.sl1++;else s.sl1=1;sl1=0}if(a_dcn){note.a_dcn=a_dcn;a_dcn=null}s.notes.push(note);if(!in_chord)break;c=line.char();while(1){switch(c){case")":if(note.sl2)note.sl2++;else note.sl2=1;if(s.sl2)s.sl2++;else s.sl2=1;c=line.next_char();continue;case"-":note.ti1=parse_vpos();s.ti1=true;c=line.char();continue;case".":c=line.next_char();if(c!="-"){syntax(1,"Misplaced dot");break}continue}break}if(c=="]"){line.index++;nd=parse_dur(line);s.nhd=s.notes.length-1;for(i=0;i<=s.nhd;i++){note=s.notes[i];note.dur=note.dur*nd[0]/nd[1]}break}}s.dur_orig=s.notes[0].dur;s.dur=s.notes[0].dur*curvoice.dur_fact}if(s.grace&&s.type!=NOTE){syntax(1,"Not a note in grace note sequence");return}if(s.notes){if(!s.grace){switch(curvoice.pos.stm){case SL_ABOVE:s.stem=1;break;case SL_BELOW:s.stem=-1;break;case SL_HIDDEN:s.stemless=true;break}s.combine=curvoice.combine;s.dur*=tp_fact;num=curvoice.brk_rhythm;if(num){curvoice.brk_rhythm=0;s2=curvoice.last_note;if(num>0){n=num*2-1;s.dur=s.dur*n/num;s.dur_orig=s.dur_orig*n/num;for(i=0;i<=s.nhd;i++)s.notes[i].dur=s.notes[i].dur*n/num;s2.dur/=num;s2.dur_orig/=num;for(i=0;i<=s2.nhd;i++)s2.notes[i].dur/=num}else{num=-num;n=num*2-1;s.dur/=num;s.dur_orig/=num;for(i=0;i<=s.nhd;i++)s.notes[i].dur/=num;s2.dur=s2.dur*n/num;s2.dur_orig=s2.dur_orig*n/num;for(i=0;i<=s2.nhd;i++)s2.notes[i].dur=s2.notes[i].dur*n/num}curvoice.time=s2.time+s2.dur;res=identify_note(s2,s2.dur_orig);s2.head=res[0];s2.dots=res[1];s2.nflags=res[2];if(s2.nflags<=-2)s2.stemless=true;else delete s2.stemless;for(s2=s2.next;s2;s2=s2.next)s2.time=curvoice.time}}else{var div=curvoice.key.k_bagpipe?8:4;for(i=0;i<=s.nhd;i++)s.notes[i].dur/=div;s.dur/=div;s.dur_orig/=div;if(grace.stem)s.stem=grace.stem}if(s.type==NOTE){res=identify_note(s,s.dur_orig);s.head=res[0];s.dots=res[1];s.nflags=res[2];if(s.nflags<=-2)s.stemless=true}else{dur=s.dur_orig;if(dur==curvoice.wmeasure){if(dur<BASE_LEN*2)dur=BASE_LEN;else if(dur<BASE_LEN*4)dur=BASE_LEN*2;else dur=BASE_LEN*4}res=identify_note(s,dur);s.head=res[0];s.dots=res[1];s.nflags=res[2]}curvoice.last_note=s}sym_link(s);if(s.type==NOTE){if(curvoice.vtransp)note_transp(s);if(curvoice.map&&maps[curvoice.map]){for(i=0;i<=s.nhd;i++)set_map(s.notes[i])}}if(cfmt.shiftunison)s.shiftunison=cfmt.shiftunison;if(!grace){if(!curvoice.lyric_restart)curvoice.lyric_restart=s;if(!curvoice.sym_restart)curvoice.sym_restart=s}if(a_dcn_sav)deco_cnv(a_dcn_sav,s,s.prev);if(parse.stemless)s.stemless=true;s.iend=parse.bol+line.index;return s}var nil=["0"];var char_tb=[nil,nil,nil,nil,nil,nil,nil,nil,nil," ","\n",nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil," ","!",'"',"i","\n",nil,"&",nil,"(",")","i",nil,nil,"-","!dot!",nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,"|","i","<","n","<","i","i","n","n","n","n","n","n","n","!fermata!","d","d","d","!emphasis!","!lowermordent!","d","!coda!","!uppermordent!","d","d","!segno!","!trill!","d","d","d","n","d","n","[","\\","|","n","n","i","n","n","n","n","n","n","n","d","d","d","d","d","d","d","d","d","d","d","d","d","!upbow!","!downbow!","d","n","n","n","{","|","}","!roll!",nil];function parse_music_line(){var grace,last_note_sav,a_dcn_sav,no_eol,s,tp_a=[],tp,tpn=-1,tp_fact=1,slur_start=0,line=parse.line;function check_mac(m){var i,j,b;for(i=1,j=line.index+1;i<m.length;i++,j++){if(m[i]==line.buffer[j])continue;if(m[i]!="n")return;b=ntb.indexOf(line.buffer[j]);if(b<0)return;while(line.buffer[j+1]=="'"){b+=7;j++}while(line.buffer[j+1]==","){b-=7;j++}}line.index=j;return b}function expand(m,b){var c,d,r="",n=m.length;for(i=0;i<n;i++){c=m[i];if(c>="h"&&c<="z"){d=b+c.charCodeAt(0)-"n".charCodeAt(0);c="";while(d<0){d+=7;c+=","}while(d>14){d-=7;c+="'"}r+=ntb[d]+c}else{r+=c}}return r}function parse_mac(m,b){var seq,line_sav=line,istart_sav=parse.istart;parse.line=line=new scanBuf;parse.istart+=line_sav.index;line.buffer=b?expand(m,b):m;parse_seq(true);parse.line=line=line_sav;parse.istart=istart_sav}function parse_seq(in_mac){var c,idx,type,k,s,dcn,i,n,text;while(1){c=line.char();if(!c||c=="%")break;if(c=="."){switch(line.buffer[line.index+1]){case"(":case"-":case"|":c=line.next_char();break}}idx=c.charCodeAt(0);if(idx>=128){syntax(1,not_ascii);line.index++;break}if(!in_mac&&maci[idx]){n=0;for(k in mac){if(!mac.hasOwnProperty(k)||k[0]!=c)continue;if(k.indexOf("n")<0){if(line.buffer.indexOf(k,line.index)!=line.index)continue;line.index+=k.length}else{n=check_mac(k);if(!n)continue}parse_mac(mac[k],n);n=1;break}if(n)continue}type=char_tb[idx];switch(type[0]){case" ":s=curvoice.last_note;if(s){s.beam_end=true;if(grace)grace.gr_shift=true}break;case"\n":if(cfmt.barsperstaff)break;if(par_sy.voices[curvoice.v].range==0&&curvoice.last_sym)curvoice.last_sym.eoln=true;break;case"&":c=line.next_char();if(c==")"){get_vover(")");break}get_vover("&");continue;case"(":c=line.next_char();if(c>"0"&&c<="9"){var pplet=line.get_int(),qplet=qplet_tb[pplet],rplet=pplet,c=line.char();if(c==":"){c=line.next_char();if(c>"0"&&c<="9"){qplet=line.get_int();c=line.char()}if(c==":"){c=line.next_char();if(c>"0"&&c<="9"){rplet=line.get_int();c=line.char()}else{syntax(1,"Invalid 'r' in tuplet");continue}}}if(qplet==0||qplet==undefined)qplet=curvoice.wmeasure%9==0?3:2;tp=tp_a[++tpn];if(!tp)tp_a[tpn]=tp={};tp.p=pplet;tp.q=qplet;tp.r=rplet;tp.f=cfmt.tuplets;tp.fact=tp_fact*qplet/pplet;tp_fact=tp.fact;continue}if(c=="&"){get_vover("(");break}slur_start<<=4;line.index--;slur_start+=parse_vpos();continue;case")":if(curvoice.ignore)break;s=curvoice.last_sym;if(s){switch(s.type){case NOTE:case REST:case SPACE:break;default:s=null;break}}if(!s){syntax(1,"Bad character '$1'",c);break}if(s.slur_end)s.slur_end++;else s.slur_end=1;break;case"!":if(!a_dcn)a_dcn=[];if(type.length>1){dcn=type.slice(1,-1)}else{dcn="";i=line.index;while(1){c=line.next_char();if(c=="%")c=0;if(!c)break;if(c=="!")break;dcn+=c}if(!c){line.index=i;syntax(1,"No end of decoration");break}}if(ottava[dcn])set_ottava(dcn);a_dcn.push(dcn);break;case'"':parse_gchord(type);break;case"-":var tie_pos=0;if(!curvoice.last_note||curvoice.last_note.type!=NOTE){syntax(1,"No note before '-'");break}tie_pos=parse_vpos();s=curvoice.last_note;for(i=0;i<=s.nhd;i++){if(!s.notes[i].ti1)s.notes[i].ti1=tie_pos;else if(s.nhd==0)syntax(1,"Too many ties")}s.ti1=true;if(grace)grace.ti1=true;continue;case"[":var c_next=line.buffer[line.index+1];if('|[]: "'.indexOf(c_next)>=0||c_next>="1"&&c_next<="9"){if(grace){syntax(1,bar_grace);break}new_bar();continue}if(line.buffer[line.index+2]==":"){i=line.buffer.indexOf("]",line.index+1);if(i<0){syntax(1,"Lack of ']'");break}text=line.buffer.slice(line.index+3,i).trim();parse.istart=parse.bol+line.index;parse.iend=parse.bol+i++;line.index=0;do_info(c_next,text);line.index=i;continue}case"n":s=new_note(grace,tp_fact);if(!s)continue;if(s.type==NOTE){if(slur_start){s.slur_start=slur_start;slur_start=0}}if(grace){if(tpn>=0)s.in_tuplet=true;continue}if(tpn>=0&&s.notes){s.in_tuplet=true;if(tpn>0){if(tp_a[0].p){s.tp0=tp_a[0].p;s.tq0=tp_a[0].q;s.tf=tp_a[0].f;tp_a[0].p=0}tp_a[0].r--;if(tp.p){s.tp1=tp.p;s.tq1=tp.q;s.tf=tp.f;tp.p=0}}else if(tp.p){s.tp0=tp.p;s.tq0=tp.q;s.tf=tp.f;tp.p=0}tp.r--;if(tp.r==0){if(tpn--==0){s.te0=true;tp_fact=1;curvoice.time=Math.round(curvoice.time);s.dur=curvoice.time-s.time}else{s.te1=true;tp=tp_a[0];if(tp.r==0){tpn--;s.te0=true;tp_fact=1;curvoice.time=Math.round(curvoice.time);s.dur=curvoice.time-s.time}else{tp_fact=tp.fact}}}}continue;case"<":if(!curvoice.last_note){syntax(1,"No note before '<'");break}if(grace){syntax(1,"Cannot have a broken rhythm in grace notes");break}n=c=="<"?1:-1;while(c=="<"||c==">"){n*=2;c=line.next_char()}curvoice.brk_rhythm=n;continue;case"i":break;case"{":if(grace){syntax(1,"'{' in grace note");break}last_note_sav=curvoice.last_note;curvoice.last_note=null;a_dcn_sav=a_dcn;a_dcn=undefined;grace={type:GRACE,ctx:parse.ctx,istart:parse.bol+line.index,dur:0,multi:0};switch(curvoice.pos.gst){case SL_ABOVE:grace.stem=1;break;case SL_BELOW:grace.stem=-1;break;case SL_HIDDEN:grace.stem=2;break}sym_link(grace);c=line.next_char();if(c=="/"){grace.sappo=true;break}continue;case"|":if(grace){syntax(1,bar_grace);break}c=line.buffer[line.index-1];new_bar();if(c==".")curvoice.last_sym.bar_dotted=true;continue;case"}":s=curvoice.last_note;if(!grace||!s){syntax(1,"Bad character '$1'",c);break}if(a_dcn)syntax(1,"Decoration ignored");s.gr_end=true;grace.extra=grace.next;grace.extra.prev=null;grace.next=null;curvoice.last_sym=grace;grace=null;if(!s.prev&&!curvoice.key.k_bagpipe){for(i=0;i<=s.nhd;i++)s.notes[i].dur*=2;s.dur*=2;s.dur_orig*=2;var res=identify_note(s,s.dur_orig);s.head=res[0];s.dots=res[1];s.nflags=res[2]}curvoice.last_note=last_note_sav;a_dcn=a_dcn_sav;break;case"\\":for(i=line.index+1;;i++){switch(line.buffer[i]){case" ":case"\t":continue;case"%":line.index=line.buffer.length;case undefined:c=undefined;no_eol=true;break}break}if(!c)break;default:syntax(1,"Bad character '$1'",c);break}line.index++}}if(parse.state!=3){if(parse.state!=2)return;goto_tune()}parse_seq();if(tpn>=0){syntax(1,"No end of tuplet");for(s=curvoice.last_note;s;s=s.prev){if(s.tp1)s.tp1=0;if(s.tp0){s.tp0=0;break}}}if(grace){syntax(1,"No end of grace note sequence");curvoice.last_sym=grace.prev;curvoice.last_note=last_note_sav;if(grace.prev)grace.prev.next=null}if(cfmt.breakoneoln&&curvoice.last_note)curvoice.last_note.beam_end=true;if(no_eol||cfmt.barsperstaff)return;if(char_tb["\n".charCodeAt(0)]=="\n"&&par_sy.voices[curvoice.v].range==0&&curvoice.last_sym)curvoice.last_sym.eoln=true}var cw_tb=new Float32Array([.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.25,.333,.408,.5,.5,.833,.778,.333,.333,.333,.5,.564,.25,.564,.25,.278,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.278,.278,.564,.564,.564,.444,.921,.722,.667,.667,.722,.611,.556,.722,.722,.333,.389,.722,.611,.889,.722,.722,.556,.722,.667,.556,.611,.722,.722,.944,.722,.722,.611,.333,.278,.333,.469,.5,.333,.444,.5,.444,.5,.444,.333,.5,.5,.278,.278,.5,.278,.778,.5,.5,.5,.5,.333,.389,.278,.5,.5,.722,.5,.5,.444,.48,.2,.48,.541,.5]);function cwid(c){var i=c.charCodeAt(0);if(i>=128){if(i>=768&&i<880)return 0;i=97}return cw_tb[i]}function strw(str){var swfac=gene.curfont.swfac,w=0,i,j,c,n=str.length;for(i=0;i<n;i++){c=str[i];switch(c){case"$":c=str[i+1];if(c=="0"){gene.curfont=gene.deffont}else if(c>="1"&&c<="9"){gene.curfont=get_font("u"+c)}else{c="$";break}i++;swfac=gene.curfont.swfac;continue;case"&":j=str.indexOf(";",i);if(j>0&&j-i<10){i=j;c="a"}break}w+=cwid(c)*swfac}return w}function set_font(xxx){gene.curfont=gene.deffont=get_font(xxx)}function out_str(str){var n_font,o_font=gene.curfont,c_font=o_font;output.push(str.replace(/<|>|&.*?;|&|  |\$./g,function(c){switch(c[0]){case"<":return"&lt;";case">":return"&gt;";case"&":if(c=="&")return"&amp;";return c;case" ":return"  ";case"$":if(c[1]=="0"){n_font=gene.deffont;use_font(n_font)}else if(c[1]>="1"&&c[1]<="9")n_font=get_font("u"+c[1]);else return c;c="";if(n_font==c_font)return c;if(c_font!=o_font)c="</tspan>";c_font=n_font;if(c_font==o_font)return c;return c+'<tspan\n\tclass="'+font_class(n_font)+'">'}}));if(c_font!=o_font){output.push("</tspan>");gene.curfont=c_font}}function xy_str(x,y,str,action,line_w){y+=gene.curfont.size*.2;output.push('<text class="'+font_class(gene.curfont)+'" x="');out_sxsy(x,'" y="',y);switch(action){case"c":output.push('" text-anchor="middle">');break;case"j":output.push('" textLength="'+line_w.toFixed(2)+'">');break;case"r":output.push('" text-anchor="end">');break;default:output.push('">');break}out_str(str);output.push("</text>\n")}function xy_str_b(x,y,str){var w=strw(str);output.push('<rect class="stroke" x="');out_sxsy(x-2,'" y="',y+gene.curfont.size+1);output.push('" width="'+(w+4).toFixed(2)+'" height="'+(gene.curfont.size+3).toFixed(2)+'"/>\n');xy_str(x,y,str)}function trim_title(title,is_subtitle){var i;if(cfmt.titletrim){i=title.lastIndexOf(", ");if(i<0||title[i+2]<"A"||title[i+2]>"Z"||i<title.length-7||title.indexOf(" ",i+3)>=0)i=0}if(!is_subtitle&&cfmt.writefields.indexOf("X")>=0)title=info.X+".  "+title;if(i)title=title.slice(i+2).trim()+" "+title.slice(0,i);if(cfmt.titlecaps)return title.toUpperCase();return title}function get_lwidth(){return(img.width-img.lm-img.rm-2)/cfmt.scale}function write_title(title,is_subtitle){var font,sz;if(!title)return;set_page();title=trim_title(title,is_subtitle);if(is_subtitle){set_font("subtitle");sz=gene.curfont.size;vskip(cfmt.subtitlespace+sz)}else{set_font("title");sz=gene.curfont.size;vskip(cfmt.titlespace+sz)}if(cfmt.titleleft)xy_str(0,0,title);else xy_str(get_lwidth()/2,0,title,"c")}function put_inf2r(x,y,str1,str2,action){if(!str1){if(!str2)return;str1=str2;str2=null}if(!str2)xy_str(x,y,str1,action);else xy_str(x,y,str1+" ("+str2+")",action)}function write_text(text,action){if(action=="s")return;set_font("text");set_page();var strlw=get_lwidth(),lineskip=gene.curfont.size*cfmt.lineskipfac,parskip=gene.curfont.size*cfmt.parskipfac,p_start=block.started?function(){}:blk_out,p_flush=block.started?svg_flush:blk_flush,i,j,x,words,w,k,ww;p_start();switch(action){default:switch(action){case"c":x=strlw/2;break;case"r":x=strlw;break;default:x=0;break}j=0;while(1){i=text.indexOf("\n",j);if(i<0){vskip(lineskip);xy_str(x,0,text.slice(j),action);break}if(i==j){vskip(parskip);p_flush();use_font(gene.curfont);while(text[i+1]=="\n"){vskip(lineskip);i++}if(i==text.length)break;p_start()}else{vskip(lineskip);xy_str(x,0,text.slice(j,i),action)}j=i+1}vskip(parskip);p_flush();break;case"f":case"j":j=0;while(1){i=text.indexOf("\n\n",j);if(i<0)words=text.slice(j);else words=text.slice(j,i);words=words.split(/\s+/);w=k=0;for(j=0;j<words.length;j++){ww=strw(words[j]+" ");w+=ww;if(w>=strlw){vskip(lineskip);xy_str(0,0,words.slice(k,j).join(" "),action,strlw);k=j;w=ww}}if(w!=0){vskip(lineskip);xy_str(0,0,words.slice(k).join(" "))}vskip(parskip);p_flush();if(i<0)break;while(text[i+2]=="\n"){vskip(lineskip);i++}if(i==text.length)break;p_start();use_font(gene.curfont);j=i+2}break}}function put_words(words){var p,i,j,n,nw,i2,i_end,have_text;function put_wline(p,x,right){var i=0,j,k;if(p[i]=="$"&&p[i+1]>="0"&&p[i+1]<="9")i+=2;k=0;j=i;if(p[i]>="0"&&p[i]<="9"||p[i+1]=="."){while(i<p.length){i++;if(p[i]==" "||p[i-1]==":"||p[i-1]==".")break}k=i;while(p[i]==" ")i++}if(k!=0)xy_str(x,0,p.slice(j,k),"r");if(i<p.length)xy_str(x+5,0,p.slice(i),"l");return i>=p.length&&k==0}blk_out();set_font("words");var middle=get_lwidth()/2,max2col=(middle-45)/(cwid("a")*gene.curfont.swfac);n=0;words=words.split("\n");nw=words.length;for(i=0;i<nw;i++){p=words[i];if(p.length>max2col){n=0;break}if(!p){if(have_text){n++;have_text=false}}else{have_text=true}}if(n>0){i=n=(n+1)/2|0;have_text=false;for(i_end=0;i_end<nw;i_end++){p=words[i_end];j=0;while(p[j]==" ")j++;if(j==p.length){if(have_text&&--i<=0)break;have_text=false}else{have_text=true}}i2=i_end+1}else{i2=i_end=nw}vskip(cfmt.wordsspace);for(i=0;i<i_end||i2<nw;i++){if(i<i_end&&words[i].length==0){blk_out();use_font(gene.curfont)}vskip(cfmt.lineskipfac*gene.curfont.size);if(i<i_end)put_wline(words[i],45,0);if(i2<nw){if(put_wline(words[i2],20+middle,1)){if(--n==0){if(i<i_end){n++}else if(i2<words.length-1){middle*=.6}}}i2++}}}function put_history(){var i,j,c,str,font,h,w,head,names=cfmt.infoname.split("\n"),n=names.length;for(i=0;i<n;i++){c=names[i][0];if(cfmt.writefields.indexOf(c)<0)continue;str=info[c];if(!str)continue;if(!font){font=true;set_font("history");vskip(cfmt.textspace);h=gene.curfont.size*cfmt.lineskipfac}head=names[i].slice(2);if(head[0]=='"')head=head.slice(1,-1);vskip(h);xy_str(0,0,head);w=strw(head);str=str.split("\n");xy_str(w,0,str[0]);for(j=1;j<str.length;j++){vskip(h);xy_str(w,0,str[j])}vskip(h*.3);blk_out();use_font(gene.curfont)}}var info_font_init={A:"info",C:"composer",O:"composer",P:"parts",Q:"tempo",R:"info",T:"title",X:"title"};function write_headform(lwidth){var c,font,font_name,align,x,y,sz,info_val={},info_font=clone(info_font_init),info_sz={A:cfmt.infospace,C:cfmt.composerspace,O:cfmt.composerspace,R:cfmt.infospace},info_nb={};var fmt="",p=cfmt.titleformat,j=0,i=0;while(1){while(p[i]==" ")i++;if(i>=p.length)break;c=p[i++];if(c<"A"||c>"Z"){if(c=="+"){if(fmt.length==0||fmt.slice(-1)=="+")continue;fmt=fmt.slice(0,-1)+"+"}else if(c==","){if(fmt.slice(-1)=="+")fmt=fmt.slice(0,-1)+"l";fmt+="\n"}continue}if(!info_val[c]){if(!info[c])continue;info_val[c]=info[c].split("\n");info_nb[c]=1}else{info_nb[c]++}fmt+=c;switch(p[i]){case"-":fmt+="l";i++;break;case"0":fmt+="c";i++;break;case"1":fmt+="r";i++;break;default:fmt+="c";break}}if(fmt.slice(-1)=="+")fmt=fmt.slice(0,-1)+"l";fmt+="\n";var ya={l:cfmt.titlespace,c:cfmt.titlespace,r:cfmt.titlespace},xa={l:0,c:lwidth*.5,r:lwidth},yb={},str;p=fmt;i=0;while(1){yb.l=yb.c=yb.r=y=0;j=i;while(1){c=p[j++];if(c=="\n")break;align=p[j++];if(align=="+")align=p[j+1];else if(yb[align]!=0)continue;str=info_val[c];if(!str)continue;font_name=info_font[c];if(!font_name)font_name="history";font=get_font(font_name);sz=font.size*1.1;if(info_sz[c])sz+=info_sz[c];if(y<sz)y=sz;yb[align]=sz}ya.l+=y-yb.l;ya.c+=y-yb.c;ya.r+=y-yb.r;while(1){c=p[i++];if(c=="\n")break;align=p[i++];if(info_val[c].length==0)continue;str=info_val[c].shift();if(align=="+"){info_nb[c]--;c=p[i++];align=p[i++];if(info_val[c].length>0){if(str)str+=" "+info_val[c].shift();else str=" "+info_val[c].shift()}}font_name=info_font[c];if(!font_name)font_name="history";font=get_font(font_name);sz=font.size*1.1;if(info_sz[c])sz+=info_sz[c];set_font(font_name);x=xa[align];y=ya[align]+sz;if(c=="Q"){if(!glovar.tempo.del){if(align!="l"){var w=tempo_width(glovar.tempo);if(align=="c")w*=.5;x-=w}write_tempo(glovar.tempo,x,-y)}}else if(str){xy_str(x,-y,str,align)}if(c=="T"){font_name=info_font.T="subtitle";info_sz.T=cfmt.subtitlespace}if(info_nb[c]<=1){if(c=="T"){font=get_font(font_name);sz=font.size*1.1;if(info_sz[c])sz+=info_sz[c];set_font(font_name)}while(info_val[c].length>0){y+=sz;str=info_val[c].shift();xy_str(x,-y,str,align)}}info_nb[c]--;ya[align]=y}if(ya.c>ya.l)ya.l=ya.c;if(ya.r>ya.l)ya.l=ya.r;if(i>=fmt.length)break;ya.c=ya.r=ya.l}vskip(ya.l)}function write_heading(){var i,j,area,composer,origin,rhythm,down1,down2,lwidth=get_lwidth();blk_out();vskip(cfmt.topspace);if(cfmt.titleformat){write_headform(lwidth);vskip(cfmt.musicspace);return}if(info.T&&cfmt.writefields.indexOf("T")>=0){i=0;while(1){j=info.T.indexOf("\n",i);if(j<0){write_title(info.T.substring(i),i!=0);break}write_title(info.T.slice(i,j),i!=0);i=j+1}}set_font("composer");down1=down2=0;if(parse.ckey.k_bagpipe&&!cfmt.infoline&&cfmt.writefields.indexOf("R")>=0)rhythm=info.R;if(rhythm){xy_str(0,-cfmt.composerspace,rhythm);down1=cfmt.composerspace}area=info.A;if(cfmt.writefields.indexOf("C")>=0)composer=info.C;if(cfmt.writefields.indexOf("O")>=0)origin=info.O;if(composer||origin||cfmt.infoline){var xcomp,align;vskip(cfmt.composerspace);if(cfmt.aligncomposer<0){xcomp=0;align=" "}else if(cfmt.aligncomposer==0){xcomp=lwidth*.5;align="c"}else{xcomp=lwidth;align="r"}down2=down1;if(composer||origin){if(cfmt.aligncomposer>=0&&down1!=down2)vskip(down1-down2);i=0;while(1){vskip(gene.curfont.size);if(composer)j=composer.indexOf("\n",i);else j=-1;if(j<0){put_inf2r(xcomp,0,composer?composer.substring(i):null,origin,align);break}xy_str(xcomp,0,composer.slice(i,j),align);down1+=gene.curfont.size;i=j+1}if(down2>down1)vskip(down2-down1)}rhythm=rhythm?null:info.R;if((rhythm||area)&&cfmt.infoline){set_font("info");vskip(gene.curfont.size+cfmt.infospace);put_inf2r(lwidth,0,rhythm,area,"r");down1+=gene.curfont.size+cfmt.infospace}}else{down2=cfmt.composerspace}if(info.P&&cfmt.writefields.indexOf("P")>=0){set_font("parts");down1=cfmt.partsspace+gene.curfont.size-down1;if(down1>0)down2+=down1;if(down2>.01)vskip(down2);xy_str(0,0,info.P);down2=0}vskip(down2+cfmt.musicspace)}var output=[],style="\n.fill {fill: currentColor}\n.stroke {stroke: currentColor; fill: none}\n.music text, .music tspan {fill:currentColor}",font_style="",posx=cfmt.leftmargin/cfmt.scale,posy=0,img={width:cfmt.pagewidth,lm:cfmt.leftmargin,rm:cfmt.rightmargin},defined_glyph={},defs="",fulldefs="",stv_g={scale:1,dy:0,st:-1,v:0,g:0},block={};var tgls={sgno:{x:-6,y:4,c:""},coda:{x:-12,y:6,c:""},tclef:{x:-8,y:0,c:""},cclef:{x:-8,y:0,c:""},bclef:{x:-8,y:0,c:""},pclef:{x:-6,y:0,c:""},stclef:{x:-8,y:0,c:""},scclef:{x:-8,y:0,c:""},sbclef:{x:-7,y:0,c:""},csig:{x:0,y:0,c:""},ctsig:{x:0,y:0,c:""},HDD:{x:-7,y:0,c:""},breve:{x:-6,y:0,c:""},HD:{x:-5.2,y:0,c:""},Hd:{x:-3.8,y:0,c:""},hd:{x:-3.7,y:0,c:""},srep:{x:-5,y:0,c:""},dot:{x:-2,y:0,c:""},"acc-1":{x:-3,y:0,c:""},acc3:{x:-2,y:0,c:""},acc1:{x:-3,y:0,c:""},acc2:{x:-3,y:0,c:""},pshhd:{x:-3,y:0,c:""},"acc-2":{x:-3,y:0,c:""},accent:{x:-3,y:0,c:""},marcato:{x:-3,y:0,c:""},hld:{x:-7,y:0,c:""},r00:{x:-1.5,y:0,c:""},r0:{x:-1.5,y:0,c:""},r1:{x:-3.5,y:6,c:""},r2:{x:-3.2,y:0,c:""},r4:{x:-3,y:0,c:""},r8:{x:-3,y:0,c:""},r16:{x:-4,y:0,c:""},r32:{x:-4,y:0,c:""},r64:{x:-4,y:0,c:""},r128:{x:-4,y:0,c:""},mrest:{x:-10,y:0,c:""},mrep:{x:-6,y:0,c:""},mrep2:{x:-9,y:0,c:""},turn:{x:-5,y:4,c:""},umrd:{x:-7,y:2,c:""},lmrd:{x:-7,y:2,c:""},ped:{x:-10,y:0,c:""},pedoff:{x:-5,y:0,c:""},longa:{x:-6,y:0,c:""}};var glyphs={brace:'<text id="brace"></text>',ghd:'<g id="ghd" transform="translate(4.5,0) scale(0.66)">\n\t<text x="-3.7"></text>\n</g>',acc1_1_4:'<g id="acc1_1_4">\n\t<path d="m0 7.8v-15.4" class="stroke"/>\n\t<path class="fill" d="M-1.8 2.7l3.6 -1.1v2.2l-3.6 1.1v-2.2z\n\t\tM-1.8 -3.7l3.6 -1.1v2.2l-3.6 1.1v-2.2"/>\n</g>',acc1_3_4:'<g id="acc1_3_4">\n\t<path d="m-2.5 8.7v-15.4M0 7.8v-15.4M2.5 6.9v-15.4" class="stroke"/>\n\t<path class="fill" d="m-3.7 3.1l7.4 -2.2v2.2l-7.4 2.2v-2.2z\n\t\tM-3.7 -3.2l7.4 -2.2v2.2l-7.4 2.2v-2.2"/>\n</g>',"acc-1_1_4":'<g id="acc-1_1_4" transform="scale(-1,1)">\n\t<text x="-3"></text>\n</g>',"acc-1_3_4":'<g id="acc-1_3_4">\n    <path class="fill" d="m0.6 -2.7\n\tc-5.7 -3.1 -5.7 3.6 0 6.7c-3.9 -4 -4 -7.6 0 -5.8\n\tM1 -2.7c5.7 -3.1 5.7 3.6 0 6.7c3.9 -4 4 -7.6 0 -5.8"/>\n    <path d="m1.6 3.5v-13M0 3.5v-13" class="stroke" stroke-width=".6"/>\n</g>',turnx:'<g id="turnx">\n\t<text x="-5" y="-4"></text>\n\t<path class="stroke" d="m0 -1.5v-9"/>\n</g>',pfthd:'<g id="pfthd">\n\t<text x="-3"></text>\n\t<circle r="4" class="stroke"/>\n</g>',pmsig:'<path id="pmsig" class="stroke" stroke-width="0.8"\n\td="m0 -7a5 5 0 0 1 0 -10a5 5 0 0 1 0 10"/>',pMsig:'<g id="pMsig">\n\t<use xlink:href="#pmsig"/>\n\t<path class="fill" d="m0 -10a2 2 0 0 1 0 -4a2 2 0 0 1 0 4"/>\n</g>',imsig:'<path id="imsig" class="stroke" stroke-width="0.8"\n\td="m3 -8a5 5 0 1 1 0 -8"/>',iMsig:'<g id="iMsig">\n\t<use xlink:href="#imsig"/>\n\t<path class="fill" d="m0 -10a2 2 0 0 1 0 -4a2 2 0 0 1 0 4"/>\n</g>',hl:'<path id="hl" class="stroke" stroke-width="1" d="m-6 0h12"/>',hl1:'<path id="hl1" class="stroke" stroke-width="1" d="m-7 0h14"/>',hl2:'<path id="hl2" class="stroke" stroke-width="1" d="m-9 0h18"/>',ghl:'<path id="ghl" class="stroke" d="m-3.5 0h7"/>',rdots:'<g id="rdots" class="fill">\n\t<circle cx="0" cy="-9" r="1.2"/>\n\t<circle cx="0" cy="-15" r="1.2"/>\n</g>',grm:'<path id="grm" class="fill" d="m-5 -2.5\n\tc5 -8.5 5.5 4.5 10 -2\n\t-5 8.5 -5.5 -4.5 -10 2"/>',stc:'<circle id="stc" class="fill" cx="0" cy="-3" r="1.2"/>',sld:'<path id="sld" class="fill" d="m-7.2 4.8\n\tc1.8 .7 4.5 -.2 7.2 -4.8\n\t-2.1 5 -5.4 6.8 -7.6 6"/>',emb:'<path id="emb" class="stroke" stroke-width="1.2" stroke-linecap="round"\n\td="m-2.5 -3h5"/>',brth:'<text id="brth" y="-6" style="font-family:serif; font-weight:bold; font-style:italic; font-size:30px">,</text>',roll:'<path id="roll" class="fill" d="m-6 0\n\tc0.4 -7.3 11.3 -7.3 11.7 0\n\t-1.3 -6 -10.4 -6 -11.7 0"/>',upb:'<path id="upb" class="stroke" d="m-2.6 -9.4\n\tl2.6 8.8\n\tl2.6 -8.8"/>',dnb:'<g id="dnb">\n\t<path d="M-3.2 -2v-7.2m6.4 0v7.2" class="stroke"/>\n\t<path d="M-3.2 -6.8v-2.4l6.4 0v2.4" class="fill"/>\n</g>',dplus:'<path id="dplus" class="stroke" stroke-width="1.7"\n\td="m0 -.5v-6m-3 3h6"/>',lphr:'<path id="lphr" class="stroke" stroke-width="1.2"\n\td="m0 0v18"/>',mphr:'<path id="mphr" class="stroke" stroke-width="1.2"\n\td="m0 0v12"/>',sphr:'<path id="sphr" class="stroke" stroke-width="1.2"\n\td="m0 0v6"/>',sfz:'<text id="sfz" x="-5" y="-7" style="font-family:serif; font-style:italic; font-size:14px">\n\ts<tspan font-size="16" font-weight="bold">f</tspan>z</text>',trl:'<text id="trl" x="-2" y="-4"\n\tstyle="font-family:serif; font-weight:bold; font-style:italic; font-size:16px">tr</text>',opend:'<circle id="opend" class="stroke"\n\tcx="0" cy="-3" r="2.5"/>',snap:'<path id="snap" class="stroke" d="m-3 -6\n\tc0 -5 6 -5 6 0\n\t0 5 -6 5 -6 0\n\tM0 -5v6"/>',thumb:'<path id="thumb" class="stroke" d="m-2.5 -7\n\tc0 -6 5 -6 5 0\n\t0 6 -5 6 -5 0\n\tM-2.5 -9v4"/>',wedge:'<path id="wedge" class="fill" d="m0 -1l-1.5 -5h3l-1.5 5"/>',ltr:'<path id="ltr" class="fill"\n\td="m0 -.4c2 -1.5 3.4 -1.9 3.9 .4\n\t0.2 .8 .7 .7 2.1 -.4\n\tv0.8c-2 1.5 -3.4 1.9 -3.9 -.4\n\t-.2 -.8 -.7 -.7 -2.1 .4z"/>',custos:'<g id="custos">\n\t<path class="fill" d="m-4 0l2 2.5 2 -2.5 2 2.5 2 -2.5\n\t\t-2 -2.5 -2 2.5 -2 -2.5 -2 2.5"/>\n\t<path class="stroke" d="m3.5 0l5 -7"/>\n</g>',oct:'<text id="oct" style="font-family:serif; font-size:12px">8</text>'};function def_use(gl){var i,j,g;if(defined_glyph[gl])return;defined_glyph[gl]=true;g=glyphs[gl];if(!g){error(1,null,"Unknown glyph: '$1'",gl);return}j=0;while(1){i=g.indexOf('xlink:href="#',j);if(i<0)break;i+=13;j=g.indexOf('"',i);def_use(g.slice(i,j))}defs+="\n"+g}function defs_add(text){var i,j,gl,tag,is,ie=0;text=text.replace(/<!--.*?-->/g,"");while(1){is=text.indexOf("<",ie);if(is<0)break;i=text.indexOf('id="',is);if(i<0)break;i+=4;j=text.indexOf('"',i);if(j<0)break;gl=text.slice(i,j);ie=text.indexOf(">",j);if(ie<0)break;if(text[ie-1]=="/"){ie++}else{i=text.indexOf(" ",is);if(i<0)break;tag=text.slice(is+1,i);ie=text.indexOf("</"+tag+">",ie);if(ie<0)break;ie+=3+tag.length}if(text.substr(is,7)=="<filter")fulldefs+="\n"+text.slice(is,ie);else glyphs[gl]=text.slice(is,ie)}}function set_g(){if(stv_g.started){stv_g.started=false;output.push("</g>\n")}if(stv_g.scale==1&&!stv_g.color)return;output.push("<g ");if(stv_g.scale!=1){if(stv_g.st>=0)output.push(staff_tb[stv_g.st].scale_str);else output.push(voice_tb[stv_g.v].scale_str)}if(stv_g.color){if(stv_g.scale!=1)output.push(" ");output.push('style="color:'+stv_g.color+'"')}output.push(">\n");stv_g.started=true}function set_color(color){if(color==stv_g.color)return null;var old_color=stv_g.color;stv_g.color=color;set_g();return old_color}function set_sscale(st){var new_scale,dy;if(st!=stv_g.st&&stv_g.scale!=1)stv_g.scale=0;new_scale=st>=0?staff_tb[st].staffscale:1;if(st>=0&&new_scale!=1)dy=staff_tb[st].y;else dy=posy;if(new_scale==stv_g.scale&&dy==stv_g.dy)return;stv_g.scale=new_scale;stv_g.dy=dy;stv_g.st=st;set_g()}function set_scale(s){var new_scale=s.p_v.scale;if(new_scale==1){set_sscale(s.st);return}if(new_scale==stv_g.scale&&stv_g.dy==posy)return;stv_g.scale=new_scale;stv_g.dy=posy;stv_g.st=-1;stv_g.v=s.v;set_g()}function set_dscale(st,no_scale){if(st<0){stv_g.scale=1;output=staff_tb[0].output}else{stv_g.scale=no_scale?1:staff_tb[st].staffscale;output=stv_g.scale==1?staff_tb[st].output:staff_tb[st].sc_out}stv_g.st=st;stv_g.dy=0}function delayed_update(){var st,new_out,text;for(st=0;st<=nstaff;st++){if(staff_tb[st].sc_out.length!=0){output.push('<g transform="translate(0,'+(posy-staff_tb[st].y).toFixed(2)+") scale("+staff_tb[st].staffscale.toFixed(2)+')">\n');output.push(staff_tb[st].sc_out.join(""));output.push("</g>\n");staff_tb[st].sc_out=[]}if(staff_tb[st].output.length==0)continue;output.push('<g transform="translate(0,'+(-staff_tb[st].y).toFixed(2)+')">\n');output.push(staff_tb[st].output.join(""));output.push("</g>\n");staff_tb[st].output=[]}}var anno_type=["bar","clef","custos","","grace","key","meter","Zrest","note","part","rest","yspace","staves","Break","tempo","","block","remark"];function anno_out(s,t,f){if(s.istart==undefined)return;var type=s.type,h=s.ymx-s.ymn+4,wl=s.wl||2,wr=s.wr||2;if(s.grace)type=GRACE;f(t||anno_type[type],s.istart,s.iend,s.x-wl-2,staff_tb[s.st].y+s.ymn+h-2,wl+wr+4,h,s)}function a_start(s,t){anno_out(s,t,user.anno_start)}function a_stop(s,t){anno_out(s,t,user.anno_stop)}function empty_function(){}var anno_start=user.anno_start?a_start:empty_function,anno_stop=user.anno_stop?a_stop:empty_function;function out_XYAB(str,x,y,a,b){x=sx(x);y=sy(y);output.push(str.replace(/X|Y|A|B|F|G/g,function(c){switch(c){case"X":return x.toFixed(2);case"Y":return y.toFixed(2);case"A":return a;case"B":return b;case"F":return a.toFixed(2);default:return b.toFixed(2)}}))}function g_open(x,y,rot,sx,sy){out_XYAB('<g transform="translate(X,Y',x,y);if(rot)output.push(") rotate("+rot.toFixed(2));if(sx){if(sy)output.push(") scale("+sx.toFixed(2)+", "+sy.toFixed(2));else output.push(") scale("+sx.toFixed(2))}output.push(')">\n');stv_g.g++}function g_close(){stv_g.g--;output.push("</g>\n")}function out_svg(str){output.push(str)}Abc.prototype.out_svg=out_svg;function sx(x){if(stv_g.g)return x;return(x+posx)/stv_g.scale}Abc.prototype.sx=sx;function sy(y){if(stv_g.g)return y;if(stv_g.scale==1)return posy-y;if(stv_g.st<0)return(posy-y)/stv_g.scale;return stv_g.dy-y}Abc.prototype.sy=sy;Abc.prototype.sh=function(h){if(stv_g.st<0)return h/stv_g.scale;return h};Abc.prototype.ax=function(x){return x+posx};Abc.prototype.ay=function(y){if(stv_g.st<0)return posy-y;return posy+(stv_g.dy-y)*stv_g.scale-stv_g.dy};Abc.prototype.ah=function(h){if(stv_g.st<0)return h;return h*stv_g.scale};function out_sxsy(x,sep,y){x=sx(x);y=sy(y);output.push(x.toFixed(2)+sep+y.toFixed(2))}Abc.prototype.out_sxsy=out_sxsy;function xypath(x,y,fill){out_XYAB('<path class="A" d="mX Y\n',x,y,fill?"fill":"stroke")}Abc.prototype.xypath=xypath;function xygl(x,y,gl){var tgl=tgls[gl];if(tgl&&!glyphs[gl]){out_XYAB('<text x="X" y="Y">A</text>\n',x+tgl.x*stv_g.scale,y+tgl.y,tgl.c);return}if(!glyphs[gl]){error(1,null,"no definition of $1",gl);return}def_use(gl);out_XYAB('<use x="X" y="Y" xlink:href="#A"/>\n',x,y,gl)}function out_acciac(x,y,dx,dy,up){if(up){x-=1;y+=4}else{x-=5;y-=4}out_XYAB('<path class="stroke" d="mX YlF G"/>\n',x,y,dx,-dy)}function out_bar(x,y,h,dotted){output.push('<path class="stroke" stroke-width="1" '+(dotted?'stroke-dasharray="5,5" ':"")+'d="m'+(x+posx).toFixed(2)+" "+(posy-y).toFixed(2)+"v"+(-h).toFixed(2)+'"/>\n')}function out_bnum(x,y,str){out_XYAB('<text style="font-family:serif; font-style:italic; font-size:12px"\n\tx="X" y="Y" text-anchor="middle">A</text>\n',x,y,str.toString())}function out_brace(x,y,h){def_use("brace");x+=posx-6;y=posy-y;h/=24;output.push('<use transform="translate('+x.toFixed(2)+","+y.toFixed(2)+") scale(2.5,"+h.toFixed(2)+')" xlink:href="#brace"/>\n')}function out_bracket(x,y,h){x+=posx-5;y=posy-y-3;h+=2;output.push('<path class="fill"\n\td="m'+x.toFixed(2)+" "+y.toFixed(2)+"\n\tc10.5 1 12 -4.5 12 -3.5c0 1 -3.5 5.5 -8.5 5.5\n\tv"+h.toFixed(2)+'\n\tc5 0 8.5 4.5 8.5 5.5c0 1 -1.5 -4.5 -12 -3.5"/>\n')}function out_hyph(x,y,w){var n,a_y,d=25+(w/20|0)*3;if(w>15)n=(w-15)/d|0;else n=0;x+=(w-d*n-5)/2;out_XYAB('<path class="stroke" stroke-width="1.2"\n\tstroke-dasharray="5,F"\n\td="mX YhG"/>\n',x,y+3,Math.round((d-5)/stv_g.scale),d*n+5)}function out_stem(x,y,h,grace,nflags,straight){var dx=grace?GSTEM_XOFF:3.5,slen=-h;if(h<0)dx=-dx;x+=dx*stv_g.scale;if(stv_g.st<0)slen/=stv_g.scale;out_XYAB('<path class="stroke" d="mX YvF"/>\n',x,y,slen);if(!nflags)return;output.push('<path class="fill"\n\td="');y+=h;if(h>0){if(!straight){if(!grace){if(nflags==1){out_XYAB("MX Yc0.6 5.6 9.6 9 5.6 18.4\n\t1.6 -6 -1.3 -11.6 -5.6 -12.8\n",x,y)}else{while(--nflags>=0){out_XYAB("MX Yc0.9 3.7 9.1 6.4 6 12.4\n\t1 -5.4 -4.2 -8.4 -6 -8.4\n",x,y);y-=5.4}}}else{if(nflags==1){out_XYAB("MX Yc0.6 3.4 5.6 3.8 3 10\n\t1.2 -4.4 -1.4 -7 -3 -7\n",x,y)}else{while(--nflags>=0){out_XYAB("MX Yc1 3.2 5.6 2.8 3.2 8\n\t1.4 -4.8 -2.4 -5.4 -3.2 -5.2\n",x,y);y-=3.5}}}}else{if(!grace){y+=1;while(--nflags>=0){out_XYAB("MX Yl7 3.2 0 3.2 -7 -3.2z\n",x,y);y-=5.4}}else{while(--nflags>=0){out_XYAB("MX Yl3 1.5 0 2 -3 -1.5z\n",x,y);y-=3}}}}else{if(!straight){if(!grace){if(nflags==1){out_XYAB("MX Yc0.6 -5.6 9.6 -9 5.6 -18.4\n\t1.6 6 -1.3 11.6 -5.6 12.8\n",x,y)}else{while(--nflags>=0){out_XYAB("MX Yc0.9 -3.7 9.1 -6.4 6 -12.4\n\t1 5.4 -4.2 8.4 -6 8.4\n",x,y);y+=5.4}}}else{if(nflags==1){out_XYAB("MX Yc0.6 -3.4 5.6 -3.8 3 -10\n\t1.2 4.4 -1.4 7 -3 7\n",x,y)}else{while(--nflags>=0){out_XYAB("MX Yc1 -3.2 5.6 -2.8 3.2 -8\n\t1.4 4.8 -2.4 5.4 -3.2 5.2\n",x,y);y+=3.5}}}}else{if(!grace){y+=1;while(--nflags>=0){out_XYAB("MX Yl7 -3.2 0 -3.2 -7 3.2z\n",x,y);y+=5.4}}}}output.push('"/>\n')}function out_thbar(x,y,h){x+=posx+1.5;y=posy-y;output.push('<path class="stroke" stroke-width="3" d="m'+x.toFixed(2)+" "+y.toFixed(2)+"v"+(-h).toFixed(2)+'"/>\n')}function out_trem(x,y,ntrem){out_XYAB('<path class="fill" d="mX Y\n\t',x-4.5,y);while(1){output.push("l9 -3v3l-9 3z");if(--ntrem<=0)break;output.push("m0 5.4")}output.push('"/>\n')}function out_tubr(x,y,dx,dy,up){var h=up?-3:3;y+=h;dx/=stv_g.scale;output.push('<path class="stroke" d="m');out_sxsy(x," ",y);output.push("v"+h.toFixed(2)+"l"+dx.toFixed(2)+" "+(-dy).toFixed(2)+"v"+(-h).toFixed(2)+'"/>\n')}function out_tubrn(x,y,dx,dy,up,str){var sw=str.length*10,h=up?-3:3;dx/=stv_g.scale;out_XYAB('<text style="font-family:serif; font-style:italic; font-size:12px"\n\tx="X" y="Y" text-anchor="middle">A</text>\n',x+dx/2,y+dy/2,str);if(!up)y+=6;output.push('<path class="stroke" d="m');out_sxsy(x," ",y);output.push("v"+h.toFixed(2)+"m"+dx.toFixed(2)+" "+(-dy).toFixed(2)+"v"+(-h).toFixed(2)+'"/>\n');output.push('<path class="stroke" stroke-dasharray="'+((dx-sw)/2).toFixed(2)+" "+sw.toFixed(2)+'" d="m');out_sxsy(x," ",y-h);output.push("l"+dx.toFixed(2)+" "+(-dy).toFixed(2)+'"/>\n')}function out_wln(x,y,w){out_XYAB('<path class="stroke" stroke-width="0.8" d="mX YhF"/>\n',x,y,w)}var deco_str_style={crdc:{dx:0,dy:5,style:"font-family:serif; font-style:italic; font-size:14px"},dacs:{dx:0,dy:3,style:"font-family:serif; font-size:16px",anchor:' text-anchor="middle"'},fng:{dx:0,dy:1,style:"font-family:Bookman; font-size:8px",anchor:' text-anchor="middle"'},pf:{dx:0,dy:5,style:"font-family:serif; font-weight:bold; font-style:italic; font-size:16px"},"@":{dx:0,dy:5,style:"font-family:sans-serif; font-size:12px"}};function out_deco_str(x,y,name,str){var a,f,a_deco=deco_str_style[name];if(!a_deco){xygl(x,y,name);return}x+=a_deco.dx;y+=a_deco.dy;if(!a_deco.def){style+="\n."+name+" {"+a_deco.style+"}";a_deco.def=true}out_XYAB('<text x="X" y="Y" class="A"B>',x,y,name,a_deco.anchor||"");set_font("annotation");out_str(str);output.push("</text>\n")}function out_arp(x,y,val){g_open(x,y,270);x=0;y=-4;val=Math.ceil(val/6);while(--val>=0){xygl(x,y,"ltr");x+=6}g_close()}function out_cresc(x,y,val,defl){x+=val;val=-val;out_XYAB('<path class="stroke"\n\td="mX YlA ',x,y+5,val);if(defl.nost)output.push("-2.2m0 -3.6l"+(-val).toFixed(2)+' -2.2"/>\n');else output.push("-4l"+(-val).toFixed(2)+' -4"/>\n')}function out_dim(x,y,val,defl){out_XYAB('<path class="stroke"\n\td="mX YlA ',x,y+5,val);if(defl.noen)output.push("-2.2m0 -3.6l"+(-val).toFixed(2)+' -2.2"/>\n');else output.push("-4l"+(-val).toFixed(2)+' -4"/>\n')}function out_ltr(x,y,val){y+=4;val=Math.ceil(val/6);while(--val>=0){xygl(x,y,"ltr");x+=6}}function out_8va(x,y,val,defl){if(!defl.nost){out_XYAB('<text x="X" y="Y" style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">8<tspan dy="-4" style="font-size:10px">va</tspan></text>\n',x-8,y);x+=12;val-=12}else{val-=5}y+=6;out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',x,y,val);if(!defl.noen)out_XYAB('<path class="stroke" d="mX Yv6"/>\n',x+val,y)}function out_8vb(x,y,val,defl){if(!defl.nost){out_XYAB('<text x="X" y="Y" style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">8<tspan dy="-4" style="font-size:10px">vb</tspan></text>\n',x-8,y);x+=4;val-=4}else{val-=5}out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',x,y,val);if(!defl.noen)out_XYAB('<path class="stroke" d="mX Yv-6"/>\n',x+val,y)}function out_15ma(x,y,val,defl){if(!defl.nost){out_XYAB('<text x="X" y="Y" style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">15<tspan dy="-4" style="font-size:10px">ma</tspan></text>\n',x-10,y);x+=20;val-=20}else{val-=5}y+=6;out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',x,y,val);if(!defl.noen)out_XYAB('<path class="stroke" d="mX Yv6"/>\n',x+val,y)}function out_15mb(x,y,val,defl){if(!defl.nost){out_XYAB('<text x="X" y="Y" style="font-family:serif; font-weight:bold; font-style:italic; font-size:12px">15<tspan dy="-4" style="font-size:10px">mb</tspan></text>\n',x-10,y);x+=7;val-=7}else{val-=5}out_XYAB('<path class="stroke" stroke-dasharray="6,6" d="mX YhA"/>\n',x,y,val);if(!defl.noen)out_XYAB('<path class="stroke" d="mX Yv-6"/>\n',x+val,y)}var deco_val_tb={arp:out_arp,cresc:out_cresc,dim:out_dim,ltr:out_ltr,"8va":out_8va,"8vb":out_8vb,"15ma":out_15ma,"15mb":out_15mb};function out_deco_val(x,y,name,val,defl){if(deco_val_tb[name])deco_val_tb[name](x,y,val,defl);else error(1,null,"No function for decoration '$1'",name)}function out_glisq(x2,y2,de){var de1=de.start,x1=de1.x,y1=de1.y+staff_tb[de1.st].y,ar=-Math.atan2(y2-y1,x2-x1),a=ar/Math.PI*180,len=(x2-x1)/Math.cos(ar);g_open(x1,y1,a);x1=de1.s.dots?13+de1.s.xmx:8;len=(len-x1-6)/6|0;if(len<1)len=1;while(--len>=0){xygl(x1,0,"ltr");x1+=6}g_close()}function out_gliss(x2,y2,de){var de1=de.start,x1=de1.x,y1=de1.y+staff_tb[de1.st].y,ar=-Math.atan2(y2-y1,x2-x1),a=ar/Math.PI*180,len=(x2-x1)/Math.cos(ar);g_open(x1,y1,a);x1=de1.s.dots?13+de1.s.xmx:8;len-=x1+8;xypath(x1,0);output.push("l"+len.toFixed(2)+' 0" stroke-width="1"/>\n');g_close()}var deco_l_tb={glisq:out_glisq,gliss:out_gliss};function out_deco_long(x,y,de){var name=de.dd.glyph;if(deco_l_tb[name])deco_l_tb[name](x,y,de);else error(1,null,"No function for decoration '$1'",name)}function vskip(h){posy+=h}function svg_flush(){if(multicol||output.length==0||!user.img_out||posy==0)return;var head='<svg xmlns="http://www.w3.org/2000/svg" version="1.1"\n\txmlns:xlink="http://www.w3.org/1999/xlink"\n\tcolor="black" class="music" stroke-width=".7"',g="";if(cfmt.bgcolor)head+=' style="background-color: '+cfmt.bgcolor+'"';posy*=cfmt.scale;if(user.imagesize){head+="\n"+user.imagesize+' viewBox="0 0 '+img.width.toFixed(0)+" "+posy.toFixed(0)+'">\n'}else{head+='\n\twidth="'+img.width.toFixed(0)+'px" height="'+posy.toFixed(0)+'px">\n'}if(style||font_style||musicfont){head+='<style type="text/css">'+style+font_style;if(musicfont){if(musicfont.indexOf("(")>0){head+='\n.music {font-family: music; font-size: 24px; fill: currentColor}\n@font-face {\n  font-family: "music";\n  src: '+musicfont+"}"}else{head+="\n.music {font-family: "+musicfont+"; font-size: 24px; fill: currentColor}"}}head+="\n</style>\n"}defs+=fulldefs;if(defs)head+="<defs>"+defs+"\n</defs>\n";if(cfmt.scale!=1){head+='<g class="g" transform="scale('+cfmt.scale.toFixed(2)+')">\n';g="</g>\n"}if(psvg)psvg.ps_flush(true);user.img_out(head+output.join("")+g+"</svg>");output=[];font_style="";if(cfmt.fullsvg){defined_glyph={};defined_font={}}else{musicfont="";style="";fulldefs=""}defs="";posy=0}function blk_out(){if(multicol||!user.img_out)return;blk_flush();if(user.page_format&&!block.started){block.started=true;if(block.newpage){block.newpage=false;user.img_out('<div class="nobrk newpage">')}else{user.img_out('<div class="nobrk">')}}}Abc.prototype.blk_out=blk_out;function blk_flush(){svg_flush();if(block.started){block.started=false;user.img_out("</div>")}}Abc.prototype.blk_flush=blk_flush;var par_sy,cur_sy,voice_tb,curvoice,staves_found,vover,tsfirst;function voice_filter(){var opt,sel,i;for(opt in parse.voice_opts){if(!parse.voice_opts.hasOwnProperty(opt))continue;sel=new RegExp(opt);if(sel.test(curvoice.id)||sel.test(curvoice.nm)){for(i in parse.voice_opts[opt])if(parse.voice_opts[opt].hasOwnProperty(i))do_pscom(parse.voice_opts[opt][i])}}}function sym_link(s){if(!s.ctx)set_ref(s);if(!curvoice.ignore){parse.last_sym=s;s.prev=curvoice.last_sym;if(curvoice.last_sym)curvoice.last_sym.next=s;else curvoice.sym=s;curvoice.last_sym=s}s.v=curvoice.v;s.p_v=curvoice;s.st=curvoice.cst;s.time=curvoice.time;if(s.dur&&!s.grace)curvoice.time+=s.dur;s.pos=curvoice.pos;if(curvoice.second)s.second=true;if(curvoice.floating)s.floating=true}function sym_add(p_voice,type){var s={type:type,dur:0},s2,p_voice2=curvoice;curvoice=p_voice;sym_link(s);curvoice=p_voice2;s2=s.prev;if(!s2)s2=s.next;if(s2){s.ctx=s2.ctx;s.istart=s2.istart;s.iend=s2.iend}return s}function mrest_expand(s){var p_voice,s2,next,nb=s.nmes,dur=s.dur/nb;var a_dd=s.a_dd;s.type=REST;s.dur=dur;s.head=FULL;s.nflags=-2;next=s.next;p_voice=s.p_v;p_voice.last_sym=s;p_voice.time=s.time+dur;p_voice.cst=s.st;s2=s;while(--nb>0){s2=sym_add(p_voice,BAR);s2.bar_type="|";s2=sym_add(p_voice,REST);if(s.invis)s2.invis=true;s2.dur=dur;s2.head=FULL;s2.nflags=-2;p_voice.time+=dur}s2.next=next;if(next)next.prev=s2;s2.a_dd=a_dd}var w_tb=new Uint8Array([2,1,8,0,3,5,6,9,9,0,9,3,0,7,0,0,0,0]);function sort_all(){var s,s2,p_voice,v,time,w,wmin,ir,multi,prev,nb,ir2,v2,sy,nv=voice_tb.length,vtb=[],vn=[],mrest_time=-1;for(v=0;v<nv;v++)vtb.push(voice_tb[v].sym);var fl=1,new_sy=cur_sy;while(1){if(new_sy&&fl){sy=new_sy;new_sy=null;multi=-1;vn=[];for(v=0;v<nv;v++){if(!sy.voices[v]){sy.voices[v]={range:-1};continue}ir=sy.voices[v].range;if(ir<0)continue;vn[ir]=v;multi++}}wmin=time=1e6;for(ir=0;ir<nv;ir++){v=vn[ir];if(v==undefined)break;s=vtb[v];if(!s||s.time>time)continue;w=w_tb[s.type];if(s.time<time){time=s.time;wmin=w}else if(w<wmin){wmin=w}if(s.type==MREST){if(s.nmes==1)mrest_expand(s);else if(multi>0)mrest_time=time}}if(wmin>127)break;if(time==mrest_time){nb=0;for(ir=0;ir<nv;ir++){v=vn[ir];if(v==undefined)break;s=vtb[v];if(!s||s.time!=time||w_tb[s.type]!=wmin)continue;if(s.type!=MREST){mrest_time=-1;break}if(nb==0){nb=s.nmes}else if(nb!=s.nmes){mrest_time=-1;break}}if(mrest_time<0){for(ir=0;ir<nv;ir++){v=vn[ir];if(v==undefined)break;s=vtb[v];if(s&&s.type==MREST)mrest_expand(s)}}}for(ir=0;ir<nv;ir++){v=vn[ir];if(v==undefined)break;s=vtb[v];if(!s||s.time!=time||w_tb[s.type]!=wmin)continue;if(s.type==STAVES){new_sy=s.sy;for(ir2=0;ir2<nv;ir2++){if(vn[ir2]==undefined)break}for(v2=0;v2<nv;v2++){if(!new_sy.voices[v2])continue;ir=new_sy.voices[v2].range;if(ir<0||sy.voices[v2].range>=0)continue;vn[ir2++]=v2}}if(fl){fl=0;s.seqst=true}s.ts_prev=prev;if(prev)prev.ts_next=s;else tsfirst=s;prev=s;vtb[v]=s.next}fl=wmin}}function voice_adj(){var p_voice,s,s2,v;function set_feathered_beam(s1){var s,s2,t,d,b,i,a,d=s1.dur,n=1;for(s=s1;s;s=s.next){if(s.beam_end||!s.next)break;n++}if(n<=1){delete s1.feathered_beam;return}s2=s;b=d/2;a=d/(n-1);t=s1.time;if(s1.feathered_beam>0){for(s=s1,i=n-1;s!=s2;s=s.next,i--){d=(a*i|0)+b;s.dur=d;s.time=t;t+=d}}else{for(s=s1,i=0;s!=s2;s=s.next,i++){d=(a*i|0)+b;s.dur=d;s.time=t;t+=d}}s.dur=s.time+s.dur-t;s.time=t}s=glovar.tempo;if(s&&staves_found<=0){v=par_sy.top_voice;p_voice=voice_tb[v];if(p_voice.sym&&p_voice.sym.type!=TEMPO){s=clone(s);s.v=v;s.p_v=p_voice;s.st=p_voice.st;s.time=0;s.next=p_voice.sym;if(s.next)s.next.prev=s;p_voice.sym=s}}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.ignore)p_voice.ignore=false;for(s=p_voice.sym;s;s=s.next){if(s.time>=staves_found)break}for(;s;s=s.next){switch(s.type){case GRACE:if(s.next&&s.next.type==BAR)s.time--;if(!cfmt.graceword)continue;for(s2=s.next;s2;s2=s2.next){switch(s2.type){case SPACE:continue;case NOTE:if(!s2.a_ly)break;s.a_ly=s2.a_ly;s2.a_ly=null;break}break}continue}if(s.feathered_beam)set_feathered_beam(s)}}}function dupl_voice(){var p_voice,p_voice2,s,s2,g,g2,v,i,nv=voice_tb.length;for(v=0;v<nv;v++){p_voice=voice_tb[v];p_voice2=p_voice.clone;if(!p_voice2)continue;p_voice.clone=null;for(s=p_voice.sym;s;s=s.next){if(s.time>=staves_found)break}p_voice2.clef=clone(p_voice.clef);curvoice=p_voice2;for(;s;s=s.next){if(s.type==STAVES)continue;s2=clone(s);if(s.notes){s2.notes=[];for(i=0;i<=s.nhd;i++)s2.notes.push(clone(s.notes[i]))}sym_link(s2);if(p_voice2.second)s2.second=true;else delete s2.second;if(p_voice2.floating)s2.floating=true;else delete s2.floating;delete s2.a_ly;g=s2.extra;if(!g)continue;g2=clone(g);s2.extra=g2;s2=g2;s2.v=p_voice2.v;s2.p_v=p_voice2;s2.st=p_voice2.st;for(g=g.next;g;g=g.next){g2=clone(g);if(g.notes){g2.notes=[];for(i=0;i<=g.nhd;i++)g2.notes.push(clone(g.notes[i]))}s2.next=g2;g2.prev=s2;s2=g2;s2.v=p_voice2.v;s2.p_v=p_voice2;s2.st=p_voice2.st}}}}function new_syst(init){var st,v,sy_new={voices:[],staves:[],top_voice:0};if(init){cur_sy=par_sy=sy_new;return}for(v=0;v<voice_tb.length;v++){st=par_sy.voices[v].st;var sy_staff=par_sy.staves[st],p_voice=voice_tb[v];if(p_voice.stafflines!=undefined)sy_staff.stafflines=p_voice.stafflines;if(p_voice.staffscale)sy_staff.staffscale=p_voice.staffscale;sy_new.voices[v]=clone(par_sy.voices[v]);sy_new.voices[v].range=-1;delete sy_new.voices[v].second}for(st=0;st<par_sy.staves.length;st++){sy_new.staves[st]=clone(par_sy.staves[st]);sy_new.staves[st].flags=0}par_sy.next=sy_new;par_sy=sy_new}function go_global_time(s,symsel){var s2,bar_time,seq;if(symsel.bar<=1){if(symsel.bar==1){for(s2=s;s2;s2=s2.ts_next){if(s2.type==BAR&&s2.time!=0)break}if(s2.time<voice_tb[cur_sy.top_voice].meter.wmeasure)s=s2}}else{for(;s;s=s.ts_next){if(s.type==BAR&&s.bar_num>=symsel.bar)break}if(!s)return;if(symsel.seq!=0){seq=symsel.seq;for(s=s.ts_next;s;s=s.ts_next){if(s.type==BAR&&s.bar_num==symsel.bar){if(--seq==0)break}}if(!s)return}}if(symsel.time==0)return s;bar_time=s.time+symsel.time;while(s.time<bar_time){s=s.ts_next;if(!s)return s}do{s=s.ts_prev}while(!s.seqst);return s}function do_clip(){var s,s2,sy,p_voice,v;s=tsfirst;if(clip_start.bar>0||clip_start.time>0){s=go_global_time(s,clip_start);if(!s){tsfirst=null;return}sy=cur_sy;for(s2=tsfirst;s2!=s;s2=s2.ts_next){switch(s2.type){case CLEF:s2.p_v.clef=s2;break;case KEY:s2.p_v.key=clone(s2.as.u.key);break;case METER:s2.p_v.meter=clone(s2.as.u.meter);break;case STAVES:sy=s.sy;break}}cur_sy=sy;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];for(s2=s;s2;s2=s2.ts_next){if(s2.v==v){delete s2.prev;break}}p_voice.sym=s2}tsfirst=s;delete s.ts_prev}s=go_global_time(s,clip_end);if(!s)return;do{s=s.ts_next;if(!s)return}while(!s.seqst);for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];for(s2=s.ts_prev;s2;s2=s2.ts_prev){if(s2.v==v){delete s2.next;break}}if(!s2)p_voice.sym=null}delete s.ts_prev.ts_next}function set_bar_num(){var s,s2,tim,v=cur_sy.top_voice,wmeasure=voice_tb[v].meter.wmeasure,bar_rep=gene.nbar;function do_break(){var s,i,m,n,d,t;for(i=0;i<glovar.break.length;i++){m=glovar.break[i].m;n=glovar.break[i].n;d=glovar.break[i].d;for(s=voice_tb[v].sym;s;s=s.next){if(s.type==BAR&&s.bar_num==m)break}if(!s)continue;if(n!=0){t=s.time+n/d;for(;s;s=s.next){if(s.time>t)break}if(!s)continue}s.eoln=true}}for(s=tsfirst;;s=s.ts_next){if(!s)return;switch(s.type){case METER:case CLEF:case KEY:case STBRK:continue;case BAR:if(s.bar_num){gene.nbar=s.bar_num;break}if(s.text&&!cfmt.contbarnb){if(s.text[0]=="1"){bar_rep=gene.nbar}else{gene.nbar=bar_rep;s.bar_num=gene.nbar}}break}break}var bar_time=s.time+wmeasure,bar_num=gene.nbar;for(;s;s=s.ts_next){switch(s.type){case METER:wmeasure=s.wmeasure;if(s.time<bar_time)bar_time=s.time+wmeasure;break;case MREST:bar_num+=s.nmes-1;while(s.ts_next&&s.ts_next.type!=BAR)s=s.ts_next;break;case BAR:if(s.bar_num){bar_num=s.bar_num;if(s.time<bar_time){delete s.bar_num;break}}else{if(s.time<bar_time)break;bar_num++}tim=s.time;s2=s;do{if(s2.type==BAR&&s2.text&&!cfmt.contbarnb){if(s2.text[0]=="1")bar_rep=bar_num;else bar_num=bar_rep;break}s2=s2.next}while(s2&&s2.time==tim);s.bar_num=bar_num;bar_time=s.time+wmeasure;break}}if(glovar.break)do_break();if(cfmt.measurenb<0)gene.nbar=bar_num}function get_break(param){var a=param.split(" "),b,c,d,i,j,k,n;glovar.break=[];for(k in a){if(!a.hasOwnProperty(k))continue;b=a[k];i=b.indexOf(":");if(i<0){glovar.break.push({m:b,n:0,d:1});continue}j=b.indexOf("/");if(j<0){syntax(1,"'/' missing in %%break");break}d=parseInt(b.slice(j+1));if(isNaN(d)||d<=1){syntax(1,"Bad denominator in %%break");break}glovar.break.push({m:b.slice(0,i-1),n:b.slice(i+1,j-1),d:d})}}function get_map(text){if(!text)return;var i,note,notes,map,tmp,ns,a=info_split(text,2);if(a.length<3){syntax(1,"Not enough parameters in %%map");return}ns=a[1];if(ns.indexOf("octave,")==0||ns.indexOf("key,")==0){ns=ns.replace(/[,']+$/m,"").toLowerCase();if(ns[0]=="k")ns=ns.replace(/[_=^]+/,"")}else if(ns[0]=="*"||ns.indexOf("all")==0){ns="all"}else{tmp=new scanBuf;tmp.buffer=a[1];note=parse_acc_pit(tmp);if(!note){syntax(1,"Bad note in %%map");return}ns="abcdefg"[(note.pit+77)%7];if(note.acc)ns=["__","_","","^","^^","="][note.acc+2]+ns;for(i=note.pit;i>=28;i-=7)ns+="'";for(i=note.pit;i<21;i+=7)ns+=","}notes=maps[a[0]];if(!notes)maps[a[0]]=notes={};map=notes[ns];if(!map)notes[ns]=map=[];if(!a[2])return;i=2;if(a[2].indexOf("=")<0){if(a[2][0]!="*"){tmp=new scanBuf;tmp.buffer=a[2];map[1]=parse_acc_pit(tmp)}if(!a[3])return;i++;if(a[3].indexOf("=")<0){map[0]=a[3].split(",");i++}}for(;i<a.length;i++){switch(a[i]){case"heads=":map[0]=a[++i].split(",");break;case"print=":tmp=new scanBuf;tmp.buffer=a[++i];map[1]=parse_acc_pit(tmp);break;case"color=":map[2]=a[++i];break}}}function get_midi(param){var chan,prog,a=param.split(/\s+/);switch(a[0]){case"program":if(a[2]){chan=a[1];prog=a[2]}else{chan=0;prog=a[1]}prog=parseInt(prog);if(isNaN(prog)||prog<0||prog>127){syntax(1,"Bad program in %%MIDI");return}if(curvoice)curvoice.instr=prog;else glovar.instr=prog;break}}function set_transp(){var s,transp,vtransp;if(curvoice.ckey.k_bagpipe||curvoice.ckey.k_drum)return;if(cfmt.transp&&curvoice.transp)syntax(0,"Mix of old and new transposition syntaxes");transp=(cfmt.transp||0)+(curvoice.transp||0)+(curvoice.shift||0);vtransp=curvoice.vtransp||0;if(transp==vtransp)return;curvoice.vtransp=transp;s=curvoice.last_sym;if(!s){curvoice.key=clone(curvoice.okey);key_transp(curvoice.key);curvoice.ckey=clone(curvoice.key);if(curvoice.key.k_none)curvoice.key.k_sf=0;return}while(1){if(s.type==KEY)break;if(!s.prev){s=curvoice.key;break}s=s.prev}key_transp(s);curvoice.ckey=clone(s);if(curvoice.key.k_none)s.k_sf=0}function set_ottava(dcn){if(cfmt.sound)return;switch(dcn){case"15ma(":curvoice.ottava=-14;break;case"8va(":curvoice.ottava=-7;break;case"8vb(":curvoice.ottava=7;break;case"15mb(":curvoice.ottava=14;break;case"15ma)":case"8va)":case"8vb)":case"15mb)":curvoice.ottava=0;break}}function do_pscom(text){var h1,val,s,cmd,param,n,k,b,lock=false;if(text.match(/ lock$/)){lock=true;text=text.slice(0,-5).trim()}cmd=text.match(/(\w|-)+/);if(!cmd)return;cmd=cmd[0];param=text.replace(cmd,"").trim();switch(cmd){case"break":get_break(param);return;case"center":if(parse.state>=2){s=new_block("text");s.text=cnv_escape(param);s.opt="c";return}write_text(cnv_escape(param),"c");return;case"clef":if(parse.state>=2){if(parse.state==2)goto_tune();s=new_clef(param);if(s)get_clef(s)}return;case"clip":return;case"deco":deco_add(param);return;case"linebreak":set_linebreak(param);return;case"MIDI":get_midi(param);return;case"map":get_map(param);return;case"maxsysstaffsep":if(parse.state==3){par_sy.voices[curvoice.v].maxsep=get_unit(param);return}break;case"multicol":generate();switch(param){case"start":blk_out();multicol={posy:posy,maxy:posy,lmarg:cfmt.leftmargin,rmarg:cfmt.rightmargin,state:parse.state};break;case"new":if(!multicol){syntax(1,"%%multicol new without start");break}if(posy>multicol.maxy)multicol.maxy=posy;cfmt.leftmargin=multicol.lmarg;cfmt.rightmargin=multicol.rmarg;img.chg=true;set_page();posy=multicol.posy;break;case"end":if(!multicol){syntax(1,"%%multicol end without start");break}if(posy<multicol.maxy)posy=multicol.maxy;cfmt.leftmargin=multicol.lmarg;cfmt.rightmargin=multicol.rmarg;multicol=undefined;blk_out();img.chg=true;set_page();break;default:syntax(1,"Unknown keyword '$1' in %%multicol",param);break}return;case"musicfont":musicfont=param;return;case"ottava":if(parse.state!=3){if(parse.state!=2)return;goto_tune()}n=parseInt(param);if(isNaN(n)||n<-2||n>2){syntax(1,err_bad_val_s,"%%ottava");return}switch(curvoice.ottava){case 14:b="15mb)";break;case 7:b="8vb)";break;case-7:b="8va)";break;case-14:b="15ma)";break}if(b){if(!a_dcn)a_dcn=[];a_dcn.push(b);set_ottava(b)}switch(n){case-2:b="15mb(";break;case-1:b="8vb(";break;case 0:return;case 1:b="8va(";break;case 2:b="15ma(";break}if(!a_dcn)a_dcn=[];a_dcn.push(b);set_ottava(b);return;case"repbra":if(parse.state>=2){if(parse.state==2)goto_tune();curvoice.norepbra=!get_bool(param)}return;case"repeat":if(parse.state!=3)return;if(!curvoice.last_sym){syntax(1,"%%repeat cannot start a tune");return}if(!param.length){n=1;k=1}else{b=param.split(/\s+/);n=parseInt(b[0]);k=parseInt(b[1]);if(isNaN(n)||n<1||curvoice.last_sym.type==BAR&&n>2){syntax(1,"Incorrect 1st value in %%repeat");return}if(isNaN(k)){k=1}else{if(k<1){syntax(1,"Incorrect 2nd value in %%repeat");return}}}parse.repeat_n=curvoice.last_sym.type==BAR?n:-n;parse.repeat_k=k;return;case"sep":var h2,len,values,lwidth;set_page();lwidth=img.width-img.lm-img.rm;h1=h2=len=0;if(param){values=param.split(/\s+/);h1=get_unit(values[0]);if(values[1]){h2=get_unit(values[1]);if(values[2])len=get_unit(values[2])}}if(h1<1)h1=14;if(h2<1)h2=h1;if(len<1)len=90;if(parse.state>=2){s=new_block(cmd);s.x=(lwidth-len)/2/cfmt.scale;s.l=len/cfmt.scale;s.sk1=h1;s.sk2=h2;return}blk_out();vskip(h1);output.push('<path class="stroke"\n\td="M');out_sxsy((lwidth-len)/2/cfmt.scale," ",0);output.push("h"+(len/cfmt.scale).toFixed(2)+'"/>\n');vskip(h2);blk_flush();return;case"setbarnb":val=parseInt(param);if(isNaN(val))syntax(1,"Bad %%setbarnb value");else if(parse.state>=2)glovar.new_nbar=val;else cfmt.measurefirst=val;return;case"staff":if(parse.state!=3){if(parse.state!=2)return;goto_tune()}val=parseInt(param);if(isNaN(val)){syntax(1,"Bad %%staff value '$1'",param);return}var st;if(param[0]=="+"||param[0]=="-")st=curvoice.cst+val;else st=val-1;if(st<0||st>nstaff){syntax(1,"Bad %%staff number $1 (cur $2, max $3)",st,curvoice.cst,nstaff);return}delete curvoice.floating;curvoice.cst=st;return;case"staffbreak":if(parse.state!=3){if(parse.state!=2)return;goto_tune()}s={type:STBRK,dur:0};if(param[0]>="0"&&param[0]<="9"){s.xmx=get_unit(param);if(param.slice(-1)=="f")s.stbrk_forced=true}else{s.xmx=14;if(param[0]=="f")s.stbrk_forced=true}sym_link(s);return;case"stafflines":val=get_st_lines(param);if(val==undefined)syntax(1,"Bad %%stafflines value");else set_v_param(cmd,val);return;case"staffscale":val=parseFloat(param);if(isNaN(val)||val<.3||val>2)syntax(1,"Bad %%staffscale value");else set_v_param(cmd,val);return;case"staves":case"score":if(parse.state==0)return;get_staves(cmd,param);return;case"sysstaffsep":if(parse.state==3){par_sy.voices[curvoice.v].sep=get_unit(param);return}break;case"text":if(parse.state>=2){s=new_block(cmd);s.text=cnv_escape(param);s.opt=cfmt.textoption;return}write_text(cnv_escape(param),cfmt.textoption);return;case"transpose":if(cfmt.sound)return;switch(parse.state){case 0:cfmt.transp=0;case 1:case 2:cfmt.transp=(cfmt.transp||0)+get_transp(param);return}for(s=curvoice.last_sym;s;s=s.prev){switch(s.type){case NOTE:s=clone(curvoice.okey);s.k_old_sf=curvoice.ckey.k_sf;sym_link(s);break;case KEY:break;default:continue}break}do_info("V",curvoice.id+" shift="+param);return;case"tune":return;case"user":set_user(param);return;case"voicecolor":if(parse.state!=3){if(parse.state!=2)return;goto_tune()}curvoice.color=param;return;case"vskip":val=get_unit(param);if(val<0){syntax(1,"%%vskip cannot be negative");return}if(parse.state>=2){s=new_block(cmd);s.sk=val;return}vskip(val);return;case"newpage":case"leftmargin":case"rightmargin":case"pagescale":case"pagewidth":case"printmargin":case"scale":case"staffwidth":if(parse.state==3){s=new_block(cmd);s.param=param;return}if(cmd=="newpage"){blk_flush();block.newpage=true;return}break}set_format(cmd,param,lock)}function do_begin_end(type,opt,text){var i,j,action,s;switch(type){default:if(opt!="nosvg"&&psvg)psvg.ps_eval(text);break;case"js":if(is_secure(text))eval('"use strict"\n'+text);else syntax(1,"Unsecure code");break;case"ml":if(parse.state>=2){s=new_block(type);s.text=text}else{svg_flush();user.img_out(text)}break;case"svg":j=0;while(1){i=text.indexOf('<style type="text/css">\n',j);if(i<0)break;j=text.indexOf("</style>",i);if(j<0){syntax(1,"No </style> in %%beginsvg sequence");break}style+=text.slice(i+23,j).replace(/\s+$/,"")}j=0;while(1){i=text.indexOf("<defs>\n",j);if(i<0)break;j=text.indexOf("</defs>",i);if(j<0){syntax(1,"No </defs> in %%beginsvg sequence");break}defs_add(text.slice(i+6,j))}break;case"text":action=get_textopt(opt);if(!action)action=cfmt.textoption;if(parse.state>=2){s=new_block(type);s.text=cnv_escape(text);s.opt=action;break}write_text(cnv_escape(text),action);break}}function generate(){var v,p_voice;if(vover){syntax(1,"No end of voice overlay");get_vover(vover.bar?"|":")")}if(voice_tb.length==0)return;voice_adj();dupl_voice();sort_all();if(!tsfirst)return;set_bar_num();if(!tsfirst)return;if(user.get_abcmodel)user.get_abcmodel(tsfirst,voice_tb,anno_type,info);if(user.img_out)output_music();for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];p_voice.time=0;p_voice.sym=p_voice.last_sym=null;p_voice.st=cur_sy.voices[v].st;p_voice.second=cur_sy.voices[v].second;delete p_voice.have_ly;p_voice.hy_st=0;delete p_voice.bar_start;delete p_voice.slur_st;delete p_voice.s_tie;delete p_voice.s_rtie}staves_found=0}function key_transp(s_key){var t=curvoice.vtransp/3|0,sf=(t&~1)+(t&1)*7+s_key.k_sf;switch((curvoice.vtransp+210)%3){case 1:sf=(sf+4+12*4)%12-4;break;case 2:sf=(sf+7+12*4)%12-7;break;default:sf=(sf+5+12*4)%12-5;break}s_key.k_sf=sf;s_key.k_delta=cgd2cde[(sf+7)%7]}function set_k_acc(s){var i,j,n,nacc,p_acc,accs=[],pits=[],m_n=[],m_d=[];if(s.k_sf>0){for(nacc=0;nacc<s.k_sf;nacc++){accs[nacc]=1;pits[nacc]=[26,23,27,24,21,25,22][nacc]}}else{for(nacc=0;nacc<-s.k_sf;nacc++){accs[nacc]=-1;pits[nacc]=[22,25,21,24,20,23,26][nacc]}}n=s.k_a_acc.length;for(i=0;i<n;i++){p_acc=s.k_a_acc[i];for(j=0;j<nacc;j++){if(pits[j]==p_acc.pit){accs[j]=p_acc.acc;if(p_acc.micro_n){m_n[j]=p_acc.micro_n;m_d[j]=p_acc.micro_d}break}}if(j==nacc){accs[j]=p_acc.acc;pits[j]=p_acc.pit;if(p_acc.micro_n){m_n[j]=p_acc.micro_n;m_d[j]=p_acc.micro_d}nacc++}}for(i=0;i<nacc;i++){p_acc=s.k_a_acc[i];if(!p_acc)p_acc=s.k_a_acc[i]={};p_acc.acc=accs[i];p_acc.pit=pits[i];if(m_n[i]){p_acc.micro_n=m_n[i];p_acc.micro_d=m_d[i]}else{delete p_acc.micro_n;delete p_acc.micro_d}}}function acc_same_pitch(pitch){var i,time,s=curvoice.last_sym.prev;if(!s)return;time=s.time;for(;s;s=s.prev){switch(s.type){case BAR:if(s.time<time)return;while(1){s=s.prev;if(!s)return;if(s.type==NOTE){if(s.time+s.dur==time)break;return}if(s.time<time)return}for(i=0;i<=s.nhd;i++){if(s.notes[i].pit==pitch&&s.notes[i].ti1)return s.notes[i].acc}return;case NOTE:for(i=0;i<=s.nhd;i++){if(s.notes[i].pit==pitch)return s.notes[i].acc}break}}return}function get_staves(cmd,parm){var s,p_voice,p_voice2,i,flags,v,vid,st,range,a_vf=parse_staves(parm);if(!a_vf)return;if(voice_tb.length!=0){voice_adj();dupl_voice()}var maxtime=0,no_sym=true;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.time>maxtime)maxtime=p_voice.time;if(p_voice.sym)no_sym=false}if(no_sym||maxtime==0&&staves_found<0){for(v=0;v<par_sy.voices.length;v++)par_sy.voices[v].range=-1}else{for(v=0;v<par_sy.voices.length;v++){if(par_sy.voices[v].range>=0){curvoice=voice_tb[v];break}}curvoice.time=maxtime;s={type:STAVES,dur:0};sym_link(s);par_sy.nstaff=nstaff;new_syst();s.sy=par_sy}staves_found=maxtime;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];delete p_voice.second;delete p_voice.ignore;delete p_voice.floating}range=0;for(i=0;i<a_vf.length;i++){vid=a_vf[i][0];p_voice=new_voice(vid);p_voice.time=maxtime;v=p_voice.v;if(i==0)par_sy.top_voice=p_voice.v;if(par_sy.voices[v].range>=0){p_voice2=clone(p_voice);par_sy.voices[voice_tb.length]=clone(par_sy.voices[v]);v=voice_tb.length;p_voice2.v=v;p_voice2.sym=p_voice2.last_sym=null;p_voice2.time=maxtime;voice_tb.push(p_voice2);delete p_voice2.clone;while(p_voice.clone)p_voice=p_voice.clone;p_voice.clone=p_voice2;p_voice=p_voice2}a_vf[i][0]=p_voice;par_sy.voices[v].range=range++}if(cmd[1]=="t"){for(i=0;i<a_vf.length;i++){flags=a_vf[i][1];if(!(flags&(OPEN_BRACE|OPEN_BRACE2)))continue;if((flags&(OPEN_BRACE|CLOSE_BRACE))==(OPEN_BRACE|CLOSE_BRACE)||(flags&(OPEN_BRACE2|CLOSE_BRACE2))==(OPEN_BRACE2|CLOSE_BRACE2))continue;if(a_vf[i+1][1]!=0)continue;if(flags&OPEN_PARENTH||a_vf[i+2][1]&OPEN_PARENTH)continue;if(a_vf[i+2][1]&(CLOSE_BRACE|CLOSE_BRACE2)){a_vf[i+1][1]|=FL_VOICE}else if(a_vf[i+2][1]==0&&a_vf[i+3][1]&(CLOSE_BRACE|CLOSE_BRACE2)){a_vf[i][1]|=OPEN_PARENTH;a_vf[i+1][1]|=CLOSE_PARENTH;a_vf[i+2][1]|=OPEN_PARENTH;a_vf[i+3][1]|=CLOSE_PARENTH}}}st=-1;for(i=0;i<a_vf.length;i++){flags=a_vf[i][1];if((flags&(OPEN_PARENTH|CLOSE_PARENTH))==(OPEN_PARENTH|CLOSE_PARENTH)){flags&=~(OPEN_PARENTH|CLOSE_PARENTH);a_vf[i][1]=flags}p_voice=a_vf[i][0];if(flags&FL_VOICE){p_voice.floating=true;p_voice.second=true}else{st++;if(!par_sy.staves[st]){par_sy.staves[st]={stafflines:"|||||",staffscale:1}}par_sy.staves[st].flags=0}v=p_voice.v;p_voice.st=p_voice.cst=par_sy.voices[v].st=st;par_sy.staves[st].flags|=flags;if(flags&OPEN_PARENTH){p_voice2=p_voice;while(i<a_vf.length-1){p_voice=a_vf[++i][0];v=p_voice.v;if(a_vf[i][1]&MASTER_VOICE){p_voice2.second=true;p_voice2=p_voice}else{p_voice.second=true}p_voice.st=p_voice.cst=par_sy.voices[v].st=st;if(a_vf[i][1]&CLOSE_PARENTH)break}par_sy.staves[st].flags|=a_vf[i][1]}}if(st<0)st=0;par_sy.nstaff=nstaff=st;if(cmd[1]=="c"){for(st=0;st<nstaff;st++)par_sy.staves[st].flags^=STOP_BAR}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(par_sy.voices[v].range<0){p_voice.ignore=true;continue}par_sy.voices[v].second=p_voice.second;st=p_voice.st;if(st>0&&!p_voice.norepbra&&!(par_sy.staves[st-1].flags&STOP_BAR))p_voice.norepbra=true}curvoice=parse.state>=2?voice_tb[par_sy.top_voice]:null}var err_no_strt_ov="No note in voice overlay";function get_vover(type){var p_voice2,p_voice3,range,s,time,v,v2,v3,line=parse.line;function clone_voice(id){var v,p_voice;for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];if(p_voice.id==id)return p_voice}p_voice=clone(curvoice);p_voice.v=voice_tb.length;p_voice.id=id;p_voice.sym=p_voice.last_sym=null;delete p_voice.nm;delete p_voice.snm;delete p_voice.new_name;delete p_voice.lyric_restart;delete p_voice.lyric_cont;delete p_voice.ly_a_h;delete p_voice.sym_restart;delete p_voice.sym_cont;voice_tb.push(p_voice);return p_voice}if(curvoice.ignore)return;if(type=="|"||type==")"){if(!curvoice.last_note){syntax(1,err_no_strt_ov);return}curvoice.last_note.beam_end=true;if(!vover){syntax(1,"Erroneous end of voice overlay");return}if(curvoice.time!=vover.mxtime)syntax(1,"Wrong duration in voice overlay");curvoice=vover.p_voice;vover=null;return}if(type=="("){if(vover){syntax(1,"Voice overlay already started");return}vover={p_voice:curvoice,time:curvoice.time};return}if(!curvoice.last_note){syntax(1,err_no_strt_ov);return}curvoice.last_note.beam_end=true;p_voice2=curvoice.voice_down;if(!p_voice2){p_voice2=clone_voice(curvoice.id+"o");curvoice.voice_down=p_voice2;p_voice2.time=0;p_voice2.second=true;v2=p_voice2.v;par_sy.voices[v2]={st:curvoice.st,second:true};var f_clone=curvoice.clone!=undefined?1:0;range=par_sy.voices[curvoice.v].range;for(v=0;v<par_sy.voices.length;v++){if(par_sy.voices[v].range>range)par_sy.voices[v].range+=f_clone+1}par_sy.voices[v2].range=range+1;if(f_clone){p_voice3=clone_voice(p_voice2.id+"c");p_voice3.second=true;v3=p_voice3.v;par_sy.voices[v3]={second:true,range:range+2};p_voice2.clone=p_voice3}}p_voice2.ulen=curvoice.ulen;p_voice2.dur_fact=curvoice.dur_fact;if(curvoice.uscale)p_voice2.uscale=curvoice.uscale;if(!vover){vover={bar:true,mxtime:curvoice.time,p_voice:curvoice};time=p_voice2.time;for(s=curvoice.last_sym;;s=s.prev){if(s.type==BAR||s.time<=time)break}vover.time=s.time}else{if(!vover.mxtime)vover.mxtime=curvoice.time;else if(curvoice.time!=vover.mxtime)syntax(1,"Wrong duration in voice overlay")}p_voice2.time=vover.time;curvoice=p_voice2}function is_voice_sig(){var s;if(!curvoice.sym)return true;if(curvoice.time!=0)return false;for(s=curvoice.last_sym;s;s=s.prev)if(w_tb[s.type]!=0)return false;return true}function get_clef(s){var s2,s3;if(is_voice_sig()){curvoice.clef=s;return}for(s2=curvoice.last_sym;s2&&s2.prev&&s2.time==curvoice.time;s2=s2.prev){if(w_tb[s2.type]!=0)break}if(s2&&s2.prev&&s2.time==curvoice.time&&(s2.type==KEY&&!s2.k_none||s2.type==BAR)){for(s3=s2;s3.prev;s3=s3.prev){switch(s3.prev.type){case KEY:case BAR:continue}break}s2=curvoice.last_sym;curvoice.last_sym=s3.prev;sym_link(s);s.next=s3;s3.prev=s;curvoice.last_sym=s2}else{sym_link(s)}s.clef_small=true}function get_key(parm){var v,p_voice,s,transp,a=new_key(parm),s_key=a[0];a=a[1];if(s_key.k_sf&&!s_key.k_exp&&s_key.k_a_acc)set_k_acc(s_key);switch(parse.state){case 1:if(s_key.k_sf==undefined&&!s_key.k_a_acc){s_key.k_sf=0;s_key.k_none=true}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];p_voice.key=clone(s_key);p_voice.okey=clone(s_key);p_voice.ckey=clone(s_key)}parse.okey=clone(s_key);parse.ckey=s_key;if(a.length!=0)memo_kv_parm("*",a);if(!glovar.ulen)glovar.ulen=BASE_LEN/8;parse.state=2;set_page();write_heading();reset_gen();gene.nbar=cfmt.measurefirst;return;case 2:goto_tune(true);break}if(a.length!=0)set_kv_parm(a);transp=(cfmt.transp||0)+(curvoice.transp||0)+(curvoice.shift||0);if(s_key.k_sf==undefined){if(!s_key.k_a_acc&&!transp)return;s_key.k_sf=curvoice.okey.k_sf}curvoice.okey=clone(s_key);if(transp){curvoice.vtransp=transp;key_transp(s_key)}s_key.k_old_sf=curvoice.ckey.k_sf;curvoice.ckey=s_key;if(is_voice_sig()){curvoice.key=clone(s_key);if(s_key.k_none)curvoice.key.k_sf=0;return}s=curvoice.last_sym;if(s&&s.type==METER){curvoice.last_sym=s.prev;if(!curvoice.last_sym)curvoice.sym=null;sym_link(s_key);s_key.next=s;s.prev=s_key;curvoice.last_sym=s}else{sym_link(s_key)}}function new_voice(id){var p_voice,v,p_v_sav,n=voice_tb.length;if(n==1&&voice_tb[0].default){delete voice_tb[0].default;if(voice_tb[0].time==0){p_voice=voice_tb[0];p_voice.id=id;if(cfmt.transp&&parse.state>=2){p_v_sav=curvoice;curvoice=p_voice;set_transp();curvoice=p_v_sav}return p_voice}}for(v=0;v<n;v++){p_voice=voice_tb[v];if(p_voice.id==id)return p_voice}p_voice={v:v,id:id,time:0,new:true,pos:{dyn:0,gch:0,gst:0,orn:0,stm:0,voc:0,vol:0},scale:1,combine:0,ulen:glovar.ulen,dur_fact:1,key:clone(parse.ckey),ckey:clone(parse.ckey),okey:clone(parse.okey),meter:clone(glovar.meter),wmeasure:glovar.meter.wmeasure,clef:{type:CLEF,clef_auto:true,clef_type:"a",time:0},hy_st:0,instr:glovar.instr||0};voice_tb.push(p_voice);par_sy.voices[v]={range:-1};return p_voice}function init_tune(){nstaff=-1;voice_tb=[];curvoice=null;new_syst(true);staves_found=-1;gene={};a_de=[];od={};if(capo)capo=false}function get_voice(parm){var v,transp,vtransp,a=info_split(parm,1),vid=a.shift();if(parse.state<2){if(a.length!=0)memo_kv_parm(vid,a);if(vid!="*"&&parse.state==1)new_voice(vid);return}if(vid=="*"){syntax(1,"Cannot have V:* in tune body");return}curvoice=new_voice(vid);set_kv_parm(a);if(parse.state==2)goto_tune();set_transp();v=curvoice.v;if(curvoice.new){delete curvoice.new;if(staves_found<0){curvoice.st=curvoice.cst=++nstaff;par_sy.nstaff=nstaff;par_sy.voices[v].st=nstaff;par_sy.voices[v].range=v;par_sy.staves[nstaff]={stafflines:"|||||",staffscale:1}}if(par_sy.voices[v].range<0){if(staves_found>=0)curvoice.ignore=true}}if(!curvoice.filtered&&!curvoice.ignore&&parse.voice_opts){curvoice.filtered=true;voice_filter()}}function goto_tune(is_K){var v,p_voice,s={type:STAVES,dur:0,sy:par_sy};parse.state=3;if(voice_tb.length==0){curvoice=new_voice("1");curvoice.clef.istart=curvoice.key.istart;curvoice.clef.iend=curvoice.key.iend;curvoice.default=true}else if(!curvoice){curvoice=voice_tb[staves_found<0?0:par_sy.top_voice]}if(!curvoice.init&&!is_K){set_kv_parm([]);set_transp()}for(v=0;v<voice_tb.length;v++){p_voice=voice_tb[v];p_voice.ulen=glovar.ulen;if(p_voice.key.k_bagpipe&&!p_voice.pos.stm){p_voice.pos=clone(p_voice.pos);p_voice.pos.stm=SL_BELOW}}if(staves_found<0){nstaff=voice_tb.length-1;for(v=0;v<=nstaff;v++){p_voice=voice_tb[v];delete p_voice.new;p_voice.st=p_voice.cst=par_sy.voices[v].st=par_sy.voices[v].range=v;par_sy.staves[v]={stafflines:"|||||",staffscale:1}}par_sy.nstaff=nstaff}p_voice=curvoice;curvoice=voice_tb[par_sy.top_voice];sym_link(s);if(staves_found<0)s.default=true;curvoice=p_voice}function get_sym(p,cont){var s,c,i,j,d;if(curvoice.ignore)return;if(cont){s=curvoice.sym_cont;if(!s){syntax(1,"+: symbol line without music");return}}else{if(curvoice.sym_restart){curvoice.sym_start=s=curvoice.sym_restart;curvoice.sym_restart=null}else{s=curvoice.sym_start}if(!s)s=curvoice.sym;if(!s){syntax(1,"s: without music");return}}i=0;while(1){while(p[i]==" "||p[i]=="\t")i++;c=p[i];if(!c)break;switch(c){case"|":while(s&&s.type!=BAR)s=s.next;if(!s){syntax(1,"Not enough measure bars for symbol line");return}s=s.next;i++;continue;case"!":case'"':j=++i;i=p.indexOf(c,j);if(i<0){syntax(1,c=="!"?"No end of decoration":"No end of guitar chord");i=p.length;continue}d=p.slice(j-1,i+1);break;case"*":break;default:d=c.charCodeAt(0);if(d<128){d=char_tb[d];if(d.length>1&&(d[0]=="!"||d[0]=='"')){c=d[0];break}}syntax(1,"Bad character '$1'",c);break}while(s&&(s.type!=NOTE||s.grace))s=s.next;if(!s){syntax(1,"Too many elements in symbol line");return}switch(c){default:break;case"!":deco_cnv([d.slice(1,-1)],s,s.prev);break;case'"':a_gch=s.a_gch;parse_gchord(d);if(a_gch)gch_build(s);break}s=s.next;i++}curvoice.lyric_cont=s}function get_lyrics(text,cont){var s,word,p,i,j,ly;if(curvoice.ignore)return;if(curvoice.pos.voc!=SL_HIDDEN)curvoice.have_ly=true;if(cont){s=curvoice.lyric_cont;if(!s){syntax(1,"+: lyric without music");return}}else{set_font("vocal");if(curvoice.lyric_restart){curvoice.lyric_start=s=curvoice.lyric_restart;curvoice.lyric_restart=null;curvoice.lyric_line=0}else{curvoice.lyric_line++;s=curvoice.lyric_start}if(!s)s=curvoice.sym;if(!s){syntax(1,"w: without music");return}}p=text;i=0;while(1){while(p[i]==" "||p[i]=="\t")i++;if(!p[i])break;j=parse.istart+i+2;switch(p[i]){case"|":while(s&&s.type!=BAR)s=s.next;if(!s){syntax(1,"Not enough measure bars for lyric line");return}s=s.next;i++;continue;case"-":word="-\n";break;case"_":word="_\n";break;case"*":word="";break;default:if(p[i]=="\\"&&i==p.length-1){curvoice.lyric_cont=s;return}word="";while(1){if(!p[i])break;switch(p[i]){case"_":case"*":case"|":i--;case" ":case"\t":break;case"~":word+=" ";i++;continue;case"-":word+="\n";break;case"\\":word+=p[++i];i++;continue;default:word+=p[i++];continue}break}break}while(s&&(s.type!=NOTE||s.grace))s=s.next;if(!s){syntax(1,"Too many words in lyric line");return}if(word&&s.pos.voc!=SL_HIDDEN){if(word.match(/^\$\d/)){if(word[1]=="0")set_font("vocal");else set_font("u"+word[1]);word=word.slice(2)}ly={t:word,font:gene.curfont,w:strw(word),istart:j,iend:j+word.length};if(!s.a_ly)s.a_ly=[];s.a_ly[curvoice.lyric_line]=ly}s=s.next;i++}curvoice.lyric_cont=s}function ly_width(s,wlw){var ly,sz,swfac,align,xx,w,i,j,k,shift,p,a_ly=s.a_ly;align=0;for(i=0;i<a_ly.length;i++){ly=a_ly[i];if(!ly)continue;p=ly.t;w=ly.w;swfac=ly.font.swfac;xx=w+2*cwid(" ")*swfac;if(s.type==GRACE){shift=s.wl}else if(p[0]>="0"&&p[0]<="9"&&p.length>2||p[1]==":"||p[0]=="("||p[0]==")"){if(p[0]=="("){sz=cwid("(")*swfac}else{j=p.indexOf(" ");gene.curfont=gene.deffont=ly.font;if(j>0)sz=strw(p.slice(0,j));else sz=w}shift=(w-sz+2*cwid(" ")*swfac)*.4;if(shift>20)shift=20;shift+=sz;if(ly.t[0]>="0"&&ly.t[0]<="9"){if(shift>align)align=shift}}else if(p=="-\n"||p=="_\n"){shift=0}else{shift=xx*.4;if(shift>20)shift=20}ly.shift=shift;if(wlw<shift)wlw=shift;xx-=shift;shift=2*cwid(" ")*swfac;for(k=s.next;k;k=k.next){switch(k.type){case NOTE:case REST:if(!k.a_ly||!k.a_ly[i]||k.a_ly[i].w==0)xx-=9;else if(k.a_ly[i].t=="-\n"||k.a_ly[i].t=="_\n")xx-=shift;else break;if(xx<=0)break;continue;case CLEF:case METER:case KEY:xx-=10;continue;default:xx-=5;break}break}if(xx>s.wr)s.wr=xx}if(align>0){for(i=0;i<a_ly.length;i++){ly=a_ly[i];if(ly&&ly.t[0]>="0"&&ly.t[0]<="9")ly.shift=align}}return wlw}function draw_lyric_line(p_voice,j,y){var p,lastx,w,s,s2,ly,lyl,hyflag,lflag,x0,font,shift;if(p_voice.hy_st&1<<j){hyflag=true;p_voice.hy_st&=~(1<<j)}for(s=p_voice.sym;;s=s.next)if(s.type!=CLEF&&s.type!=KEY&&s.type!=METER)break;lastx=s.prev?s.prev.x:tsfirst.x;x0=0;for(;s;s=s.next){if(s.a_ly)ly=s.a_ly[j];else ly=null;if(!ly){switch(s.type){case REST:case MREST:if(lflag){out_wln(lastx+3,y,x0-lastx);lflag=false;lastx=s.x+s.wr}}continue}if(ly.font!=gene.curfont)gene.curfont=font=ly.font;p=ly.t;w=ly.w;shift=ly.shift;if(hyflag){if(p=="_\n"){p="-\n"}else if(p!="-\n"){out_hyph(lastx,y,s.x-shift-lastx);hyflag=false;lastx=s.x+s.wr}}if(lflag&&p!="_\n"){out_wln(lastx+3,y,x0-lastx+3);lflag=false;lastx=s.x+s.wr}if(p=="-\n"||p=="_\n"){if(x0==0&&lastx>s.x-18)lastx=s.x-18;if(p[0]=="-")hyflag=true;else lflag=true;x0=s.x-shift;continue}x0=s.x-shift;if(p.slice(-1)=="\n"){p=p.slice(0,-1);hyflag=true}if(user.anno_start||user.anno_stop){s2={st:s.st,istart:ly.istart,iend:ly.iend,x:x0,y:y,ymn:y,ymx:y+gene.curfont.size,wl:0,wr:w};anno_start(s2,"lyrics")}xy_str(x0,y,p);anno_stop(s2,"lyrics");lastx=x0+w}if(hyflag){hyflag=false;x0=realwidth-10;if(x0<lastx+10)x0=lastx+10;out_hyph(lastx,y,x0-lastx);if(cfmt.hyphencont)p_voice.hy_st|=1<<j}for(p_voice.s_next;s;s=s.next){if(s.type==NOTE){if(!s.a_ly)break;ly=s.a_ly[j];if(ly&&ly.t=="_\n"){lflag=true;x0=realwidth-15;if(x0<lastx+12)x0=lastx+12}break}}if(lflag){out_wln(lastx+3,y,x0-lastx+3);lflag=false}}function draw_lyrics(p_voice,nly,a_h,y,incr){var j,top,sc=staff_tb[p_voice.st].staffscale;set_font("vocal");if(incr>0){if(y>-cfmt.vocalspace)y=-cfmt.vocalspace;y*=sc;for(j=0;j<nly;j++){y-=a_h[j]*1.1;draw_lyric_line(p_voice,j,y)}return(y-a_h[j-1]/6)/sc}top=staff_tb[p_voice.st].topbar+cfmt.vocalspace;if(y<top)y=top;y*=sc;for(j=nly;--j>=0;){draw_lyric_line(p_voice,j,y);y+=a_h[j]*1.1}return y/sc}function draw_all_lyrics(){var p_voice,s,v,nly,i,x,y,w,a_ly,ly,lyst_tb=new Array(nstaff),nv=voice_tb.length,h_tb=new Array(nv),nly_tb=new Array(nv),above_tb=new Array(nv),rv_tb=new Array(nv),top=0,bot=0,st=-1;for(v=0;v<nv;v++){p_voice=voice_tb[v];if(!p_voice.sym)continue;if(p_voice.st!=st){top=0;bot=0;st=p_voice.st}nly=0;if(p_voice.have_ly){if(!h_tb[v])h_tb[v]=[];for(s=p_voice.sym;s;s=s.next){a_ly=s.a_ly;if(!a_ly)continue;x=s.x;w=10;for(i=0;i<a_ly.length;i++){ly=a_ly[i];if(ly&&ly.w!=0){x-=ly.shift;w=ly.w;break}}y=y_get(p_voice.st,1,x,w);if(top<y)top=y;y=y_get(p_voice.st,0,x,w);if(bot>y)bot=y;while(nly<a_ly.length)h_tb[v][nly++]=0;for(i=0;i<a_ly.length;i++){ly=a_ly[i];if(!ly)continue;if(!h_tb[v][i]||ly.font.size>h_tb[v][i])h_tb[v][i]=ly.font.size}}}else{y=y_get(p_voice.st,1,0,realwidth);if(top<y)top=y;y=y_get(p_voice.st,0,0,realwidth);if(bot>y)bot=y}if(!lyst_tb[st])lyst_tb[st]={};lyst_tb[st].top=top;lyst_tb[st].bot=bot;nly_tb[v]=nly;if(nly==0)continue;if(p_voice.pos.voc)above_tb[v]=p_voice.pos.voc==SL_ABOVE;else if(voice_tb[v+1]&&voice_tb[v+1].st==st&&voice_tb[v+1].have_ly)above_tb[v]=true;else above_tb[v]=false;if(above_tb[v])lyst_tb[st].a=true;else lyst_tb[st].b=true}i=0;for(v=0;v<nv;v++){p_voice=voice_tb[v];if(!p_voice.sym)continue;if(!p_voice.have_ly)continue;if(above_tb[v]){rv_tb[i++]=v;continue}st=p_voice.st;set_dscale(st,true);if(nly_tb[v]>0)lyst_tb[st].bot=draw_lyrics(p_voice,nly_tb[v],h_tb[v],lyst_tb[st].bot,1)}while(--i>=0){v=rv_tb[i];p_voice=voice_tb[v];st=p_voice.st;set_dscale(st,true);lyst_tb[st].top=draw_lyrics(p_voice,nly_tb[v],h_tb[v],lyst_tb[st].top,-1)}for(v=0;v<nv;v++){p_voice=voice_tb[v];if(!p_voice.sym)continue;st=p_voice.st;if(lyst_tb[st].a){top=lyst_tb[st].top+2;for(s=p_voice.sym.next;s;s=s.next){if(s.a_ly){y_set(st,1,s.x-2,10,top)}}}if(lyst_tb[st].b){bot=lyst_tb[st].bot-2;if(nly_tb[p_voice.v]>0){for(s=p_voice.sym.next;s;s=s.next){if(s.a_ly){y_set(st,0,s.x-2,10,bot)}}}else{y_set(st,0,0,realwidth,bot)}}}}var capo;function parse_gchord(type){var c,text,gch,x_abs,y_abs,type,i,istart,iend,ann_font=get_font("annotation"),h_ann=ann_font.size,line=parse.line;function get_float(){var txt="";while(1){c=text[i++];if("1234567890.-".indexOf(c)<0)return parseFloat(txt);txt+=c}}istart=parse.bol+line.index;if(type.length>1){text=type.slice(1,-1);iend=istart+1}else{text="";while(1){c=line.next_char();if(!c){syntax(1,"No end of guitar chord");return}if(c=='"')break;if(c=="\\"){text+=c;c=line.next_char()}text+=c}iend=parse.bol+line.index+1}if(curvoice.pos.gch==SL_HIDDEN)return;i=0;type="g";while(1){c=text[i];if(!c)break;gch={text:"",istart:istart,iend:iend};switch(c){case"@":type=c;i++;x_abs=get_float();if(c!=","){syntax(1,"',' lacking in annotation '@x,y'");y_abs=0}else{y_abs=get_float();if(c!=" ")i--}gch.x=x_abs;gch.y=y_abs-h_ann/2;break;case"^":case"_":case"<":case">":i++;type=c;break}gch.type=type;while(1){c=text[i];if(!c)break;switch(c){case"\\":c=text[++i];if(!c||c=="n")break;gch.text+="\\";default:gch.text+=c;i++;continue;case"&":while(1){gch.text+=c;c=text[++i];switch(c){default:continue;case";":case undefined:case"\\":break}break}if(c==";"){gch.text+=c;continue}break;case";":break}i++;break}if(!a_gch)a_gch=[];a_gch.push(gch)}}function gch_capo(s){var gch,gch2,i2,i=0;while(1){gch=s.a_gch[i++];if(!gch)return;if(gch.type=="g")break}gch2=clone(gch);gch2.text=gch_tr1(gch2.text,-cfmt.capo);if(!capo){capo=true;gch2.text+="  (capo: "+cfmt.capo.toString()+")"}gch2.type="^";s.a_gch.splice(i,0,gch2)}var note_names="CDEFGAB",latin_names=["Do","Ré","Mi","Fa","Sol","La","Si"],acc_name=["bb","b","","#","##"],note_pit=new Int8Array([0,2,4,5,7,9,11]),pit_note=new Int8Array([0,0,1,2,2,3,3,4,5,5,6,6]),pit_acc=new Int8Array([2,3,2,1,2,2,3,2,1,2,1,2]);function gch_tr1(p,i2){var new_txt,l,n,i1,i3,i4,ix,a,ip,ip2,latin=0;switch(p[0]){case"A":n=5;break;case"B":n=6;break;case"C":n=0;break;case"D":if(p[1]=="o"){latin++;n=0;break}n=1;break;case"E":n=2;break;case"F":if(p[1]=="a")latin++;n=3;break;case"G":n=4;break;case"L":latin++;n=5;break;case"M":latin++;n=2;break;case"R":latin++;if(p[1]!="e")latin++;n=1;break;case"S":latin++;if(p[1]=="o"){latin++;n=4}else{n=6}break;case"/":latin--;break;default:return p}a=0;ip=latin+1;if(latin>=0){while(p[ip]=="#"){a++;ip++}while(p[ip]=="b"){a--;ip++}i3=(note_pit[n]+a+i2+12)%12;i4=pit_note[i3];i1=pit_acc[i3];new_txt=(latin?latin_names[i4]:note_names[i4])+acc_name[i1]}else{new_txt=""}ip2=p.indexOf("/",ip);if(ip2<0)return new_txt+p.slice(ip);n=note_names.indexOf(p[++ip2]);if(n<0)return new_txt+p.slice(ip);new_txt+=p.slice(ip,ip2);a=0;if(p[++ip2]=="#"){a++;if(p[++ip2]=="#"){a++;ip2++}}else if(p[ip2]=="b"){a--;if(p[++ip2]=="b"){a--;ip2++}}i3=(note_pit[n]+a+i2+12)%12;i4=pit_note[i3];i1=pit_acc[i3];return new_txt+note_names[i4]+acc_name[i1]+p.slice(ip2)}function gch_transp(s){var gch,p,j,i=0,i2=(curvoice.ckey.k_sf-curvoice.okey.k_sf+12)*7%12;while(1){gch=s.a_gch[i++];if(!gch)return;if(gch.type!="g")continue;p=gch.text;j=p.indexOf("\t");if(j>=0){j++;p=p.slice(0,j)+gch_tr1(p.slice(j),i2)}gch.text=gch_tr1(p,i2)}}function gch_build(s){var gch,w,xspc,ix,pos=curvoice.pos.gch==SL_BELOW?-1:1,gch_font=get_font("gchord"),ann_font=get_font("annotation"),y_above=0,y_below=0,y_left=0,y_right=0,h_gch=gch_font.size,h_ann=ann_font.size,box=cfmt.gchordbox,GCHPRE=.4;s.a_gch=a_gch;a_gch=null;if(cfmt.capo)gch_capo(s);if(curvoice.vtransp)gch_transp(s);for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];if(gch.type=="g"){if(cfmt.chordnames){gch.text=gch.text.replace(/A|B|C|D|E|F|G/g,function(c){return cfmt.chordnames[c]});if(cfmt.chordnames.B=="H")gch.text=gch.text.replace(/Hb/g,"Bb")}gch.text=gch.text.replace(/##|#|=|bb|b/g,function(x){switch(x){case"##":return"&#x1d12a;";case"#":return"♯";case"=":return"♮";case"b":return"♭"}return"&#x1d12b;"});gch.font=gch_font}else{gch.text=cnv_escape(gch.text);gch.font=ann_font;if(gch.type=="@"&&!user.anno_start)continue}gene.curfont=gch.font;w=strw(gch.text);gch.w=w;switch(gch.type){case"@":break;case"^":xspc=w*GCHPRE;if(xspc>8)xspc=8;gch.x=-xspc;y_above-=h_ann;gch.y=y_above;break;case"_":xspc=w*GCHPRE;if(xspc>8)xspc=8;gch.x=-xspc;y_below-=h_ann;gch.y=y_below;break;case"<":gch.x=-(w+6);y_left-=h_ann;gch.y=y_left+h_ann/2;break;case">":gch.x=6;y_right-=h_ann;gch.y=y_right+h_ann/2;break;default:gch.box=box;xspc=w*GCHPRE;if(xspc>8)xspc=8;gch.x=-xspc;if(pos<0){y_below-=h_gch;gch.y=y_below;if(box){y_below-=2;gch.y-=1}}else{y_above-=h_gch;gch.y=y_above;if(box){y_above-=2;gch.y-=1}}break}}y_left/=2;y_right/=2;for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];switch(gch.type){case"^":gch.y-=y_above;break;case"<":gch.y-=y_left;break;case">":gch.y-=y_right;break;case"g":if(pos>0)gch.y-=y_above;break}}}function draw_gchord(s,gchy_min,gchy_max){var gch,gch2,text,ix,x,y,y2,i,j,hbox,h;var w=s.a_gch[0].w,y_above=y_get(s.st,1,s.x-2,w),y_below=y_get(s.st,0,s.x-2,w),yav=((s.notes[s.nhd].pit+s.notes[0].pit>>1)-18)*3;for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];if(gch.type!="g")continue;gch2=gch;if(gch.y<0)break}if(gch2){if(gch2.y>=0){if(y_above<gchy_max)y_above=gchy_max}else{if(y_below>gchy_min)y_below=gchy_min}}set_dscale(s.st);for(ix=0;ix<s.a_gch.length;ix++){gch=s.a_gch[ix];use_font(gch.font);gene.curfont=gene.deffont=gch.font;h=gch.font.size;w=gch.w;x=s.x+gch.x;text=gch.text;switch(gch.type){case"_":y=gch.y+y_below;y_set(s.st,0,x,w,y-h*.2-2);break;case"^":y=gch.y+y_above;y_set(s.st,1,x,w,y+h*.8+2);break;case"<":if(s.notes[0].acc)x-=s.notes[0].shac;y=gch.y+yav-h/2;break;case">":x+=s.xmx;if(s.dots>0)x+=1.5+3.5*s.dots;y=gch.y+yav-h/2;break;default:hbox=gch.box?3:2;if(gch.y>=0){y=gch.y+y_above;y_set(s.st,true,x,w,y+h+hbox)}else{y=gch.y+y_below;y_set(s.st,false,x,w,y-hbox)}i=text.indexOf("\t");if(i>=0){x=realwidth;for(var next=s.next;next;next=next.next){switch(next.type){default:continue;case NOTE:case REST:case BAR:x=next.x;break}break}j=2;for(;;){i=text.indexOf("\t",i+1);if(i<0)break;j++}var expdx=(x-s.x)/j;x=s.x;y*=staff_tb[s.st].staffscale;if(user.anno_start)user.anno_start("gchord",gch.istart,gch.iend,x-2,y+h+2,w+4,h+4,s);i=0;j=i;for(;;){i=text.indexOf("\t",j);if(i<0)break;xy_str(x,y,text.slice(j,i),"c");x+=expdx;j=i+1}xy_str(x,y,text.slice(j),"c");if(user.anno_stop)user.anno_stop("gchord",gch.istart,gch.iend,s.x-2,y+h+2,w+4,h+4,s);continue}break;case"@":y=gch.y+yav;if(y>0){y2=y+h;if(y2>staff_tb[s.st].ann_top)staff_tb[s.st].ann_top=y2}else{if(y<staff_tb[s.st].ann_bot)staff_tb[s.st].ann_bot=y}break}if(user.anno_start)user.anno_start("annot",gch.istart,gch.iend,x-2,y+h+2,w+4,h+4,s);if(gch.box)xy_str_b(x,y,text);else xy_str(x,y,text);if(user.anno_stop)user.anno_stop("annot",gch.istart,gch.iend,x-2,y+h+2,w+4,h+4,s)}}var psdeco=function(f,x,y,de){return false},psxygl=function(x,y,gl){return false};function ps_def(abcobj){if(psvg||typeof Psvg!="function")return;function svgcall(f,x,y,v1,v2){var xy=psvg.getorig();psvg.ps_flush();f((x+xy[0])*stv_g.scale,y-xy[1],v1,v2)}Abc.prototype.arpps=function(val,x,y){svgcall(out_arp,x,y,val)};Abc.prototype.ltrps=function(val,x,y){svgcall(out_ltr,x,y,val)};Abc.prototype.xyglsps=function(str,x,y,gl){svgcall(out_deco_str,x,y,gl,str)};Abc.prototype.xyglvps=function(val,x,y,gl){svgcall(out_deco_val,x,y,gl,val)};Abc.prototype.xyglps=function(x,y,gl){svgcall(xygl,x,y,gl)};Abc.prototype.get_y=function(st,y){return y+staff_tb[st].y};Abc.prototype.set_ps=function(deco,xygl){psdeco=deco;psxygl=xygl};Abc.prototype.stv_g=stv_g;Abc.prototype.psget_x=function(){return posx/stv_g.scale};Abc.prototype.psget_y=function(){return stv_g.started?stv_g.dy:posy};psvg=new Psvg(abcobj)}Abc.prototype.ps_def=ps_def;ps_def(this);font_init();init_tune();for(var i=0;i<128;i++)maci[i]=0}if(true){exports.abc2svg=abc2svg;exports.Abc=Abc}


/***/ })
/******/ ])["default"];
});